/*
 * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License, version 2.0,
 * as published by the Free Software Foundation.
 *
 * This program is also distributed with certain software (including
 * but not limited to OpenSSL) that is licensed under separate terms, as
 * designated in a particular file or component or in included license
 * documentation. The authors of MySQL hereby grant you an additional
 * permission to link the program and your derivative works with the
 * separately licensed software that they have included with MySQL.
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
 * the GNU General Public License, version 2.0, for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 */


// Generated from MySQLParser.g4 by ANTLR 4.7.2


#include "MySQLParserListener.h"
#include "MySQLParserVisitor.h"

#include "MySQLParser.h"


#include "MySQLBaseRecognizer.h"


using namespace antlrcpp;
using namespace parsers;
using namespace antlr4;

MySQLParser::MySQLParser(TokenStream *input) : MySQLBaseRecognizer(input) {
  _interpreter = new atn::ParserATNSimulator(this, _atn, _decisionToDFA, _sharedContextCache);
}

MySQLParser::~MySQLParser() {
  delete _interpreter;
}

std::string MySQLParser::getGrammarFileName() const {
  return "MySQLParser.g4";
}

const std::vector<std::string>& MySQLParser::getRuleNames() const {
  return _ruleNames;
}

dfa::Vocabulary& MySQLParser::getVocabulary() const {
  return _vocabulary;
}


//----------------- QueryContext ------------------------------------------------------------------

MySQLParser::QueryContext::QueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::QueryContext::EOF() {
  return getToken(MySQLParser::EOF, 0);
}

MySQLParser::SimpleStatementContext* MySQLParser::QueryContext::simpleStatement() {
  return getRuleContext<MySQLParser::SimpleStatementContext>(0);
}

MySQLParser::BeginWorkContext* MySQLParser::QueryContext::beginWork() {
  return getRuleContext<MySQLParser::BeginWorkContext>(0);
}

tree::TerminalNode* MySQLParser::QueryContext::SEMICOLON_SYMBOL() {
  return getToken(MySQLParser::SEMICOLON_SYMBOL, 0);
}


size_t MySQLParser::QueryContext::getRuleIndex() const {
  return MySQLParser::RuleQuery;
}

void MySQLParser::QueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuery(this);
}

void MySQLParser::QueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuery(this);
}


antlrcpp::Any MySQLParser::QueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitQuery(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::QueryContext* MySQLParser::query() {
  QueryContext *_localctx = _tracker.createInstance<QueryContext>(_ctx, getState());
  enterRule(_localctx, 0, MySQLParser::RuleQuery);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1174);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1162);
      match(MySQLParser::EOF);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1165);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx)) {
      case 1: {
        setState(1163);
        simpleStatement();
        break;
      }

      case 2: {
        setState(1164);
        beginWork();
        break;
      }

      }
      setState(1172);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::SEMICOLON_SYMBOL: {
          setState(1167);
          match(MySQLParser::SEMICOLON_SYMBOL);
          setState(1169);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx)) {
          case 1: {
            setState(1168);
            match(MySQLParser::EOF);
            break;
          }

          }
          break;
        }

        case MySQLParser::EOF: {
          setState(1171);
          match(MySQLParser::EOF);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleStatementContext ------------------------------------------------------------------

MySQLParser::SimpleStatementContext::SimpleStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::AlterStatementContext* MySQLParser::SimpleStatementContext::alterStatement() {
  return getRuleContext<MySQLParser::AlterStatementContext>(0);
}

MySQLParser::CreateStatementContext* MySQLParser::SimpleStatementContext::createStatement() {
  return getRuleContext<MySQLParser::CreateStatementContext>(0);
}

MySQLParser::DropStatementContext* MySQLParser::SimpleStatementContext::dropStatement() {
  return getRuleContext<MySQLParser::DropStatementContext>(0);
}

MySQLParser::RenameTableStatementContext* MySQLParser::SimpleStatementContext::renameTableStatement() {
  return getRuleContext<MySQLParser::RenameTableStatementContext>(0);
}

MySQLParser::TruncateTableStatementContext* MySQLParser::SimpleStatementContext::truncateTableStatement() {
  return getRuleContext<MySQLParser::TruncateTableStatementContext>(0);
}

MySQLParser::ImportStatementContext* MySQLParser::SimpleStatementContext::importStatement() {
  return getRuleContext<MySQLParser::ImportStatementContext>(0);
}

MySQLParser::CallStatementContext* MySQLParser::SimpleStatementContext::callStatement() {
  return getRuleContext<MySQLParser::CallStatementContext>(0);
}

MySQLParser::DeleteStatementContext* MySQLParser::SimpleStatementContext::deleteStatement() {
  return getRuleContext<MySQLParser::DeleteStatementContext>(0);
}

MySQLParser::DoStatementContext* MySQLParser::SimpleStatementContext::doStatement() {
  return getRuleContext<MySQLParser::DoStatementContext>(0);
}

MySQLParser::HandlerStatementContext* MySQLParser::SimpleStatementContext::handlerStatement() {
  return getRuleContext<MySQLParser::HandlerStatementContext>(0);
}

MySQLParser::InsertStatementContext* MySQLParser::SimpleStatementContext::insertStatement() {
  return getRuleContext<MySQLParser::InsertStatementContext>(0);
}

MySQLParser::LoadStatementContext* MySQLParser::SimpleStatementContext::loadStatement() {
  return getRuleContext<MySQLParser::LoadStatementContext>(0);
}

MySQLParser::ReplaceStatementContext* MySQLParser::SimpleStatementContext::replaceStatement() {
  return getRuleContext<MySQLParser::ReplaceStatementContext>(0);
}

MySQLParser::SelectStatementContext* MySQLParser::SimpleStatementContext::selectStatement() {
  return getRuleContext<MySQLParser::SelectStatementContext>(0);
}

MySQLParser::UpdateStatementContext* MySQLParser::SimpleStatementContext::updateStatement() {
  return getRuleContext<MySQLParser::UpdateStatementContext>(0);
}

MySQLParser::TransactionOrLockingStatementContext* MySQLParser::SimpleStatementContext::transactionOrLockingStatement() {
  return getRuleContext<MySQLParser::TransactionOrLockingStatementContext>(0);
}

MySQLParser::ReplicationStatementContext* MySQLParser::SimpleStatementContext::replicationStatement() {
  return getRuleContext<MySQLParser::ReplicationStatementContext>(0);
}

MySQLParser::PreparedStatementContext* MySQLParser::SimpleStatementContext::preparedStatement() {
  return getRuleContext<MySQLParser::PreparedStatementContext>(0);
}

MySQLParser::CloneStatementContext* MySQLParser::SimpleStatementContext::cloneStatement() {
  return getRuleContext<MySQLParser::CloneStatementContext>(0);
}

MySQLParser::AccountManagementStatementContext* MySQLParser::SimpleStatementContext::accountManagementStatement() {
  return getRuleContext<MySQLParser::AccountManagementStatementContext>(0);
}

MySQLParser::TableAdministrationStatementContext* MySQLParser::SimpleStatementContext::tableAdministrationStatement() {
  return getRuleContext<MySQLParser::TableAdministrationStatementContext>(0);
}

MySQLParser::InstallUninstallStatmentContext* MySQLParser::SimpleStatementContext::installUninstallStatment() {
  return getRuleContext<MySQLParser::InstallUninstallStatmentContext>(0);
}

MySQLParser::SetStatementContext* MySQLParser::SimpleStatementContext::setStatement() {
  return getRuleContext<MySQLParser::SetStatementContext>(0);
}

MySQLParser::ShowStatementContext* MySQLParser::SimpleStatementContext::showStatement() {
  return getRuleContext<MySQLParser::ShowStatementContext>(0);
}

MySQLParser::ResourceGroupManagementContext* MySQLParser::SimpleStatementContext::resourceGroupManagement() {
  return getRuleContext<MySQLParser::ResourceGroupManagementContext>(0);
}

MySQLParser::OtherAdministrativeStatementContext* MySQLParser::SimpleStatementContext::otherAdministrativeStatement() {
  return getRuleContext<MySQLParser::OtherAdministrativeStatementContext>(0);
}

MySQLParser::UtilityStatementContext* MySQLParser::SimpleStatementContext::utilityStatement() {
  return getRuleContext<MySQLParser::UtilityStatementContext>(0);
}

MySQLParser::GetDiagnosticsContext* MySQLParser::SimpleStatementContext::getDiagnostics() {
  return getRuleContext<MySQLParser::GetDiagnosticsContext>(0);
}

MySQLParser::SignalStatementContext* MySQLParser::SimpleStatementContext::signalStatement() {
  return getRuleContext<MySQLParser::SignalStatementContext>(0);
}

MySQLParser::ResignalStatementContext* MySQLParser::SimpleStatementContext::resignalStatement() {
  return getRuleContext<MySQLParser::ResignalStatementContext>(0);
}


size_t MySQLParser::SimpleStatementContext::getRuleIndex() const {
  return MySQLParser::RuleSimpleStatement;
}

void MySQLParser::SimpleStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleStatement(this);
}

void MySQLParser::SimpleStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleStatement(this);
}


antlrcpp::Any MySQLParser::SimpleStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SimpleStatementContext* MySQLParser::simpleStatement() {
  SimpleStatementContext *_localctx = _tracker.createInstance<SimpleStatementContext>(_ctx, getState());
  enterRule(_localctx, 2, MySQLParser::RuleSimpleStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1212);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1176);
      alterStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1177);
      createStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1178);
      dropStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1179);
      renameTableStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1180);
      truncateTableStatement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1181);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(1182);
      importStatement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1183);
      callStatement();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1184);
      deleteStatement();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1185);
      doStatement();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1186);
      handlerStatement();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1187);
      insertStatement();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(1188);
      loadStatement();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(1189);
      replaceStatement();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(1190);
      selectStatement();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(1191);
      updateStatement();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(1192);
      transactionOrLockingStatement();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(1193);
      replicationStatement();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(1194);
      preparedStatement();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(1195);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(1196);
      cloneStatement();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(1197);
      accountManagementStatement();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(1198);
      tableAdministrationStatement();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(1199);
      installUninstallStatment();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(1200);
      setStatement();
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(1201);
      showStatement();
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(1202);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(1203);
      resourceGroupManagement();
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(1204);
      otherAdministrativeStatement();
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(1205);
      utilityStatement();
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(1206);

      if (!(serverVersion >= 50604)) throw FailedPredicateException(this, "serverVersion >= 50604");
      setState(1207);
      getDiagnostics();
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(1208);

      if (!(serverVersion >= 50500)) throw FailedPredicateException(this, "serverVersion >= 50500");
      setState(1209);
      signalStatement();
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(1210);

      if (!(serverVersion >= 50500)) throw FailedPredicateException(this, "serverVersion >= 50500");
      setState(1211);
      resignalStatement();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterStatementContext ------------------------------------------------------------------

MySQLParser::AlterStatementContext::AlterStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterStatementContext::ALTER_SYMBOL() {
  return getToken(MySQLParser::ALTER_SYMBOL, 0);
}

MySQLParser::AlterTableContext* MySQLParser::AlterStatementContext::alterTable() {
  return getRuleContext<MySQLParser::AlterTableContext>(0);
}

MySQLParser::AlterDatabaseContext* MySQLParser::AlterStatementContext::alterDatabase() {
  return getRuleContext<MySQLParser::AlterDatabaseContext>(0);
}

tree::TerminalNode* MySQLParser::AlterStatementContext::PROCEDURE_SYMBOL() {
  return getToken(MySQLParser::PROCEDURE_SYMBOL, 0);
}

MySQLParser::ProcedureRefContext* MySQLParser::AlterStatementContext::procedureRef() {
  return getRuleContext<MySQLParser::ProcedureRefContext>(0);
}

tree::TerminalNode* MySQLParser::AlterStatementContext::FUNCTION_SYMBOL() {
  return getToken(MySQLParser::FUNCTION_SYMBOL, 0);
}

MySQLParser::FunctionRefContext* MySQLParser::AlterStatementContext::functionRef() {
  return getRuleContext<MySQLParser::FunctionRefContext>(0);
}

MySQLParser::AlterViewContext* MySQLParser::AlterStatementContext::alterView() {
  return getRuleContext<MySQLParser::AlterViewContext>(0);
}

MySQLParser::AlterEventContext* MySQLParser::AlterStatementContext::alterEvent() {
  return getRuleContext<MySQLParser::AlterEventContext>(0);
}

MySQLParser::AlterTablespaceContext* MySQLParser::AlterStatementContext::alterTablespace() {
  return getRuleContext<MySQLParser::AlterTablespaceContext>(0);
}

MySQLParser::AlterUndoTablespaceContext* MySQLParser::AlterStatementContext::alterUndoTablespace() {
  return getRuleContext<MySQLParser::AlterUndoTablespaceContext>(0);
}

MySQLParser::AlterLogfileGroupContext* MySQLParser::AlterStatementContext::alterLogfileGroup() {
  return getRuleContext<MySQLParser::AlterLogfileGroupContext>(0);
}

MySQLParser::AlterServerContext* MySQLParser::AlterStatementContext::alterServer() {
  return getRuleContext<MySQLParser::AlterServerContext>(0);
}

tree::TerminalNode* MySQLParser::AlterStatementContext::INSTANCE_SYMBOL() {
  return getToken(MySQLParser::INSTANCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterStatementContext::ROTATE_SYMBOL() {
  return getToken(MySQLParser::ROTATE_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::AlterStatementContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::AlterStatementContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterStatementContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

MySQLParser::RoutineAlterOptionsContext* MySQLParser::AlterStatementContext::routineAlterOptions() {
  return getRuleContext<MySQLParser::RoutineAlterOptionsContext>(0);
}


size_t MySQLParser::AlterStatementContext::getRuleIndex() const {
  return MySQLParser::RuleAlterStatement;
}

void MySQLParser::AlterStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterStatement(this);
}

void MySQLParser::AlterStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterStatement(this);
}


antlrcpp::Any MySQLParser::AlterStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterStatementContext* MySQLParser::alterStatement() {
  AlterStatementContext *_localctx = _tracker.createInstance<AlterStatementContext>(_ctx, getState());
  enterRule(_localctx, 4, MySQLParser::RuleAlterStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1214);
    match(MySQLParser::ALTER_SYMBOL);
    setState(1241);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx)) {
    case 1: {
      setState(1215);
      alterTable();
      break;
    }

    case 2: {
      setState(1216);
      alterDatabase();
      break;
    }

    case 3: {
      setState(1217);
      match(MySQLParser::PROCEDURE_SYMBOL);
      setState(1218);
      procedureRef();
      setState(1220);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MySQLParser::COMMENT_SYMBOL)
        | (1ULL << MySQLParser::CONTAINS_SYMBOL)
        | (1ULL << MySQLParser::LANGUAGE_SYMBOL)
        | (1ULL << MySQLParser::NO_SYMBOL))) != 0) || _la == MySQLParser::DETERMINISTIC_SYMBOL || ((((_la - 566) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 566)) & ((1ULL << (MySQLParser::MODIFIES_SYMBOL - 566))
        | (1ULL << (MySQLParser::NOT_SYMBOL - 566))
        | (1ULL << (MySQLParser::READS_SYMBOL - 566)))) != 0) || _la == MySQLParser::SQL_SYMBOL) {
        setState(1219);
        routineAlterOptions();
      }
      break;
    }

    case 4: {
      setState(1222);
      match(MySQLParser::FUNCTION_SYMBOL);
      setState(1223);
      functionRef();
      setState(1225);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MySQLParser::COMMENT_SYMBOL)
        | (1ULL << MySQLParser::CONTAINS_SYMBOL)
        | (1ULL << MySQLParser::LANGUAGE_SYMBOL)
        | (1ULL << MySQLParser::NO_SYMBOL))) != 0) || _la == MySQLParser::DETERMINISTIC_SYMBOL || ((((_la - 566) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 566)) & ((1ULL << (MySQLParser::MODIFIES_SYMBOL - 566))
        | (1ULL << (MySQLParser::NOT_SYMBOL - 566))
        | (1ULL << (MySQLParser::READS_SYMBOL - 566)))) != 0) || _la == MySQLParser::SQL_SYMBOL) {
        setState(1224);
        routineAlterOptions();
      }
      break;
    }

    case 5: {
      setState(1227);
      alterView();
      break;
    }

    case 6: {
      setState(1228);
      alterEvent();
      break;
    }

    case 7: {
      setState(1229);
      alterTablespace();
      break;
    }

    case 8: {
      setState(1230);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(1231);
      alterUndoTablespace();
      break;
    }

    case 9: {
      setState(1232);
      alterLogfileGroup();
      break;
    }

    case 10: {
      setState(1233);
      alterServer();
      break;
    }

    case 11: {
      setState(1234);

      if (!(serverVersion >= 50713)) throw FailedPredicateException(this, "serverVersion >= 50713");
      setState(1235);
      match(MySQLParser::INSTANCE_SYMBOL);
      setState(1236);
      match(MySQLParser::ROTATE_SYMBOL);
      setState(1237);
      textOrIdentifier();
      setState(1238);
      match(MySQLParser::MASTER_SYMBOL);
      setState(1239);
      match(MySQLParser::KEY_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterDatabaseContext ------------------------------------------------------------------

MySQLParser::AlterDatabaseContext::AlterDatabaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterDatabaseContext::DATABASE_SYMBOL() {
  return getToken(MySQLParser::DATABASE_SYMBOL, 0);
}

MySQLParser::SchemaRefContext* MySQLParser::AlterDatabaseContext::schemaRef() {
  return getRuleContext<MySQLParser::SchemaRefContext>(0);
}

tree::TerminalNode* MySQLParser::AlterDatabaseContext::UPGRADE_SYMBOL() {
  return getToken(MySQLParser::UPGRADE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterDatabaseContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterDatabaseContext::DIRECTORY_SYMBOL() {
  return getToken(MySQLParser::DIRECTORY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterDatabaseContext::NAME_SYMBOL() {
  return getToken(MySQLParser::NAME_SYMBOL, 0);
}

std::vector<MySQLParser::CreateDatabaseOptionContext *> MySQLParser::AlterDatabaseContext::createDatabaseOption() {
  return getRuleContexts<MySQLParser::CreateDatabaseOptionContext>();
}

MySQLParser::CreateDatabaseOptionContext* MySQLParser::AlterDatabaseContext::createDatabaseOption(size_t i) {
  return getRuleContext<MySQLParser::CreateDatabaseOptionContext>(i);
}


size_t MySQLParser::AlterDatabaseContext::getRuleIndex() const {
  return MySQLParser::RuleAlterDatabase;
}

void MySQLParser::AlterDatabaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterDatabase(this);
}

void MySQLParser::AlterDatabaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterDatabase(this);
}


antlrcpp::Any MySQLParser::AlterDatabaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterDatabase(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterDatabaseContext* MySQLParser::alterDatabase() {
  AlterDatabaseContext *_localctx = _tracker.createInstance<AlterDatabaseContext>(_ctx, getState());
  enterRule(_localctx, 6, MySQLParser::RuleAlterDatabase);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1243);
    match(MySQLParser::DATABASE_SYMBOL);
    setState(1244);
    schemaRef();
    setState(1255);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
    case 1: {
      setState(1246); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(1245);
                createDatabaseOption();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(1248); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    case 2: {
      setState(1250);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(1251);
      match(MySQLParser::UPGRADE_SYMBOL);
      setState(1252);
      match(MySQLParser::DATA_SYMBOL);
      setState(1253);
      match(MySQLParser::DIRECTORY_SYMBOL);
      setState(1254);
      match(MySQLParser::NAME_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterEventContext ------------------------------------------------------------------

MySQLParser::AlterEventContext::AlterEventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterEventContext::EVENT_SYMBOL() {
  return getToken(MySQLParser::EVENT_SYMBOL, 0);
}

MySQLParser::EventRefContext* MySQLParser::AlterEventContext::eventRef() {
  return getRuleContext<MySQLParser::EventRefContext>(0);
}

MySQLParser::DefinerClauseContext* MySQLParser::AlterEventContext::definerClause() {
  return getRuleContext<MySQLParser::DefinerClauseContext>(0);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterEventContext::ON_SYMBOL() {
  return getTokens(MySQLParser::ON_SYMBOL);
}

tree::TerminalNode* MySQLParser::AlterEventContext::ON_SYMBOL(size_t i) {
  return getToken(MySQLParser::ON_SYMBOL, i);
}

tree::TerminalNode* MySQLParser::AlterEventContext::SCHEDULE_SYMBOL() {
  return getToken(MySQLParser::SCHEDULE_SYMBOL, 0);
}

MySQLParser::ScheduleContext* MySQLParser::AlterEventContext::schedule() {
  return getRuleContext<MySQLParser::ScheduleContext>(0);
}

tree::TerminalNode* MySQLParser::AlterEventContext::COMPLETION_SYMBOL() {
  return getToken(MySQLParser::COMPLETION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterEventContext::PRESERVE_SYMBOL() {
  return getToken(MySQLParser::PRESERVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterEventContext::RENAME_SYMBOL() {
  return getToken(MySQLParser::RENAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterEventContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::AlterEventContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::AlterEventContext::ENABLE_SYMBOL() {
  return getToken(MySQLParser::ENABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterEventContext::DISABLE_SYMBOL() {
  return getToken(MySQLParser::DISABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterEventContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::AlterEventContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::AlterEventContext::DO_SYMBOL() {
  return getToken(MySQLParser::DO_SYMBOL, 0);
}

MySQLParser::CompoundStatementContext* MySQLParser::AlterEventContext::compoundStatement() {
  return getRuleContext<MySQLParser::CompoundStatementContext>(0);
}

tree::TerminalNode* MySQLParser::AlterEventContext::NOT_SYMBOL() {
  return getToken(MySQLParser::NOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterEventContext::SLAVE_SYMBOL() {
  return getToken(MySQLParser::SLAVE_SYMBOL, 0);
}


size_t MySQLParser::AlterEventContext::getRuleIndex() const {
  return MySQLParser::RuleAlterEvent;
}

void MySQLParser::AlterEventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterEvent(this);
}

void MySQLParser::AlterEventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterEvent(this);
}


antlrcpp::Any MySQLParser::AlterEventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterEvent(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterEventContext* MySQLParser::alterEvent() {
  AlterEventContext *_localctx = _tracker.createInstance<AlterEventContext>(_ctx, getState());
  enterRule(_localctx, 8, MySQLParser::RuleAlterEvent);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1258);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFINER_SYMBOL) {
      setState(1257);
      definerClause();
    }
    setState(1260);
    match(MySQLParser::EVENT_SYMBOL);
    setState(1261);
    eventRef();
    setState(1265);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx)) {
    case 1: {
      setState(1262);
      match(MySQLParser::ON_SYMBOL);
      setState(1263);
      match(MySQLParser::SCHEDULE_SYMBOL);
      setState(1264);
      schedule();
      break;
    }

    }
    setState(1273);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ON_SYMBOL) {
      setState(1267);
      match(MySQLParser::ON_SYMBOL);
      setState(1268);
      match(MySQLParser::COMPLETION_SYMBOL);
      setState(1270);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::NOT_SYMBOL) {
        setState(1269);
        match(MySQLParser::NOT_SYMBOL);
      }
      setState(1272);
      match(MySQLParser::PRESERVE_SYMBOL);
    }
    setState(1278);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::RENAME_SYMBOL) {
      setState(1275);
      match(MySQLParser::RENAME_SYMBOL);
      setState(1276);
      match(MySQLParser::TO_SYMBOL);
      setState(1277);
      identifier();
    }
    setState(1286);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ENABLE_SYMBOL: {
        setState(1280);
        match(MySQLParser::ENABLE_SYMBOL);
        break;
      }

      case MySQLParser::DISABLE_SYMBOL: {
        setState(1281);
        match(MySQLParser::DISABLE_SYMBOL);
        setState(1284);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ON_SYMBOL) {
          setState(1282);
          match(MySQLParser::ON_SYMBOL);
          setState(1283);
          match(MySQLParser::SLAVE_SYMBOL);
        }
        break;
      }

      case MySQLParser::EOF:
      case MySQLParser::COMMENT_SYMBOL:
      case MySQLParser::DO_SYMBOL:
      case MySQLParser::SEMICOLON_SYMBOL: {
        break;
      }

    default:
      break;
    }
    setState(1290);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::COMMENT_SYMBOL) {
      setState(1288);
      match(MySQLParser::COMMENT_SYMBOL);
      setState(1289);
      textLiteral();
    }
    setState(1294);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DO_SYMBOL) {
      setState(1292);
      match(MySQLParser::DO_SYMBOL);
      setState(1293);
      compoundStatement();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterLogfileGroupContext ------------------------------------------------------------------

MySQLParser::AlterLogfileGroupContext::AlterLogfileGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterLogfileGroupContext::LOGFILE_SYMBOL() {
  return getToken(MySQLParser::LOGFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterLogfileGroupContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::LogfileGroupRefContext* MySQLParser::AlterLogfileGroupContext::logfileGroupRef() {
  return getRuleContext<MySQLParser::LogfileGroupRefContext>(0);
}

tree::TerminalNode* MySQLParser::AlterLogfileGroupContext::ADD_SYMBOL() {
  return getToken(MySQLParser::ADD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterLogfileGroupContext::UNDOFILE_SYMBOL() {
  return getToken(MySQLParser::UNDOFILE_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::AlterLogfileGroupContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

MySQLParser::AlterLogfileGroupOptionsContext* MySQLParser::AlterLogfileGroupContext::alterLogfileGroupOptions() {
  return getRuleContext<MySQLParser::AlterLogfileGroupOptionsContext>(0);
}


size_t MySQLParser::AlterLogfileGroupContext::getRuleIndex() const {
  return MySQLParser::RuleAlterLogfileGroup;
}

void MySQLParser::AlterLogfileGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterLogfileGroup(this);
}

void MySQLParser::AlterLogfileGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterLogfileGroup(this);
}


antlrcpp::Any MySQLParser::AlterLogfileGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterLogfileGroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterLogfileGroupContext* MySQLParser::alterLogfileGroup() {
  AlterLogfileGroupContext *_localctx = _tracker.createInstance<AlterLogfileGroupContext>(_ctx, getState());
  enterRule(_localctx, 10, MySQLParser::RuleAlterLogfileGroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1296);
    match(MySQLParser::LOGFILE_SYMBOL);
    setState(1297);
    match(MySQLParser::GROUP_SYMBOL);
    setState(1298);
    logfileGroupRef();
    setState(1299);
    match(MySQLParser::ADD_SYMBOL);
    setState(1300);
    match(MySQLParser::UNDOFILE_SYMBOL);
    setState(1301);
    textLiteral();
    setState(1303);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ENGINE_SYMBOL

    || _la == MySQLParser::INITIAL_SIZE_SYMBOL || _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL

    || _la == MySQLParser::WAIT_SYMBOL) {
      setState(1302);
      alterLogfileGroupOptions();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterLogfileGroupOptionsContext ------------------------------------------------------------------

MySQLParser::AlterLogfileGroupOptionsContext::AlterLogfileGroupOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::AlterLogfileGroupOptionContext *> MySQLParser::AlterLogfileGroupOptionsContext::alterLogfileGroupOption() {
  return getRuleContexts<MySQLParser::AlterLogfileGroupOptionContext>();
}

MySQLParser::AlterLogfileGroupOptionContext* MySQLParser::AlterLogfileGroupOptionsContext::alterLogfileGroupOption(size_t i) {
  return getRuleContext<MySQLParser::AlterLogfileGroupOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterLogfileGroupOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::AlterLogfileGroupOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::AlterLogfileGroupOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleAlterLogfileGroupOptions;
}

void MySQLParser::AlterLogfileGroupOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterLogfileGroupOptions(this);
}

void MySQLParser::AlterLogfileGroupOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterLogfileGroupOptions(this);
}


antlrcpp::Any MySQLParser::AlterLogfileGroupOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterLogfileGroupOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterLogfileGroupOptionsContext* MySQLParser::alterLogfileGroupOptions() {
  AlterLogfileGroupOptionsContext *_localctx = _tracker.createInstance<AlterLogfileGroupOptionsContext>(_ctx, getState());
  enterRule(_localctx, 12, MySQLParser::RuleAlterLogfileGroupOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1305);
    alterLogfileGroupOption();
    setState(1312);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::ENGINE_SYMBOL

    || _la == MySQLParser::INITIAL_SIZE_SYMBOL || _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL

    || _la == MySQLParser::WAIT_SYMBOL || _la == MySQLParser::COMMA_SYMBOL) {
      setState(1307);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(1306);
        match(MySQLParser::COMMA_SYMBOL);
      }
      setState(1309);
      alterLogfileGroupOption();
      setState(1314);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterLogfileGroupOptionContext ------------------------------------------------------------------

MySQLParser::AlterLogfileGroupOptionContext::AlterLogfileGroupOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TsOptionInitialSizeContext* MySQLParser::AlterLogfileGroupOptionContext::tsOptionInitialSize() {
  return getRuleContext<MySQLParser::TsOptionInitialSizeContext>(0);
}

MySQLParser::TsOptionEngineContext* MySQLParser::AlterLogfileGroupOptionContext::tsOptionEngine() {
  return getRuleContext<MySQLParser::TsOptionEngineContext>(0);
}

MySQLParser::TsOptionWaitContext* MySQLParser::AlterLogfileGroupOptionContext::tsOptionWait() {
  return getRuleContext<MySQLParser::TsOptionWaitContext>(0);
}


size_t MySQLParser::AlterLogfileGroupOptionContext::getRuleIndex() const {
  return MySQLParser::RuleAlterLogfileGroupOption;
}

void MySQLParser::AlterLogfileGroupOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterLogfileGroupOption(this);
}

void MySQLParser::AlterLogfileGroupOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterLogfileGroupOption(this);
}


antlrcpp::Any MySQLParser::AlterLogfileGroupOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterLogfileGroupOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterLogfileGroupOptionContext* MySQLParser::alterLogfileGroupOption() {
  AlterLogfileGroupOptionContext *_localctx = _tracker.createInstance<AlterLogfileGroupOptionContext>(_ctx, getState());
  enterRule(_localctx, 14, MySQLParser::RuleAlterLogfileGroupOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1318);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INITIAL_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(1315);
        tsOptionInitialSize();
        break;
      }

      case MySQLParser::ENGINE_SYMBOL:
      case MySQLParser::STORAGE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(1316);
        tsOptionEngine();
        break;
      }

      case MySQLParser::NO_WAIT_SYMBOL:
      case MySQLParser::WAIT_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(1317);
        tsOptionWait();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterServerContext ------------------------------------------------------------------

MySQLParser::AlterServerContext::AlterServerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterServerContext::SERVER_SYMBOL() {
  return getToken(MySQLParser::SERVER_SYMBOL, 0);
}

MySQLParser::ServerRefContext* MySQLParser::AlterServerContext::serverRef() {
  return getRuleContext<MySQLParser::ServerRefContext>(0);
}

MySQLParser::ServerOptionsContext* MySQLParser::AlterServerContext::serverOptions() {
  return getRuleContext<MySQLParser::ServerOptionsContext>(0);
}


size_t MySQLParser::AlterServerContext::getRuleIndex() const {
  return MySQLParser::RuleAlterServer;
}

void MySQLParser::AlterServerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterServer(this);
}

void MySQLParser::AlterServerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterServer(this);
}


antlrcpp::Any MySQLParser::AlterServerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterServer(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterServerContext* MySQLParser::alterServer() {
  AlterServerContext *_localctx = _tracker.createInstance<AlterServerContext>(_ctx, getState());
  enterRule(_localctx, 16, MySQLParser::RuleAlterServer);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1320);
    match(MySQLParser::SERVER_SYMBOL);
    setState(1321);
    serverRef();
    setState(1322);
    serverOptions();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterTableContext ------------------------------------------------------------------

MySQLParser::AlterTableContext::AlterTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterTableContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::AlterTableContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::OnlineOptionContext* MySQLParser::AlterTableContext::onlineOption() {
  return getRuleContext<MySQLParser::OnlineOptionContext>(0);
}

tree::TerminalNode* MySQLParser::AlterTableContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

MySQLParser::AlterTableActionsContext* MySQLParser::AlterTableContext::alterTableActions() {
  return getRuleContext<MySQLParser::AlterTableActionsContext>(0);
}


size_t MySQLParser::AlterTableContext::getRuleIndex() const {
  return MySQLParser::RuleAlterTable;
}

void MySQLParser::AlterTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTable(this);
}

void MySQLParser::AlterTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTable(this);
}


antlrcpp::Any MySQLParser::AlterTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterTableContext* MySQLParser::alterTable() {
  AlterTableContext *_localctx = _tracker.createInstance<AlterTableContext>(_ctx, getState());
  enterRule(_localctx, 18, MySQLParser::RuleAlterTable);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1325);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx)) {
    case 1: {
      setState(1324);
      onlineOption();
      break;
    }

    }
    setState(1329);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
    case 1: {
      setState(1327);

      if (!(serverVersion < 50700)) throw FailedPredicateException(this, "serverVersion < 50700");
      setState(1328);
      match(MySQLParser::IGNORE_SYMBOL);
      break;
    }

    }
    setState(1331);
    match(MySQLParser::TABLE_SYMBOL);
    setState(1332);
    tableRef();
    setState(1334);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {
    case 1: {
      setState(1333);
      alterTableActions();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterTableActionsContext ------------------------------------------------------------------

MySQLParser::AlterTableActionsContext::AlterTableActionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::AlterCommandListContext* MySQLParser::AlterTableActionsContext::alterCommandList() {
  return getRuleContext<MySQLParser::AlterCommandListContext>(0);
}

MySQLParser::PartitionClauseContext* MySQLParser::AlterTableActionsContext::partitionClause() {
  return getRuleContext<MySQLParser::PartitionClauseContext>(0);
}

MySQLParser::RemovePartitioningContext* MySQLParser::AlterTableActionsContext::removePartitioning() {
  return getRuleContext<MySQLParser::RemovePartitioningContext>(0);
}

MySQLParser::StandaloneAlterCommandsContext* MySQLParser::AlterTableActionsContext::standaloneAlterCommands() {
  return getRuleContext<MySQLParser::StandaloneAlterCommandsContext>(0);
}

MySQLParser::AlterCommandsModifierListContext* MySQLParser::AlterTableActionsContext::alterCommandsModifierList() {
  return getRuleContext<MySQLParser::AlterCommandsModifierListContext>(0);
}

tree::TerminalNode* MySQLParser::AlterTableActionsContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}


size_t MySQLParser::AlterTableActionsContext::getRuleIndex() const {
  return MySQLParser::RuleAlterTableActions;
}

void MySQLParser::AlterTableActionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTableActions(this);
}

void MySQLParser::AlterTableActionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTableActions(this);
}


antlrcpp::Any MySQLParser::AlterTableActionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterTableActions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterTableActionsContext* MySQLParser::alterTableActions() {
  AlterTableActionsContext *_localctx = _tracker.createInstance<AlterTableActionsContext>(_ctx, getState());
  enterRule(_localctx, 20, MySQLParser::RuleAlterTableActions);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1349);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1336);
      alterCommandList();
      setState(1339);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::PARTITION_SYMBOL: {
          setState(1337);
          partitionClause();
          break;
        }

        case MySQLParser::REMOVE_SYMBOL: {
          setState(1338);
          removePartitioning();
          break;
        }

        case MySQLParser::EOF:
        case MySQLParser::SEMICOLON_SYMBOL: {
          break;
        }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1341);
      partitionClause();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1342);
      removePartitioning();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1346);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
      case 1: {
        setState(1343);
        alterCommandsModifierList();
        setState(1344);
        match(MySQLParser::COMMA_SYMBOL);
        break;
      }

      }
      setState(1348);
      standaloneAlterCommands();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterCommandListContext ------------------------------------------------------------------

MySQLParser::AlterCommandListContext::AlterCommandListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::AlterCommandsModifierListContext* MySQLParser::AlterCommandListContext::alterCommandsModifierList() {
  return getRuleContext<MySQLParser::AlterCommandsModifierListContext>(0);
}

MySQLParser::AlterListContext* MySQLParser::AlterCommandListContext::alterList() {
  return getRuleContext<MySQLParser::AlterListContext>(0);
}

tree::TerminalNode* MySQLParser::AlterCommandListContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}


size_t MySQLParser::AlterCommandListContext::getRuleIndex() const {
  return MySQLParser::RuleAlterCommandList;
}

void MySQLParser::AlterCommandListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterCommandList(this);
}

void MySQLParser::AlterCommandListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterCommandList(this);
}


antlrcpp::Any MySQLParser::AlterCommandListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterCommandList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterCommandListContext* MySQLParser::alterCommandList() {
  AlterCommandListContext *_localctx = _tracker.createInstance<AlterCommandListContext>(_ctx, getState());
  enterRule(_localctx, 22, MySQLParser::RuleAlterCommandList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1358);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1351);
      alterCommandsModifierList();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1355);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
      case 1: {
        setState(1352);
        alterCommandsModifierList();
        setState(1353);
        match(MySQLParser::COMMA_SYMBOL);
        break;
      }

      }
      setState(1357);
      alterList();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterCommandsModifierListContext ------------------------------------------------------------------

MySQLParser::AlterCommandsModifierListContext::AlterCommandsModifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::AlterCommandsModifierContext *> MySQLParser::AlterCommandsModifierListContext::alterCommandsModifier() {
  return getRuleContexts<MySQLParser::AlterCommandsModifierContext>();
}

MySQLParser::AlterCommandsModifierContext* MySQLParser::AlterCommandsModifierListContext::alterCommandsModifier(size_t i) {
  return getRuleContext<MySQLParser::AlterCommandsModifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterCommandsModifierListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::AlterCommandsModifierListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::AlterCommandsModifierListContext::getRuleIndex() const {
  return MySQLParser::RuleAlterCommandsModifierList;
}

void MySQLParser::AlterCommandsModifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterCommandsModifierList(this);
}

void MySQLParser::AlterCommandsModifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterCommandsModifierList(this);
}


antlrcpp::Any MySQLParser::AlterCommandsModifierListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterCommandsModifierList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterCommandsModifierListContext* MySQLParser::alterCommandsModifierList() {
  AlterCommandsModifierListContext *_localctx = _tracker.createInstance<AlterCommandsModifierListContext>(_ctx, getState());
  enterRule(_localctx, 24, MySQLParser::RuleAlterCommandsModifierList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1360);
    alterCommandsModifier();
    setState(1365);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1361);
        match(MySQLParser::COMMA_SYMBOL);
        setState(1362);
        alterCommandsModifier(); 
      }
      setState(1367);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StandaloneAlterCommandsContext ------------------------------------------------------------------

MySQLParser::StandaloneAlterCommandsContext::StandaloneAlterCommandsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::StandaloneAlterCommandsContext::DISCARD_SYMBOL() {
  return getToken(MySQLParser::DISCARD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::StandaloneAlterCommandsContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::StandaloneAlterCommandsContext::IMPORT_SYMBOL() {
  return getToken(MySQLParser::IMPORT_SYMBOL, 0);
}

MySQLParser::AlterPartitionContext* MySQLParser::StandaloneAlterCommandsContext::alterPartition() {
  return getRuleContext<MySQLParser::AlterPartitionContext>(0);
}

tree::TerminalNode* MySQLParser::StandaloneAlterCommandsContext::SECONDARY_LOAD_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_LOAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::StandaloneAlterCommandsContext::SECONDARY_UNLOAD_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_UNLOAD_SYMBOL, 0);
}


size_t MySQLParser::StandaloneAlterCommandsContext::getRuleIndex() const {
  return MySQLParser::RuleStandaloneAlterCommands;
}

void MySQLParser::StandaloneAlterCommandsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStandaloneAlterCommands(this);
}

void MySQLParser::StandaloneAlterCommandsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStandaloneAlterCommands(this);
}


antlrcpp::Any MySQLParser::StandaloneAlterCommandsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitStandaloneAlterCommands(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::StandaloneAlterCommandsContext* MySQLParser::standaloneAlterCommands() {
  StandaloneAlterCommandsContext *_localctx = _tracker.createInstance<StandaloneAlterCommandsContext>(_ctx, getState());
  enterRule(_localctx, 26, MySQLParser::RuleStandaloneAlterCommands);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1375);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1368);
      match(MySQLParser::DISCARD_SYMBOL);
      setState(1369);
      match(MySQLParser::TABLESPACE_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1370);
      match(MySQLParser::IMPORT_SYMBOL);
      setState(1371);
      match(MySQLParser::TABLESPACE_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1372);
      alterPartition();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1373);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(1374);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::SECONDARY_LOAD_SYMBOL

      || _la == MySQLParser::SECONDARY_UNLOAD_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterPartitionContext ------------------------------------------------------------------

MySQLParser::AlterPartitionContext::AlterPartitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::ADD_SYMBOL() {
  return getToken(MySQLParser::ADD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

MySQLParser::PartitionDefinitionsContext* MySQLParser::AlterPartitionContext::partitionDefinitions() {
  return getRuleContext<MySQLParser::PartitionDefinitionsContext>(0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::PARTITIONS_SYMBOL() {
  return getToken(MySQLParser::PARTITIONS_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::AlterPartitionContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

std::vector<MySQLParser::NoWriteToBinLogContext *> MySQLParser::AlterPartitionContext::noWriteToBinLog() {
  return getRuleContexts<MySQLParser::NoWriteToBinLogContext>();
}

MySQLParser::NoWriteToBinLogContext* MySQLParser::AlterPartitionContext::noWriteToBinLog(size_t i) {
  return getRuleContext<MySQLParser::NoWriteToBinLogContext>(i);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

MySQLParser::IdentifierListContext* MySQLParser::AlterPartitionContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::REBUILD_SYMBOL() {
  return getToken(MySQLParser::REBUILD_SYMBOL, 0);
}

MySQLParser::AllOrPartitionNameListContext* MySQLParser::AlterPartitionContext::allOrPartitionNameList() {
  return getRuleContext<MySQLParser::AllOrPartitionNameListContext>(0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::OPTIMIZE_SYMBOL() {
  return getToken(MySQLParser::OPTIMIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::ANALYZE_SYMBOL() {
  return getToken(MySQLParser::ANALYZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::CHECK_SYMBOL() {
  return getToken(MySQLParser::CHECK_SYMBOL, 0);
}

std::vector<MySQLParser::CheckOptionContext *> MySQLParser::AlterPartitionContext::checkOption() {
  return getRuleContexts<MySQLParser::CheckOptionContext>();
}

MySQLParser::CheckOptionContext* MySQLParser::AlterPartitionContext::checkOption(size_t i) {
  return getRuleContext<MySQLParser::CheckOptionContext>(i);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::REPAIR_SYMBOL() {
  return getToken(MySQLParser::REPAIR_SYMBOL, 0);
}

std::vector<MySQLParser::RepairTypeContext *> MySQLParser::AlterPartitionContext::repairType() {
  return getRuleContexts<MySQLParser::RepairTypeContext>();
}

MySQLParser::RepairTypeContext* MySQLParser::AlterPartitionContext::repairType(size_t i) {
  return getRuleContext<MySQLParser::RepairTypeContext>(i);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::COALESCE_SYMBOL() {
  return getToken(MySQLParser::COALESCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::TRUNCATE_SYMBOL() {
  return getToken(MySQLParser::TRUNCATE_SYMBOL, 0);
}

MySQLParser::ReorgPartitionRuleContext* MySQLParser::AlterPartitionContext::reorgPartitionRule() {
  return getRuleContext<MySQLParser::ReorgPartitionRuleContext>(0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::REORGANIZE_SYMBOL() {
  return getToken(MySQLParser::REORGANIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::EXCHANGE_SYMBOL() {
  return getToken(MySQLParser::EXCHANGE_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::AlterPartitionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::AlterPartitionContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::WithValidationContext* MySQLParser::AlterPartitionContext::withValidation() {
  return getRuleContext<MySQLParser::WithValidationContext>(0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::DISCARD_SYMBOL() {
  return getToken(MySQLParser::DISCARD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::IMPORT_SYMBOL() {
  return getToken(MySQLParser::IMPORT_SYMBOL, 0);
}


size_t MySQLParser::AlterPartitionContext::getRuleIndex() const {
  return MySQLParser::RuleAlterPartition;
}

void MySQLParser::AlterPartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterPartition(this);
}

void MySQLParser::AlterPartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterPartition(this);
}


antlrcpp::Any MySQLParser::AlterPartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterPartition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterPartitionContext* MySQLParser::alterPartition() {
  AlterPartitionContext *_localctx = _tracker.createInstance<AlterPartitionContext>(_ctx, getState());
  enterRule(_localctx, 28, MySQLParser::RuleAlterPartition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1475);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1377);
      match(MySQLParser::ADD_SYMBOL);
      setState(1378);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1380);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL) {
        setState(1379);
        noWriteToBinLog();
      }
      setState(1385);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::OPEN_PAR_SYMBOL: {
          setState(1382);
          partitionDefinitions();
          break;
        }

        case MySQLParser::PARTITIONS_SYMBOL: {
          setState(1383);
          match(MySQLParser::PARTITIONS_SYMBOL);
          setState(1384);
          real_ulong_number();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1387);
      match(MySQLParser::DROP_SYMBOL);
      setState(1388);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1389);
      identifierList();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1390);
      match(MySQLParser::REBUILD_SYMBOL);
      setState(1391);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1393);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
      case 1: {
        setState(1392);
        noWriteToBinLog();
        break;
      }

      }
      setState(1395);
      allOrPartitionNameList();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1396);
      match(MySQLParser::OPTIMIZE_SYMBOL);
      setState(1397);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1399);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx)) {
      case 1: {
        setState(1398);
        noWriteToBinLog();
        break;
      }

      }
      setState(1401);
      allOrPartitionNameList();
      setState(1403);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL) {
        setState(1402);
        noWriteToBinLog();
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1405);
      match(MySQLParser::ANALYZE_SYMBOL);
      setState(1406);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1408);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx)) {
      case 1: {
        setState(1407);
        noWriteToBinLog();
        break;
      }

      }
      setState(1410);
      allOrPartitionNameList();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1411);
      match(MySQLParser::CHECK_SYMBOL);
      setState(1412);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1413);
      allOrPartitionNameList();
      setState(1417);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 80) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 80)) & ((1ULL << (MySQLParser::CHANGED_SYMBOL - 80))
        | (1ULL << (MySQLParser::EXTENDED_SYMBOL - 80))
        | (1ULL << (MySQLParser::FAST_SYMBOL - 80)))) != 0) || _la == MySQLParser::MEDIUM_SYMBOL

      || _la == MySQLParser::QUICK_SYMBOL || _la == MySQLParser::FOR_SYMBOL) {
        setState(1414);
        checkOption();
        setState(1419);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1420);
      match(MySQLParser::REPAIR_SYMBOL);
      setState(1421);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1423);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
      case 1: {
        setState(1422);
        noWriteToBinLog();
        break;
      }

      }
      setState(1425);
      allOrPartitionNameList();
      setState(1429);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::EXTENDED_SYMBOL || _la == MySQLParser::QUICK_SYMBOL || _la == MySQLParser::USE_FRM_SYMBOL) {
        setState(1426);
        repairType();
        setState(1431);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1432);
      match(MySQLParser::COALESCE_SYMBOL);
      setState(1433);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1435);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL) {
        setState(1434);
        noWriteToBinLog();
      }
      setState(1437);
      real_ulong_number();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1438);

      if (!(serverVersion >= 50500)) throw FailedPredicateException(this, "serverVersion >= 50500");
      setState(1439);
      match(MySQLParser::TRUNCATE_SYMBOL);
      setState(1440);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1441);
      allOrPartitionNameList();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1442);
      reorgPartitionRule();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1443);
      match(MySQLParser::REORGANIZE_SYMBOL);
      setState(1444);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1446);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
      case 1: {
        setState(1445);
        noWriteToBinLog();
        break;
      }

      }
      setState(1452);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
      case 1: {
        setState(1448);
        identifierList();
        setState(1449);
        match(MySQLParser::INTO_SYMBOL);
        setState(1450);
        partitionDefinitions();
        break;
      }

      }
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(1454);
      match(MySQLParser::EXCHANGE_SYMBOL);
      setState(1455);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1456);
      identifier();
      setState(1457);
      match(MySQLParser::WITH_SYMBOL);
      setState(1458);
      match(MySQLParser::TABLE_SYMBOL);
      setState(1459);
      tableRef();
      setState(1461);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx)) {
      case 1: {
        setState(1460);
        withValidation();
        break;
      }

      }
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(1463);

      if (!(serverVersion >= 50704)) throw FailedPredicateException(this, "serverVersion >= 50704");
      setState(1464);
      match(MySQLParser::DISCARD_SYMBOL);
      setState(1465);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1466);
      allOrPartitionNameList();
      setState(1467);
      match(MySQLParser::TABLESPACE_SYMBOL);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(1469);

      if (!(serverVersion >= 50704)) throw FailedPredicateException(this, "serverVersion >= 50704");
      setState(1470);
      match(MySQLParser::IMPORT_SYMBOL);
      setState(1471);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1472);
      allOrPartitionNameList();
      setState(1473);
      match(MySQLParser::TABLESPACE_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterListContext ------------------------------------------------------------------

MySQLParser::AlterListContext::AlterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::AlterListItemContext *> MySQLParser::AlterListContext::alterListItem() {
  return getRuleContexts<MySQLParser::AlterListItemContext>();
}

MySQLParser::AlterListItemContext* MySQLParser::AlterListContext::alterListItem(size_t i) {
  return getRuleContext<MySQLParser::AlterListItemContext>(i);
}

std::vector<MySQLParser::CreateTableOptionsSpaceSeparatedContext *> MySQLParser::AlterListContext::createTableOptionsSpaceSeparated() {
  return getRuleContexts<MySQLParser::CreateTableOptionsSpaceSeparatedContext>();
}

MySQLParser::CreateTableOptionsSpaceSeparatedContext* MySQLParser::AlterListContext::createTableOptionsSpaceSeparated(size_t i) {
  return getRuleContext<MySQLParser::CreateTableOptionsSpaceSeparatedContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::AlterListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

std::vector<MySQLParser::AlterCommandsModifierContext *> MySQLParser::AlterListContext::alterCommandsModifier() {
  return getRuleContexts<MySQLParser::AlterCommandsModifierContext>();
}

MySQLParser::AlterCommandsModifierContext* MySQLParser::AlterListContext::alterCommandsModifier(size_t i) {
  return getRuleContext<MySQLParser::AlterCommandsModifierContext>(i);
}


size_t MySQLParser::AlterListContext::getRuleIndex() const {
  return MySQLParser::RuleAlterList;
}

void MySQLParser::AlterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterList(this);
}

void MySQLParser::AlterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterList(this);
}


antlrcpp::Any MySQLParser::AlterListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterListContext* MySQLParser::alterList() {
  AlterListContext *_localctx = _tracker.createInstance<AlterListContext>(_ctx, getState());
  enterRule(_localctx, 30, MySQLParser::RuleAlterList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1479);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx)) {
    case 1: {
      setState(1477);
      alterListItem();
      break;
    }

    case 2: {
      setState(1478);
      createTableOptionsSpaceSeparated();
      break;
    }

    }
    setState(1489);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(1481);
      match(MySQLParser::COMMA_SYMBOL);
      setState(1485);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx)) {
      case 1: {
        setState(1482);
        alterListItem();
        break;
      }

      case 2: {
        setState(1483);
        alterCommandsModifier();
        break;
      }

      case 3: {
        setState(1484);
        createTableOptionsSpaceSeparated();
        break;
      }

      }
      setState(1491);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterCommandsModifierContext ------------------------------------------------------------------

MySQLParser::AlterCommandsModifierContext::AlterCommandsModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::AlterAlgorithmOptionContext* MySQLParser::AlterCommandsModifierContext::alterAlgorithmOption() {
  return getRuleContext<MySQLParser::AlterAlgorithmOptionContext>(0);
}

MySQLParser::AlterLockOptionContext* MySQLParser::AlterCommandsModifierContext::alterLockOption() {
  return getRuleContext<MySQLParser::AlterLockOptionContext>(0);
}

MySQLParser::WithValidationContext* MySQLParser::AlterCommandsModifierContext::withValidation() {
  return getRuleContext<MySQLParser::WithValidationContext>(0);
}


size_t MySQLParser::AlterCommandsModifierContext::getRuleIndex() const {
  return MySQLParser::RuleAlterCommandsModifier;
}

void MySQLParser::AlterCommandsModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterCommandsModifier(this);
}

void MySQLParser::AlterCommandsModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterCommandsModifier(this);
}


antlrcpp::Any MySQLParser::AlterCommandsModifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterCommandsModifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterCommandsModifierContext* MySQLParser::alterCommandsModifier() {
  AlterCommandsModifierContext *_localctx = _tracker.createInstance<AlterCommandsModifierContext>(_ctx, getState());
  enterRule(_localctx, 32, MySQLParser::RuleAlterCommandsModifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1497);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1492);

      if (!(serverVersion >= 50600)) throw FailedPredicateException(this, "serverVersion >= 50600");
      setState(1493);
      alterAlgorithmOption();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1494);

      if (!(serverVersion >= 50600)) throw FailedPredicateException(this, "serverVersion >= 50600");
      setState(1495);
      alterLockOption();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1496);
      withValidation();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterListItemContext ------------------------------------------------------------------

MySQLParser::AlterListItemContext::AlterListItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterListItemContext::ADD_SYMBOL() {
  return getToken(MySQLParser::ADD_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::AlterListItemContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::FieldDefinitionContext* MySQLParser::AlterListItemContext::fieldDefinition() {
  return getRuleContext<MySQLParser::FieldDefinitionContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::TableElementListContext* MySQLParser::AlterListItemContext::tableElementList() {
  return getRuleContext<MySQLParser::TableElementListContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::COLUMN_SYMBOL() {
  return getToken(MySQLParser::COLUMN_SYMBOL, 0);
}

MySQLParser::CheckOrReferencesContext* MySQLParser::AlterListItemContext::checkOrReferences() {
  return getRuleContext<MySQLParser::CheckOrReferencesContext>(0);
}

MySQLParser::PlaceContext* MySQLParser::AlterListItemContext::place() {
  return getRuleContext<MySQLParser::PlaceContext>(0);
}

MySQLParser::TableConstraintDefContext* MySQLParser::AlterListItemContext::tableConstraintDef() {
  return getRuleContext<MySQLParser::TableConstraintDefContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::CHANGE_SYMBOL() {
  return getToken(MySQLParser::CHANGE_SYMBOL, 0);
}

MySQLParser::ColumnInternalRefContext* MySQLParser::AlterListItemContext::columnInternalRef() {
  return getRuleContext<MySQLParser::ColumnInternalRefContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::MODIFY_SYMBOL() {
  return getToken(MySQLParser::MODIFY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::FOREIGN_SYMBOL() {
  return getToken(MySQLParser::FOREIGN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::PRIMARY_SYMBOL() {
  return getToken(MySQLParser::PRIMARY_SYMBOL, 0);
}

MySQLParser::KeyOrIndexContext* MySQLParser::AlterListItemContext::keyOrIndex() {
  return getRuleContext<MySQLParser::KeyOrIndexContext>(0);
}

MySQLParser::IndexRefContext* MySQLParser::AlterListItemContext::indexRef() {
  return getRuleContext<MySQLParser::IndexRefContext>(0);
}

MySQLParser::RestrictContext* MySQLParser::AlterListItemContext::restrict() {
  return getRuleContext<MySQLParser::RestrictContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::DISABLE_SYMBOL() {
  return getToken(MySQLParser::DISABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::KEYS_SYMBOL() {
  return getToken(MySQLParser::KEYS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::ENABLE_SYMBOL() {
  return getToken(MySQLParser::ENABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::ALTER_SYMBOL() {
  return getToken(MySQLParser::ALTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::ExprWithParenthesesContext* MySQLParser::AlterListItemContext::exprWithParentheses() {
  return getRuleContext<MySQLParser::ExprWithParenthesesContext>(0);
}

MySQLParser::SignedLiteralContext* MySQLParser::AlterListItemContext::signedLiteral() {
  return getRuleContext<MySQLParser::SignedLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

MySQLParser::VisibilityContext* MySQLParser::AlterListItemContext::visibility() {
  return getRuleContext<MySQLParser::VisibilityContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::RENAME_SYMBOL() {
  return getToken(MySQLParser::RENAME_SYMBOL, 0);
}

MySQLParser::TableNameContext* MySQLParser::AlterListItemContext::tableName() {
  return getRuleContext<MySQLParser::TableNameContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::IndexNameContext* MySQLParser::AlterListItemContext::indexName() {
  return getRuleContext<MySQLParser::IndexNameContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::CONVERT_SYMBOL() {
  return getToken(MySQLParser::CONVERT_SYMBOL, 0);
}

MySQLParser::CharsetContext* MySQLParser::AlterListItemContext::charset() {
  return getRuleContext<MySQLParser::CharsetContext>(0);
}

MySQLParser::CharsetNameContext* MySQLParser::AlterListItemContext::charsetName() {
  return getRuleContext<MySQLParser::CharsetNameContext>(0);
}

MySQLParser::CollateContext* MySQLParser::AlterListItemContext::collate() {
  return getRuleContext<MySQLParser::CollateContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::FORCE_SYMBOL() {
  return getToken(MySQLParser::FORCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::ORDER_SYMBOL() {
  return getToken(MySQLParser::ORDER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::AlterOrderListContext* MySQLParser::AlterListItemContext::alterOrderList() {
  return getRuleContext<MySQLParser::AlterOrderListContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::UPGRADE_SYMBOL() {
  return getToken(MySQLParser::UPGRADE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::PARTITIONING_SYMBOL() {
  return getToken(MySQLParser::PARTITIONING_SYMBOL, 0);
}


size_t MySQLParser::AlterListItemContext::getRuleIndex() const {
  return MySQLParser::RuleAlterListItem;
}

void MySQLParser::AlterListItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterListItem(this);
}

void MySQLParser::AlterListItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterListItem(this);
}


antlrcpp::Any MySQLParser::AlterListItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterListItem(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterListItemContext* MySQLParser::alterListItem() {
  AlterListItemContext *_localctx = _tracker.createInstance<AlterListItemContext>(_ctx, getState());
  enterRule(_localctx, 34, MySQLParser::RuleAlterListItem);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1619);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1499);
      match(MySQLParser::ADD_SYMBOL);
      setState(1501);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
      case 1: {
        setState(1500);
        match(MySQLParser::COLUMN_SYMBOL);
        break;
      }

      }
      setState(1515);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx)) {
      case 1: {
        setState(1503);
        identifier();
        setState(1504);
        fieldDefinition();
        setState(1506);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::CHECK_SYMBOL || _la == MySQLParser::REFERENCES_SYMBOL) {
          setState(1505);
          checkOrReferences();
        }
        setState(1509);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::AFTER_SYMBOL || _la == MySQLParser::FIRST_SYMBOL) {
          setState(1508);
          place();
        }
        break;
      }

      case 2: {
        setState(1511);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(1512);
        tableElementList();
        setState(1513);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1517);
      match(MySQLParser::ADD_SYMBOL);
      setState(1518);
      tableConstraintDef();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1519);
      match(MySQLParser::CHANGE_SYMBOL);
      setState(1521);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 55, _ctx)) {
      case 1: {
        setState(1520);
        match(MySQLParser::COLUMN_SYMBOL);
        break;
      }

      }
      setState(1523);
      columnInternalRef();
      setState(1524);
      identifier();
      setState(1525);
      fieldDefinition();
      setState(1527);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::AFTER_SYMBOL || _la == MySQLParser::FIRST_SYMBOL) {
        setState(1526);
        place();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1529);
      match(MySQLParser::MODIFY_SYMBOL);
      setState(1531);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx)) {
      case 1: {
        setState(1530);
        match(MySQLParser::COLUMN_SYMBOL);
        break;
      }

      }
      setState(1533);
      columnInternalRef();
      setState(1534);
      fieldDefinition();
      setState(1536);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::AFTER_SYMBOL || _la == MySQLParser::FIRST_SYMBOL) {
        setState(1535);
        place();
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1538);
      match(MySQLParser::DROP_SYMBOL);
      setState(1561);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx)) {
      case 1: {
        setState(1540);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx)) {
        case 1: {
          setState(1539);
          match(MySQLParser::COLUMN_SYMBOL);
          break;
        }

        }
        setState(1542);
        columnInternalRef();
        setState(1544);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::CASCADE_SYMBOL || _la == MySQLParser::RESTRICT_SYMBOL) {
          setState(1543);
          restrict();
        }
        break;
      }

      case 2: {
        setState(1546);
        match(MySQLParser::FOREIGN_SYMBOL);
        setState(1547);
        match(MySQLParser::KEY_SYMBOL);
        setState(1554);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx)) {
        case 1: {
          setState(1548);

          if (!(serverVersion >= 50700)) throw FailedPredicateException(this, "serverVersion >= 50700");
          setState(1549);
          columnInternalRef();
          break;
        }

        case 2: {
          setState(1550);

          if (!(serverVersion < 50700)) throw FailedPredicateException(this, "serverVersion < 50700");
          setState(1552);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx)) {
          case 1: {
            setState(1551);
            columnInternalRef();
            break;
          }

          }
          break;
        }

        }
        break;
      }

      case 3: {
        setState(1556);
        match(MySQLParser::PRIMARY_SYMBOL);
        setState(1557);
        match(MySQLParser::KEY_SYMBOL);
        break;
      }

      case 4: {
        setState(1558);
        keyOrIndex();
        setState(1559);
        indexRef();
        break;
      }

      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1563);
      match(MySQLParser::DISABLE_SYMBOL);
      setState(1564);
      match(MySQLParser::KEYS_SYMBOL);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1565);
      match(MySQLParser::ENABLE_SYMBOL);
      setState(1566);
      match(MySQLParser::KEYS_SYMBOL);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1567);
      match(MySQLParser::ALTER_SYMBOL);
      setState(1569);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx)) {
      case 1: {
        setState(1568);
        match(MySQLParser::COLUMN_SYMBOL);
        break;
      }

      }
      setState(1571);
      columnInternalRef();
      setState(1581);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::SET_SYMBOL: {
          setState(1572);
          match(MySQLParser::SET_SYMBOL);
          setState(1573);
          match(MySQLParser::DEFAULT_SYMBOL);
          setState(1577);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
          case 1: {
            setState(1574);

            if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
            setState(1575);
            exprWithParentheses();
            break;
          }

          case 2: {
            setState(1576);
            signedLiteral();
            break;
          }

          }
          break;
        }

        case MySQLParser::DROP_SYMBOL: {
          setState(1579);
          match(MySQLParser::DROP_SYMBOL);
          setState(1580);
          match(MySQLParser::DEFAULT_SYMBOL);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1583);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(1584);
      match(MySQLParser::ALTER_SYMBOL);
      setState(1585);
      match(MySQLParser::INDEX_SYMBOL);
      setState(1586);
      indexRef();
      setState(1587);
      visibility();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1589);
      match(MySQLParser::RENAME_SYMBOL);
      setState(1591);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx)) {
      case 1: {
        setState(1590);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::AS_SYMBOL || _la == MySQLParser::TO_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      }
      setState(1593);
      tableName();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1594);

      if (!(serverVersion >= 50700)) throw FailedPredicateException(this, "serverVersion >= 50700");
      setState(1595);
      match(MySQLParser::RENAME_SYMBOL);
      setState(1596);
      keyOrIndex();
      setState(1597);
      indexRef();
      setState(1598);
      match(MySQLParser::TO_SYMBOL);
      setState(1599);
      indexName();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(1601);
      match(MySQLParser::CONVERT_SYMBOL);
      setState(1602);
      match(MySQLParser::TO_SYMBOL);
      setState(1603);
      charset();
      setState(1607);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 68, _ctx)) {
      case 1: {
        setState(1604);

        if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
        setState(1605);
        match(MySQLParser::DEFAULT_SYMBOL);
        break;
      }

      case 2: {
        setState(1606);
        charsetName();
        break;
      }

      }
      setState(1610);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COLLATE_SYMBOL) {
        setState(1609);
        collate();
      }
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(1612);
      match(MySQLParser::FORCE_SYMBOL);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(1613);
      match(MySQLParser::ORDER_SYMBOL);
      setState(1614);
      match(MySQLParser::BY_SYMBOL);
      setState(1615);
      alterOrderList();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(1616);

      if (!(serverVersion >= 50708 && serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion >= 50708 && serverVersion < 80000");
      setState(1617);
      match(MySQLParser::UPGRADE_SYMBOL);
      setState(1618);
      match(MySQLParser::PARTITIONING_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PlaceContext ------------------------------------------------------------------

MySQLParser::PlaceContext::PlaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::PlaceContext::AFTER_SYMBOL() {
  return getToken(MySQLParser::AFTER_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::PlaceContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::PlaceContext::FIRST_SYMBOL() {
  return getToken(MySQLParser::FIRST_SYMBOL, 0);
}


size_t MySQLParser::PlaceContext::getRuleIndex() const {
  return MySQLParser::RulePlace;
}

void MySQLParser::PlaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlace(this);
}

void MySQLParser::PlaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlace(this);
}


antlrcpp::Any MySQLParser::PlaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPlace(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PlaceContext* MySQLParser::place() {
  PlaceContext *_localctx = _tracker.createInstance<PlaceContext>(_ctx, getState());
  enterRule(_localctx, 36, MySQLParser::RulePlace);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1624);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::AFTER_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(1621);
        match(MySQLParser::AFTER_SYMBOL);
        setState(1622);
        identifier();
        break;
      }

      case MySQLParser::FIRST_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(1623);
        match(MySQLParser::FIRST_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RestrictContext ------------------------------------------------------------------

MySQLParser::RestrictContext::RestrictContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RestrictContext::RESTRICT_SYMBOL() {
  return getToken(MySQLParser::RESTRICT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RestrictContext::CASCADE_SYMBOL() {
  return getToken(MySQLParser::CASCADE_SYMBOL, 0);
}


size_t MySQLParser::RestrictContext::getRuleIndex() const {
  return MySQLParser::RuleRestrict;
}

void MySQLParser::RestrictContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRestrict(this);
}

void MySQLParser::RestrictContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRestrict(this);
}


antlrcpp::Any MySQLParser::RestrictContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRestrict(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RestrictContext* MySQLParser::restrict() {
  RestrictContext *_localctx = _tracker.createInstance<RestrictContext>(_ctx, getState());
  enterRule(_localctx, 38, MySQLParser::RuleRestrict);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1626);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::CASCADE_SYMBOL || _la == MySQLParser::RESTRICT_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterOrderListContext ------------------------------------------------------------------

MySQLParser::AlterOrderListContext::AlterOrderListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::IdentifierContext *> MySQLParser::AlterOrderListContext::identifier() {
  return getRuleContexts<MySQLParser::IdentifierContext>();
}

MySQLParser::IdentifierContext* MySQLParser::AlterOrderListContext::identifier(size_t i) {
  return getRuleContext<MySQLParser::IdentifierContext>(i);
}

std::vector<MySQLParser::DirectionContext *> MySQLParser::AlterOrderListContext::direction() {
  return getRuleContexts<MySQLParser::DirectionContext>();
}

MySQLParser::DirectionContext* MySQLParser::AlterOrderListContext::direction(size_t i) {
  return getRuleContext<MySQLParser::DirectionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterOrderListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::AlterOrderListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::AlterOrderListContext::getRuleIndex() const {
  return MySQLParser::RuleAlterOrderList;
}

void MySQLParser::AlterOrderListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterOrderList(this);
}

void MySQLParser::AlterOrderListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterOrderList(this);
}


antlrcpp::Any MySQLParser::AlterOrderListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterOrderList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterOrderListContext* MySQLParser::alterOrderList() {
  AlterOrderListContext *_localctx = _tracker.createInstance<AlterOrderListContext>(_ctx, getState());
  enterRule(_localctx, 40, MySQLParser::RuleAlterOrderList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1628);
    identifier();
    setState(1630);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ASC_SYMBOL

    || _la == MySQLParser::DESC_SYMBOL) {
      setState(1629);
      direction();
    }
    setState(1639);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1632);
        match(MySQLParser::COMMA_SYMBOL);
        setState(1633);
        identifier();
        setState(1635);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ASC_SYMBOL

        || _la == MySQLParser::DESC_SYMBOL) {
          setState(1634);
          direction();
        } 
      }
      setState(1641);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterAlgorithmOptionContext ------------------------------------------------------------------

MySQLParser::AlterAlgorithmOptionContext::AlterAlgorithmOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterAlgorithmOptionContext::ALGORITHM_SYMBOL() {
  return getToken(MySQLParser::ALGORITHM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterAlgorithmOptionContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::AlterAlgorithmOptionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::AlterAlgorithmOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::AlterAlgorithmOptionContext::getRuleIndex() const {
  return MySQLParser::RuleAlterAlgorithmOption;
}

void MySQLParser::AlterAlgorithmOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterAlgorithmOption(this);
}

void MySQLParser::AlterAlgorithmOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterAlgorithmOption(this);
}


antlrcpp::Any MySQLParser::AlterAlgorithmOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterAlgorithmOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterAlgorithmOptionContext* MySQLParser::alterAlgorithmOption() {
  AlterAlgorithmOptionContext *_localctx = _tracker.createInstance<AlterAlgorithmOptionContext>(_ctx, getState());
  enterRule(_localctx, 42, MySQLParser::RuleAlterAlgorithmOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1642);
    match(MySQLParser::ALGORITHM_SYMBOL);
    setState(1644);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
    case 1: {
      setState(1643);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(1648);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx)) {
    case 1: {
      setState(1646);
      match(MySQLParser::DEFAULT_SYMBOL);
      break;
    }

    case 2: {
      setState(1647);
      identifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterLockOptionContext ------------------------------------------------------------------

MySQLParser::AlterLockOptionContext::AlterLockOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterLockOptionContext::LOCK_SYMBOL() {
  return getToken(MySQLParser::LOCK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterLockOptionContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::AlterLockOptionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::AlterLockOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::AlterLockOptionContext::getRuleIndex() const {
  return MySQLParser::RuleAlterLockOption;
}

void MySQLParser::AlterLockOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterLockOption(this);
}

void MySQLParser::AlterLockOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterLockOption(this);
}


antlrcpp::Any MySQLParser::AlterLockOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterLockOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterLockOptionContext* MySQLParser::alterLockOption() {
  AlterLockOptionContext *_localctx = _tracker.createInstance<AlterLockOptionContext>(_ctx, getState());
  enterRule(_localctx, 44, MySQLParser::RuleAlterLockOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1650);
    match(MySQLParser::LOCK_SYMBOL);
    setState(1652);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx)) {
    case 1: {
      setState(1651);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(1656);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx)) {
    case 1: {
      setState(1654);
      match(MySQLParser::DEFAULT_SYMBOL);
      break;
    }

    case 2: {
      setState(1655);
      identifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexLockAndAlgorithmContext ------------------------------------------------------------------

MySQLParser::IndexLockAndAlgorithmContext::IndexLockAndAlgorithmContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::AlterAlgorithmOptionContext* MySQLParser::IndexLockAndAlgorithmContext::alterAlgorithmOption() {
  return getRuleContext<MySQLParser::AlterAlgorithmOptionContext>(0);
}

MySQLParser::AlterLockOptionContext* MySQLParser::IndexLockAndAlgorithmContext::alterLockOption() {
  return getRuleContext<MySQLParser::AlterLockOptionContext>(0);
}


size_t MySQLParser::IndexLockAndAlgorithmContext::getRuleIndex() const {
  return MySQLParser::RuleIndexLockAndAlgorithm;
}

void MySQLParser::IndexLockAndAlgorithmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexLockAndAlgorithm(this);
}

void MySQLParser::IndexLockAndAlgorithmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexLockAndAlgorithm(this);
}


antlrcpp::Any MySQLParser::IndexLockAndAlgorithmContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIndexLockAndAlgorithm(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexLockAndAlgorithmContext* MySQLParser::indexLockAndAlgorithm() {
  IndexLockAndAlgorithmContext *_localctx = _tracker.createInstance<IndexLockAndAlgorithmContext>(_ctx, getState());
  enterRule(_localctx, 46, MySQLParser::RuleIndexLockAndAlgorithm);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1658);

    if (!(serverVersion >= 50600)) throw FailedPredicateException(this, "serverVersion >= 50600");
    setState(1667);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ALGORITHM_SYMBOL: {
        setState(1659);
        alterAlgorithmOption();
        setState(1661);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LOCK_SYMBOL) {
          setState(1660);
          alterLockOption();
        }
        break;
      }

      case MySQLParser::LOCK_SYMBOL: {
        setState(1663);
        alterLockOption();
        setState(1665);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ALGORITHM_SYMBOL) {
          setState(1664);
          alterAlgorithmOption();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WithValidationContext ------------------------------------------------------------------

MySQLParser::WithValidationContext::WithValidationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WithValidationContext::VALIDATION_SYMBOL() {
  return getToken(MySQLParser::VALIDATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WithValidationContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WithValidationContext::WITHOUT_SYMBOL() {
  return getToken(MySQLParser::WITHOUT_SYMBOL, 0);
}


size_t MySQLParser::WithValidationContext::getRuleIndex() const {
  return MySQLParser::RuleWithValidation;
}

void MySQLParser::WithValidationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWithValidation(this);
}

void MySQLParser::WithValidationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWithValidation(this);
}


antlrcpp::Any MySQLParser::WithValidationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitWithValidation(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WithValidationContext* MySQLParser::withValidation() {
  WithValidationContext *_localctx = _tracker.createInstance<WithValidationContext>(_ctx, getState());
  enterRule(_localctx, 48, MySQLParser::RuleWithValidation);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1669);

    if (!(serverVersion >= 50706)) throw FailedPredicateException(this, "serverVersion >= 50706");
    setState(1670);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::WITH_SYMBOL

    || _la == MySQLParser::WITHOUT_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1671);
    match(MySQLParser::VALIDATION_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RemovePartitioningContext ------------------------------------------------------------------

MySQLParser::RemovePartitioningContext::RemovePartitioningContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RemovePartitioningContext::REMOVE_SYMBOL() {
  return getToken(MySQLParser::REMOVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RemovePartitioningContext::PARTITIONING_SYMBOL() {
  return getToken(MySQLParser::PARTITIONING_SYMBOL, 0);
}


size_t MySQLParser::RemovePartitioningContext::getRuleIndex() const {
  return MySQLParser::RuleRemovePartitioning;
}

void MySQLParser::RemovePartitioningContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRemovePartitioning(this);
}

void MySQLParser::RemovePartitioningContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRemovePartitioning(this);
}


antlrcpp::Any MySQLParser::RemovePartitioningContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRemovePartitioning(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RemovePartitioningContext* MySQLParser::removePartitioning() {
  RemovePartitioningContext *_localctx = _tracker.createInstance<RemovePartitioningContext>(_ctx, getState());
  enterRule(_localctx, 50, MySQLParser::RuleRemovePartitioning);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1673);
    match(MySQLParser::REMOVE_SYMBOL);
    setState(1674);
    match(MySQLParser::PARTITIONING_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AllOrPartitionNameListContext ------------------------------------------------------------------

MySQLParser::AllOrPartitionNameListContext::AllOrPartitionNameListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AllOrPartitionNameListContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

MySQLParser::IdentifierListContext* MySQLParser::AllOrPartitionNameListContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}


size_t MySQLParser::AllOrPartitionNameListContext::getRuleIndex() const {
  return MySQLParser::RuleAllOrPartitionNameList;
}

void MySQLParser::AllOrPartitionNameListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAllOrPartitionNameList(this);
}

void MySQLParser::AllOrPartitionNameListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAllOrPartitionNameList(this);
}


antlrcpp::Any MySQLParser::AllOrPartitionNameListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAllOrPartitionNameList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AllOrPartitionNameListContext* MySQLParser::allOrPartitionNameList() {
  AllOrPartitionNameListContext *_localctx = _tracker.createInstance<AllOrPartitionNameListContext>(_ctx, getState());
  enterRule(_localctx, 52, MySQLParser::RuleAllOrPartitionNameList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1678);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1676);
      match(MySQLParser::ALL_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1677);
      identifierList();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReorgPartitionRuleContext ------------------------------------------------------------------

MySQLParser::ReorgPartitionRuleContext::ReorgPartitionRuleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ReorgPartitionRuleContext::REORGANIZE_SYMBOL() {
  return getToken(MySQLParser::REORGANIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReorgPartitionRuleContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

MySQLParser::NoWriteToBinLogContext* MySQLParser::ReorgPartitionRuleContext::noWriteToBinLog() {
  return getRuleContext<MySQLParser::NoWriteToBinLogContext>(0);
}

MySQLParser::IdentifierListContext* MySQLParser::ReorgPartitionRuleContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

tree::TerminalNode* MySQLParser::ReorgPartitionRuleContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

MySQLParser::PartitionDefinitionsContext* MySQLParser::ReorgPartitionRuleContext::partitionDefinitions() {
  return getRuleContext<MySQLParser::PartitionDefinitionsContext>(0);
}


size_t MySQLParser::ReorgPartitionRuleContext::getRuleIndex() const {
  return MySQLParser::RuleReorgPartitionRule;
}

void MySQLParser::ReorgPartitionRuleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReorgPartitionRule(this);
}

void MySQLParser::ReorgPartitionRuleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReorgPartitionRule(this);
}


antlrcpp::Any MySQLParser::ReorgPartitionRuleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitReorgPartitionRule(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ReorgPartitionRuleContext* MySQLParser::reorgPartitionRule() {
  ReorgPartitionRuleContext *_localctx = _tracker.createInstance<ReorgPartitionRuleContext>(_ctx, getState());
  enterRule(_localctx, 54, MySQLParser::RuleReorgPartitionRule);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1680);
    match(MySQLParser::REORGANIZE_SYMBOL);
    setState(1681);
    match(MySQLParser::PARTITION_SYMBOL);
    setState(1683);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx)) {
    case 1: {
      setState(1682);
      noWriteToBinLog();
      break;
    }

    }
    setState(1689);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx)) {
    case 1: {
      setState(1685);
      identifierList();
      setState(1686);
      match(MySQLParser::INTO_SYMBOL);
      setState(1687);
      partitionDefinitions();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterTablespaceContext ------------------------------------------------------------------

MySQLParser::AlterTablespaceContext::AlterTablespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

MySQLParser::TablespaceRefContext* MySQLParser::AlterTablespaceContext::tablespaceRef() {
  return getRuleContext<MySQLParser::TablespaceRefContext>(0);
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::DATAFILE_SYMBOL() {
  return getToken(MySQLParser::DATAFILE_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::AlterTablespaceContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::RENAME_SYMBOL() {
  return getToken(MySQLParser::RENAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::AlterTablespaceContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::AlterTablespaceOptionsContext* MySQLParser::AlterTablespaceContext::alterTablespaceOptions() {
  return getRuleContext<MySQLParser::AlterTablespaceOptionsContext>(0);
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::ADD_SYMBOL() {
  return getToken(MySQLParser::ADD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::CHANGE_SYMBOL() {
  return getToken(MySQLParser::CHANGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::NOT_SYMBOL() {
  return getToken(MySQLParser::NOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::ACCESSIBLE_SYMBOL() {
  return getToken(MySQLParser::ACCESSIBLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::READ_ONLY_SYMBOL() {
  return getToken(MySQLParser::READ_ONLY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::READ_WRITE_SYMBOL() {
  return getToken(MySQLParser::READ_WRITE_SYMBOL, 0);
}

std::vector<MySQLParser::ChangeTablespaceOptionContext *> MySQLParser::AlterTablespaceContext::changeTablespaceOption() {
  return getRuleContexts<MySQLParser::ChangeTablespaceOptionContext>();
}

MySQLParser::ChangeTablespaceOptionContext* MySQLParser::AlterTablespaceContext::changeTablespaceOption(size_t i) {
  return getRuleContext<MySQLParser::ChangeTablespaceOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterTablespaceContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::AlterTablespaceContext::getRuleIndex() const {
  return MySQLParser::RuleAlterTablespace;
}

void MySQLParser::AlterTablespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTablespace(this);
}

void MySQLParser::AlterTablespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTablespace(this);
}


antlrcpp::Any MySQLParser::AlterTablespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterTablespace(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterTablespaceContext* MySQLParser::alterTablespace() {
  AlterTablespaceContext *_localctx = _tracker.createInstance<AlterTablespaceContext>(_ctx, getState());
  enterRule(_localctx, 56, MySQLParser::RuleAlterTablespace);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1691);
    match(MySQLParser::TABLESPACE_SYMBOL);
    setState(1692);
    tablespaceRef();
    setState(1726);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx)) {
    case 1: {
      setState(1693);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::ADD_SYMBOL

      || _la == MySQLParser::DROP_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1694);
      match(MySQLParser::DATAFILE_SYMBOL);
      setState(1695);
      textLiteral();
      setState(1697);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 68) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 68)) & ((1ULL << (MySQLParser::AUTOEXTEND_SIZE_SYMBOL - 68))
        | (1ULL << (MySQLParser::ENCRYPTION_SYMBOL - 68))
        | (1ULL << (MySQLParser::ENGINE_SYMBOL - 68)))) != 0) || _la == MySQLParser::INITIAL_SIZE_SYMBOL

      || _la == MySQLParser::MAX_SIZE_SYMBOL || _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL

      || _la == MySQLParser::WAIT_SYMBOL) {
        setState(1696);
        alterTablespaceOptions();
      }
      break;
    }

    case 2: {
      setState(1699);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(1719);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::EOF:
        case MySQLParser::SEMICOLON_SYMBOL: {
          break;
        }

        case MySQLParser::CHANGE_SYMBOL: {
          setState(1701);
          match(MySQLParser::CHANGE_SYMBOL);
          setState(1702);
          match(MySQLParser::DATAFILE_SYMBOL);
          setState(1703);
          textLiteral();
          setState(1714);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLParser::AUTOEXTEND_SIZE_SYMBOL || _la == MySQLParser::INITIAL_SIZE_SYMBOL

          || _la == MySQLParser::MAX_SIZE_SYMBOL) {
            setState(1704);
            changeTablespaceOption();
            setState(1711);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == MySQLParser::AUTOEXTEND_SIZE_SYMBOL || _la == MySQLParser::INITIAL_SIZE_SYMBOL

            || _la == MySQLParser::MAX_SIZE_SYMBOL || _la == MySQLParser::COMMA_SYMBOL) {
              setState(1706);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == MySQLParser::COMMA_SYMBOL) {
                setState(1705);
                match(MySQLParser::COMMA_SYMBOL);
              }
              setState(1708);
              changeTablespaceOption();
              setState(1713);
              _errHandler->sync(this);
              _la = _input->LA(1);
            }
          }
          break;
        }

        case MySQLParser::READ_ONLY_SYMBOL:
        case MySQLParser::READ_WRITE_SYMBOL: {
          setState(1716);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::READ_ONLY_SYMBOL || _la == MySQLParser::READ_WRITE_SYMBOL)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        case MySQLParser::NOT_SYMBOL: {
          setState(1717);
          match(MySQLParser::NOT_SYMBOL);
          setState(1718);
          match(MySQLParser::ACCESSIBLE_SYMBOL);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 3: {
      setState(1721);
      match(MySQLParser::RENAME_SYMBOL);
      setState(1722);
      match(MySQLParser::TO_SYMBOL);
      setState(1723);
      identifier();
      break;
    }

    case 4: {
      setState(1724);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(1725);
      alterTablespaceOptions();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterUndoTablespaceContext ------------------------------------------------------------------

MySQLParser::AlterUndoTablespaceContext::AlterUndoTablespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterUndoTablespaceContext::UNDO_SYMBOL() {
  return getToken(MySQLParser::UNDO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterUndoTablespaceContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

MySQLParser::TablespaceRefContext* MySQLParser::AlterUndoTablespaceContext::tablespaceRef() {
  return getRuleContext<MySQLParser::TablespaceRefContext>(0);
}

tree::TerminalNode* MySQLParser::AlterUndoTablespaceContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterUndoTablespaceContext::ACTIVE_SYMBOL() {
  return getToken(MySQLParser::ACTIVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterUndoTablespaceContext::INACTIVE_SYMBOL() {
  return getToken(MySQLParser::INACTIVE_SYMBOL, 0);
}

MySQLParser::UndoTableSpaceOptionsContext* MySQLParser::AlterUndoTablespaceContext::undoTableSpaceOptions() {
  return getRuleContext<MySQLParser::UndoTableSpaceOptionsContext>(0);
}


size_t MySQLParser::AlterUndoTablespaceContext::getRuleIndex() const {
  return MySQLParser::RuleAlterUndoTablespace;
}

void MySQLParser::AlterUndoTablespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterUndoTablespace(this);
}

void MySQLParser::AlterUndoTablespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterUndoTablespace(this);
}


antlrcpp::Any MySQLParser::AlterUndoTablespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterUndoTablespace(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterUndoTablespaceContext* MySQLParser::alterUndoTablespace() {
  AlterUndoTablespaceContext *_localctx = _tracker.createInstance<AlterUndoTablespaceContext>(_ctx, getState());
  enterRule(_localctx, 58, MySQLParser::RuleAlterUndoTablespace);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1728);
    match(MySQLParser::UNDO_SYMBOL);
    setState(1729);
    match(MySQLParser::TABLESPACE_SYMBOL);
    setState(1730);
    tablespaceRef();
    setState(1731);
    match(MySQLParser::SET_SYMBOL);
    setState(1732);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::ACTIVE_SYMBOL

    || _la == MySQLParser::INACTIVE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1734);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL) {
      setState(1733);
      undoTableSpaceOptions();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UndoTableSpaceOptionsContext ------------------------------------------------------------------

MySQLParser::UndoTableSpaceOptionsContext::UndoTableSpaceOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::UndoTableSpaceOptionContext *> MySQLParser::UndoTableSpaceOptionsContext::undoTableSpaceOption() {
  return getRuleContexts<MySQLParser::UndoTableSpaceOptionContext>();
}

MySQLParser::UndoTableSpaceOptionContext* MySQLParser::UndoTableSpaceOptionsContext::undoTableSpaceOption(size_t i) {
  return getRuleContext<MySQLParser::UndoTableSpaceOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::UndoTableSpaceOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::UndoTableSpaceOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::UndoTableSpaceOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleUndoTableSpaceOptions;
}

void MySQLParser::UndoTableSpaceOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUndoTableSpaceOptions(this);
}

void MySQLParser::UndoTableSpaceOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUndoTableSpaceOptions(this);
}


antlrcpp::Any MySQLParser::UndoTableSpaceOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitUndoTableSpaceOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UndoTableSpaceOptionsContext* MySQLParser::undoTableSpaceOptions() {
  UndoTableSpaceOptionsContext *_localctx = _tracker.createInstance<UndoTableSpaceOptionsContext>(_ctx, getState());
  enterRule(_localctx, 60, MySQLParser::RuleUndoTableSpaceOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1736);
    undoTableSpaceOption();
    setState(1743);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL || _la == MySQLParser::COMMA_SYMBOL) {
      setState(1738);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(1737);
        match(MySQLParser::COMMA_SYMBOL);
      }
      setState(1740);
      undoTableSpaceOption();
      setState(1745);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UndoTableSpaceOptionContext ------------------------------------------------------------------

MySQLParser::UndoTableSpaceOptionContext::UndoTableSpaceOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TsOptionEngineContext* MySQLParser::UndoTableSpaceOptionContext::tsOptionEngine() {
  return getRuleContext<MySQLParser::TsOptionEngineContext>(0);
}


size_t MySQLParser::UndoTableSpaceOptionContext::getRuleIndex() const {
  return MySQLParser::RuleUndoTableSpaceOption;
}

void MySQLParser::UndoTableSpaceOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUndoTableSpaceOption(this);
}

void MySQLParser::UndoTableSpaceOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUndoTableSpaceOption(this);
}


antlrcpp::Any MySQLParser::UndoTableSpaceOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitUndoTableSpaceOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UndoTableSpaceOptionContext* MySQLParser::undoTableSpaceOption() {
  UndoTableSpaceOptionContext *_localctx = _tracker.createInstance<UndoTableSpaceOptionContext>(_ctx, getState());
  enterRule(_localctx, 62, MySQLParser::RuleUndoTableSpaceOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1746);
    tsOptionEngine();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterTablespaceOptionsContext ------------------------------------------------------------------

MySQLParser::AlterTablespaceOptionsContext::AlterTablespaceOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::AlterTablespaceOptionContext *> MySQLParser::AlterTablespaceOptionsContext::alterTablespaceOption() {
  return getRuleContexts<MySQLParser::AlterTablespaceOptionContext>();
}

MySQLParser::AlterTablespaceOptionContext* MySQLParser::AlterTablespaceOptionsContext::alterTablespaceOption(size_t i) {
  return getRuleContext<MySQLParser::AlterTablespaceOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterTablespaceOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::AlterTablespaceOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::AlterTablespaceOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleAlterTablespaceOptions;
}

void MySQLParser::AlterTablespaceOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTablespaceOptions(this);
}

void MySQLParser::AlterTablespaceOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTablespaceOptions(this);
}


antlrcpp::Any MySQLParser::AlterTablespaceOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterTablespaceOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterTablespaceOptionsContext* MySQLParser::alterTablespaceOptions() {
  AlterTablespaceOptionsContext *_localctx = _tracker.createInstance<AlterTablespaceOptionsContext>(_ctx, getState());
  enterRule(_localctx, 64, MySQLParser::RuleAlterTablespaceOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1748);
    alterTablespaceOption();
    setState(1755);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 68) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 68)) & ((1ULL << (MySQLParser::AUTOEXTEND_SIZE_SYMBOL - 68))
      | (1ULL << (MySQLParser::ENCRYPTION_SYMBOL - 68))
      | (1ULL << (MySQLParser::ENGINE_SYMBOL - 68)))) != 0) || _la == MySQLParser::INITIAL_SIZE_SYMBOL

    || _la == MySQLParser::MAX_SIZE_SYMBOL || _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL

    || _la == MySQLParser::WAIT_SYMBOL || _la == MySQLParser::COMMA_SYMBOL) {
      setState(1750);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(1749);
        match(MySQLParser::COMMA_SYMBOL);
      }
      setState(1752);
      alterTablespaceOption();
      setState(1757);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterTablespaceOptionContext ------------------------------------------------------------------

MySQLParser::AlterTablespaceOptionContext::AlterTablespaceOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterTablespaceOptionContext::INITIAL_SIZE_SYMBOL() {
  return getToken(MySQLParser::INITIAL_SIZE_SYMBOL, 0);
}

MySQLParser::SizeNumberContext* MySQLParser::AlterTablespaceOptionContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode* MySQLParser::AlterTablespaceOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TsOptionAutoextendSizeContext* MySQLParser::AlterTablespaceOptionContext::tsOptionAutoextendSize() {
  return getRuleContext<MySQLParser::TsOptionAutoextendSizeContext>(0);
}

MySQLParser::TsOptionMaxSizeContext* MySQLParser::AlterTablespaceOptionContext::tsOptionMaxSize() {
  return getRuleContext<MySQLParser::TsOptionMaxSizeContext>(0);
}

MySQLParser::TsOptionEngineContext* MySQLParser::AlterTablespaceOptionContext::tsOptionEngine() {
  return getRuleContext<MySQLParser::TsOptionEngineContext>(0);
}

MySQLParser::TsOptionWaitContext* MySQLParser::AlterTablespaceOptionContext::tsOptionWait() {
  return getRuleContext<MySQLParser::TsOptionWaitContext>(0);
}

MySQLParser::TsOptionEncryptionContext* MySQLParser::AlterTablespaceOptionContext::tsOptionEncryption() {
  return getRuleContext<MySQLParser::TsOptionEncryptionContext>(0);
}


size_t MySQLParser::AlterTablespaceOptionContext::getRuleIndex() const {
  return MySQLParser::RuleAlterTablespaceOption;
}

void MySQLParser::AlterTablespaceOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTablespaceOption(this);
}

void MySQLParser::AlterTablespaceOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTablespaceOption(this);
}


antlrcpp::Any MySQLParser::AlterTablespaceOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterTablespaceOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterTablespaceOptionContext* MySQLParser::alterTablespaceOption() {
  AlterTablespaceOptionContext *_localctx = _tracker.createInstance<AlterTablespaceOptionContext>(_ctx, getState());
  enterRule(_localctx, 66, MySQLParser::RuleAlterTablespaceOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1768);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INITIAL_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(1758);
        match(MySQLParser::INITIAL_SIZE_SYMBOL);
        setState(1760);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 96, _ctx)) {
        case 1: {
          setState(1759);
          match(MySQLParser::EQUAL_OPERATOR);
          break;
        }

        }
        setState(1762);
        sizeNumber();
        break;
      }

      case MySQLParser::AUTOEXTEND_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(1763);
        tsOptionAutoextendSize();
        break;
      }

      case MySQLParser::MAX_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(1764);
        tsOptionMaxSize();
        break;
      }

      case MySQLParser::ENGINE_SYMBOL:
      case MySQLParser::STORAGE_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(1765);
        tsOptionEngine();
        break;
      }

      case MySQLParser::NO_WAIT_SYMBOL:
      case MySQLParser::WAIT_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(1766);
        tsOptionWait();
        break;
      }

      case MySQLParser::ENCRYPTION_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(1767);
        tsOptionEncryption();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeTablespaceOptionContext ------------------------------------------------------------------

MySQLParser::ChangeTablespaceOptionContext::ChangeTablespaceOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ChangeTablespaceOptionContext::INITIAL_SIZE_SYMBOL() {
  return getToken(MySQLParser::INITIAL_SIZE_SYMBOL, 0);
}

MySQLParser::SizeNumberContext* MySQLParser::ChangeTablespaceOptionContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode* MySQLParser::ChangeTablespaceOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TsOptionAutoextendSizeContext* MySQLParser::ChangeTablespaceOptionContext::tsOptionAutoextendSize() {
  return getRuleContext<MySQLParser::TsOptionAutoextendSizeContext>(0);
}

MySQLParser::TsOptionMaxSizeContext* MySQLParser::ChangeTablespaceOptionContext::tsOptionMaxSize() {
  return getRuleContext<MySQLParser::TsOptionMaxSizeContext>(0);
}


size_t MySQLParser::ChangeTablespaceOptionContext::getRuleIndex() const {
  return MySQLParser::RuleChangeTablespaceOption;
}

void MySQLParser::ChangeTablespaceOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeTablespaceOption(this);
}

void MySQLParser::ChangeTablespaceOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeTablespaceOption(this);
}


antlrcpp::Any MySQLParser::ChangeTablespaceOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitChangeTablespaceOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeTablespaceOptionContext* MySQLParser::changeTablespaceOption() {
  ChangeTablespaceOptionContext *_localctx = _tracker.createInstance<ChangeTablespaceOptionContext>(_ctx, getState());
  enterRule(_localctx, 68, MySQLParser::RuleChangeTablespaceOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1777);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INITIAL_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(1770);
        match(MySQLParser::INITIAL_SIZE_SYMBOL);
        setState(1772);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx)) {
        case 1: {
          setState(1771);
          match(MySQLParser::EQUAL_OPERATOR);
          break;
        }

        }
        setState(1774);
        sizeNumber();
        break;
      }

      case MySQLParser::AUTOEXTEND_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(1775);
        tsOptionAutoextendSize();
        break;
      }

      case MySQLParser::MAX_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(1776);
        tsOptionMaxSize();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterViewContext ------------------------------------------------------------------

MySQLParser::AlterViewContext::AlterViewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterViewContext::VIEW_SYMBOL() {
  return getToken(MySQLParser::VIEW_SYMBOL, 0);
}

MySQLParser::ViewRefContext* MySQLParser::AlterViewContext::viewRef() {
  return getRuleContext<MySQLParser::ViewRefContext>(0);
}

MySQLParser::ViewTailContext* MySQLParser::AlterViewContext::viewTail() {
  return getRuleContext<MySQLParser::ViewTailContext>(0);
}

MySQLParser::ViewAlgorithmContext* MySQLParser::AlterViewContext::viewAlgorithm() {
  return getRuleContext<MySQLParser::ViewAlgorithmContext>(0);
}

MySQLParser::DefinerClauseContext* MySQLParser::AlterViewContext::definerClause() {
  return getRuleContext<MySQLParser::DefinerClauseContext>(0);
}

MySQLParser::ViewSuidContext* MySQLParser::AlterViewContext::viewSuid() {
  return getRuleContext<MySQLParser::ViewSuidContext>(0);
}


size_t MySQLParser::AlterViewContext::getRuleIndex() const {
  return MySQLParser::RuleAlterView;
}

void MySQLParser::AlterViewContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterView(this);
}

void MySQLParser::AlterViewContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterView(this);
}


antlrcpp::Any MySQLParser::AlterViewContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterView(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterViewContext* MySQLParser::alterView() {
  AlterViewContext *_localctx = _tracker.createInstance<AlterViewContext>(_ctx, getState());
  enterRule(_localctx, 70, MySQLParser::RuleAlterView);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1780);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ALGORITHM_SYMBOL) {
      setState(1779);
      viewAlgorithm();
    }
    setState(1783);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFINER_SYMBOL) {
      setState(1782);
      definerClause();
    }
    setState(1786);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::SQL_SYMBOL) {
      setState(1785);
      viewSuid();
    }
    setState(1788);
    match(MySQLParser::VIEW_SYMBOL);
    setState(1789);
    viewRef();
    setState(1790);
    viewTail();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewTailContext ------------------------------------------------------------------

MySQLParser::ViewTailContext::ViewTailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ViewTailContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::ViewSelectContext* MySQLParser::ViewTailContext::viewSelect() {
  return getRuleContext<MySQLParser::ViewSelectContext>(0);
}

MySQLParser::ColumnInternalRefListContext* MySQLParser::ViewTailContext::columnInternalRefList() {
  return getRuleContext<MySQLParser::ColumnInternalRefListContext>(0);
}


size_t MySQLParser::ViewTailContext::getRuleIndex() const {
  return MySQLParser::RuleViewTail;
}

void MySQLParser::ViewTailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewTail(this);
}

void MySQLParser::ViewTailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewTail(this);
}


antlrcpp::Any MySQLParser::ViewTailContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitViewTail(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ViewTailContext* MySQLParser::viewTail() {
  ViewTailContext *_localctx = _tracker.createInstance<ViewTailContext>(_ctx, getState());
  enterRule(_localctx, 72, MySQLParser::RuleViewTail);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1793);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(1792);
      columnInternalRefList();
    }
    setState(1795);
    match(MySQLParser::AS_SYMBOL);
    setState(1796);
    viewSelect();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewSelectContext ------------------------------------------------------------------

MySQLParser::ViewSelectContext::ViewSelectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryExpressionOrParensContext* MySQLParser::ViewSelectContext::queryExpressionOrParens() {
  return getRuleContext<MySQLParser::QueryExpressionOrParensContext>(0);
}

MySQLParser::ViewCheckOptionContext* MySQLParser::ViewSelectContext::viewCheckOption() {
  return getRuleContext<MySQLParser::ViewCheckOptionContext>(0);
}


size_t MySQLParser::ViewSelectContext::getRuleIndex() const {
  return MySQLParser::RuleViewSelect;
}

void MySQLParser::ViewSelectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewSelect(this);
}

void MySQLParser::ViewSelectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewSelect(this);
}


antlrcpp::Any MySQLParser::ViewSelectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitViewSelect(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ViewSelectContext* MySQLParser::viewSelect() {
  ViewSelectContext *_localctx = _tracker.createInstance<ViewSelectContext>(_ctx, getState());
  enterRule(_localctx, 74, MySQLParser::RuleViewSelect);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1798);
    queryExpressionOrParens();
    setState(1800);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::WITH_SYMBOL) {
      setState(1799);
      viewCheckOption();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewCheckOptionContext ------------------------------------------------------------------

MySQLParser::ViewCheckOptionContext::ViewCheckOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ViewCheckOptionContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ViewCheckOptionContext::CHECK_SYMBOL() {
  return getToken(MySQLParser::CHECK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ViewCheckOptionContext::OPTION_SYMBOL() {
  return getToken(MySQLParser::OPTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ViewCheckOptionContext::CASCADED_SYMBOL() {
  return getToken(MySQLParser::CASCADED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ViewCheckOptionContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}


size_t MySQLParser::ViewCheckOptionContext::getRuleIndex() const {
  return MySQLParser::RuleViewCheckOption;
}

void MySQLParser::ViewCheckOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewCheckOption(this);
}

void MySQLParser::ViewCheckOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewCheckOption(this);
}


antlrcpp::Any MySQLParser::ViewCheckOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitViewCheckOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ViewCheckOptionContext* MySQLParser::viewCheckOption() {
  ViewCheckOptionContext *_localctx = _tracker.createInstance<ViewCheckOptionContext>(_ctx, getState());
  enterRule(_localctx, 76, MySQLParser::RuleViewCheckOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1802);
    match(MySQLParser::WITH_SYMBOL);
    setState(1804);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::CASCADED_SYMBOL || _la == MySQLParser::LOCAL_SYMBOL) {
      setState(1803);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::CASCADED_SYMBOL || _la == MySQLParser::LOCAL_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1806);
    match(MySQLParser::CHECK_SYMBOL);
    setState(1807);
    match(MySQLParser::OPTION_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateStatementContext ------------------------------------------------------------------

MySQLParser::CreateStatementContext::CreateStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateStatementContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

MySQLParser::CreateDatabaseContext* MySQLParser::CreateStatementContext::createDatabase() {
  return getRuleContext<MySQLParser::CreateDatabaseContext>(0);
}

MySQLParser::CreateTableContext* MySQLParser::CreateStatementContext::createTable() {
  return getRuleContext<MySQLParser::CreateTableContext>(0);
}

MySQLParser::CreateFunctionContext* MySQLParser::CreateStatementContext::createFunction() {
  return getRuleContext<MySQLParser::CreateFunctionContext>(0);
}

MySQLParser::CreateProcedureContext* MySQLParser::CreateStatementContext::createProcedure() {
  return getRuleContext<MySQLParser::CreateProcedureContext>(0);
}

MySQLParser::CreateUdfContext* MySQLParser::CreateStatementContext::createUdf() {
  return getRuleContext<MySQLParser::CreateUdfContext>(0);
}

MySQLParser::CreateLogfileGroupContext* MySQLParser::CreateStatementContext::createLogfileGroup() {
  return getRuleContext<MySQLParser::CreateLogfileGroupContext>(0);
}

MySQLParser::CreateViewContext* MySQLParser::CreateStatementContext::createView() {
  return getRuleContext<MySQLParser::CreateViewContext>(0);
}

MySQLParser::CreateTriggerContext* MySQLParser::CreateStatementContext::createTrigger() {
  return getRuleContext<MySQLParser::CreateTriggerContext>(0);
}

MySQLParser::CreateIndexContext* MySQLParser::CreateStatementContext::createIndex() {
  return getRuleContext<MySQLParser::CreateIndexContext>(0);
}

MySQLParser::CreateServerContext* MySQLParser::CreateStatementContext::createServer() {
  return getRuleContext<MySQLParser::CreateServerContext>(0);
}

MySQLParser::CreateTablespaceContext* MySQLParser::CreateStatementContext::createTablespace() {
  return getRuleContext<MySQLParser::CreateTablespaceContext>(0);
}

MySQLParser::CreateEventContext* MySQLParser::CreateStatementContext::createEvent() {
  return getRuleContext<MySQLParser::CreateEventContext>(0);
}

MySQLParser::CreateRoleContext* MySQLParser::CreateStatementContext::createRole() {
  return getRuleContext<MySQLParser::CreateRoleContext>(0);
}

MySQLParser::CreateSpatialReferenceContext* MySQLParser::CreateStatementContext::createSpatialReference() {
  return getRuleContext<MySQLParser::CreateSpatialReferenceContext>(0);
}

MySQLParser::CreateUndoTablespaceContext* MySQLParser::CreateStatementContext::createUndoTablespace() {
  return getRuleContext<MySQLParser::CreateUndoTablespaceContext>(0);
}


size_t MySQLParser::CreateStatementContext::getRuleIndex() const {
  return MySQLParser::RuleCreateStatement;
}

void MySQLParser::CreateStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateStatement(this);
}

void MySQLParser::CreateStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateStatement(this);
}


antlrcpp::Any MySQLParser::CreateStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateStatementContext* MySQLParser::createStatement() {
  CreateStatementContext *_localctx = _tracker.createInstance<CreateStatementContext>(_ctx, getState());
  enterRule(_localctx, 78, MySQLParser::RuleCreateStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1809);
    match(MySQLParser::CREATE_SYMBOL);
    setState(1828);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx)) {
    case 1: {
      setState(1810);
      createDatabase();
      break;
    }

    case 2: {
      setState(1811);
      createTable();
      break;
    }

    case 3: {
      setState(1812);
      createFunction();
      break;
    }

    case 4: {
      setState(1813);
      createProcedure();
      break;
    }

    case 5: {
      setState(1814);
      createUdf();
      break;
    }

    case 6: {
      setState(1815);
      createLogfileGroup();
      break;
    }

    case 7: {
      setState(1816);
      createView();
      break;
    }

    case 8: {
      setState(1817);
      createTrigger();
      break;
    }

    case 9: {
      setState(1818);
      createIndex();
      break;
    }

    case 10: {
      setState(1819);
      createServer();
      break;
    }

    case 11: {
      setState(1820);
      createTablespace();
      break;
    }

    case 12: {
      setState(1821);
      createEvent();
      break;
    }

    case 13: {
      setState(1822);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(1823);
      createRole();
      break;
    }

    case 14: {
      setState(1824);

      if (!(serverVersion >= 80011)) throw FailedPredicateException(this, "serverVersion >= 80011");
      setState(1825);
      createSpatialReference();
      break;
    }

    case 15: {
      setState(1826);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(1827);
      createUndoTablespace();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateDatabaseContext ------------------------------------------------------------------

MySQLParser::CreateDatabaseContext::CreateDatabaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateDatabaseContext::DATABASE_SYMBOL() {
  return getToken(MySQLParser::DATABASE_SYMBOL, 0);
}

MySQLParser::SchemaNameContext* MySQLParser::CreateDatabaseContext::schemaName() {
  return getRuleContext<MySQLParser::SchemaNameContext>(0);
}

MySQLParser::IfNotExistsContext* MySQLParser::CreateDatabaseContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}

std::vector<MySQLParser::CreateDatabaseOptionContext *> MySQLParser::CreateDatabaseContext::createDatabaseOption() {
  return getRuleContexts<MySQLParser::CreateDatabaseOptionContext>();
}

MySQLParser::CreateDatabaseOptionContext* MySQLParser::CreateDatabaseContext::createDatabaseOption(size_t i) {
  return getRuleContext<MySQLParser::CreateDatabaseOptionContext>(i);
}


size_t MySQLParser::CreateDatabaseContext::getRuleIndex() const {
  return MySQLParser::RuleCreateDatabase;
}

void MySQLParser::CreateDatabaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateDatabase(this);
}

void MySQLParser::CreateDatabaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateDatabase(this);
}


antlrcpp::Any MySQLParser::CreateDatabaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateDatabase(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateDatabaseContext* MySQLParser::createDatabase() {
  CreateDatabaseContext *_localctx = _tracker.createInstance<CreateDatabaseContext>(_ctx, getState());
  enterRule(_localctx, 80, MySQLParser::RuleCreateDatabase);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1830);
    match(MySQLParser::DATABASE_SYMBOL);
    setState(1832);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx)) {
    case 1: {
      setState(1831);
      ifNotExists();
      break;
    }

    }
    setState(1834);
    schemaName();
    setState(1838);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1835);
        createDatabaseOption(); 
      }
      setState(1840);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateDatabaseOptionContext ------------------------------------------------------------------

MySQLParser::CreateDatabaseOptionContext::CreateDatabaseOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::DefaultCharsetContext* MySQLParser::CreateDatabaseOptionContext::defaultCharset() {
  return getRuleContext<MySQLParser::DefaultCharsetContext>(0);
}

MySQLParser::DefaultCollationContext* MySQLParser::CreateDatabaseOptionContext::defaultCollation() {
  return getRuleContext<MySQLParser::DefaultCollationContext>(0);
}

MySQLParser::DefaultEncryptionContext* MySQLParser::CreateDatabaseOptionContext::defaultEncryption() {
  return getRuleContext<MySQLParser::DefaultEncryptionContext>(0);
}


size_t MySQLParser::CreateDatabaseOptionContext::getRuleIndex() const {
  return MySQLParser::RuleCreateDatabaseOption;
}

void MySQLParser::CreateDatabaseOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateDatabaseOption(this);
}

void MySQLParser::CreateDatabaseOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateDatabaseOption(this);
}


antlrcpp::Any MySQLParser::CreateDatabaseOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateDatabaseOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateDatabaseOptionContext* MySQLParser::createDatabaseOption() {
  CreateDatabaseOptionContext *_localctx = _tracker.createInstance<CreateDatabaseOptionContext>(_ctx, getState());
  enterRule(_localctx, 82, MySQLParser::RuleCreateDatabaseOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1845);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1841);
      defaultCharset();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1842);
      defaultCollation();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1843);

      if (!(serverVersion >= 80016)) throw FailedPredicateException(this, "serverVersion >= 80016");
      setState(1844);
      defaultEncryption();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTableContext ------------------------------------------------------------------

MySQLParser::CreateTableContext::CreateTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateTableContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

MySQLParser::TableNameContext* MySQLParser::CreateTableContext::tableName() {
  return getRuleContext<MySQLParser::TableNameContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTableContext::LIKE_SYMBOL() {
  return getToken(MySQLParser::LIKE_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::CreateTableContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTableContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableContext::TEMPORARY_SYMBOL() {
  return getToken(MySQLParser::TEMPORARY_SYMBOL, 0);
}

MySQLParser::IfNotExistsContext* MySQLParser::CreateTableContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}

MySQLParser::TableElementListContext* MySQLParser::CreateTableContext::tableElementList() {
  return getRuleContext<MySQLParser::TableElementListContext>(0);
}

MySQLParser::CreateTableOptionsContext* MySQLParser::CreateTableContext::createTableOptions() {
  return getRuleContext<MySQLParser::CreateTableOptionsContext>(0);
}

MySQLParser::PartitionClauseContext* MySQLParser::CreateTableContext::partitionClause() {
  return getRuleContext<MySQLParser::PartitionClauseContext>(0);
}

MySQLParser::DuplicateAsQueryExpressionContext* MySQLParser::CreateTableContext::duplicateAsQueryExpression() {
  return getRuleContext<MySQLParser::DuplicateAsQueryExpressionContext>(0);
}


size_t MySQLParser::CreateTableContext::getRuleIndex() const {
  return MySQLParser::RuleCreateTable;
}

void MySQLParser::CreateTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTable(this);
}

void MySQLParser::CreateTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTable(this);
}


antlrcpp::Any MySQLParser::CreateTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateTableContext* MySQLParser::createTable() {
  CreateTableContext *_localctx = _tracker.createInstance<CreateTableContext>(_ctx, getState());
  enterRule(_localctx, 84, MySQLParser::RuleCreateTable);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1848);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::TEMPORARY_SYMBOL) {
      setState(1847);
      match(MySQLParser::TEMPORARY_SYMBOL);
    }
    setState(1850);
    match(MySQLParser::TABLE_SYMBOL);
    setState(1852);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx)) {
    case 1: {
      setState(1851);
      ifNotExists();
      break;
    }

    }
    setState(1854);
    tableName();
    setState(1877);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx)) {
    case 1: {
      setState(1859);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 112, _ctx)) {
      case 1: {
        setState(1855);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(1856);
        tableElementList();
        setState(1857);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      }
      setState(1862);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 113, _ctx)) {
      case 1: {
        setState(1861);
        createTableOptions();
        break;
      }

      }
      setState(1865);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx)) {
      case 1: {
        setState(1864);
        partitionClause();
        break;
      }

      }
      setState(1868);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 115, _ctx)) {
      case 1: {
        setState(1867);
        duplicateAsQueryExpression();
        break;
      }

      }
      break;
    }

    case 2: {
      setState(1870);
      match(MySQLParser::LIKE_SYMBOL);
      setState(1871);
      tableRef();
      break;
    }

    case 3: {
      setState(1872);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(1873);
      match(MySQLParser::LIKE_SYMBOL);
      setState(1874);
      tableRef();
      setState(1875);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableElementListContext ------------------------------------------------------------------

MySQLParser::TableElementListContext::TableElementListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TableElementContext *> MySQLParser::TableElementListContext::tableElement() {
  return getRuleContexts<MySQLParser::TableElementContext>();
}

MySQLParser::TableElementContext* MySQLParser::TableElementListContext::tableElement(size_t i) {
  return getRuleContext<MySQLParser::TableElementContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::TableElementListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::TableElementListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::TableElementListContext::getRuleIndex() const {
  return MySQLParser::RuleTableElementList;
}

void MySQLParser::TableElementListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableElementList(this);
}

void MySQLParser::TableElementListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableElementList(this);
}


antlrcpp::Any MySQLParser::TableElementListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTableElementList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableElementListContext* MySQLParser::tableElementList() {
  TableElementListContext *_localctx = _tracker.createInstance<TableElementListContext>(_ctx, getState());
  enterRule(_localctx, 86, MySQLParser::RuleTableElementList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1879);
    tableElement();
    setState(1884);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(1880);
      match(MySQLParser::COMMA_SYMBOL);
      setState(1881);
      tableElement();
      setState(1886);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableElementContext ------------------------------------------------------------------

MySQLParser::TableElementContext::TableElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ColumnDefinitionContext* MySQLParser::TableElementContext::columnDefinition() {
  return getRuleContext<MySQLParser::ColumnDefinitionContext>(0);
}

MySQLParser::TableConstraintDefContext* MySQLParser::TableElementContext::tableConstraintDef() {
  return getRuleContext<MySQLParser::TableConstraintDefContext>(0);
}


size_t MySQLParser::TableElementContext::getRuleIndex() const {
  return MySQLParser::RuleTableElement;
}

void MySQLParser::TableElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableElement(this);
}

void MySQLParser::TableElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableElement(this);
}


antlrcpp::Any MySQLParser::TableElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTableElement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableElementContext* MySQLParser::tableElement() {
  TableElementContext *_localctx = _tracker.createInstance<TableElementContext>(_ctx, getState());
  enterRule(_localctx, 88, MySQLParser::RuleTableElement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1889);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1887);
      columnDefinition();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1888);
      tableConstraintDef();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DuplicateAsQueryExpressionContext ------------------------------------------------------------------

MySQLParser::DuplicateAsQueryExpressionContext::DuplicateAsQueryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryExpressionOrParensContext* MySQLParser::DuplicateAsQueryExpressionContext::queryExpressionOrParens() {
  return getRuleContext<MySQLParser::QueryExpressionOrParensContext>(0);
}

tree::TerminalNode* MySQLParser::DuplicateAsQueryExpressionContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DuplicateAsQueryExpressionContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DuplicateAsQueryExpressionContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}


size_t MySQLParser::DuplicateAsQueryExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleDuplicateAsQueryExpression;
}

void MySQLParser::DuplicateAsQueryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDuplicateAsQueryExpression(this);
}

void MySQLParser::DuplicateAsQueryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDuplicateAsQueryExpression(this);
}


antlrcpp::Any MySQLParser::DuplicateAsQueryExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDuplicateAsQueryExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DuplicateAsQueryExpressionContext* MySQLParser::duplicateAsQueryExpression() {
  DuplicateAsQueryExpressionContext *_localctx = _tracker.createInstance<DuplicateAsQueryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 90, MySQLParser::RuleDuplicateAsQueryExpression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1892);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 119, _ctx)) {
    case 1: {
      setState(1891);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::IGNORE_SYMBOL || _la == MySQLParser::REPLACE_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
    setState(1895);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx)) {
    case 1: {
      setState(1894);
      match(MySQLParser::AS_SYMBOL);
      break;
    }

    }
    setState(1897);
    queryExpressionOrParens();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryExpressionOrParensContext ------------------------------------------------------------------

MySQLParser::QueryExpressionOrParensContext::QueryExpressionOrParensContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryExpressionContext* MySQLParser::QueryExpressionOrParensContext::queryExpression() {
  return getRuleContext<MySQLParser::QueryExpressionContext>(0);
}

MySQLParser::QueryExpressionParensContext* MySQLParser::QueryExpressionOrParensContext::queryExpressionParens() {
  return getRuleContext<MySQLParser::QueryExpressionParensContext>(0);
}


size_t MySQLParser::QueryExpressionOrParensContext::getRuleIndex() const {
  return MySQLParser::RuleQueryExpressionOrParens;
}

void MySQLParser::QueryExpressionOrParensContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryExpressionOrParens(this);
}

void MySQLParser::QueryExpressionOrParensContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryExpressionOrParens(this);
}


antlrcpp::Any MySQLParser::QueryExpressionOrParensContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitQueryExpressionOrParens(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::QueryExpressionOrParensContext* MySQLParser::queryExpressionOrParens() {
  QueryExpressionOrParensContext *_localctx = _tracker.createInstance<QueryExpressionOrParensContext>(_ctx, getState());
  enterRule(_localctx, 92, MySQLParser::RuleQueryExpressionOrParens);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1901);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1899);
      queryExpression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1900);
      queryExpressionParens();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateRoutineContext ------------------------------------------------------------------

MySQLParser::CreateRoutineContext::CreateRoutineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateRoutineContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateRoutineContext::EOF() {
  return getToken(MySQLParser::EOF, 0);
}

MySQLParser::CreateProcedureContext* MySQLParser::CreateRoutineContext::createProcedure() {
  return getRuleContext<MySQLParser::CreateProcedureContext>(0);
}

MySQLParser::CreateFunctionContext* MySQLParser::CreateRoutineContext::createFunction() {
  return getRuleContext<MySQLParser::CreateFunctionContext>(0);
}

MySQLParser::CreateUdfContext* MySQLParser::CreateRoutineContext::createUdf() {
  return getRuleContext<MySQLParser::CreateUdfContext>(0);
}

tree::TerminalNode* MySQLParser::CreateRoutineContext::SEMICOLON_SYMBOL() {
  return getToken(MySQLParser::SEMICOLON_SYMBOL, 0);
}


size_t MySQLParser::CreateRoutineContext::getRuleIndex() const {
  return MySQLParser::RuleCreateRoutine;
}

void MySQLParser::CreateRoutineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateRoutine(this);
}

void MySQLParser::CreateRoutineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateRoutine(this);
}


antlrcpp::Any MySQLParser::CreateRoutineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateRoutine(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateRoutineContext* MySQLParser::createRoutine() {
  CreateRoutineContext *_localctx = _tracker.createInstance<CreateRoutineContext>(_ctx, getState());
  enterRule(_localctx, 94, MySQLParser::RuleCreateRoutine);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1903);
    match(MySQLParser::CREATE_SYMBOL);
    setState(1907);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx)) {
    case 1: {
      setState(1904);
      createProcedure();
      break;
    }

    case 2: {
      setState(1905);
      createFunction();
      break;
    }

    case 3: {
      setState(1906);
      createUdf();
      break;
    }

    }
    setState(1910);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::SEMICOLON_SYMBOL) {
      setState(1909);
      match(MySQLParser::SEMICOLON_SYMBOL);
    }
    setState(1912);
    match(MySQLParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateProcedureContext ------------------------------------------------------------------

MySQLParser::CreateProcedureContext::CreateProcedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateProcedureContext::PROCEDURE_SYMBOL() {
  return getToken(MySQLParser::PROCEDURE_SYMBOL, 0);
}

MySQLParser::ProcedureNameContext* MySQLParser::CreateProcedureContext::procedureName() {
  return getRuleContext<MySQLParser::ProcedureNameContext>(0);
}

tree::TerminalNode* MySQLParser::CreateProcedureContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateProcedureContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::CompoundStatementContext* MySQLParser::CreateProcedureContext::compoundStatement() {
  return getRuleContext<MySQLParser::CompoundStatementContext>(0);
}

MySQLParser::DefinerClauseContext* MySQLParser::CreateProcedureContext::definerClause() {
  return getRuleContext<MySQLParser::DefinerClauseContext>(0);
}

std::vector<MySQLParser::ProcedureParameterContext *> MySQLParser::CreateProcedureContext::procedureParameter() {
  return getRuleContexts<MySQLParser::ProcedureParameterContext>();
}

MySQLParser::ProcedureParameterContext* MySQLParser::CreateProcedureContext::procedureParameter(size_t i) {
  return getRuleContext<MySQLParser::ProcedureParameterContext>(i);
}

std::vector<MySQLParser::RoutineCreateOptionContext *> MySQLParser::CreateProcedureContext::routineCreateOption() {
  return getRuleContexts<MySQLParser::RoutineCreateOptionContext>();
}

MySQLParser::RoutineCreateOptionContext* MySQLParser::CreateProcedureContext::routineCreateOption(size_t i) {
  return getRuleContext<MySQLParser::RoutineCreateOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::CreateProcedureContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::CreateProcedureContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::CreateProcedureContext::getRuleIndex() const {
  return MySQLParser::RuleCreateProcedure;
}

void MySQLParser::CreateProcedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateProcedure(this);
}

void MySQLParser::CreateProcedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateProcedure(this);
}


antlrcpp::Any MySQLParser::CreateProcedureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateProcedure(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateProcedureContext* MySQLParser::createProcedure() {
  CreateProcedureContext *_localctx = _tracker.createInstance<CreateProcedureContext>(_ctx, getState());
  enterRule(_localctx, 96, MySQLParser::RuleCreateProcedure);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1915);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFINER_SYMBOL) {
      setState(1914);
      definerClause();
    }
    setState(1917);
    match(MySQLParser::PROCEDURE_SYMBOL);
    setState(1918);
    procedureName();
    setState(1919);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(1928);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 126, _ctx)) {
    case 1: {
      setState(1920);
      procedureParameter();
      setState(1925);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(1921);
        match(MySQLParser::COMMA_SYMBOL);
        setState(1922);
        procedureParameter();
        setState(1927);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    }
    setState(1930);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
    setState(1934);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 127, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1931);
        routineCreateOption(); 
      }
      setState(1936);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 127, _ctx);
    }
    setState(1937);
    compoundStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateFunctionContext ------------------------------------------------------------------

MySQLParser::CreateFunctionContext::CreateFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateFunctionContext::FUNCTION_SYMBOL() {
  return getToken(MySQLParser::FUNCTION_SYMBOL, 0);
}

MySQLParser::FunctionNameContext* MySQLParser::CreateFunctionContext::functionName() {
  return getRuleContext<MySQLParser::FunctionNameContext>(0);
}

tree::TerminalNode* MySQLParser::CreateFunctionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateFunctionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateFunctionContext::RETURNS_SYMBOL() {
  return getToken(MySQLParser::RETURNS_SYMBOL, 0);
}

MySQLParser::TypeWithOptCollateContext* MySQLParser::CreateFunctionContext::typeWithOptCollate() {
  return getRuleContext<MySQLParser::TypeWithOptCollateContext>(0);
}

MySQLParser::CompoundStatementContext* MySQLParser::CreateFunctionContext::compoundStatement() {
  return getRuleContext<MySQLParser::CompoundStatementContext>(0);
}

MySQLParser::DefinerClauseContext* MySQLParser::CreateFunctionContext::definerClause() {
  return getRuleContext<MySQLParser::DefinerClauseContext>(0);
}

std::vector<MySQLParser::FunctionParameterContext *> MySQLParser::CreateFunctionContext::functionParameter() {
  return getRuleContexts<MySQLParser::FunctionParameterContext>();
}

MySQLParser::FunctionParameterContext* MySQLParser::CreateFunctionContext::functionParameter(size_t i) {
  return getRuleContext<MySQLParser::FunctionParameterContext>(i);
}

std::vector<MySQLParser::RoutineCreateOptionContext *> MySQLParser::CreateFunctionContext::routineCreateOption() {
  return getRuleContexts<MySQLParser::RoutineCreateOptionContext>();
}

MySQLParser::RoutineCreateOptionContext* MySQLParser::CreateFunctionContext::routineCreateOption(size_t i) {
  return getRuleContext<MySQLParser::RoutineCreateOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::CreateFunctionContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::CreateFunctionContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::CreateFunctionContext::getRuleIndex() const {
  return MySQLParser::RuleCreateFunction;
}

void MySQLParser::CreateFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateFunction(this);
}

void MySQLParser::CreateFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateFunction(this);
}


antlrcpp::Any MySQLParser::CreateFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateFunctionContext* MySQLParser::createFunction() {
  CreateFunctionContext *_localctx = _tracker.createInstance<CreateFunctionContext>(_ctx, getState());
  enterRule(_localctx, 98, MySQLParser::RuleCreateFunction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1940);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFINER_SYMBOL) {
      setState(1939);
      definerClause();
    }
    setState(1942);
    match(MySQLParser::FUNCTION_SYMBOL);
    setState(1943);
    functionName();
    setState(1944);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(1953);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 130, _ctx)) {
    case 1: {
      setState(1945);
      functionParameter();
      setState(1950);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(1946);
        match(MySQLParser::COMMA_SYMBOL);
        setState(1947);
        functionParameter();
        setState(1952);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    }
    setState(1955);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
    setState(1956);
    match(MySQLParser::RETURNS_SYMBOL);
    setState(1957);
    typeWithOptCollate();
    setState(1961);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 131, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1958);
        routineCreateOption(); 
      }
      setState(1963);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 131, _ctx);
    }
    setState(1964);
    compoundStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUdfContext ------------------------------------------------------------------

MySQLParser::CreateUdfContext::CreateUdfContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateUdfContext::FUNCTION_SYMBOL() {
  return getToken(MySQLParser::FUNCTION_SYMBOL, 0);
}

MySQLParser::UdfNameContext* MySQLParser::CreateUdfContext::udfName() {
  return getRuleContext<MySQLParser::UdfNameContext>(0);
}

tree::TerminalNode* MySQLParser::CreateUdfContext::RETURNS_SYMBOL() {
  return getToken(MySQLParser::RETURNS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateUdfContext::SONAME_SYMBOL() {
  return getToken(MySQLParser::SONAME_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::CreateUdfContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::CreateUdfContext::STRING_SYMBOL() {
  return getToken(MySQLParser::STRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateUdfContext::INT_SYMBOL() {
  return getToken(MySQLParser::INT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateUdfContext::REAL_SYMBOL() {
  return getToken(MySQLParser::REAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateUdfContext::DECIMAL_SYMBOL() {
  return getToken(MySQLParser::DECIMAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateUdfContext::AGGREGATE_SYMBOL() {
  return getToken(MySQLParser::AGGREGATE_SYMBOL, 0);
}


size_t MySQLParser::CreateUdfContext::getRuleIndex() const {
  return MySQLParser::RuleCreateUdf;
}

void MySQLParser::CreateUdfContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUdf(this);
}

void MySQLParser::CreateUdfContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUdf(this);
}


antlrcpp::Any MySQLParser::CreateUdfContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateUdf(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateUdfContext* MySQLParser::createUdf() {
  CreateUdfContext *_localctx = _tracker.createInstance<CreateUdfContext>(_ctx, getState());
  enterRule(_localctx, 100, MySQLParser::RuleCreateUdf);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1967);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::AGGREGATE_SYMBOL) {
      setState(1966);
      match(MySQLParser::AGGREGATE_SYMBOL);
    }
    setState(1969);
    match(MySQLParser::FUNCTION_SYMBOL);
    setState(1970);
    udfName();
    setState(1971);
    match(MySQLParser::RETURNS_SYMBOL);
    setState(1972);
    dynamic_cast<CreateUdfContext *>(_localctx)->type = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::STRING_SYMBOL || _la == MySQLParser::DECIMAL_SYMBOL

    || _la == MySQLParser::INT_SYMBOL || _la == MySQLParser::REAL_SYMBOL)) {
      dynamic_cast<CreateUdfContext *>(_localctx)->type = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1973);
    match(MySQLParser::SONAME_SYMBOL);
    setState(1974);
    textLiteral();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoutineCreateOptionContext ------------------------------------------------------------------

MySQLParser::RoutineCreateOptionContext::RoutineCreateOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RoutineOptionContext* MySQLParser::RoutineCreateOptionContext::routineOption() {
  return getRuleContext<MySQLParser::RoutineOptionContext>(0);
}

tree::TerminalNode* MySQLParser::RoutineCreateOptionContext::DETERMINISTIC_SYMBOL() {
  return getToken(MySQLParser::DETERMINISTIC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoutineCreateOptionContext::NOT_SYMBOL() {
  return getToken(MySQLParser::NOT_SYMBOL, 0);
}


size_t MySQLParser::RoutineCreateOptionContext::getRuleIndex() const {
  return MySQLParser::RuleRoutineCreateOption;
}

void MySQLParser::RoutineCreateOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoutineCreateOption(this);
}

void MySQLParser::RoutineCreateOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoutineCreateOption(this);
}


antlrcpp::Any MySQLParser::RoutineCreateOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRoutineCreateOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoutineCreateOptionContext* MySQLParser::routineCreateOption() {
  RoutineCreateOptionContext *_localctx = _tracker.createInstance<RoutineCreateOptionContext>(_ctx, getState());
  enterRule(_localctx, 102, MySQLParser::RuleRoutineCreateOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1981);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::COMMENT_SYMBOL:
      case MySQLParser::CONTAINS_SYMBOL:
      case MySQLParser::LANGUAGE_SYMBOL:
      case MySQLParser::NO_SYMBOL:
      case MySQLParser::MODIFIES_SYMBOL:
      case MySQLParser::READS_SYMBOL:
      case MySQLParser::SQL_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(1976);
        routineOption();
        break;
      }

      case MySQLParser::DETERMINISTIC_SYMBOL:
      case MySQLParser::NOT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(1978);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::NOT_SYMBOL) {
          setState(1977);
          match(MySQLParser::NOT_SYMBOL);
        }
        setState(1980);
        match(MySQLParser::DETERMINISTIC_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoutineAlterOptionsContext ------------------------------------------------------------------

MySQLParser::RoutineAlterOptionsContext::RoutineAlterOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::RoutineCreateOptionContext *> MySQLParser::RoutineAlterOptionsContext::routineCreateOption() {
  return getRuleContexts<MySQLParser::RoutineCreateOptionContext>();
}

MySQLParser::RoutineCreateOptionContext* MySQLParser::RoutineAlterOptionsContext::routineCreateOption(size_t i) {
  return getRuleContext<MySQLParser::RoutineCreateOptionContext>(i);
}


size_t MySQLParser::RoutineAlterOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleRoutineAlterOptions;
}

void MySQLParser::RoutineAlterOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoutineAlterOptions(this);
}

void MySQLParser::RoutineAlterOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoutineAlterOptions(this);
}


antlrcpp::Any MySQLParser::RoutineAlterOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRoutineAlterOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoutineAlterOptionsContext* MySQLParser::routineAlterOptions() {
  RoutineAlterOptionsContext *_localctx = _tracker.createInstance<RoutineAlterOptionsContext>(_ctx, getState());
  enterRule(_localctx, 104, MySQLParser::RuleRoutineAlterOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1984); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1983);
      routineCreateOption();
      setState(1986); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLParser::COMMENT_SYMBOL)
      | (1ULL << MySQLParser::CONTAINS_SYMBOL)
      | (1ULL << MySQLParser::LANGUAGE_SYMBOL)
      | (1ULL << MySQLParser::NO_SYMBOL))) != 0) || _la == MySQLParser::DETERMINISTIC_SYMBOL || ((((_la - 566) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 566)) & ((1ULL << (MySQLParser::MODIFIES_SYMBOL - 566))
      | (1ULL << (MySQLParser::NOT_SYMBOL - 566))
      | (1ULL << (MySQLParser::READS_SYMBOL - 566)))) != 0) || _la == MySQLParser::SQL_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoutineOptionContext ------------------------------------------------------------------

MySQLParser::RoutineOptionContext::RoutineOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextLiteralContext* MySQLParser::RoutineOptionContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::RoutineOptionContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoutineOptionContext::SQL_SYMBOL() {
  return getToken(MySQLParser::SQL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoutineOptionContext::LANGUAGE_SYMBOL() {
  return getToken(MySQLParser::LANGUAGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoutineOptionContext::NO_SYMBOL() {
  return getToken(MySQLParser::NO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoutineOptionContext::CONTAINS_SYMBOL() {
  return getToken(MySQLParser::CONTAINS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoutineOptionContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoutineOptionContext::READS_SYMBOL() {
  return getToken(MySQLParser::READS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoutineOptionContext::MODIFIES_SYMBOL() {
  return getToken(MySQLParser::MODIFIES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoutineOptionContext::SECURITY_SYMBOL() {
  return getToken(MySQLParser::SECURITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoutineOptionContext::DEFINER_SYMBOL() {
  return getToken(MySQLParser::DEFINER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoutineOptionContext::INVOKER_SYMBOL() {
  return getToken(MySQLParser::INVOKER_SYMBOL, 0);
}


size_t MySQLParser::RoutineOptionContext::getRuleIndex() const {
  return MySQLParser::RuleRoutineOption;
}

void MySQLParser::RoutineOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoutineOption(this);
}

void MySQLParser::RoutineOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoutineOption(this);
}


antlrcpp::Any MySQLParser::RoutineOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRoutineOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoutineOptionContext* MySQLParser::routineOption() {
  RoutineOptionContext *_localctx = _tracker.createInstance<RoutineOptionContext>(_ctx, getState());
  enterRule(_localctx, 106, MySQLParser::RuleRoutineOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2005);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::COMMENT_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(1988);
        dynamic_cast<RoutineOptionContext *>(_localctx)->option = match(MySQLParser::COMMENT_SYMBOL);
        setState(1989);
        textLiteral();
        break;
      }

      case MySQLParser::LANGUAGE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(1990);
        dynamic_cast<RoutineOptionContext *>(_localctx)->option = match(MySQLParser::LANGUAGE_SYMBOL);
        setState(1991);
        match(MySQLParser::SQL_SYMBOL);
        break;
      }

      case MySQLParser::NO_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(1992);
        dynamic_cast<RoutineOptionContext *>(_localctx)->option = match(MySQLParser::NO_SYMBOL);
        setState(1993);
        match(MySQLParser::SQL_SYMBOL);
        break;
      }

      case MySQLParser::CONTAINS_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(1994);
        dynamic_cast<RoutineOptionContext *>(_localctx)->option = match(MySQLParser::CONTAINS_SYMBOL);
        setState(1995);
        match(MySQLParser::SQL_SYMBOL);
        break;
      }

      case MySQLParser::READS_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(1996);
        dynamic_cast<RoutineOptionContext *>(_localctx)->option = match(MySQLParser::READS_SYMBOL);
        setState(1997);
        match(MySQLParser::SQL_SYMBOL);
        setState(1998);
        match(MySQLParser::DATA_SYMBOL);
        break;
      }

      case MySQLParser::MODIFIES_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(1999);
        dynamic_cast<RoutineOptionContext *>(_localctx)->option = match(MySQLParser::MODIFIES_SYMBOL);
        setState(2000);
        match(MySQLParser::SQL_SYMBOL);
        setState(2001);
        match(MySQLParser::DATA_SYMBOL);
        break;
      }

      case MySQLParser::SQL_SYMBOL: {
        enterOuterAlt(_localctx, 7);
        setState(2002);
        dynamic_cast<RoutineOptionContext *>(_localctx)->option = match(MySQLParser::SQL_SYMBOL);
        setState(2003);
        match(MySQLParser::SECURITY_SYMBOL);
        setState(2004);
        dynamic_cast<RoutineOptionContext *>(_localctx)->security = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::DEFINER_SYMBOL

        || _la == MySQLParser::INVOKER_SYMBOL)) {
          dynamic_cast<RoutineOptionContext *>(_localctx)->security = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateIndexContext ------------------------------------------------------------------

MySQLParser::CreateIndexContext::CreateIndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CreateIndexTargetContext* MySQLParser::CreateIndexContext::createIndexTarget() {
  return getRuleContext<MySQLParser::CreateIndexTargetContext>(0);
}

tree::TerminalNode* MySQLParser::CreateIndexContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

MySQLParser::IndexNameContext* MySQLParser::CreateIndexContext::indexName() {
  return getRuleContext<MySQLParser::IndexNameContext>(0);
}

MySQLParser::OnlineOptionContext* MySQLParser::CreateIndexContext::onlineOption() {
  return getRuleContext<MySQLParser::OnlineOptionContext>(0);
}

tree::TerminalNode* MySQLParser::CreateIndexContext::FULLTEXT_SYMBOL() {
  return getToken(MySQLParser::FULLTEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateIndexContext::SPATIAL_SYMBOL() {
  return getToken(MySQLParser::SPATIAL_SYMBOL, 0);
}

MySQLParser::IndexLockAndAlgorithmContext* MySQLParser::CreateIndexContext::indexLockAndAlgorithm() {
  return getRuleContext<MySQLParser::IndexLockAndAlgorithmContext>(0);
}

tree::TerminalNode* MySQLParser::CreateIndexContext::UNIQUE_SYMBOL() {
  return getToken(MySQLParser::UNIQUE_SYMBOL, 0);
}

std::vector<MySQLParser::IndexOptionContext *> MySQLParser::CreateIndexContext::indexOption() {
  return getRuleContexts<MySQLParser::IndexOptionContext>();
}

MySQLParser::IndexOptionContext* MySQLParser::CreateIndexContext::indexOption(size_t i) {
  return getRuleContext<MySQLParser::IndexOptionContext>(i);
}

std::vector<MySQLParser::FulltextIndexOptionContext *> MySQLParser::CreateIndexContext::fulltextIndexOption() {
  return getRuleContexts<MySQLParser::FulltextIndexOptionContext>();
}

MySQLParser::FulltextIndexOptionContext* MySQLParser::CreateIndexContext::fulltextIndexOption(size_t i) {
  return getRuleContext<MySQLParser::FulltextIndexOptionContext>(i);
}

std::vector<MySQLParser::SpatialIndexOptionContext *> MySQLParser::CreateIndexContext::spatialIndexOption() {
  return getRuleContexts<MySQLParser::SpatialIndexOptionContext>();
}

MySQLParser::SpatialIndexOptionContext* MySQLParser::CreateIndexContext::spatialIndexOption(size_t i) {
  return getRuleContext<MySQLParser::SpatialIndexOptionContext>(i);
}

MySQLParser::IndexTypeClauseContext* MySQLParser::CreateIndexContext::indexTypeClause() {
  return getRuleContext<MySQLParser::IndexTypeClauseContext>(0);
}

MySQLParser::IndexNameAndTypeContext* MySQLParser::CreateIndexContext::indexNameAndType() {
  return getRuleContext<MySQLParser::IndexNameAndTypeContext>(0);
}


size_t MySQLParser::CreateIndexContext::getRuleIndex() const {
  return MySQLParser::RuleCreateIndex;
}

void MySQLParser::CreateIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateIndex(this);
}

void MySQLParser::CreateIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateIndex(this);
}


antlrcpp::Any MySQLParser::CreateIndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateIndex(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateIndexContext* MySQLParser::createIndex() {
  CreateIndexContext *_localctx = _tracker.createInstance<CreateIndexContext>(_ctx, getState());
  enterRule(_localctx, 108, MySQLParser::RuleCreateIndex);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2008);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 137, _ctx)) {
    case 1: {
      setState(2007);
      onlineOption();
      break;
    }

    }
    setState(2051);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INDEX_SYMBOL:
      case MySQLParser::UNIQUE_SYMBOL: {
        setState(2011);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::UNIQUE_SYMBOL) {
          setState(2010);
          match(MySQLParser::UNIQUE_SYMBOL);
        }
        setState(2013);
        dynamic_cast<CreateIndexContext *>(_localctx)->type = match(MySQLParser::INDEX_SYMBOL);
        setState(2022);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx)) {
        case 1: {
          setState(2014);

          if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
          setState(2015);
          indexName();
          setState(2017);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLParser::TYPE_SYMBOL || _la == MySQLParser::USING_SYMBOL) {
            setState(2016);
            indexTypeClause();
          }
          break;
        }

        case 2: {
          setState(2020);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 140, _ctx)) {
          case 1: {
            setState(2019);
            indexNameAndType();
            break;
          }

          }
          break;
        }

        }
        setState(2024);
        createIndexTarget();
        setState(2028);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 142, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2025);
            indexOption(); 
          }
          setState(2030);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 142, _ctx);
        }
        break;
      }

      case MySQLParser::FULLTEXT_SYMBOL: {
        setState(2031);
        dynamic_cast<CreateIndexContext *>(_localctx)->type = match(MySQLParser::FULLTEXT_SYMBOL);
        setState(2032);
        match(MySQLParser::INDEX_SYMBOL);
        setState(2033);
        indexName();
        setState(2034);
        createIndexTarget();
        setState(2038);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 143, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2035);
            fulltextIndexOption(); 
          }
          setState(2040);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 143, _ctx);
        }
        break;
      }

      case MySQLParser::SPATIAL_SYMBOL: {
        setState(2041);
        dynamic_cast<CreateIndexContext *>(_localctx)->type = match(MySQLParser::SPATIAL_SYMBOL);
        setState(2042);
        match(MySQLParser::INDEX_SYMBOL);
        setState(2043);
        indexName();
        setState(2044);
        createIndexTarget();
        setState(2048);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2045);
            spatialIndexOption(); 
          }
          setState(2050);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2054);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 146, _ctx)) {
    case 1: {
      setState(2053);
      indexLockAndAlgorithm();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexNameAndTypeContext ------------------------------------------------------------------

MySQLParser::IndexNameAndTypeContext::IndexNameAndTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IndexNameContext* MySQLParser::IndexNameAndTypeContext::indexName() {
  return getRuleContext<MySQLParser::IndexNameContext>(0);
}

tree::TerminalNode* MySQLParser::IndexNameAndTypeContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

MySQLParser::IndexTypeContext* MySQLParser::IndexNameAndTypeContext::indexType() {
  return getRuleContext<MySQLParser::IndexTypeContext>(0);
}

tree::TerminalNode* MySQLParser::IndexNameAndTypeContext::TYPE_SYMBOL() {
  return getToken(MySQLParser::TYPE_SYMBOL, 0);
}


size_t MySQLParser::IndexNameAndTypeContext::getRuleIndex() const {
  return MySQLParser::RuleIndexNameAndType;
}

void MySQLParser::IndexNameAndTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexNameAndType(this);
}

void MySQLParser::IndexNameAndTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexNameAndType(this);
}


antlrcpp::Any MySQLParser::IndexNameAndTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIndexNameAndType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexNameAndTypeContext* MySQLParser::indexNameAndType() {
  IndexNameAndTypeContext *_localctx = _tracker.createInstance<IndexNameAndTypeContext>(_ctx, getState());
  enterRule(_localctx, 110, MySQLParser::RuleIndexNameAndType);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2065);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 148, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2056);
      indexName();
      setState(2059);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 147, _ctx)) {
      case 1: {
        setState(2057);
        match(MySQLParser::USING_SYMBOL);
        setState(2058);
        indexType();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2061);
      indexName();
      setState(2062);
      match(MySQLParser::TYPE_SYMBOL);
      setState(2063);
      indexType();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateIndexTargetContext ------------------------------------------------------------------

MySQLParser::CreateIndexTargetContext::CreateIndexTargetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateIndexTargetContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::CreateIndexTargetContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::KeyListVariantsContext* MySQLParser::CreateIndexTargetContext::keyListVariants() {
  return getRuleContext<MySQLParser::KeyListVariantsContext>(0);
}


size_t MySQLParser::CreateIndexTargetContext::getRuleIndex() const {
  return MySQLParser::RuleCreateIndexTarget;
}

void MySQLParser::CreateIndexTargetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateIndexTarget(this);
}

void MySQLParser::CreateIndexTargetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateIndexTarget(this);
}


antlrcpp::Any MySQLParser::CreateIndexTargetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateIndexTarget(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateIndexTargetContext* MySQLParser::createIndexTarget() {
  CreateIndexTargetContext *_localctx = _tracker.createInstance<CreateIndexTargetContext>(_ctx, getState());
  enterRule(_localctx, 112, MySQLParser::RuleCreateIndexTarget);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2067);
    match(MySQLParser::ON_SYMBOL);
    setState(2068);
    tableRef();
    setState(2069);
    keyListVariants();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateLogfileGroupContext ------------------------------------------------------------------

MySQLParser::CreateLogfileGroupContext::CreateLogfileGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateLogfileGroupContext::LOGFILE_SYMBOL() {
  return getToken(MySQLParser::LOGFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateLogfileGroupContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::LogfileGroupNameContext* MySQLParser::CreateLogfileGroupContext::logfileGroupName() {
  return getRuleContext<MySQLParser::LogfileGroupNameContext>(0);
}

tree::TerminalNode* MySQLParser::CreateLogfileGroupContext::ADD_SYMBOL() {
  return getToken(MySQLParser::ADD_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::CreateLogfileGroupContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::CreateLogfileGroupContext::UNDOFILE_SYMBOL() {
  return getToken(MySQLParser::UNDOFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateLogfileGroupContext::REDOFILE_SYMBOL() {
  return getToken(MySQLParser::REDOFILE_SYMBOL, 0);
}

MySQLParser::LogfileGroupOptionsContext* MySQLParser::CreateLogfileGroupContext::logfileGroupOptions() {
  return getRuleContext<MySQLParser::LogfileGroupOptionsContext>(0);
}


size_t MySQLParser::CreateLogfileGroupContext::getRuleIndex() const {
  return MySQLParser::RuleCreateLogfileGroup;
}

void MySQLParser::CreateLogfileGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateLogfileGroup(this);
}

void MySQLParser::CreateLogfileGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateLogfileGroup(this);
}


antlrcpp::Any MySQLParser::CreateLogfileGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateLogfileGroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateLogfileGroupContext* MySQLParser::createLogfileGroup() {
  CreateLogfileGroupContext *_localctx = _tracker.createInstance<CreateLogfileGroupContext>(_ctx, getState());
  enterRule(_localctx, 114, MySQLParser::RuleCreateLogfileGroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2071);
    match(MySQLParser::LOGFILE_SYMBOL);
    setState(2072);
    match(MySQLParser::GROUP_SYMBOL);
    setState(2073);
    logfileGroupName();
    setState(2074);
    match(MySQLParser::ADD_SYMBOL);
    setState(2075);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::REDOFILE_SYMBOL || _la == MySQLParser::UNDOFILE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2076);
    textLiteral();
    setState(2078);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::COMMENT_SYMBOL || _la == MySQLParser::ENGINE_SYMBOL

    || _la == MySQLParser::INITIAL_SIZE_SYMBOL || ((((_la - 237) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 237)) & ((1ULL << (MySQLParser::NO_WAIT_SYMBOL - 237))
      | (1ULL << (MySQLParser::NODEGROUP_SYMBOL - 237))
      | (1ULL << (MySQLParser::REDO_BUFFER_SIZE_SYMBOL - 237)))) != 0) || ((((_la - 328) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 328)) & ((1ULL << (MySQLParser::STORAGE_SYMBOL - 328))
      | (1ULL << (MySQLParser::UNDO_BUFFER_SIZE_SYMBOL - 328))
      | (1ULL << (MySQLParser::WAIT_SYMBOL - 328)))) != 0)) {
      setState(2077);
      logfileGroupOptions();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogfileGroupOptionsContext ------------------------------------------------------------------

MySQLParser::LogfileGroupOptionsContext::LogfileGroupOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::LogfileGroupOptionContext *> MySQLParser::LogfileGroupOptionsContext::logfileGroupOption() {
  return getRuleContexts<MySQLParser::LogfileGroupOptionContext>();
}

MySQLParser::LogfileGroupOptionContext* MySQLParser::LogfileGroupOptionsContext::logfileGroupOption(size_t i) {
  return getRuleContext<MySQLParser::LogfileGroupOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::LogfileGroupOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::LogfileGroupOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::LogfileGroupOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleLogfileGroupOptions;
}

void MySQLParser::LogfileGroupOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogfileGroupOptions(this);
}

void MySQLParser::LogfileGroupOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogfileGroupOptions(this);
}


antlrcpp::Any MySQLParser::LogfileGroupOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLogfileGroupOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LogfileGroupOptionsContext* MySQLParser::logfileGroupOptions() {
  LogfileGroupOptionsContext *_localctx = _tracker.createInstance<LogfileGroupOptionsContext>(_ctx, getState());
  enterRule(_localctx, 116, MySQLParser::RuleLogfileGroupOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2080);
    logfileGroupOption();
    setState(2087);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMENT_SYMBOL || _la == MySQLParser::ENGINE_SYMBOL

    || _la == MySQLParser::INITIAL_SIZE_SYMBOL || ((((_la - 237) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 237)) & ((1ULL << (MySQLParser::NO_WAIT_SYMBOL - 237))
      | (1ULL << (MySQLParser::NODEGROUP_SYMBOL - 237))
      | (1ULL << (MySQLParser::REDO_BUFFER_SIZE_SYMBOL - 237)))) != 0) || ((((_la - 328) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 328)) & ((1ULL << (MySQLParser::STORAGE_SYMBOL - 328))
      | (1ULL << (MySQLParser::UNDO_BUFFER_SIZE_SYMBOL - 328))
      | (1ULL << (MySQLParser::WAIT_SYMBOL - 328)))) != 0) || _la == MySQLParser::COMMA_SYMBOL) {
      setState(2082);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(2081);
        match(MySQLParser::COMMA_SYMBOL);
      }
      setState(2084);
      logfileGroupOption();
      setState(2089);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogfileGroupOptionContext ------------------------------------------------------------------

MySQLParser::LogfileGroupOptionContext::LogfileGroupOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TsOptionInitialSizeContext* MySQLParser::LogfileGroupOptionContext::tsOptionInitialSize() {
  return getRuleContext<MySQLParser::TsOptionInitialSizeContext>(0);
}

MySQLParser::TsOptionUndoRedoBufferSizeContext* MySQLParser::LogfileGroupOptionContext::tsOptionUndoRedoBufferSize() {
  return getRuleContext<MySQLParser::TsOptionUndoRedoBufferSizeContext>(0);
}

MySQLParser::TsOptionNodegroupContext* MySQLParser::LogfileGroupOptionContext::tsOptionNodegroup() {
  return getRuleContext<MySQLParser::TsOptionNodegroupContext>(0);
}

MySQLParser::TsOptionEngineContext* MySQLParser::LogfileGroupOptionContext::tsOptionEngine() {
  return getRuleContext<MySQLParser::TsOptionEngineContext>(0);
}

MySQLParser::TsOptionWaitContext* MySQLParser::LogfileGroupOptionContext::tsOptionWait() {
  return getRuleContext<MySQLParser::TsOptionWaitContext>(0);
}

MySQLParser::TsOptionCommentContext* MySQLParser::LogfileGroupOptionContext::tsOptionComment() {
  return getRuleContext<MySQLParser::TsOptionCommentContext>(0);
}


size_t MySQLParser::LogfileGroupOptionContext::getRuleIndex() const {
  return MySQLParser::RuleLogfileGroupOption;
}

void MySQLParser::LogfileGroupOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogfileGroupOption(this);
}

void MySQLParser::LogfileGroupOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogfileGroupOption(this);
}


antlrcpp::Any MySQLParser::LogfileGroupOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLogfileGroupOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LogfileGroupOptionContext* MySQLParser::logfileGroupOption() {
  LogfileGroupOptionContext *_localctx = _tracker.createInstance<LogfileGroupOptionContext>(_ctx, getState());
  enterRule(_localctx, 118, MySQLParser::RuleLogfileGroupOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2096);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INITIAL_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2090);
        tsOptionInitialSize();
        break;
      }

      case MySQLParser::REDO_BUFFER_SIZE_SYMBOL:
      case MySQLParser::UNDO_BUFFER_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2091);
        tsOptionUndoRedoBufferSize();
        break;
      }

      case MySQLParser::NODEGROUP_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(2092);
        tsOptionNodegroup();
        break;
      }

      case MySQLParser::ENGINE_SYMBOL:
      case MySQLParser::STORAGE_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(2093);
        tsOptionEngine();
        break;
      }

      case MySQLParser::NO_WAIT_SYMBOL:
      case MySQLParser::WAIT_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(2094);
        tsOptionWait();
        break;
      }

      case MySQLParser::COMMENT_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(2095);
        tsOptionComment();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateServerContext ------------------------------------------------------------------

MySQLParser::CreateServerContext::CreateServerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateServerContext::SERVER_SYMBOL() {
  return getToken(MySQLParser::SERVER_SYMBOL, 0);
}

MySQLParser::ServerNameContext* MySQLParser::CreateServerContext::serverName() {
  return getRuleContext<MySQLParser::ServerNameContext>(0);
}

tree::TerminalNode* MySQLParser::CreateServerContext::FOREIGN_SYMBOL() {
  return getToken(MySQLParser::FOREIGN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateServerContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateServerContext::WRAPPER_SYMBOL() {
  return getToken(MySQLParser::WRAPPER_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::CreateServerContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

MySQLParser::ServerOptionsContext* MySQLParser::CreateServerContext::serverOptions() {
  return getRuleContext<MySQLParser::ServerOptionsContext>(0);
}


size_t MySQLParser::CreateServerContext::getRuleIndex() const {
  return MySQLParser::RuleCreateServer;
}

void MySQLParser::CreateServerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateServer(this);
}

void MySQLParser::CreateServerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateServer(this);
}


antlrcpp::Any MySQLParser::CreateServerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateServer(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateServerContext* MySQLParser::createServer() {
  CreateServerContext *_localctx = _tracker.createInstance<CreateServerContext>(_ctx, getState());
  enterRule(_localctx, 120, MySQLParser::RuleCreateServer);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2098);
    match(MySQLParser::SERVER_SYMBOL);
    setState(2099);
    serverName();
    setState(2100);
    match(MySQLParser::FOREIGN_SYMBOL);
    setState(2101);
    match(MySQLParser::DATA_SYMBOL);
    setState(2102);
    match(MySQLParser::WRAPPER_SYMBOL);
    setState(2103);
    textOrIdentifier();
    setState(2104);
    serverOptions();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ServerOptionsContext ------------------------------------------------------------------

MySQLParser::ServerOptionsContext::ServerOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ServerOptionsContext::OPTIONS_SYMBOL() {
  return getToken(MySQLParser::OPTIONS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ServerOptionsContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::ServerOptionContext *> MySQLParser::ServerOptionsContext::serverOption() {
  return getRuleContexts<MySQLParser::ServerOptionContext>();
}

MySQLParser::ServerOptionContext* MySQLParser::ServerOptionsContext::serverOption(size_t i) {
  return getRuleContext<MySQLParser::ServerOptionContext>(i);
}

tree::TerminalNode* MySQLParser::ServerOptionsContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::ServerOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ServerOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ServerOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleServerOptions;
}

void MySQLParser::ServerOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterServerOptions(this);
}

void MySQLParser::ServerOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitServerOptions(this);
}


antlrcpp::Any MySQLParser::ServerOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitServerOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ServerOptionsContext* MySQLParser::serverOptions() {
  ServerOptionsContext *_localctx = _tracker.createInstance<ServerOptionsContext>(_ctx, getState());
  enterRule(_localctx, 122, MySQLParser::RuleServerOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2106);
    match(MySQLParser::OPTIONS_SYMBOL);
    setState(2107);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(2108);
    serverOption();
    setState(2113);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(2109);
      match(MySQLParser::COMMA_SYMBOL);
      setState(2110);
      serverOption();
      setState(2115);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2116);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ServerOptionContext ------------------------------------------------------------------

MySQLParser::ServerOptionContext::ServerOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextLiteralContext* MySQLParser::ServerOptionContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::ServerOptionContext::HOST_SYMBOL() {
  return getToken(MySQLParser::HOST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ServerOptionContext::DATABASE_SYMBOL() {
  return getToken(MySQLParser::DATABASE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ServerOptionContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ServerOptionContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ServerOptionContext::SOCKET_SYMBOL() {
  return getToken(MySQLParser::SOCKET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ServerOptionContext::OWNER_SYMBOL() {
  return getToken(MySQLParser::OWNER_SYMBOL, 0);
}

MySQLParser::Ulong_numberContext* MySQLParser::ServerOptionContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::ServerOptionContext::PORT_SYMBOL() {
  return getToken(MySQLParser::PORT_SYMBOL, 0);
}


size_t MySQLParser::ServerOptionContext::getRuleIndex() const {
  return MySQLParser::RuleServerOption;
}

void MySQLParser::ServerOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterServerOption(this);
}

void MySQLParser::ServerOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitServerOption(this);
}


antlrcpp::Any MySQLParser::ServerOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitServerOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ServerOptionContext* MySQLParser::serverOption() {
  ServerOptionContext *_localctx = _tracker.createInstance<ServerOptionContext>(_ctx, getState());
  enterRule(_localctx, 124, MySQLParser::RuleServerOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2132);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::HOST_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2118);
        dynamic_cast<ServerOptionContext *>(_localctx)->option = match(MySQLParser::HOST_SYMBOL);
        setState(2119);
        textLiteral();
        break;
      }

      case MySQLParser::DATABASE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2120);
        dynamic_cast<ServerOptionContext *>(_localctx)->option = match(MySQLParser::DATABASE_SYMBOL);
        setState(2121);
        textLiteral();
        break;
      }

      case MySQLParser::USER_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(2122);
        dynamic_cast<ServerOptionContext *>(_localctx)->option = match(MySQLParser::USER_SYMBOL);
        setState(2123);
        textLiteral();
        break;
      }

      case MySQLParser::PASSWORD_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(2124);
        dynamic_cast<ServerOptionContext *>(_localctx)->option = match(MySQLParser::PASSWORD_SYMBOL);
        setState(2125);
        textLiteral();
        break;
      }

      case MySQLParser::SOCKET_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(2126);
        dynamic_cast<ServerOptionContext *>(_localctx)->option = match(MySQLParser::SOCKET_SYMBOL);
        setState(2127);
        textLiteral();
        break;
      }

      case MySQLParser::OWNER_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(2128);
        dynamic_cast<ServerOptionContext *>(_localctx)->option = match(MySQLParser::OWNER_SYMBOL);
        setState(2129);
        textLiteral();
        break;
      }

      case MySQLParser::PORT_SYMBOL: {
        enterOuterAlt(_localctx, 7);
        setState(2130);
        dynamic_cast<ServerOptionContext *>(_localctx)->option = match(MySQLParser::PORT_SYMBOL);
        setState(2131);
        ulong_number();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTablespaceContext ------------------------------------------------------------------

MySQLParser::CreateTablespaceContext::CreateTablespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateTablespaceContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

MySQLParser::TablespaceNameContext* MySQLParser::CreateTablespaceContext::tablespaceName() {
  return getRuleContext<MySQLParser::TablespaceNameContext>(0);
}

MySQLParser::TsDataFileNameContext* MySQLParser::CreateTablespaceContext::tsDataFileName() {
  return getRuleContext<MySQLParser::TsDataFileNameContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTablespaceContext::USE_SYMBOL() {
  return getToken(MySQLParser::USE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTablespaceContext::LOGFILE_SYMBOL() {
  return getToken(MySQLParser::LOGFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTablespaceContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::LogfileGroupRefContext* MySQLParser::CreateTablespaceContext::logfileGroupRef() {
  return getRuleContext<MySQLParser::LogfileGroupRefContext>(0);
}

MySQLParser::TablespaceOptionsContext* MySQLParser::CreateTablespaceContext::tablespaceOptions() {
  return getRuleContext<MySQLParser::TablespaceOptionsContext>(0);
}


size_t MySQLParser::CreateTablespaceContext::getRuleIndex() const {
  return MySQLParser::RuleCreateTablespace;
}

void MySQLParser::CreateTablespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTablespace(this);
}

void MySQLParser::CreateTablespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTablespace(this);
}


antlrcpp::Any MySQLParser::CreateTablespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateTablespace(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateTablespaceContext* MySQLParser::createTablespace() {
  CreateTablespaceContext *_localctx = _tracker.createInstance<CreateTablespaceContext>(_ctx, getState());
  enterRule(_localctx, 126, MySQLParser::RuleCreateTablespace);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2134);
    match(MySQLParser::TABLESPACE_SYMBOL);
    setState(2135);
    tablespaceName();
    setState(2136);
    tsDataFileName();
    setState(2141);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 155, _ctx)) {
    case 1: {
      setState(2137);
      match(MySQLParser::USE_SYMBOL);
      setState(2138);
      match(MySQLParser::LOGFILE_SYMBOL);
      setState(2139);
      match(MySQLParser::GROUP_SYMBOL);
      setState(2140);
      logfileGroupRef();
      break;
    }

    }
    setState(2144);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 156, _ctx)) {
    case 1: {
      setState(2143);
      tablespaceOptions();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUndoTablespaceContext ------------------------------------------------------------------

MySQLParser::CreateUndoTablespaceContext::CreateUndoTablespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateUndoTablespaceContext::UNDO_SYMBOL() {
  return getToken(MySQLParser::UNDO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateUndoTablespaceContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

MySQLParser::TablespaceNameContext* MySQLParser::CreateUndoTablespaceContext::tablespaceName() {
  return getRuleContext<MySQLParser::TablespaceNameContext>(0);
}

tree::TerminalNode* MySQLParser::CreateUndoTablespaceContext::ADD_SYMBOL() {
  return getToken(MySQLParser::ADD_SYMBOL, 0);
}

MySQLParser::TsDataFileContext* MySQLParser::CreateUndoTablespaceContext::tsDataFile() {
  return getRuleContext<MySQLParser::TsDataFileContext>(0);
}

MySQLParser::UndoTableSpaceOptionsContext* MySQLParser::CreateUndoTablespaceContext::undoTableSpaceOptions() {
  return getRuleContext<MySQLParser::UndoTableSpaceOptionsContext>(0);
}


size_t MySQLParser::CreateUndoTablespaceContext::getRuleIndex() const {
  return MySQLParser::RuleCreateUndoTablespace;
}

void MySQLParser::CreateUndoTablespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUndoTablespace(this);
}

void MySQLParser::CreateUndoTablespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUndoTablespace(this);
}


antlrcpp::Any MySQLParser::CreateUndoTablespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateUndoTablespace(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateUndoTablespaceContext* MySQLParser::createUndoTablespace() {
  CreateUndoTablespaceContext *_localctx = _tracker.createInstance<CreateUndoTablespaceContext>(_ctx, getState());
  enterRule(_localctx, 128, MySQLParser::RuleCreateUndoTablespace);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2146);
    match(MySQLParser::UNDO_SYMBOL);
    setState(2147);
    match(MySQLParser::TABLESPACE_SYMBOL);
    setState(2148);
    tablespaceName();
    setState(2149);
    match(MySQLParser::ADD_SYMBOL);
    setState(2150);
    tsDataFile();
    setState(2152);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL) {
      setState(2151);
      undoTableSpaceOptions();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsDataFileNameContext ------------------------------------------------------------------

MySQLParser::TsDataFileNameContext::TsDataFileNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsDataFileNameContext::ADD_SYMBOL() {
  return getToken(MySQLParser::ADD_SYMBOL, 0);
}

MySQLParser::TsDataFileContext* MySQLParser::TsDataFileNameContext::tsDataFile() {
  return getRuleContext<MySQLParser::TsDataFileContext>(0);
}


size_t MySQLParser::TsDataFileNameContext::getRuleIndex() const {
  return MySQLParser::RuleTsDataFileName;
}

void MySQLParser::TsDataFileNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsDataFileName(this);
}

void MySQLParser::TsDataFileNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsDataFileName(this);
}


antlrcpp::Any MySQLParser::TsDataFileNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTsDataFileName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsDataFileNameContext* MySQLParser::tsDataFileName() {
  TsDataFileNameContext *_localctx = _tracker.createInstance<TsDataFileNameContext>(_ctx, getState());
  enterRule(_localctx, 130, MySQLParser::RuleTsDataFileName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2161);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 159, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2154);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(2157);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 158, _ctx)) {
      case 1: {
        setState(2155);
        match(MySQLParser::ADD_SYMBOL);
        setState(2156);
        tsDataFile();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2159);
      match(MySQLParser::ADD_SYMBOL);
      setState(2160);
      tsDataFile();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsDataFileContext ------------------------------------------------------------------

MySQLParser::TsDataFileContext::TsDataFileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsDataFileContext::DATAFILE_SYMBOL() {
  return getToken(MySQLParser::DATAFILE_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::TsDataFileContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}


size_t MySQLParser::TsDataFileContext::getRuleIndex() const {
  return MySQLParser::RuleTsDataFile;
}

void MySQLParser::TsDataFileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsDataFile(this);
}

void MySQLParser::TsDataFileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsDataFile(this);
}


antlrcpp::Any MySQLParser::TsDataFileContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTsDataFile(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsDataFileContext* MySQLParser::tsDataFile() {
  TsDataFileContext *_localctx = _tracker.createInstance<TsDataFileContext>(_ctx, getState());
  enterRule(_localctx, 132, MySQLParser::RuleTsDataFile);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2163);
    match(MySQLParser::DATAFILE_SYMBOL);
    setState(2164);
    textLiteral();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TablespaceOptionsContext ------------------------------------------------------------------

MySQLParser::TablespaceOptionsContext::TablespaceOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TablespaceOptionContext *> MySQLParser::TablespaceOptionsContext::tablespaceOption() {
  return getRuleContexts<MySQLParser::TablespaceOptionContext>();
}

MySQLParser::TablespaceOptionContext* MySQLParser::TablespaceOptionsContext::tablespaceOption(size_t i) {
  return getRuleContext<MySQLParser::TablespaceOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::TablespaceOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::TablespaceOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::TablespaceOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleTablespaceOptions;
}

void MySQLParser::TablespaceOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTablespaceOptions(this);
}

void MySQLParser::TablespaceOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTablespaceOptions(this);
}


antlrcpp::Any MySQLParser::TablespaceOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTablespaceOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TablespaceOptionsContext* MySQLParser::tablespaceOptions() {
  TablespaceOptionsContext *_localctx = _tracker.createInstance<TablespaceOptionsContext>(_ctx, getState());
  enterRule(_localctx, 134, MySQLParser::RuleTablespaceOptions);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2166);
    tablespaceOption();
    setState(2173);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2168);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 160, _ctx)) {
        case 1: {
          setState(2167);
          match(MySQLParser::COMMA_SYMBOL);
          break;
        }

        }
        setState(2170);
        tablespaceOption(); 
      }
      setState(2175);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TablespaceOptionContext ------------------------------------------------------------------

MySQLParser::TablespaceOptionContext::TablespaceOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TsOptionInitialSizeContext* MySQLParser::TablespaceOptionContext::tsOptionInitialSize() {
  return getRuleContext<MySQLParser::TsOptionInitialSizeContext>(0);
}

MySQLParser::TsOptionAutoextendSizeContext* MySQLParser::TablespaceOptionContext::tsOptionAutoextendSize() {
  return getRuleContext<MySQLParser::TsOptionAutoextendSizeContext>(0);
}

MySQLParser::TsOptionMaxSizeContext* MySQLParser::TablespaceOptionContext::tsOptionMaxSize() {
  return getRuleContext<MySQLParser::TsOptionMaxSizeContext>(0);
}

MySQLParser::TsOptionExtentSizeContext* MySQLParser::TablespaceOptionContext::tsOptionExtentSize() {
  return getRuleContext<MySQLParser::TsOptionExtentSizeContext>(0);
}

MySQLParser::TsOptionNodegroupContext* MySQLParser::TablespaceOptionContext::tsOptionNodegroup() {
  return getRuleContext<MySQLParser::TsOptionNodegroupContext>(0);
}

MySQLParser::TsOptionEngineContext* MySQLParser::TablespaceOptionContext::tsOptionEngine() {
  return getRuleContext<MySQLParser::TsOptionEngineContext>(0);
}

MySQLParser::TsOptionWaitContext* MySQLParser::TablespaceOptionContext::tsOptionWait() {
  return getRuleContext<MySQLParser::TsOptionWaitContext>(0);
}

MySQLParser::TsOptionCommentContext* MySQLParser::TablespaceOptionContext::tsOptionComment() {
  return getRuleContext<MySQLParser::TsOptionCommentContext>(0);
}

MySQLParser::TsOptionFileblockSizeContext* MySQLParser::TablespaceOptionContext::tsOptionFileblockSize() {
  return getRuleContext<MySQLParser::TsOptionFileblockSizeContext>(0);
}

MySQLParser::TsOptionEncryptionContext* MySQLParser::TablespaceOptionContext::tsOptionEncryption() {
  return getRuleContext<MySQLParser::TsOptionEncryptionContext>(0);
}


size_t MySQLParser::TablespaceOptionContext::getRuleIndex() const {
  return MySQLParser::RuleTablespaceOption;
}

void MySQLParser::TablespaceOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTablespaceOption(this);
}

void MySQLParser::TablespaceOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTablespaceOption(this);
}


antlrcpp::Any MySQLParser::TablespaceOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTablespaceOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TablespaceOptionContext* MySQLParser::tablespaceOption() {
  TablespaceOptionContext *_localctx = _tracker.createInstance<TablespaceOptionContext>(_ctx, getState());
  enterRule(_localctx, 136, MySQLParser::RuleTablespaceOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2188);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 162, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2176);
      tsOptionInitialSize();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2177);
      tsOptionAutoextendSize();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2178);
      tsOptionMaxSize();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2179);
      tsOptionExtentSize();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2180);
      tsOptionNodegroup();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2181);
      tsOptionEngine();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2182);
      tsOptionWait();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2183);
      tsOptionComment();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2184);

      if (!(serverVersion >= 50707)) throw FailedPredicateException(this, "serverVersion >= 50707");
      setState(2185);
      tsOptionFileblockSize();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(2186);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(2187);
      tsOptionEncryption();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionInitialSizeContext ------------------------------------------------------------------

MySQLParser::TsOptionInitialSizeContext::TsOptionInitialSizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsOptionInitialSizeContext::INITIAL_SIZE_SYMBOL() {
  return getToken(MySQLParser::INITIAL_SIZE_SYMBOL, 0);
}

MySQLParser::SizeNumberContext* MySQLParser::TsOptionInitialSizeContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode* MySQLParser::TsOptionInitialSizeContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::TsOptionInitialSizeContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionInitialSize;
}

void MySQLParser::TsOptionInitialSizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionInitialSize(this);
}

void MySQLParser::TsOptionInitialSizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionInitialSize(this);
}


antlrcpp::Any MySQLParser::TsOptionInitialSizeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTsOptionInitialSize(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionInitialSizeContext* MySQLParser::tsOptionInitialSize() {
  TsOptionInitialSizeContext *_localctx = _tracker.createInstance<TsOptionInitialSizeContext>(_ctx, getState());
  enterRule(_localctx, 138, MySQLParser::RuleTsOptionInitialSize);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2190);
    match(MySQLParser::INITIAL_SIZE_SYMBOL);
    setState(2192);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 163, _ctx)) {
    case 1: {
      setState(2191);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(2194);
    sizeNumber();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionUndoRedoBufferSizeContext ------------------------------------------------------------------

MySQLParser::TsOptionUndoRedoBufferSizeContext::TsOptionUndoRedoBufferSizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SizeNumberContext* MySQLParser::TsOptionUndoRedoBufferSizeContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode* MySQLParser::TsOptionUndoRedoBufferSizeContext::UNDO_BUFFER_SIZE_SYMBOL() {
  return getToken(MySQLParser::UNDO_BUFFER_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TsOptionUndoRedoBufferSizeContext::REDO_BUFFER_SIZE_SYMBOL() {
  return getToken(MySQLParser::REDO_BUFFER_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TsOptionUndoRedoBufferSizeContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::TsOptionUndoRedoBufferSizeContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionUndoRedoBufferSize;
}

void MySQLParser::TsOptionUndoRedoBufferSizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionUndoRedoBufferSize(this);
}

void MySQLParser::TsOptionUndoRedoBufferSizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionUndoRedoBufferSize(this);
}


antlrcpp::Any MySQLParser::TsOptionUndoRedoBufferSizeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTsOptionUndoRedoBufferSize(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionUndoRedoBufferSizeContext* MySQLParser::tsOptionUndoRedoBufferSize() {
  TsOptionUndoRedoBufferSizeContext *_localctx = _tracker.createInstance<TsOptionUndoRedoBufferSizeContext>(_ctx, getState());
  enterRule(_localctx, 140, MySQLParser::RuleTsOptionUndoRedoBufferSize);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2196);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::REDO_BUFFER_SIZE_SYMBOL || _la == MySQLParser::UNDO_BUFFER_SIZE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2198);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, _ctx)) {
    case 1: {
      setState(2197);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(2200);
    sizeNumber();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionAutoextendSizeContext ------------------------------------------------------------------

MySQLParser::TsOptionAutoextendSizeContext::TsOptionAutoextendSizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsOptionAutoextendSizeContext::AUTOEXTEND_SIZE_SYMBOL() {
  return getToken(MySQLParser::AUTOEXTEND_SIZE_SYMBOL, 0);
}

MySQLParser::SizeNumberContext* MySQLParser::TsOptionAutoextendSizeContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode* MySQLParser::TsOptionAutoextendSizeContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::TsOptionAutoextendSizeContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionAutoextendSize;
}

void MySQLParser::TsOptionAutoextendSizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionAutoextendSize(this);
}

void MySQLParser::TsOptionAutoextendSizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionAutoextendSize(this);
}


antlrcpp::Any MySQLParser::TsOptionAutoextendSizeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTsOptionAutoextendSize(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionAutoextendSizeContext* MySQLParser::tsOptionAutoextendSize() {
  TsOptionAutoextendSizeContext *_localctx = _tracker.createInstance<TsOptionAutoextendSizeContext>(_ctx, getState());
  enterRule(_localctx, 142, MySQLParser::RuleTsOptionAutoextendSize);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2202);
    match(MySQLParser::AUTOEXTEND_SIZE_SYMBOL);
    setState(2204);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx)) {
    case 1: {
      setState(2203);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(2206);
    sizeNumber();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionMaxSizeContext ------------------------------------------------------------------

MySQLParser::TsOptionMaxSizeContext::TsOptionMaxSizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsOptionMaxSizeContext::MAX_SIZE_SYMBOL() {
  return getToken(MySQLParser::MAX_SIZE_SYMBOL, 0);
}

MySQLParser::SizeNumberContext* MySQLParser::TsOptionMaxSizeContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode* MySQLParser::TsOptionMaxSizeContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::TsOptionMaxSizeContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionMaxSize;
}

void MySQLParser::TsOptionMaxSizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionMaxSize(this);
}

void MySQLParser::TsOptionMaxSizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionMaxSize(this);
}


antlrcpp::Any MySQLParser::TsOptionMaxSizeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTsOptionMaxSize(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionMaxSizeContext* MySQLParser::tsOptionMaxSize() {
  TsOptionMaxSizeContext *_localctx = _tracker.createInstance<TsOptionMaxSizeContext>(_ctx, getState());
  enterRule(_localctx, 144, MySQLParser::RuleTsOptionMaxSize);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2208);
    match(MySQLParser::MAX_SIZE_SYMBOL);
    setState(2210);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 166, _ctx)) {
    case 1: {
      setState(2209);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(2212);
    sizeNumber();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionExtentSizeContext ------------------------------------------------------------------

MySQLParser::TsOptionExtentSizeContext::TsOptionExtentSizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsOptionExtentSizeContext::EXTENT_SIZE_SYMBOL() {
  return getToken(MySQLParser::EXTENT_SIZE_SYMBOL, 0);
}

MySQLParser::SizeNumberContext* MySQLParser::TsOptionExtentSizeContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode* MySQLParser::TsOptionExtentSizeContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::TsOptionExtentSizeContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionExtentSize;
}

void MySQLParser::TsOptionExtentSizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionExtentSize(this);
}

void MySQLParser::TsOptionExtentSizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionExtentSize(this);
}


antlrcpp::Any MySQLParser::TsOptionExtentSizeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTsOptionExtentSize(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionExtentSizeContext* MySQLParser::tsOptionExtentSize() {
  TsOptionExtentSizeContext *_localctx = _tracker.createInstance<TsOptionExtentSizeContext>(_ctx, getState());
  enterRule(_localctx, 146, MySQLParser::RuleTsOptionExtentSize);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2214);
    match(MySQLParser::EXTENT_SIZE_SYMBOL);
    setState(2216);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, _ctx)) {
    case 1: {
      setState(2215);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(2218);
    sizeNumber();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionNodegroupContext ------------------------------------------------------------------

MySQLParser::TsOptionNodegroupContext::TsOptionNodegroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsOptionNodegroupContext::NODEGROUP_SYMBOL() {
  return getToken(MySQLParser::NODEGROUP_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::TsOptionNodegroupContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::TsOptionNodegroupContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::TsOptionNodegroupContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionNodegroup;
}

void MySQLParser::TsOptionNodegroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionNodegroup(this);
}

void MySQLParser::TsOptionNodegroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionNodegroup(this);
}


antlrcpp::Any MySQLParser::TsOptionNodegroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTsOptionNodegroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionNodegroupContext* MySQLParser::tsOptionNodegroup() {
  TsOptionNodegroupContext *_localctx = _tracker.createInstance<TsOptionNodegroupContext>(_ctx, getState());
  enterRule(_localctx, 148, MySQLParser::RuleTsOptionNodegroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2220);
    match(MySQLParser::NODEGROUP_SYMBOL);
    setState(2222);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::EQUAL_OPERATOR) {
      setState(2221);
      match(MySQLParser::EQUAL_OPERATOR);
    }
    setState(2224);
    real_ulong_number();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionEngineContext ------------------------------------------------------------------

MySQLParser::TsOptionEngineContext::TsOptionEngineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsOptionEngineContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

MySQLParser::EngineRefContext* MySQLParser::TsOptionEngineContext::engineRef() {
  return getRuleContext<MySQLParser::EngineRefContext>(0);
}

tree::TerminalNode* MySQLParser::TsOptionEngineContext::STORAGE_SYMBOL() {
  return getToken(MySQLParser::STORAGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TsOptionEngineContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::TsOptionEngineContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionEngine;
}

void MySQLParser::TsOptionEngineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionEngine(this);
}

void MySQLParser::TsOptionEngineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionEngine(this);
}


antlrcpp::Any MySQLParser::TsOptionEngineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTsOptionEngine(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionEngineContext* MySQLParser::tsOptionEngine() {
  TsOptionEngineContext *_localctx = _tracker.createInstance<TsOptionEngineContext>(_ctx, getState());
  enterRule(_localctx, 150, MySQLParser::RuleTsOptionEngine);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2227);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::STORAGE_SYMBOL) {
      setState(2226);
      match(MySQLParser::STORAGE_SYMBOL);
    }
    setState(2229);
    match(MySQLParser::ENGINE_SYMBOL);
    setState(2231);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 170, _ctx)) {
    case 1: {
      setState(2230);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(2233);
    engineRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionWaitContext ------------------------------------------------------------------

MySQLParser::TsOptionWaitContext::TsOptionWaitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsOptionWaitContext::WAIT_SYMBOL() {
  return getToken(MySQLParser::WAIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TsOptionWaitContext::NO_WAIT_SYMBOL() {
  return getToken(MySQLParser::NO_WAIT_SYMBOL, 0);
}


size_t MySQLParser::TsOptionWaitContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionWait;
}

void MySQLParser::TsOptionWaitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionWait(this);
}

void MySQLParser::TsOptionWaitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionWait(this);
}


antlrcpp::Any MySQLParser::TsOptionWaitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTsOptionWait(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionWaitContext* MySQLParser::tsOptionWait() {
  TsOptionWaitContext *_localctx = _tracker.createInstance<TsOptionWaitContext>(_ctx, getState());
  enterRule(_localctx, 152, MySQLParser::RuleTsOptionWait);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2235);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::WAIT_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionCommentContext ------------------------------------------------------------------

MySQLParser::TsOptionCommentContext::TsOptionCommentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsOptionCommentContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::TsOptionCommentContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::TsOptionCommentContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::TsOptionCommentContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionComment;
}

void MySQLParser::TsOptionCommentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionComment(this);
}

void MySQLParser::TsOptionCommentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionComment(this);
}


antlrcpp::Any MySQLParser::TsOptionCommentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTsOptionComment(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionCommentContext* MySQLParser::tsOptionComment() {
  TsOptionCommentContext *_localctx = _tracker.createInstance<TsOptionCommentContext>(_ctx, getState());
  enterRule(_localctx, 154, MySQLParser::RuleTsOptionComment);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2237);
    match(MySQLParser::COMMENT_SYMBOL);
    setState(2239);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 171, _ctx)) {
    case 1: {
      setState(2238);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(2241);
    textLiteral();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionFileblockSizeContext ------------------------------------------------------------------

MySQLParser::TsOptionFileblockSizeContext::TsOptionFileblockSizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsOptionFileblockSizeContext::FILE_BLOCK_SIZE_SYMBOL() {
  return getToken(MySQLParser::FILE_BLOCK_SIZE_SYMBOL, 0);
}

MySQLParser::SizeNumberContext* MySQLParser::TsOptionFileblockSizeContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode* MySQLParser::TsOptionFileblockSizeContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::TsOptionFileblockSizeContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionFileblockSize;
}

void MySQLParser::TsOptionFileblockSizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionFileblockSize(this);
}

void MySQLParser::TsOptionFileblockSizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionFileblockSize(this);
}


antlrcpp::Any MySQLParser::TsOptionFileblockSizeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTsOptionFileblockSize(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionFileblockSizeContext* MySQLParser::tsOptionFileblockSize() {
  TsOptionFileblockSizeContext *_localctx = _tracker.createInstance<TsOptionFileblockSizeContext>(_ctx, getState());
  enterRule(_localctx, 156, MySQLParser::RuleTsOptionFileblockSize);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2243);
    match(MySQLParser::FILE_BLOCK_SIZE_SYMBOL);
    setState(2245);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 172, _ctx)) {
    case 1: {
      setState(2244);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(2247);
    sizeNumber();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionEncryptionContext ------------------------------------------------------------------

MySQLParser::TsOptionEncryptionContext::TsOptionEncryptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsOptionEncryptionContext::ENCRYPTION_SYMBOL() {
  return getToken(MySQLParser::ENCRYPTION_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::TsOptionEncryptionContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::TsOptionEncryptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::TsOptionEncryptionContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionEncryption;
}

void MySQLParser::TsOptionEncryptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionEncryption(this);
}

void MySQLParser::TsOptionEncryptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionEncryption(this);
}


antlrcpp::Any MySQLParser::TsOptionEncryptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTsOptionEncryption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionEncryptionContext* MySQLParser::tsOptionEncryption() {
  TsOptionEncryptionContext *_localctx = _tracker.createInstance<TsOptionEncryptionContext>(_ctx, getState());
  enterRule(_localctx, 158, MySQLParser::RuleTsOptionEncryption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2249);
    match(MySQLParser::ENCRYPTION_SYMBOL);
    setState(2251);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 173, _ctx)) {
    case 1: {
      setState(2250);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(2253);
    textStringLiteral();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateViewContext ------------------------------------------------------------------

MySQLParser::CreateViewContext::CreateViewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateViewContext::VIEW_SYMBOL() {
  return getToken(MySQLParser::VIEW_SYMBOL, 0);
}

MySQLParser::ViewNameContext* MySQLParser::CreateViewContext::viewName() {
  return getRuleContext<MySQLParser::ViewNameContext>(0);
}

MySQLParser::ViewTailContext* MySQLParser::CreateViewContext::viewTail() {
  return getRuleContext<MySQLParser::ViewTailContext>(0);
}

MySQLParser::ViewReplaceOrAlgorithmContext* MySQLParser::CreateViewContext::viewReplaceOrAlgorithm() {
  return getRuleContext<MySQLParser::ViewReplaceOrAlgorithmContext>(0);
}

MySQLParser::DefinerClauseContext* MySQLParser::CreateViewContext::definerClause() {
  return getRuleContext<MySQLParser::DefinerClauseContext>(0);
}

MySQLParser::ViewSuidContext* MySQLParser::CreateViewContext::viewSuid() {
  return getRuleContext<MySQLParser::ViewSuidContext>(0);
}


size_t MySQLParser::CreateViewContext::getRuleIndex() const {
  return MySQLParser::RuleCreateView;
}

void MySQLParser::CreateViewContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateView(this);
}

void MySQLParser::CreateViewContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateView(this);
}


antlrcpp::Any MySQLParser::CreateViewContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateView(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateViewContext* MySQLParser::createView() {
  CreateViewContext *_localctx = _tracker.createInstance<CreateViewContext>(_ctx, getState());
  enterRule(_localctx, 160, MySQLParser::RuleCreateView);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2256);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ALGORITHM_SYMBOL || _la == MySQLParser::OR_SYMBOL) {
      setState(2255);
      viewReplaceOrAlgorithm();
    }
    setState(2259);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFINER_SYMBOL) {
      setState(2258);
      definerClause();
    }
    setState(2262);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::SQL_SYMBOL) {
      setState(2261);
      viewSuid();
    }
    setState(2264);
    match(MySQLParser::VIEW_SYMBOL);
    setState(2265);
    viewName();
    setState(2266);
    viewTail();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewReplaceOrAlgorithmContext ------------------------------------------------------------------

MySQLParser::ViewReplaceOrAlgorithmContext::ViewReplaceOrAlgorithmContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ViewReplaceOrAlgorithmContext::OR_SYMBOL() {
  return getToken(MySQLParser::OR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ViewReplaceOrAlgorithmContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

MySQLParser::ViewAlgorithmContext* MySQLParser::ViewReplaceOrAlgorithmContext::viewAlgorithm() {
  return getRuleContext<MySQLParser::ViewAlgorithmContext>(0);
}


size_t MySQLParser::ViewReplaceOrAlgorithmContext::getRuleIndex() const {
  return MySQLParser::RuleViewReplaceOrAlgorithm;
}

void MySQLParser::ViewReplaceOrAlgorithmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewReplaceOrAlgorithm(this);
}

void MySQLParser::ViewReplaceOrAlgorithmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewReplaceOrAlgorithm(this);
}


antlrcpp::Any MySQLParser::ViewReplaceOrAlgorithmContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitViewReplaceOrAlgorithm(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ViewReplaceOrAlgorithmContext* MySQLParser::viewReplaceOrAlgorithm() {
  ViewReplaceOrAlgorithmContext *_localctx = _tracker.createInstance<ViewReplaceOrAlgorithmContext>(_ctx, getState());
  enterRule(_localctx, 162, MySQLParser::RuleViewReplaceOrAlgorithm);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2274);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::OR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2268);
        match(MySQLParser::OR_SYMBOL);
        setState(2269);
        match(MySQLParser::REPLACE_SYMBOL);
        setState(2271);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ALGORITHM_SYMBOL) {
          setState(2270);
          viewAlgorithm();
        }
        break;
      }

      case MySQLParser::ALGORITHM_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2273);
        viewAlgorithm();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewAlgorithmContext ------------------------------------------------------------------

MySQLParser::ViewAlgorithmContext::ViewAlgorithmContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ViewAlgorithmContext::ALGORITHM_SYMBOL() {
  return getToken(MySQLParser::ALGORITHM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ViewAlgorithmContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::ViewAlgorithmContext::UNDEFINED_SYMBOL() {
  return getToken(MySQLParser::UNDEFINED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ViewAlgorithmContext::MERGE_SYMBOL() {
  return getToken(MySQLParser::MERGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ViewAlgorithmContext::TEMPTABLE_SYMBOL() {
  return getToken(MySQLParser::TEMPTABLE_SYMBOL, 0);
}


size_t MySQLParser::ViewAlgorithmContext::getRuleIndex() const {
  return MySQLParser::RuleViewAlgorithm;
}

void MySQLParser::ViewAlgorithmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewAlgorithm(this);
}

void MySQLParser::ViewAlgorithmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewAlgorithm(this);
}


antlrcpp::Any MySQLParser::ViewAlgorithmContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitViewAlgorithm(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ViewAlgorithmContext* MySQLParser::viewAlgorithm() {
  ViewAlgorithmContext *_localctx = _tracker.createInstance<ViewAlgorithmContext>(_ctx, getState());
  enterRule(_localctx, 164, MySQLParser::RuleViewAlgorithm);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2276);
    match(MySQLParser::ALGORITHM_SYMBOL);
    setState(2277);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(2278);
    dynamic_cast<ViewAlgorithmContext *>(_localctx)->algorithm = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MERGE_SYMBOL || _la == MySQLParser::TEMPTABLE_SYMBOL

    || _la == MySQLParser::UNDEFINED_SYMBOL)) {
      dynamic_cast<ViewAlgorithmContext *>(_localctx)->algorithm = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewSuidContext ------------------------------------------------------------------

MySQLParser::ViewSuidContext::ViewSuidContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ViewSuidContext::SQL_SYMBOL() {
  return getToken(MySQLParser::SQL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ViewSuidContext::SECURITY_SYMBOL() {
  return getToken(MySQLParser::SECURITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ViewSuidContext::DEFINER_SYMBOL() {
  return getToken(MySQLParser::DEFINER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ViewSuidContext::INVOKER_SYMBOL() {
  return getToken(MySQLParser::INVOKER_SYMBOL, 0);
}


size_t MySQLParser::ViewSuidContext::getRuleIndex() const {
  return MySQLParser::RuleViewSuid;
}

void MySQLParser::ViewSuidContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewSuid(this);
}

void MySQLParser::ViewSuidContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewSuid(this);
}


antlrcpp::Any MySQLParser::ViewSuidContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitViewSuid(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ViewSuidContext* MySQLParser::viewSuid() {
  ViewSuidContext *_localctx = _tracker.createInstance<ViewSuidContext>(_ctx, getState());
  enterRule(_localctx, 166, MySQLParser::RuleViewSuid);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2280);
    match(MySQLParser::SQL_SYMBOL);
    setState(2281);
    match(MySQLParser::SECURITY_SYMBOL);
    setState(2282);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DEFINER_SYMBOL

    || _la == MySQLParser::INVOKER_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTriggerContext ------------------------------------------------------------------

MySQLParser::CreateTriggerContext::CreateTriggerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateTriggerContext::TRIGGER_SYMBOL() {
  return getToken(MySQLParser::TRIGGER_SYMBOL, 0);
}

MySQLParser::TriggerNameContext* MySQLParser::CreateTriggerContext::triggerName() {
  return getRuleContext<MySQLParser::TriggerNameContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTriggerContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::CreateTriggerContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTriggerContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTriggerContext::EACH_SYMBOL() {
  return getToken(MySQLParser::EACH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTriggerContext::ROW_SYMBOL() {
  return getToken(MySQLParser::ROW_SYMBOL, 0);
}

MySQLParser::CompoundStatementContext* MySQLParser::CreateTriggerContext::compoundStatement() {
  return getRuleContext<MySQLParser::CompoundStatementContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTriggerContext::BEFORE_SYMBOL() {
  return getToken(MySQLParser::BEFORE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTriggerContext::AFTER_SYMBOL() {
  return getToken(MySQLParser::AFTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTriggerContext::INSERT_SYMBOL() {
  return getToken(MySQLParser::INSERT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTriggerContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTriggerContext::DELETE_SYMBOL() {
  return getToken(MySQLParser::DELETE_SYMBOL, 0);
}

MySQLParser::DefinerClauseContext* MySQLParser::CreateTriggerContext::definerClause() {
  return getRuleContext<MySQLParser::DefinerClauseContext>(0);
}

MySQLParser::TriggerFollowsPrecedesClauseContext* MySQLParser::CreateTriggerContext::triggerFollowsPrecedesClause() {
  return getRuleContext<MySQLParser::TriggerFollowsPrecedesClauseContext>(0);
}


size_t MySQLParser::CreateTriggerContext::getRuleIndex() const {
  return MySQLParser::RuleCreateTrigger;
}

void MySQLParser::CreateTriggerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTrigger(this);
}

void MySQLParser::CreateTriggerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTrigger(this);
}


antlrcpp::Any MySQLParser::CreateTriggerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateTrigger(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateTriggerContext* MySQLParser::createTrigger() {
  CreateTriggerContext *_localctx = _tracker.createInstance<CreateTriggerContext>(_ctx, getState());
  enterRule(_localctx, 168, MySQLParser::RuleCreateTrigger);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2285);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFINER_SYMBOL) {
      setState(2284);
      definerClause();
    }
    setState(2287);
    match(MySQLParser::TRIGGER_SYMBOL);
    setState(2288);
    triggerName();
    setState(2289);
    dynamic_cast<CreateTriggerContext *>(_localctx)->timing = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::AFTER_SYMBOL || _la == MySQLParser::BEFORE_SYMBOL)) {
      dynamic_cast<CreateTriggerContext *>(_localctx)->timing = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2290);
    dynamic_cast<CreateTriggerContext *>(_localctx)->event = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DELETE_SYMBOL

    || _la == MySQLParser::INSERT_SYMBOL || _la == MySQLParser::UPDATE_SYMBOL)) {
      dynamic_cast<CreateTriggerContext *>(_localctx)->event = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2291);
    match(MySQLParser::ON_SYMBOL);
    setState(2292);
    tableRef();
    setState(2293);
    match(MySQLParser::FOR_SYMBOL);
    setState(2294);
    match(MySQLParser::EACH_SYMBOL);
    setState(2295);
    match(MySQLParser::ROW_SYMBOL);
    setState(2297);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 180, _ctx)) {
    case 1: {
      setState(2296);
      triggerFollowsPrecedesClause();
      break;
    }

    }
    setState(2299);
    compoundStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerFollowsPrecedesClauseContext ------------------------------------------------------------------

MySQLParser::TriggerFollowsPrecedesClauseContext::TriggerFollowsPrecedesClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextOrIdentifierContext* MySQLParser::TriggerFollowsPrecedesClauseContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::TriggerFollowsPrecedesClauseContext::FOLLOWS_SYMBOL() {
  return getToken(MySQLParser::FOLLOWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TriggerFollowsPrecedesClauseContext::PRECEDES_SYMBOL() {
  return getToken(MySQLParser::PRECEDES_SYMBOL, 0);
}


size_t MySQLParser::TriggerFollowsPrecedesClauseContext::getRuleIndex() const {
  return MySQLParser::RuleTriggerFollowsPrecedesClause;
}

void MySQLParser::TriggerFollowsPrecedesClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTriggerFollowsPrecedesClause(this);
}

void MySQLParser::TriggerFollowsPrecedesClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTriggerFollowsPrecedesClause(this);
}


antlrcpp::Any MySQLParser::TriggerFollowsPrecedesClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTriggerFollowsPrecedesClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TriggerFollowsPrecedesClauseContext* MySQLParser::triggerFollowsPrecedesClause() {
  TriggerFollowsPrecedesClauseContext *_localctx = _tracker.createInstance<TriggerFollowsPrecedesClauseContext>(_ctx, getState());
  enterRule(_localctx, 170, MySQLParser::RuleTriggerFollowsPrecedesClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2301);

    if (!(serverVersion >= 50700)) throw FailedPredicateException(this, "serverVersion >= 50700");
    setState(2302);
    dynamic_cast<TriggerFollowsPrecedesClauseContext *>(_localctx)->ordering = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::FOLLOWS_SYMBOL

    || _la == MySQLParser::PRECEDES_SYMBOL)) {
      dynamic_cast<TriggerFollowsPrecedesClauseContext *>(_localctx)->ordering = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2303);
    textOrIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateEventContext ------------------------------------------------------------------

MySQLParser::CreateEventContext::CreateEventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateEventContext::EVENT_SYMBOL() {
  return getToken(MySQLParser::EVENT_SYMBOL, 0);
}

MySQLParser::EventNameContext* MySQLParser::CreateEventContext::eventName() {
  return getRuleContext<MySQLParser::EventNameContext>(0);
}

std::vector<tree::TerminalNode *> MySQLParser::CreateEventContext::ON_SYMBOL() {
  return getTokens(MySQLParser::ON_SYMBOL);
}

tree::TerminalNode* MySQLParser::CreateEventContext::ON_SYMBOL(size_t i) {
  return getToken(MySQLParser::ON_SYMBOL, i);
}

tree::TerminalNode* MySQLParser::CreateEventContext::SCHEDULE_SYMBOL() {
  return getToken(MySQLParser::SCHEDULE_SYMBOL, 0);
}

MySQLParser::ScheduleContext* MySQLParser::CreateEventContext::schedule() {
  return getRuleContext<MySQLParser::ScheduleContext>(0);
}

tree::TerminalNode* MySQLParser::CreateEventContext::DO_SYMBOL() {
  return getToken(MySQLParser::DO_SYMBOL, 0);
}

MySQLParser::CompoundStatementContext* MySQLParser::CreateEventContext::compoundStatement() {
  return getRuleContext<MySQLParser::CompoundStatementContext>(0);
}

MySQLParser::DefinerClauseContext* MySQLParser::CreateEventContext::definerClause() {
  return getRuleContext<MySQLParser::DefinerClauseContext>(0);
}

MySQLParser::IfNotExistsContext* MySQLParser::CreateEventContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}

tree::TerminalNode* MySQLParser::CreateEventContext::COMPLETION_SYMBOL() {
  return getToken(MySQLParser::COMPLETION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateEventContext::PRESERVE_SYMBOL() {
  return getToken(MySQLParser::PRESERVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateEventContext::ENABLE_SYMBOL() {
  return getToken(MySQLParser::ENABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateEventContext::DISABLE_SYMBOL() {
  return getToken(MySQLParser::DISABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateEventContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::CreateEventContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::CreateEventContext::NOT_SYMBOL() {
  return getToken(MySQLParser::NOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateEventContext::SLAVE_SYMBOL() {
  return getToken(MySQLParser::SLAVE_SYMBOL, 0);
}


size_t MySQLParser::CreateEventContext::getRuleIndex() const {
  return MySQLParser::RuleCreateEvent;
}

void MySQLParser::CreateEventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateEvent(this);
}

void MySQLParser::CreateEventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateEvent(this);
}


antlrcpp::Any MySQLParser::CreateEventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateEvent(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateEventContext* MySQLParser::createEvent() {
  CreateEventContext *_localctx = _tracker.createInstance<CreateEventContext>(_ctx, getState());
  enterRule(_localctx, 172, MySQLParser::RuleCreateEvent);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2306);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFINER_SYMBOL) {
      setState(2305);
      definerClause();
    }
    setState(2308);
    match(MySQLParser::EVENT_SYMBOL);
    setState(2310);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 182, _ctx)) {
    case 1: {
      setState(2309);
      ifNotExists();
      break;
    }

    }
    setState(2312);
    eventName();
    setState(2313);
    match(MySQLParser::ON_SYMBOL);
    setState(2314);
    match(MySQLParser::SCHEDULE_SYMBOL);
    setState(2315);
    schedule();
    setState(2322);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ON_SYMBOL) {
      setState(2316);
      match(MySQLParser::ON_SYMBOL);
      setState(2317);
      match(MySQLParser::COMPLETION_SYMBOL);
      setState(2319);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::NOT_SYMBOL) {
        setState(2318);
        match(MySQLParser::NOT_SYMBOL);
      }
      setState(2321);
      match(MySQLParser::PRESERVE_SYMBOL);
    }
    setState(2330);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ENABLE_SYMBOL: {
        setState(2324);
        match(MySQLParser::ENABLE_SYMBOL);
        break;
      }

      case MySQLParser::DISABLE_SYMBOL: {
        setState(2325);
        match(MySQLParser::DISABLE_SYMBOL);
        setState(2328);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ON_SYMBOL) {
          setState(2326);
          match(MySQLParser::ON_SYMBOL);
          setState(2327);
          match(MySQLParser::SLAVE_SYMBOL);
        }
        break;
      }

      case MySQLParser::COMMENT_SYMBOL:
      case MySQLParser::DO_SYMBOL: {
        break;
      }

    default:
      break;
    }
    setState(2334);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::COMMENT_SYMBOL) {
      setState(2332);
      match(MySQLParser::COMMENT_SYMBOL);
      setState(2333);
      textLiteral();
    }
    setState(2336);
    match(MySQLParser::DO_SYMBOL);
    setState(2337);
    compoundStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateRoleContext ------------------------------------------------------------------

MySQLParser::CreateRoleContext::CreateRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateRoleContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

MySQLParser::RoleListContext* MySQLParser::CreateRoleContext::roleList() {
  return getRuleContext<MySQLParser::RoleListContext>(0);
}

MySQLParser::IfNotExistsContext* MySQLParser::CreateRoleContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}


size_t MySQLParser::CreateRoleContext::getRuleIndex() const {
  return MySQLParser::RuleCreateRole;
}

void MySQLParser::CreateRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateRole(this);
}

void MySQLParser::CreateRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateRole(this);
}


antlrcpp::Any MySQLParser::CreateRoleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateRole(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateRoleContext* MySQLParser::createRole() {
  CreateRoleContext *_localctx = _tracker.createInstance<CreateRoleContext>(_ctx, getState());
  enterRule(_localctx, 174, MySQLParser::RuleCreateRole);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2339);
    match(MySQLParser::ROLE_SYMBOL);
    setState(2341);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 188, _ctx)) {
    case 1: {
      setState(2340);
      ifNotExists();
      break;
    }

    }
    setState(2343);
    roleList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateSpatialReferenceContext ------------------------------------------------------------------

MySQLParser::CreateSpatialReferenceContext::CreateSpatialReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateSpatialReferenceContext::OR_SYMBOL() {
  return getToken(MySQLParser::OR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateSpatialReferenceContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateSpatialReferenceContext::SPATIAL_SYMBOL() {
  return getToken(MySQLParser::SPATIAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateSpatialReferenceContext::REFERENCE_SYMBOL() {
  return getToken(MySQLParser::REFERENCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateSpatialReferenceContext::SYSTEM_SYMBOL() {
  return getToken(MySQLParser::SYSTEM_SYMBOL, 0);
}

MySQLParser::Real_ulonglong_numberContext* MySQLParser::CreateSpatialReferenceContext::real_ulonglong_number() {
  return getRuleContext<MySQLParser::Real_ulonglong_numberContext>(0);
}

std::vector<MySQLParser::SrsAttributeContext *> MySQLParser::CreateSpatialReferenceContext::srsAttribute() {
  return getRuleContexts<MySQLParser::SrsAttributeContext>();
}

MySQLParser::SrsAttributeContext* MySQLParser::CreateSpatialReferenceContext::srsAttribute(size_t i) {
  return getRuleContext<MySQLParser::SrsAttributeContext>(i);
}

MySQLParser::IfNotExistsContext* MySQLParser::CreateSpatialReferenceContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}


size_t MySQLParser::CreateSpatialReferenceContext::getRuleIndex() const {
  return MySQLParser::RuleCreateSpatialReference;
}

void MySQLParser::CreateSpatialReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateSpatialReference(this);
}

void MySQLParser::CreateSpatialReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateSpatialReference(this);
}


antlrcpp::Any MySQLParser::CreateSpatialReferenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateSpatialReference(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateSpatialReferenceContext* MySQLParser::createSpatialReference() {
  CreateSpatialReferenceContext *_localctx = _tracker.createInstance<CreateSpatialReferenceContext>(_ctx, getState());
  enterRule(_localctx, 176, MySQLParser::RuleCreateSpatialReference);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2370);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::OR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2345);
        match(MySQLParser::OR_SYMBOL);
        setState(2346);
        match(MySQLParser::REPLACE_SYMBOL);
        setState(2347);
        match(MySQLParser::SPATIAL_SYMBOL);
        setState(2348);
        match(MySQLParser::REFERENCE_SYMBOL);
        setState(2349);
        match(MySQLParser::SYSTEM_SYMBOL);
        setState(2350);
        real_ulonglong_number();
        setState(2354);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::NAME_SYMBOL || ((((_la - 746) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 746)) & ((1ULL << (MySQLParser::DEFINITION_SYMBOL - 746))
          | (1ULL << (MySQLParser::DESCRIPTION_SYMBOL - 746))
          | (1ULL << (MySQLParser::ORGANIZATION_SYMBOL - 746)))) != 0)) {
          setState(2351);
          srsAttribute();
          setState(2356);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MySQLParser::SPATIAL_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2357);
        match(MySQLParser::SPATIAL_SYMBOL);
        setState(2358);
        match(MySQLParser::REFERENCE_SYMBOL);
        setState(2359);
        match(MySQLParser::SYSTEM_SYMBOL);
        setState(2361);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::IF_SYMBOL) {
          setState(2360);
          ifNotExists();
        }
        setState(2363);
        real_ulonglong_number();
        setState(2367);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::NAME_SYMBOL || ((((_la - 746) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 746)) & ((1ULL << (MySQLParser::DEFINITION_SYMBOL - 746))
          | (1ULL << (MySQLParser::DESCRIPTION_SYMBOL - 746))
          | (1ULL << (MySQLParser::ORGANIZATION_SYMBOL - 746)))) != 0)) {
          setState(2364);
          srsAttribute();
          setState(2369);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SrsAttributeContext ------------------------------------------------------------------

MySQLParser::SrsAttributeContext::SrsAttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SrsAttributeContext::NAME_SYMBOL() {
  return getToken(MySQLParser::NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SrsAttributeContext::TEXT_SYMBOL() {
  return getToken(MySQLParser::TEXT_SYMBOL, 0);
}

MySQLParser::TextStringNoLinebreakContext* MySQLParser::SrsAttributeContext::textStringNoLinebreak() {
  return getRuleContext<MySQLParser::TextStringNoLinebreakContext>(0);
}

tree::TerminalNode* MySQLParser::SrsAttributeContext::DEFINITION_SYMBOL() {
  return getToken(MySQLParser::DEFINITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SrsAttributeContext::ORGANIZATION_SYMBOL() {
  return getToken(MySQLParser::ORGANIZATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SrsAttributeContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SrsAttributeContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::Real_ulonglong_numberContext* MySQLParser::SrsAttributeContext::real_ulonglong_number() {
  return getRuleContext<MySQLParser::Real_ulonglong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::SrsAttributeContext::DESCRIPTION_SYMBOL() {
  return getToken(MySQLParser::DESCRIPTION_SYMBOL, 0);
}


size_t MySQLParser::SrsAttributeContext::getRuleIndex() const {
  return MySQLParser::RuleSrsAttribute;
}

void MySQLParser::SrsAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSrsAttribute(this);
}

void MySQLParser::SrsAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSrsAttribute(this);
}


antlrcpp::Any MySQLParser::SrsAttributeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSrsAttribute(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SrsAttributeContext* MySQLParser::srsAttribute() {
  SrsAttributeContext *_localctx = _tracker.createInstance<SrsAttributeContext>(_ctx, getState());
  enterRule(_localctx, 178, MySQLParser::RuleSrsAttribute);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2387);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::NAME_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2372);
        match(MySQLParser::NAME_SYMBOL);
        setState(2373);
        match(MySQLParser::TEXT_SYMBOL);
        setState(2374);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::DEFINITION_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2375);
        match(MySQLParser::DEFINITION_SYMBOL);
        setState(2376);
        match(MySQLParser::TEXT_SYMBOL);
        setState(2377);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::ORGANIZATION_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(2378);
        match(MySQLParser::ORGANIZATION_SYMBOL);
        setState(2379);
        textStringNoLinebreak();
        setState(2380);
        match(MySQLParser::IDENTIFIED_SYMBOL);
        setState(2381);
        match(MySQLParser::BY_SYMBOL);
        setState(2382);
        real_ulonglong_number();
        break;
      }

      case MySQLParser::DESCRIPTION_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(2384);
        match(MySQLParser::DESCRIPTION_SYMBOL);
        setState(2385);
        match(MySQLParser::TEXT_SYMBOL);
        setState(2386);
        textStringNoLinebreak();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropStatementContext ------------------------------------------------------------------

MySQLParser::DropStatementContext::DropStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropStatementContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

MySQLParser::DropDatabaseContext* MySQLParser::DropStatementContext::dropDatabase() {
  return getRuleContext<MySQLParser::DropDatabaseContext>(0);
}

MySQLParser::DropEventContext* MySQLParser::DropStatementContext::dropEvent() {
  return getRuleContext<MySQLParser::DropEventContext>(0);
}

MySQLParser::DropFunctionContext* MySQLParser::DropStatementContext::dropFunction() {
  return getRuleContext<MySQLParser::DropFunctionContext>(0);
}

MySQLParser::DropProcedureContext* MySQLParser::DropStatementContext::dropProcedure() {
  return getRuleContext<MySQLParser::DropProcedureContext>(0);
}

MySQLParser::DropIndexContext* MySQLParser::DropStatementContext::dropIndex() {
  return getRuleContext<MySQLParser::DropIndexContext>(0);
}

MySQLParser::DropLogfileGroupContext* MySQLParser::DropStatementContext::dropLogfileGroup() {
  return getRuleContext<MySQLParser::DropLogfileGroupContext>(0);
}

MySQLParser::DropServerContext* MySQLParser::DropStatementContext::dropServer() {
  return getRuleContext<MySQLParser::DropServerContext>(0);
}

MySQLParser::DropTableContext* MySQLParser::DropStatementContext::dropTable() {
  return getRuleContext<MySQLParser::DropTableContext>(0);
}

MySQLParser::DropTableSpaceContext* MySQLParser::DropStatementContext::dropTableSpace() {
  return getRuleContext<MySQLParser::DropTableSpaceContext>(0);
}

MySQLParser::DropTriggerContext* MySQLParser::DropStatementContext::dropTrigger() {
  return getRuleContext<MySQLParser::DropTriggerContext>(0);
}

MySQLParser::DropViewContext* MySQLParser::DropStatementContext::dropView() {
  return getRuleContext<MySQLParser::DropViewContext>(0);
}

MySQLParser::DropRoleContext* MySQLParser::DropStatementContext::dropRole() {
  return getRuleContext<MySQLParser::DropRoleContext>(0);
}

MySQLParser::DropSpatialReferenceContext* MySQLParser::DropStatementContext::dropSpatialReference() {
  return getRuleContext<MySQLParser::DropSpatialReferenceContext>(0);
}

MySQLParser::DropUndoTablespaceContext* MySQLParser::DropStatementContext::dropUndoTablespace() {
  return getRuleContext<MySQLParser::DropUndoTablespaceContext>(0);
}


size_t MySQLParser::DropStatementContext::getRuleIndex() const {
  return MySQLParser::RuleDropStatement;
}

void MySQLParser::DropStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropStatement(this);
}

void MySQLParser::DropStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropStatement(this);
}


antlrcpp::Any MySQLParser::DropStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDropStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropStatementContext* MySQLParser::dropStatement() {
  DropStatementContext *_localctx = _tracker.createInstance<DropStatementContext>(_ctx, getState());
  enterRule(_localctx, 180, MySQLParser::RuleDropStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2389);
    match(MySQLParser::DROP_SYMBOL);
    setState(2407);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 194, _ctx)) {
    case 1: {
      setState(2390);
      dropDatabase();
      break;
    }

    case 2: {
      setState(2391);
      dropEvent();
      break;
    }

    case 3: {
      setState(2392);
      dropFunction();
      break;
    }

    case 4: {
      setState(2393);
      dropProcedure();
      break;
    }

    case 5: {
      setState(2394);
      dropIndex();
      break;
    }

    case 6: {
      setState(2395);
      dropLogfileGroup();
      break;
    }

    case 7: {
      setState(2396);
      dropServer();
      break;
    }

    case 8: {
      setState(2397);
      dropTable();
      break;
    }

    case 9: {
      setState(2398);
      dropTableSpace();
      break;
    }

    case 10: {
      setState(2399);
      dropTrigger();
      break;
    }

    case 11: {
      setState(2400);
      dropView();
      break;
    }

    case 12: {
      setState(2401);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(2402);
      dropRole();
      break;
    }

    case 13: {
      setState(2403);

      if (!(serverVersion >= 80011)) throw FailedPredicateException(this, "serverVersion >= 80011");
      setState(2404);
      dropSpatialReference();
      break;
    }

    case 14: {
      setState(2405);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(2406);
      dropUndoTablespace();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropDatabaseContext ------------------------------------------------------------------

MySQLParser::DropDatabaseContext::DropDatabaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropDatabaseContext::DATABASE_SYMBOL() {
  return getToken(MySQLParser::DATABASE_SYMBOL, 0);
}

MySQLParser::SchemaRefContext* MySQLParser::DropDatabaseContext::schemaRef() {
  return getRuleContext<MySQLParser::SchemaRefContext>(0);
}

MySQLParser::IfExistsContext* MySQLParser::DropDatabaseContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}


size_t MySQLParser::DropDatabaseContext::getRuleIndex() const {
  return MySQLParser::RuleDropDatabase;
}

void MySQLParser::DropDatabaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropDatabase(this);
}

void MySQLParser::DropDatabaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropDatabase(this);
}


antlrcpp::Any MySQLParser::DropDatabaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDropDatabase(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropDatabaseContext* MySQLParser::dropDatabase() {
  DropDatabaseContext *_localctx = _tracker.createInstance<DropDatabaseContext>(_ctx, getState());
  enterRule(_localctx, 182, MySQLParser::RuleDropDatabase);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2409);
    match(MySQLParser::DATABASE_SYMBOL);
    setState(2411);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 195, _ctx)) {
    case 1: {
      setState(2410);
      ifExists();
      break;
    }

    }
    setState(2413);
    schemaRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropEventContext ------------------------------------------------------------------

MySQLParser::DropEventContext::DropEventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropEventContext::EVENT_SYMBOL() {
  return getToken(MySQLParser::EVENT_SYMBOL, 0);
}

MySQLParser::EventRefContext* MySQLParser::DropEventContext::eventRef() {
  return getRuleContext<MySQLParser::EventRefContext>(0);
}

MySQLParser::IfExistsContext* MySQLParser::DropEventContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}


size_t MySQLParser::DropEventContext::getRuleIndex() const {
  return MySQLParser::RuleDropEvent;
}

void MySQLParser::DropEventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropEvent(this);
}

void MySQLParser::DropEventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropEvent(this);
}


antlrcpp::Any MySQLParser::DropEventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDropEvent(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropEventContext* MySQLParser::dropEvent() {
  DropEventContext *_localctx = _tracker.createInstance<DropEventContext>(_ctx, getState());
  enterRule(_localctx, 184, MySQLParser::RuleDropEvent);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2415);
    match(MySQLParser::EVENT_SYMBOL);
    setState(2417);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 196, _ctx)) {
    case 1: {
      setState(2416);
      ifExists();
      break;
    }

    }
    setState(2419);
    eventRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropFunctionContext ------------------------------------------------------------------

MySQLParser::DropFunctionContext::DropFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropFunctionContext::FUNCTION_SYMBOL() {
  return getToken(MySQLParser::FUNCTION_SYMBOL, 0);
}

MySQLParser::FunctionRefContext* MySQLParser::DropFunctionContext::functionRef() {
  return getRuleContext<MySQLParser::FunctionRefContext>(0);
}

MySQLParser::IfExistsContext* MySQLParser::DropFunctionContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}


size_t MySQLParser::DropFunctionContext::getRuleIndex() const {
  return MySQLParser::RuleDropFunction;
}

void MySQLParser::DropFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropFunction(this);
}

void MySQLParser::DropFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropFunction(this);
}


antlrcpp::Any MySQLParser::DropFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDropFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropFunctionContext* MySQLParser::dropFunction() {
  DropFunctionContext *_localctx = _tracker.createInstance<DropFunctionContext>(_ctx, getState());
  enterRule(_localctx, 186, MySQLParser::RuleDropFunction);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2421);
    match(MySQLParser::FUNCTION_SYMBOL);
    setState(2423);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 197, _ctx)) {
    case 1: {
      setState(2422);
      ifExists();
      break;
    }

    }
    setState(2425);
    functionRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropProcedureContext ------------------------------------------------------------------

MySQLParser::DropProcedureContext::DropProcedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropProcedureContext::PROCEDURE_SYMBOL() {
  return getToken(MySQLParser::PROCEDURE_SYMBOL, 0);
}

MySQLParser::ProcedureRefContext* MySQLParser::DropProcedureContext::procedureRef() {
  return getRuleContext<MySQLParser::ProcedureRefContext>(0);
}

MySQLParser::IfExistsContext* MySQLParser::DropProcedureContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}


size_t MySQLParser::DropProcedureContext::getRuleIndex() const {
  return MySQLParser::RuleDropProcedure;
}

void MySQLParser::DropProcedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropProcedure(this);
}

void MySQLParser::DropProcedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropProcedure(this);
}


antlrcpp::Any MySQLParser::DropProcedureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDropProcedure(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropProcedureContext* MySQLParser::dropProcedure() {
  DropProcedureContext *_localctx = _tracker.createInstance<DropProcedureContext>(_ctx, getState());
  enterRule(_localctx, 188, MySQLParser::RuleDropProcedure);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2427);
    match(MySQLParser::PROCEDURE_SYMBOL);
    setState(2429);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 198, _ctx)) {
    case 1: {
      setState(2428);
      ifExists();
      break;
    }

    }
    setState(2431);
    procedureRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropIndexContext ------------------------------------------------------------------

MySQLParser::DropIndexContext::DropIndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IndexRefContext* MySQLParser::DropIndexContext::indexRef() {
  return getRuleContext<MySQLParser::IndexRefContext>(0);
}

tree::TerminalNode* MySQLParser::DropIndexContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::DropIndexContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode* MySQLParser::DropIndexContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

MySQLParser::OnlineOptionContext* MySQLParser::DropIndexContext::onlineOption() {
  return getRuleContext<MySQLParser::OnlineOptionContext>(0);
}

MySQLParser::IndexLockAndAlgorithmContext* MySQLParser::DropIndexContext::indexLockAndAlgorithm() {
  return getRuleContext<MySQLParser::IndexLockAndAlgorithmContext>(0);
}


size_t MySQLParser::DropIndexContext::getRuleIndex() const {
  return MySQLParser::RuleDropIndex;
}

void MySQLParser::DropIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropIndex(this);
}

void MySQLParser::DropIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropIndex(this);
}


antlrcpp::Any MySQLParser::DropIndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDropIndex(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropIndexContext* MySQLParser::dropIndex() {
  DropIndexContext *_localctx = _tracker.createInstance<DropIndexContext>(_ctx, getState());
  enterRule(_localctx, 190, MySQLParser::RuleDropIndex);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2434);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 199, _ctx)) {
    case 1: {
      setState(2433);
      onlineOption();
      break;
    }

    }
    setState(2436);
    dynamic_cast<DropIndexContext *>(_localctx)->type = match(MySQLParser::INDEX_SYMBOL);
    setState(2437);
    indexRef();
    setState(2438);
    match(MySQLParser::ON_SYMBOL);
    setState(2439);
    tableRef();
    setState(2441);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 200, _ctx)) {
    case 1: {
      setState(2440);
      indexLockAndAlgorithm();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropLogfileGroupContext ------------------------------------------------------------------

MySQLParser::DropLogfileGroupContext::DropLogfileGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropLogfileGroupContext::LOGFILE_SYMBOL() {
  return getToken(MySQLParser::LOGFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DropLogfileGroupContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::LogfileGroupRefContext* MySQLParser::DropLogfileGroupContext::logfileGroupRef() {
  return getRuleContext<MySQLParser::LogfileGroupRefContext>(0);
}

std::vector<MySQLParser::DropLogfileGroupOptionContext *> MySQLParser::DropLogfileGroupContext::dropLogfileGroupOption() {
  return getRuleContexts<MySQLParser::DropLogfileGroupOptionContext>();
}

MySQLParser::DropLogfileGroupOptionContext* MySQLParser::DropLogfileGroupContext::dropLogfileGroupOption(size_t i) {
  return getRuleContext<MySQLParser::DropLogfileGroupOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::DropLogfileGroupContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::DropLogfileGroupContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::DropLogfileGroupContext::getRuleIndex() const {
  return MySQLParser::RuleDropLogfileGroup;
}

void MySQLParser::DropLogfileGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropLogfileGroup(this);
}

void MySQLParser::DropLogfileGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropLogfileGroup(this);
}


antlrcpp::Any MySQLParser::DropLogfileGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDropLogfileGroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropLogfileGroupContext* MySQLParser::dropLogfileGroup() {
  DropLogfileGroupContext *_localctx = _tracker.createInstance<DropLogfileGroupContext>(_ctx, getState());
  enterRule(_localctx, 192, MySQLParser::RuleDropLogfileGroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2443);
    match(MySQLParser::LOGFILE_SYMBOL);
    setState(2444);
    match(MySQLParser::GROUP_SYMBOL);
    setState(2445);
    logfileGroupRef();
    setState(2456);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL

    || _la == MySQLParser::WAIT_SYMBOL) {
      setState(2446);
      dropLogfileGroupOption();
      setState(2453);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL

      || _la == MySQLParser::WAIT_SYMBOL || _la == MySQLParser::COMMA_SYMBOL) {
        setState(2448);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::COMMA_SYMBOL) {
          setState(2447);
          match(MySQLParser::COMMA_SYMBOL);
        }
        setState(2450);
        dropLogfileGroupOption();
        setState(2455);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropLogfileGroupOptionContext ------------------------------------------------------------------

MySQLParser::DropLogfileGroupOptionContext::DropLogfileGroupOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TsOptionWaitContext* MySQLParser::DropLogfileGroupOptionContext::tsOptionWait() {
  return getRuleContext<MySQLParser::TsOptionWaitContext>(0);
}

MySQLParser::TsOptionEngineContext* MySQLParser::DropLogfileGroupOptionContext::tsOptionEngine() {
  return getRuleContext<MySQLParser::TsOptionEngineContext>(0);
}


size_t MySQLParser::DropLogfileGroupOptionContext::getRuleIndex() const {
  return MySQLParser::RuleDropLogfileGroupOption;
}

void MySQLParser::DropLogfileGroupOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropLogfileGroupOption(this);
}

void MySQLParser::DropLogfileGroupOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropLogfileGroupOption(this);
}


antlrcpp::Any MySQLParser::DropLogfileGroupOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDropLogfileGroupOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropLogfileGroupOptionContext* MySQLParser::dropLogfileGroupOption() {
  DropLogfileGroupOptionContext *_localctx = _tracker.createInstance<DropLogfileGroupOptionContext>(_ctx, getState());
  enterRule(_localctx, 194, MySQLParser::RuleDropLogfileGroupOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2460);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::NO_WAIT_SYMBOL:
      case MySQLParser::WAIT_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2458);
        tsOptionWait();
        break;
      }

      case MySQLParser::ENGINE_SYMBOL:
      case MySQLParser::STORAGE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2459);
        tsOptionEngine();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropServerContext ------------------------------------------------------------------

MySQLParser::DropServerContext::DropServerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropServerContext::SERVER_SYMBOL() {
  return getToken(MySQLParser::SERVER_SYMBOL, 0);
}

MySQLParser::ServerRefContext* MySQLParser::DropServerContext::serverRef() {
  return getRuleContext<MySQLParser::ServerRefContext>(0);
}

MySQLParser::IfExistsContext* MySQLParser::DropServerContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}


size_t MySQLParser::DropServerContext::getRuleIndex() const {
  return MySQLParser::RuleDropServer;
}

void MySQLParser::DropServerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropServer(this);
}

void MySQLParser::DropServerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropServer(this);
}


antlrcpp::Any MySQLParser::DropServerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDropServer(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropServerContext* MySQLParser::dropServer() {
  DropServerContext *_localctx = _tracker.createInstance<DropServerContext>(_ctx, getState());
  enterRule(_localctx, 196, MySQLParser::RuleDropServer);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2462);
    match(MySQLParser::SERVER_SYMBOL);
    setState(2464);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 205, _ctx)) {
    case 1: {
      setState(2463);
      ifExists();
      break;
    }

    }
    setState(2466);
    serverRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropTableContext ------------------------------------------------------------------

MySQLParser::DropTableContext::DropTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefListContext* MySQLParser::DropTableContext::tableRefList() {
  return getRuleContext<MySQLParser::TableRefListContext>(0);
}

tree::TerminalNode* MySQLParser::DropTableContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DropTableContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DropTableContext::TEMPORARY_SYMBOL() {
  return getToken(MySQLParser::TEMPORARY_SYMBOL, 0);
}

MySQLParser::IfExistsContext* MySQLParser::DropTableContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}

tree::TerminalNode* MySQLParser::DropTableContext::RESTRICT_SYMBOL() {
  return getToken(MySQLParser::RESTRICT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DropTableContext::CASCADE_SYMBOL() {
  return getToken(MySQLParser::CASCADE_SYMBOL, 0);
}


size_t MySQLParser::DropTableContext::getRuleIndex() const {
  return MySQLParser::RuleDropTable;
}

void MySQLParser::DropTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropTable(this);
}

void MySQLParser::DropTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropTable(this);
}


antlrcpp::Any MySQLParser::DropTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDropTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropTableContext* MySQLParser::dropTable() {
  DropTableContext *_localctx = _tracker.createInstance<DropTableContext>(_ctx, getState());
  enterRule(_localctx, 198, MySQLParser::RuleDropTable);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2469);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::TEMPORARY_SYMBOL) {
      setState(2468);
      match(MySQLParser::TEMPORARY_SYMBOL);
    }
    setState(2471);
    dynamic_cast<DropTableContext *>(_localctx)->type = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::TABLES_SYMBOL || _la == MySQLParser::TABLE_SYMBOL)) {
      dynamic_cast<DropTableContext *>(_localctx)->type = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2473);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 207, _ctx)) {
    case 1: {
      setState(2472);
      ifExists();
      break;
    }

    }
    setState(2475);
    tableRefList();
    setState(2477);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::CASCADE_SYMBOL || _la == MySQLParser::RESTRICT_SYMBOL) {
      setState(2476);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::CASCADE_SYMBOL || _la == MySQLParser::RESTRICT_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropTableSpaceContext ------------------------------------------------------------------

MySQLParser::DropTableSpaceContext::DropTableSpaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropTableSpaceContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

MySQLParser::TablespaceRefContext* MySQLParser::DropTableSpaceContext::tablespaceRef() {
  return getRuleContext<MySQLParser::TablespaceRefContext>(0);
}

std::vector<MySQLParser::DropLogfileGroupOptionContext *> MySQLParser::DropTableSpaceContext::dropLogfileGroupOption() {
  return getRuleContexts<MySQLParser::DropLogfileGroupOptionContext>();
}

MySQLParser::DropLogfileGroupOptionContext* MySQLParser::DropTableSpaceContext::dropLogfileGroupOption(size_t i) {
  return getRuleContext<MySQLParser::DropLogfileGroupOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::DropTableSpaceContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::DropTableSpaceContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::DropTableSpaceContext::getRuleIndex() const {
  return MySQLParser::RuleDropTableSpace;
}

void MySQLParser::DropTableSpaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropTableSpace(this);
}

void MySQLParser::DropTableSpaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropTableSpace(this);
}


antlrcpp::Any MySQLParser::DropTableSpaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDropTableSpace(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropTableSpaceContext* MySQLParser::dropTableSpace() {
  DropTableSpaceContext *_localctx = _tracker.createInstance<DropTableSpaceContext>(_ctx, getState());
  enterRule(_localctx, 200, MySQLParser::RuleDropTableSpace);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2479);
    match(MySQLParser::TABLESPACE_SYMBOL);
    setState(2480);
    tablespaceRef();
    setState(2491);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL

    || _la == MySQLParser::WAIT_SYMBOL) {
      setState(2481);
      dropLogfileGroupOption();
      setState(2488);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL

      || _la == MySQLParser::WAIT_SYMBOL || _la == MySQLParser::COMMA_SYMBOL) {
        setState(2483);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::COMMA_SYMBOL) {
          setState(2482);
          match(MySQLParser::COMMA_SYMBOL);
        }
        setState(2485);
        dropLogfileGroupOption();
        setState(2490);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropTriggerContext ------------------------------------------------------------------

MySQLParser::DropTriggerContext::DropTriggerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropTriggerContext::TRIGGER_SYMBOL() {
  return getToken(MySQLParser::TRIGGER_SYMBOL, 0);
}

MySQLParser::TriggerRefContext* MySQLParser::DropTriggerContext::triggerRef() {
  return getRuleContext<MySQLParser::TriggerRefContext>(0);
}

MySQLParser::IfExistsContext* MySQLParser::DropTriggerContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}


size_t MySQLParser::DropTriggerContext::getRuleIndex() const {
  return MySQLParser::RuleDropTrigger;
}

void MySQLParser::DropTriggerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropTrigger(this);
}

void MySQLParser::DropTriggerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropTrigger(this);
}


antlrcpp::Any MySQLParser::DropTriggerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDropTrigger(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropTriggerContext* MySQLParser::dropTrigger() {
  DropTriggerContext *_localctx = _tracker.createInstance<DropTriggerContext>(_ctx, getState());
  enterRule(_localctx, 202, MySQLParser::RuleDropTrigger);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2493);
    match(MySQLParser::TRIGGER_SYMBOL);
    setState(2495);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 212, _ctx)) {
    case 1: {
      setState(2494);
      ifExists();
      break;
    }

    }
    setState(2497);
    triggerRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropViewContext ------------------------------------------------------------------

MySQLParser::DropViewContext::DropViewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropViewContext::VIEW_SYMBOL() {
  return getToken(MySQLParser::VIEW_SYMBOL, 0);
}

MySQLParser::ViewRefListContext* MySQLParser::DropViewContext::viewRefList() {
  return getRuleContext<MySQLParser::ViewRefListContext>(0);
}

MySQLParser::IfExistsContext* MySQLParser::DropViewContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}

tree::TerminalNode* MySQLParser::DropViewContext::RESTRICT_SYMBOL() {
  return getToken(MySQLParser::RESTRICT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DropViewContext::CASCADE_SYMBOL() {
  return getToken(MySQLParser::CASCADE_SYMBOL, 0);
}


size_t MySQLParser::DropViewContext::getRuleIndex() const {
  return MySQLParser::RuleDropView;
}

void MySQLParser::DropViewContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropView(this);
}

void MySQLParser::DropViewContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropView(this);
}


antlrcpp::Any MySQLParser::DropViewContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDropView(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropViewContext* MySQLParser::dropView() {
  DropViewContext *_localctx = _tracker.createInstance<DropViewContext>(_ctx, getState());
  enterRule(_localctx, 204, MySQLParser::RuleDropView);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2499);
    match(MySQLParser::VIEW_SYMBOL);
    setState(2501);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 213, _ctx)) {
    case 1: {
      setState(2500);
      ifExists();
      break;
    }

    }
    setState(2503);
    viewRefList();
    setState(2505);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::CASCADE_SYMBOL || _la == MySQLParser::RESTRICT_SYMBOL) {
      setState(2504);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::CASCADE_SYMBOL || _la == MySQLParser::RESTRICT_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropRoleContext ------------------------------------------------------------------

MySQLParser::DropRoleContext::DropRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropRoleContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

MySQLParser::RoleListContext* MySQLParser::DropRoleContext::roleList() {
  return getRuleContext<MySQLParser::RoleListContext>(0);
}

MySQLParser::IfExistsContext* MySQLParser::DropRoleContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}


size_t MySQLParser::DropRoleContext::getRuleIndex() const {
  return MySQLParser::RuleDropRole;
}

void MySQLParser::DropRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropRole(this);
}

void MySQLParser::DropRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropRole(this);
}


antlrcpp::Any MySQLParser::DropRoleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDropRole(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropRoleContext* MySQLParser::dropRole() {
  DropRoleContext *_localctx = _tracker.createInstance<DropRoleContext>(_ctx, getState());
  enterRule(_localctx, 206, MySQLParser::RuleDropRole);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2507);
    match(MySQLParser::ROLE_SYMBOL);
    setState(2509);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 215, _ctx)) {
    case 1: {
      setState(2508);
      ifExists();
      break;
    }

    }
    setState(2511);
    roleList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropSpatialReferenceContext ------------------------------------------------------------------

MySQLParser::DropSpatialReferenceContext::DropSpatialReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropSpatialReferenceContext::SPATIAL_SYMBOL() {
  return getToken(MySQLParser::SPATIAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DropSpatialReferenceContext::REFERENCE_SYMBOL() {
  return getToken(MySQLParser::REFERENCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DropSpatialReferenceContext::SYSTEM_SYMBOL() {
  return getToken(MySQLParser::SYSTEM_SYMBOL, 0);
}

MySQLParser::Real_ulonglong_numberContext* MySQLParser::DropSpatialReferenceContext::real_ulonglong_number() {
  return getRuleContext<MySQLParser::Real_ulonglong_numberContext>(0);
}

MySQLParser::IfExistsContext* MySQLParser::DropSpatialReferenceContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}


size_t MySQLParser::DropSpatialReferenceContext::getRuleIndex() const {
  return MySQLParser::RuleDropSpatialReference;
}

void MySQLParser::DropSpatialReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropSpatialReference(this);
}

void MySQLParser::DropSpatialReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropSpatialReference(this);
}


antlrcpp::Any MySQLParser::DropSpatialReferenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDropSpatialReference(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropSpatialReferenceContext* MySQLParser::dropSpatialReference() {
  DropSpatialReferenceContext *_localctx = _tracker.createInstance<DropSpatialReferenceContext>(_ctx, getState());
  enterRule(_localctx, 208, MySQLParser::RuleDropSpatialReference);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2513);
    match(MySQLParser::SPATIAL_SYMBOL);
    setState(2514);
    match(MySQLParser::REFERENCE_SYMBOL);
    setState(2515);
    match(MySQLParser::SYSTEM_SYMBOL);
    setState(2517);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::IF_SYMBOL) {
      setState(2516);
      ifExists();
    }
    setState(2519);
    real_ulonglong_number();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropUndoTablespaceContext ------------------------------------------------------------------

MySQLParser::DropUndoTablespaceContext::DropUndoTablespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropUndoTablespaceContext::UNDO_SYMBOL() {
  return getToken(MySQLParser::UNDO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DropUndoTablespaceContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

MySQLParser::TablespaceRefContext* MySQLParser::DropUndoTablespaceContext::tablespaceRef() {
  return getRuleContext<MySQLParser::TablespaceRefContext>(0);
}

MySQLParser::UndoTableSpaceOptionsContext* MySQLParser::DropUndoTablespaceContext::undoTableSpaceOptions() {
  return getRuleContext<MySQLParser::UndoTableSpaceOptionsContext>(0);
}


size_t MySQLParser::DropUndoTablespaceContext::getRuleIndex() const {
  return MySQLParser::RuleDropUndoTablespace;
}

void MySQLParser::DropUndoTablespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropUndoTablespace(this);
}

void MySQLParser::DropUndoTablespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropUndoTablespace(this);
}


antlrcpp::Any MySQLParser::DropUndoTablespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDropUndoTablespace(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropUndoTablespaceContext* MySQLParser::dropUndoTablespace() {
  DropUndoTablespaceContext *_localctx = _tracker.createInstance<DropUndoTablespaceContext>(_ctx, getState());
  enterRule(_localctx, 210, MySQLParser::RuleDropUndoTablespace);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2521);
    match(MySQLParser::UNDO_SYMBOL);
    setState(2522);
    match(MySQLParser::TABLESPACE_SYMBOL);
    setState(2523);
    tablespaceRef();
    setState(2525);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL) {
      setState(2524);
      undoTableSpaceOptions();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RenameTableStatementContext ------------------------------------------------------------------

MySQLParser::RenameTableStatementContext::RenameTableStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RenameTableStatementContext::RENAME_SYMBOL() {
  return getToken(MySQLParser::RENAME_SYMBOL, 0);
}

std::vector<MySQLParser::RenamePairContext *> MySQLParser::RenameTableStatementContext::renamePair() {
  return getRuleContexts<MySQLParser::RenamePairContext>();
}

MySQLParser::RenamePairContext* MySQLParser::RenameTableStatementContext::renamePair(size_t i) {
  return getRuleContext<MySQLParser::RenamePairContext>(i);
}

tree::TerminalNode* MySQLParser::RenameTableStatementContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RenameTableStatementContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::RenameTableStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::RenameTableStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::RenameTableStatementContext::getRuleIndex() const {
  return MySQLParser::RuleRenameTableStatement;
}

void MySQLParser::RenameTableStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRenameTableStatement(this);
}

void MySQLParser::RenameTableStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRenameTableStatement(this);
}


antlrcpp::Any MySQLParser::RenameTableStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRenameTableStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RenameTableStatementContext* MySQLParser::renameTableStatement() {
  RenameTableStatementContext *_localctx = _tracker.createInstance<RenameTableStatementContext>(_ctx, getState());
  enterRule(_localctx, 212, MySQLParser::RuleRenameTableStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2527);
    match(MySQLParser::RENAME_SYMBOL);
    setState(2528);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::TABLES_SYMBOL || _la == MySQLParser::TABLE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2529);
    renamePair();
    setState(2534);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(2530);
      match(MySQLParser::COMMA_SYMBOL);
      setState(2531);
      renamePair();
      setState(2536);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RenamePairContext ------------------------------------------------------------------

MySQLParser::RenamePairContext::RenamePairContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext* MySQLParser::RenamePairContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode* MySQLParser::RenamePairContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::TableNameContext* MySQLParser::RenamePairContext::tableName() {
  return getRuleContext<MySQLParser::TableNameContext>(0);
}


size_t MySQLParser::RenamePairContext::getRuleIndex() const {
  return MySQLParser::RuleRenamePair;
}

void MySQLParser::RenamePairContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRenamePair(this);
}

void MySQLParser::RenamePairContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRenamePair(this);
}


antlrcpp::Any MySQLParser::RenamePairContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRenamePair(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RenamePairContext* MySQLParser::renamePair() {
  RenamePairContext *_localctx = _tracker.createInstance<RenamePairContext>(_ctx, getState());
  enterRule(_localctx, 214, MySQLParser::RuleRenamePair);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2537);
    tableRef();
    setState(2538);
    match(MySQLParser::TO_SYMBOL);
    setState(2539);
    tableName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TruncateTableStatementContext ------------------------------------------------------------------

MySQLParser::TruncateTableStatementContext::TruncateTableStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TruncateTableStatementContext::TRUNCATE_SYMBOL() {
  return getToken(MySQLParser::TRUNCATE_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::TruncateTableStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode* MySQLParser::TruncateTableStatementContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}


size_t MySQLParser::TruncateTableStatementContext::getRuleIndex() const {
  return MySQLParser::RuleTruncateTableStatement;
}

void MySQLParser::TruncateTableStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTruncateTableStatement(this);
}

void MySQLParser::TruncateTableStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTruncateTableStatement(this);
}


antlrcpp::Any MySQLParser::TruncateTableStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTruncateTableStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TruncateTableStatementContext* MySQLParser::truncateTableStatement() {
  TruncateTableStatementContext *_localctx = _tracker.createInstance<TruncateTableStatementContext>(_ctx, getState());
  enterRule(_localctx, 216, MySQLParser::RuleTruncateTableStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2541);
    match(MySQLParser::TRUNCATE_SYMBOL);
    setState(2543);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 219, _ctx)) {
    case 1: {
      setState(2542);
      match(MySQLParser::TABLE_SYMBOL);
      break;
    }

    }
    setState(2545);
    tableRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportStatementContext ------------------------------------------------------------------

MySQLParser::ImportStatementContext::ImportStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ImportStatementContext::IMPORT_SYMBOL() {
  return getToken(MySQLParser::IMPORT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ImportStatementContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ImportStatementContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

MySQLParser::TextStringLiteralListContext* MySQLParser::ImportStatementContext::textStringLiteralList() {
  return getRuleContext<MySQLParser::TextStringLiteralListContext>(0);
}


size_t MySQLParser::ImportStatementContext::getRuleIndex() const {
  return MySQLParser::RuleImportStatement;
}

void MySQLParser::ImportStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportStatement(this);
}

void MySQLParser::ImportStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportStatement(this);
}


antlrcpp::Any MySQLParser::ImportStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitImportStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ImportStatementContext* MySQLParser::importStatement() {
  ImportStatementContext *_localctx = _tracker.createInstance<ImportStatementContext>(_ctx, getState());
  enterRule(_localctx, 218, MySQLParser::RuleImportStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2547);
    match(MySQLParser::IMPORT_SYMBOL);
    setState(2548);
    match(MySQLParser::TABLE_SYMBOL);
    setState(2549);
    match(MySQLParser::FROM_SYMBOL);
    setState(2550);
    textStringLiteralList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CallStatementContext ------------------------------------------------------------------

MySQLParser::CallStatementContext::CallStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CallStatementContext::CALL_SYMBOL() {
  return getToken(MySQLParser::CALL_SYMBOL, 0);
}

MySQLParser::ProcedureRefContext* MySQLParser::CallStatementContext::procedureRef() {
  return getRuleContext<MySQLParser::ProcedureRefContext>(0);
}

tree::TerminalNode* MySQLParser::CallStatementContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CallStatementContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::ExprListContext* MySQLParser::CallStatementContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}


size_t MySQLParser::CallStatementContext::getRuleIndex() const {
  return MySQLParser::RuleCallStatement;
}

void MySQLParser::CallStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCallStatement(this);
}

void MySQLParser::CallStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCallStatement(this);
}


antlrcpp::Any MySQLParser::CallStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCallStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CallStatementContext* MySQLParser::callStatement() {
  CallStatementContext *_localctx = _tracker.createInstance<CallStatementContext>(_ctx, getState());
  enterRule(_localctx, 220, MySQLParser::RuleCallStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2552);
    match(MySQLParser::CALL_SYMBOL);
    setState(2553);
    procedureRef();
    setState(2559);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(2554);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(2556);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 220, _ctx)) {
      case 1: {
        setState(2555);
        exprList();
        break;
      }

      }
      setState(2558);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeleteStatementContext ------------------------------------------------------------------

MySQLParser::DeleteStatementContext::DeleteStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DeleteStatementContext::DELETE_SYMBOL() {
  return getToken(MySQLParser::DELETE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DeleteStatementContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

MySQLParser::TableAliasRefListContext* MySQLParser::DeleteStatementContext::tableAliasRefList() {
  return getRuleContext<MySQLParser::TableAliasRefListContext>(0);
}

MySQLParser::TableReferenceListContext* MySQLParser::DeleteStatementContext::tableReferenceList() {
  return getRuleContext<MySQLParser::TableReferenceListContext>(0);
}

MySQLParser::WithClauseContext* MySQLParser::DeleteStatementContext::withClause() {
  return getRuleContext<MySQLParser::WithClauseContext>(0);
}

std::vector<MySQLParser::DeleteStatementOptionContext *> MySQLParser::DeleteStatementContext::deleteStatementOption() {
  return getRuleContexts<MySQLParser::DeleteStatementOptionContext>();
}

MySQLParser::DeleteStatementOptionContext* MySQLParser::DeleteStatementContext::deleteStatementOption(size_t i) {
  return getRuleContext<MySQLParser::DeleteStatementOptionContext>(i);
}

tree::TerminalNode* MySQLParser::DeleteStatementContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::DeleteStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::WhereClauseContext* MySQLParser::DeleteStatementContext::whereClause() {
  return getRuleContext<MySQLParser::WhereClauseContext>(0);
}

MySQLParser::PartitionDeleteContext* MySQLParser::DeleteStatementContext::partitionDelete() {
  return getRuleContext<MySQLParser::PartitionDeleteContext>(0);
}

MySQLParser::OrderClauseContext* MySQLParser::DeleteStatementContext::orderClause() {
  return getRuleContext<MySQLParser::OrderClauseContext>(0);
}

MySQLParser::SimpleLimitClauseContext* MySQLParser::DeleteStatementContext::simpleLimitClause() {
  return getRuleContext<MySQLParser::SimpleLimitClauseContext>(0);
}


size_t MySQLParser::DeleteStatementContext::getRuleIndex() const {
  return MySQLParser::RuleDeleteStatement;
}

void MySQLParser::DeleteStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeleteStatement(this);
}

void MySQLParser::DeleteStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeleteStatement(this);
}


antlrcpp::Any MySQLParser::DeleteStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDeleteStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DeleteStatementContext* MySQLParser::deleteStatement() {
  DeleteStatementContext *_localctx = _tracker.createInstance<DeleteStatementContext>(_ctx, getState());
  enterRule(_localctx, 222, MySQLParser::RuleDeleteStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2563);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 222, _ctx)) {
    case 1: {
      setState(2561);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(2562);
      withClause();
      break;
    }

    }
    setState(2565);
    match(MySQLParser::DELETE_SYMBOL);
    setState(2569);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 223, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2566);
        deleteStatementOption(); 
      }
      setState(2571);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 223, _ctx);
    }
    setState(2600);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 231, _ctx)) {
    case 1: {
      setState(2572);
      match(MySQLParser::FROM_SYMBOL);
      setState(2592);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 229, _ctx)) {
      case 1: {
        setState(2573);
        tableAliasRefList();
        setState(2574);
        match(MySQLParser::USING_SYMBOL);
        setState(2575);
        tableReferenceList();
        setState(2577);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::WHERE_SYMBOL) {
          setState(2576);
          whereClause();
        }
        break;
      }

      case 2: {
        setState(2579);
        tableRef();
        setState(2581);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 225, _ctx)) {
        case 1: {
          setState(2580);
          partitionDelete();
          break;
        }

        }
        setState(2584);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::WHERE_SYMBOL) {
          setState(2583);
          whereClause();
        }
        setState(2587);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ORDER_SYMBOL) {
          setState(2586);
          orderClause();
        }
        setState(2590);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LIMIT_SYMBOL) {
          setState(2589);
          simpleLimitClause();
        }
        break;
      }

      }
      break;
    }

    case 2: {
      setState(2594);
      tableAliasRefList();
      setState(2595);
      match(MySQLParser::FROM_SYMBOL);
      setState(2596);
      tableReferenceList();
      setState(2598);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::WHERE_SYMBOL) {
        setState(2597);
        whereClause();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionDeleteContext ------------------------------------------------------------------

MySQLParser::PartitionDeleteContext::PartitionDeleteContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::PartitionDeleteContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDeleteContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::IdentifierListContext* MySQLParser::PartitionDeleteContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

tree::TerminalNode* MySQLParser::PartitionDeleteContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::PartitionDeleteContext::getRuleIndex() const {
  return MySQLParser::RulePartitionDelete;
}

void MySQLParser::PartitionDeleteContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDelete(this);
}

void MySQLParser::PartitionDeleteContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDelete(this);
}


antlrcpp::Any MySQLParser::PartitionDeleteContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPartitionDelete(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PartitionDeleteContext* MySQLParser::partitionDelete() {
  PartitionDeleteContext *_localctx = _tracker.createInstance<PartitionDeleteContext>(_ctx, getState());
  enterRule(_localctx, 224, MySQLParser::RulePartitionDelete);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2602);

    if (!(serverVersion >= 50602)) throw FailedPredicateException(this, "serverVersion >= 50602");
    setState(2603);
    match(MySQLParser::PARTITION_SYMBOL);
    setState(2604);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(2605);
    identifierList();
    setState(2606);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeleteStatementOptionContext ------------------------------------------------------------------

MySQLParser::DeleteStatementOptionContext::DeleteStatementOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DeleteStatementOptionContext::QUICK_SYMBOL() {
  return getToken(MySQLParser::QUICK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DeleteStatementOptionContext::LOW_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::LOW_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DeleteStatementOptionContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}


size_t MySQLParser::DeleteStatementOptionContext::getRuleIndex() const {
  return MySQLParser::RuleDeleteStatementOption;
}

void MySQLParser::DeleteStatementOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeleteStatementOption(this);
}

void MySQLParser::DeleteStatementOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeleteStatementOption(this);
}


antlrcpp::Any MySQLParser::DeleteStatementOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDeleteStatementOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DeleteStatementOptionContext* MySQLParser::deleteStatementOption() {
  DeleteStatementOptionContext *_localctx = _tracker.createInstance<DeleteStatementOptionContext>(_ctx, getState());
  enterRule(_localctx, 226, MySQLParser::RuleDeleteStatementOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2608);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::QUICK_SYMBOL || _la == MySQLParser::IGNORE_SYMBOL

    || _la == MySQLParser::LOW_PRIORITY_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DoStatementContext ------------------------------------------------------------------

MySQLParser::DoStatementContext::DoStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DoStatementContext::DO_SYMBOL() {
  return getToken(MySQLParser::DO_SYMBOL, 0);
}

MySQLParser::ExprListContext* MySQLParser::DoStatementContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

MySQLParser::SelectItemListContext* MySQLParser::DoStatementContext::selectItemList() {
  return getRuleContext<MySQLParser::SelectItemListContext>(0);
}


size_t MySQLParser::DoStatementContext::getRuleIndex() const {
  return MySQLParser::RuleDoStatement;
}

void MySQLParser::DoStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDoStatement(this);
}

void MySQLParser::DoStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDoStatement(this);
}


antlrcpp::Any MySQLParser::DoStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDoStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DoStatementContext* MySQLParser::doStatement() {
  DoStatementContext *_localctx = _tracker.createInstance<DoStatementContext>(_ctx, getState());
  enterRule(_localctx, 228, MySQLParser::RuleDoStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2610);
    match(MySQLParser::DO_SYMBOL);
    setState(2615);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 232, _ctx)) {
    case 1: {
      setState(2611);

      if (!(serverVersion < 50709)) throw FailedPredicateException(this, "serverVersion < 50709");
      setState(2612);
      exprList();
      break;
    }

    case 2: {
      setState(2613);

      if (!(serverVersion >= 50709)) throw FailedPredicateException(this, "serverVersion >= 50709");
      setState(2614);
      selectItemList();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerStatementContext ------------------------------------------------------------------

MySQLParser::HandlerStatementContext::HandlerStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::HandlerStatementContext::HANDLER_SYMBOL() {
  return getToken(MySQLParser::HANDLER_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::HandlerStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode* MySQLParser::HandlerStatementContext::OPEN_SYMBOL() {
  return getToken(MySQLParser::OPEN_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::HandlerStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::HandlerStatementContext::CLOSE_SYMBOL() {
  return getToken(MySQLParser::CLOSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HandlerStatementContext::READ_SYMBOL() {
  return getToken(MySQLParser::READ_SYMBOL, 0);
}

MySQLParser::HandlerReadOrScanContext* MySQLParser::HandlerStatementContext::handlerReadOrScan() {
  return getRuleContext<MySQLParser::HandlerReadOrScanContext>(0);
}

MySQLParser::TableAliasContext* MySQLParser::HandlerStatementContext::tableAlias() {
  return getRuleContext<MySQLParser::TableAliasContext>(0);
}

MySQLParser::WhereClauseContext* MySQLParser::HandlerStatementContext::whereClause() {
  return getRuleContext<MySQLParser::WhereClauseContext>(0);
}

MySQLParser::LimitClauseContext* MySQLParser::HandlerStatementContext::limitClause() {
  return getRuleContext<MySQLParser::LimitClauseContext>(0);
}


size_t MySQLParser::HandlerStatementContext::getRuleIndex() const {
  return MySQLParser::RuleHandlerStatement;
}

void MySQLParser::HandlerStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerStatement(this);
}

void MySQLParser::HandlerStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerStatement(this);
}


antlrcpp::Any MySQLParser::HandlerStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitHandlerStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::HandlerStatementContext* MySQLParser::handlerStatement() {
  HandlerStatementContext *_localctx = _tracker.createInstance<HandlerStatementContext>(_ctx, getState());
  enterRule(_localctx, 230, MySQLParser::RuleHandlerStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2617);
    match(MySQLParser::HANDLER_SYMBOL);
    setState(2635);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 237, _ctx)) {
    case 1: {
      setState(2618);
      tableRef();
      setState(2619);
      match(MySQLParser::OPEN_SYMBOL);
      setState(2621);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 233, _ctx)) {
      case 1: {
        setState(2620);
        tableAlias();
        break;
      }

      }
      break;
    }

    case 2: {
      setState(2623);
      identifier();
      setState(2633);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::CLOSE_SYMBOL: {
          setState(2624);
          match(MySQLParser::CLOSE_SYMBOL);
          break;
        }

        case MySQLParser::READ_SYMBOL: {
          setState(2625);
          match(MySQLParser::READ_SYMBOL);
          setState(2626);
          handlerReadOrScan();
          setState(2628);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLParser::WHERE_SYMBOL) {
            setState(2627);
            whereClause();
          }
          setState(2631);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLParser::LIMIT_SYMBOL) {
            setState(2630);
            limitClause();
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerReadOrScanContext ------------------------------------------------------------------

MySQLParser::HandlerReadOrScanContext::HandlerReadOrScanContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::HandlerReadOrScanContext::FIRST_SYMBOL() {
  return getToken(MySQLParser::FIRST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HandlerReadOrScanContext::NEXT_SYMBOL() {
  return getToken(MySQLParser::NEXT_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::HandlerReadOrScanContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::HandlerReadOrScanContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ValuesContext* MySQLParser::HandlerReadOrScanContext::values() {
  return getRuleContext<MySQLParser::ValuesContext>(0);
}

tree::TerminalNode* MySQLParser::HandlerReadOrScanContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HandlerReadOrScanContext::PREV_SYMBOL() {
  return getToken(MySQLParser::PREV_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HandlerReadOrScanContext::LAST_SYMBOL() {
  return getToken(MySQLParser::LAST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HandlerReadOrScanContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::HandlerReadOrScanContext::LESS_THAN_OPERATOR() {
  return getToken(MySQLParser::LESS_THAN_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::HandlerReadOrScanContext::GREATER_THAN_OPERATOR() {
  return getToken(MySQLParser::GREATER_THAN_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::HandlerReadOrScanContext::LESS_OR_EQUAL_OPERATOR() {
  return getToken(MySQLParser::LESS_OR_EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::HandlerReadOrScanContext::GREATER_OR_EQUAL_OPERATOR() {
  return getToken(MySQLParser::GREATER_OR_EQUAL_OPERATOR, 0);
}


size_t MySQLParser::HandlerReadOrScanContext::getRuleIndex() const {
  return MySQLParser::RuleHandlerReadOrScan;
}

void MySQLParser::HandlerReadOrScanContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerReadOrScan(this);
}

void MySQLParser::HandlerReadOrScanContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerReadOrScan(this);
}


antlrcpp::Any MySQLParser::HandlerReadOrScanContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitHandlerReadOrScan(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::HandlerReadOrScanContext* MySQLParser::handlerReadOrScan() {
  HandlerReadOrScanContext *_localctx = _tracker.createInstance<HandlerReadOrScanContext>(_ctx, getState());
  enterRule(_localctx, 232, MySQLParser::RuleHandlerReadOrScan);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2647);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 239, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2637);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::FIRST_SYMBOL || _la == MySQLParser::NEXT_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2638);
      identifier();
      setState(2645);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::FIRST_SYMBOL:
        case MySQLParser::LAST_SYMBOL:
        case MySQLParser::NEXT_SYMBOL:
        case MySQLParser::PREV_SYMBOL: {
          setState(2639);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::FIRST_SYMBOL

          || _la == MySQLParser::LAST_SYMBOL || _la == MySQLParser::NEXT_SYMBOL

          || _la == MySQLParser::PREV_SYMBOL)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        case MySQLParser::EQUAL_OPERATOR:
        case MySQLParser::GREATER_OR_EQUAL_OPERATOR:
        case MySQLParser::GREATER_THAN_OPERATOR:
        case MySQLParser::LESS_OR_EQUAL_OPERATOR:
        case MySQLParser::LESS_THAN_OPERATOR: {
          setState(2640);
          _la = _input->LA(1);
          if (!(((((_la - 383) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 383)) & ((1ULL << (MySQLParser::EQUAL_OPERATOR - 383))
            | (1ULL << (MySQLParser::GREATER_OR_EQUAL_OPERATOR - 383))
            | (1ULL << (MySQLParser::GREATER_THAN_OPERATOR - 383))
            | (1ULL << (MySQLParser::LESS_OR_EQUAL_OPERATOR - 383))
            | (1ULL << (MySQLParser::LESS_THAN_OPERATOR - 383)))) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(2641);
          match(MySQLParser::OPEN_PAR_SYMBOL);
          setState(2642);
          values();
          setState(2643);
          match(MySQLParser::CLOSE_PAR_SYMBOL);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertStatementContext ------------------------------------------------------------------

MySQLParser::InsertStatementContext::InsertStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::InsertStatementContext::INSERT_SYMBOL() {
  return getToken(MySQLParser::INSERT_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::InsertStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::InsertFromConstructorContext* MySQLParser::InsertStatementContext::insertFromConstructor() {
  return getRuleContext<MySQLParser::InsertFromConstructorContext>(0);
}

tree::TerminalNode* MySQLParser::InsertStatementContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

MySQLParser::UpdateListContext* MySQLParser::InsertStatementContext::updateList() {
  return getRuleContext<MySQLParser::UpdateListContext>(0);
}

MySQLParser::InsertQueryExpressionContext* MySQLParser::InsertStatementContext::insertQueryExpression() {
  return getRuleContext<MySQLParser::InsertQueryExpressionContext>(0);
}

MySQLParser::InsertLockOptionContext* MySQLParser::InsertStatementContext::insertLockOption() {
  return getRuleContext<MySQLParser::InsertLockOptionContext>(0);
}

tree::TerminalNode* MySQLParser::InsertStatementContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InsertStatementContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

MySQLParser::UsePartitionContext* MySQLParser::InsertStatementContext::usePartition() {
  return getRuleContext<MySQLParser::UsePartitionContext>(0);
}

MySQLParser::InsertUpdateListContext* MySQLParser::InsertStatementContext::insertUpdateList() {
  return getRuleContext<MySQLParser::InsertUpdateListContext>(0);
}


size_t MySQLParser::InsertStatementContext::getRuleIndex() const {
  return MySQLParser::RuleInsertStatement;
}

void MySQLParser::InsertStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertStatement(this);
}

void MySQLParser::InsertStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertStatement(this);
}


antlrcpp::Any MySQLParser::InsertStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitInsertStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InsertStatementContext* MySQLParser::insertStatement() {
  InsertStatementContext *_localctx = _tracker.createInstance<InsertStatementContext>(_ctx, getState());
  enterRule(_localctx, 234, MySQLParser::RuleInsertStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2649);
    match(MySQLParser::INSERT_SYMBOL);
    setState(2651);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 240, _ctx)) {
    case 1: {
      setState(2650);
      insertLockOption();
      break;
    }

    }
    setState(2654);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 241, _ctx)) {
    case 1: {
      setState(2653);
      match(MySQLParser::IGNORE_SYMBOL);
      break;
    }

    }
    setState(2657);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx)) {
    case 1: {
      setState(2656);
      match(MySQLParser::INTO_SYMBOL);
      break;
    }

    }
    setState(2659);
    tableRef();
    setState(2661);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 243, _ctx)) {
    case 1: {
      setState(2660);
      usePartition();
      break;
    }

    }
    setState(2667);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 244, _ctx)) {
    case 1: {
      setState(2663);
      insertFromConstructor();
      break;
    }

    case 2: {
      setState(2664);
      match(MySQLParser::SET_SYMBOL);
      setState(2665);
      updateList();
      break;
    }

    case 3: {
      setState(2666);
      insertQueryExpression();
      break;
    }

    }
    setState(2670);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ON_SYMBOL) {
      setState(2669);
      insertUpdateList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertLockOptionContext ------------------------------------------------------------------

MySQLParser::InsertLockOptionContext::InsertLockOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::InsertLockOptionContext::LOW_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::LOW_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InsertLockOptionContext::DELAYED_SYMBOL() {
  return getToken(MySQLParser::DELAYED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InsertLockOptionContext::HIGH_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::HIGH_PRIORITY_SYMBOL, 0);
}


size_t MySQLParser::InsertLockOptionContext::getRuleIndex() const {
  return MySQLParser::RuleInsertLockOption;
}

void MySQLParser::InsertLockOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertLockOption(this);
}

void MySQLParser::InsertLockOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertLockOption(this);
}


antlrcpp::Any MySQLParser::InsertLockOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitInsertLockOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InsertLockOptionContext* MySQLParser::insertLockOption() {
  InsertLockOptionContext *_localctx = _tracker.createInstance<InsertLockOptionContext>(_ctx, getState());
  enterRule(_localctx, 236, MySQLParser::RuleInsertLockOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2672);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DELAYED_SYMBOL

    || _la == MySQLParser::HIGH_PRIORITY_SYMBOL || _la == MySQLParser::LOW_PRIORITY_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertFromConstructorContext ------------------------------------------------------------------

MySQLParser::InsertFromConstructorContext::InsertFromConstructorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::InsertValuesContext* MySQLParser::InsertFromConstructorContext::insertValues() {
  return getRuleContext<MySQLParser::InsertValuesContext>(0);
}

tree::TerminalNode* MySQLParser::InsertFromConstructorContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InsertFromConstructorContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::FieldsContext* MySQLParser::InsertFromConstructorContext::fields() {
  return getRuleContext<MySQLParser::FieldsContext>(0);
}


size_t MySQLParser::InsertFromConstructorContext::getRuleIndex() const {
  return MySQLParser::RuleInsertFromConstructor;
}

void MySQLParser::InsertFromConstructorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertFromConstructor(this);
}

void MySQLParser::InsertFromConstructorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertFromConstructor(this);
}


antlrcpp::Any MySQLParser::InsertFromConstructorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitInsertFromConstructor(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InsertFromConstructorContext* MySQLParser::insertFromConstructor() {
  InsertFromConstructorContext *_localctx = _tracker.createInstance<InsertFromConstructorContext>(_ctx, getState());
  enterRule(_localctx, 238, MySQLParser::RuleInsertFromConstructor);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2679);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(2674);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(2676);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 246, _ctx)) {
      case 1: {
        setState(2675);
        fields();
        break;
      }

      }
      setState(2678);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
    }
    setState(2681);
    insertValues();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldsContext ------------------------------------------------------------------

MySQLParser::FieldsContext::FieldsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::InsertIdentifierContext *> MySQLParser::FieldsContext::insertIdentifier() {
  return getRuleContexts<MySQLParser::InsertIdentifierContext>();
}

MySQLParser::InsertIdentifierContext* MySQLParser::FieldsContext::insertIdentifier(size_t i) {
  return getRuleContext<MySQLParser::InsertIdentifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::FieldsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::FieldsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::FieldsContext::getRuleIndex() const {
  return MySQLParser::RuleFields;
}

void MySQLParser::FieldsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFields(this);
}

void MySQLParser::FieldsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFields(this);
}


antlrcpp::Any MySQLParser::FieldsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFields(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FieldsContext* MySQLParser::fields() {
  FieldsContext *_localctx = _tracker.createInstance<FieldsContext>(_ctx, getState());
  enterRule(_localctx, 240, MySQLParser::RuleFields);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2683);
    insertIdentifier();
    setState(2688);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(2684);
      match(MySQLParser::COMMA_SYMBOL);
      setState(2685);
      insertIdentifier();
      setState(2690);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertValuesContext ------------------------------------------------------------------

MySQLParser::InsertValuesContext::InsertValuesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ValueListContext* MySQLParser::InsertValuesContext::valueList() {
  return getRuleContext<MySQLParser::ValueListContext>(0);
}

tree::TerminalNode* MySQLParser::InsertValuesContext::VALUES_SYMBOL() {
  return getToken(MySQLParser::VALUES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InsertValuesContext::VALUE_SYMBOL() {
  return getToken(MySQLParser::VALUE_SYMBOL, 0);
}


size_t MySQLParser::InsertValuesContext::getRuleIndex() const {
  return MySQLParser::RuleInsertValues;
}

void MySQLParser::InsertValuesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertValues(this);
}

void MySQLParser::InsertValuesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertValues(this);
}


antlrcpp::Any MySQLParser::InsertValuesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitInsertValues(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InsertValuesContext* MySQLParser::insertValues() {
  InsertValuesContext *_localctx = _tracker.createInstance<InsertValuesContext>(_ctx, getState());
  enterRule(_localctx, 242, MySQLParser::RuleInsertValues);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2691);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::VALUE_SYMBOL || _la == MySQLParser::VALUES_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2692);
    valueList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertQueryExpressionContext ------------------------------------------------------------------

MySQLParser::InsertQueryExpressionContext::InsertQueryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryExpressionOrParensContext* MySQLParser::InsertQueryExpressionContext::queryExpressionOrParens() {
  return getRuleContext<MySQLParser::QueryExpressionOrParensContext>(0);
}

tree::TerminalNode* MySQLParser::InsertQueryExpressionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InsertQueryExpressionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::FieldsContext* MySQLParser::InsertQueryExpressionContext::fields() {
  return getRuleContext<MySQLParser::FieldsContext>(0);
}


size_t MySQLParser::InsertQueryExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleInsertQueryExpression;
}

void MySQLParser::InsertQueryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertQueryExpression(this);
}

void MySQLParser::InsertQueryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertQueryExpression(this);
}


antlrcpp::Any MySQLParser::InsertQueryExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitInsertQueryExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InsertQueryExpressionContext* MySQLParser::insertQueryExpression() {
  InsertQueryExpressionContext *_localctx = _tracker.createInstance<InsertQueryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 244, MySQLParser::RuleInsertQueryExpression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2701);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 250, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2694);
      queryExpressionOrParens();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2695);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(2697);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 249, _ctx)) {
      case 1: {
        setState(2696);
        fields();
        break;
      }

      }
      setState(2699);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(2700);
      queryExpressionOrParens();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueListContext ------------------------------------------------------------------

MySQLParser::ValueListContext::ValueListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::ValueListContext::OPEN_PAR_SYMBOL() {
  return getTokens(MySQLParser::OPEN_PAR_SYMBOL);
}

tree::TerminalNode* MySQLParser::ValueListContext::OPEN_PAR_SYMBOL(size_t i) {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::ValueListContext::CLOSE_PAR_SYMBOL() {
  return getTokens(MySQLParser::CLOSE_PAR_SYMBOL);
}

tree::TerminalNode* MySQLParser::ValueListContext::CLOSE_PAR_SYMBOL(size_t i) {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, i);
}

std::vector<MySQLParser::ValuesContext *> MySQLParser::ValueListContext::values() {
  return getRuleContexts<MySQLParser::ValuesContext>();
}

MySQLParser::ValuesContext* MySQLParser::ValueListContext::values(size_t i) {
  return getRuleContext<MySQLParser::ValuesContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ValueListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ValueListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ValueListContext::getRuleIndex() const {
  return MySQLParser::RuleValueList;
}

void MySQLParser::ValueListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValueList(this);
}

void MySQLParser::ValueListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValueList(this);
}


antlrcpp::Any MySQLParser::ValueListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitValueList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ValueListContext* MySQLParser::valueList() {
  ValueListContext *_localctx = _tracker.createInstance<ValueListContext>(_ctx, getState());
  enterRule(_localctx, 246, MySQLParser::RuleValueList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2703);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(2705);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 251, _ctx)) {
    case 1: {
      setState(2704);
      values();
      break;
    }

    }
    setState(2707);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
    setState(2716);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(2708);
      match(MySQLParser::COMMA_SYMBOL);
      setState(2709);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(2711);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 252, _ctx)) {
      case 1: {
        setState(2710);
        values();
        break;
      }

      }
      setState(2713);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(2718);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValuesContext ------------------------------------------------------------------

MySQLParser::ValuesContext::ValuesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::ExprContext *> MySQLParser::ValuesContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext* MySQLParser::ValuesContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ValuesContext::DEFAULT_SYMBOL() {
  return getTokens(MySQLParser::DEFAULT_SYMBOL);
}

tree::TerminalNode* MySQLParser::ValuesContext::DEFAULT_SYMBOL(size_t i) {
  return getToken(MySQLParser::DEFAULT_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::ValuesContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ValuesContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ValuesContext::getRuleIndex() const {
  return MySQLParser::RuleValues;
}

void MySQLParser::ValuesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValues(this);
}

void MySQLParser::ValuesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValues(this);
}


antlrcpp::Any MySQLParser::ValuesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitValues(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ValuesContext* MySQLParser::values() {
  ValuesContext *_localctx = _tracker.createInstance<ValuesContext>(_ctx, getState());
  enterRule(_localctx, 248, MySQLParser::RuleValues);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2721);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 254, _ctx)) {
    case 1: {
      setState(2719);
      expr(0);
      break;
    }

    case 2: {
      setState(2720);
      match(MySQLParser::DEFAULT_SYMBOL);
      break;
    }

    }
    setState(2730);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(2723);
      match(MySQLParser::COMMA_SYMBOL);
      setState(2726);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 255, _ctx)) {
      case 1: {
        setState(2724);
        expr(0);
        break;
      }

      case 2: {
        setState(2725);
        match(MySQLParser::DEFAULT_SYMBOL);
        break;
      }

      }
      setState(2732);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertUpdateListContext ------------------------------------------------------------------

MySQLParser::InsertUpdateListContext::InsertUpdateListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::InsertUpdateListContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InsertUpdateListContext::DUPLICATE_SYMBOL() {
  return getToken(MySQLParser::DUPLICATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InsertUpdateListContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InsertUpdateListContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

MySQLParser::UpdateListContext* MySQLParser::InsertUpdateListContext::updateList() {
  return getRuleContext<MySQLParser::UpdateListContext>(0);
}


size_t MySQLParser::InsertUpdateListContext::getRuleIndex() const {
  return MySQLParser::RuleInsertUpdateList;
}

void MySQLParser::InsertUpdateListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertUpdateList(this);
}

void MySQLParser::InsertUpdateListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertUpdateList(this);
}


antlrcpp::Any MySQLParser::InsertUpdateListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitInsertUpdateList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InsertUpdateListContext* MySQLParser::insertUpdateList() {
  InsertUpdateListContext *_localctx = _tracker.createInstance<InsertUpdateListContext>(_ctx, getState());
  enterRule(_localctx, 250, MySQLParser::RuleInsertUpdateList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2733);
    match(MySQLParser::ON_SYMBOL);
    setState(2734);
    match(MySQLParser::DUPLICATE_SYMBOL);
    setState(2735);
    match(MySQLParser::KEY_SYMBOL);
    setState(2736);
    match(MySQLParser::UPDATE_SYMBOL);
    setState(2737);
    updateList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoadStatementContext ------------------------------------------------------------------

MySQLParser::LoadStatementContext::LoadStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LoadStatementContext::LOAD_SYMBOL() {
  return getToken(MySQLParser::LOAD_SYMBOL, 0);
}

MySQLParser::DataOrXmlContext* MySQLParser::LoadStatementContext::dataOrXml() {
  return getRuleContext<MySQLParser::DataOrXmlContext>(0);
}

tree::TerminalNode* MySQLParser::LoadStatementContext::INFILE_SYMBOL() {
  return getToken(MySQLParser::INFILE_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::LoadStatementContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::LoadStatementContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LoadStatementContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::LoadStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::LoadDataFileTailContext* MySQLParser::LoadStatementContext::loadDataFileTail() {
  return getRuleContext<MySQLParser::LoadDataFileTailContext>(0);
}

tree::TerminalNode* MySQLParser::LoadStatementContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

MySQLParser::UsePartitionContext* MySQLParser::LoadStatementContext::usePartition() {
  return getRuleContext<MySQLParser::UsePartitionContext>(0);
}

MySQLParser::CharsetClauseContext* MySQLParser::LoadStatementContext::charsetClause() {
  return getRuleContext<MySQLParser::CharsetClauseContext>(0);
}

MySQLParser::XmlRowsIdentifiedByContext* MySQLParser::LoadStatementContext::xmlRowsIdentifiedBy() {
  return getRuleContext<MySQLParser::XmlRowsIdentifiedByContext>(0);
}

MySQLParser::FieldsClauseContext* MySQLParser::LoadStatementContext::fieldsClause() {
  return getRuleContext<MySQLParser::FieldsClauseContext>(0);
}

MySQLParser::LinesClauseContext* MySQLParser::LoadStatementContext::linesClause() {
  return getRuleContext<MySQLParser::LinesClauseContext>(0);
}

tree::TerminalNode* MySQLParser::LoadStatementContext::LOW_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::LOW_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LoadStatementContext::CONCURRENT_SYMBOL() {
  return getToken(MySQLParser::CONCURRENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LoadStatementContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LoadStatementContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}


size_t MySQLParser::LoadStatementContext::getRuleIndex() const {
  return MySQLParser::RuleLoadStatement;
}

void MySQLParser::LoadStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoadStatement(this);
}

void MySQLParser::LoadStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoadStatement(this);
}


antlrcpp::Any MySQLParser::LoadStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLoadStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LoadStatementContext* MySQLParser::loadStatement() {
  LoadStatementContext *_localctx = _tracker.createInstance<LoadStatementContext>(_ctx, getState());
  enterRule(_localctx, 252, MySQLParser::RuleLoadStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2739);
    match(MySQLParser::LOAD_SYMBOL);
    setState(2740);
    dataOrXml();
    setState(2742);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::CONCURRENT_SYMBOL || _la == MySQLParser::LOW_PRIORITY_SYMBOL) {
      setState(2741);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::CONCURRENT_SYMBOL || _la == MySQLParser::LOW_PRIORITY_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(2745);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LOCAL_SYMBOL) {
      setState(2744);
      match(MySQLParser::LOCAL_SYMBOL);
    }
    setState(2747);
    match(MySQLParser::INFILE_SYMBOL);
    setState(2748);
    textLiteral();
    setState(2750);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::IGNORE_SYMBOL || _la == MySQLParser::REPLACE_SYMBOL) {
      setState(2749);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::IGNORE_SYMBOL || _la == MySQLParser::REPLACE_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(2752);
    match(MySQLParser::INTO_SYMBOL);
    setState(2753);
    match(MySQLParser::TABLE_SYMBOL);
    setState(2754);
    tableRef();
    setState(2756);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 260, _ctx)) {
    case 1: {
      setState(2755);
      usePartition();
      break;
    }

    }
    setState(2759);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 261, _ctx)) {
    case 1: {
      setState(2758);
      charsetClause();
      break;
    }

    }
    setState(2762);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 262, _ctx)) {
    case 1: {
      setState(2761);
      xmlRowsIdentifiedBy();
      break;
    }

    }
    setState(2765);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::COLUMNS_SYMBOL) {
      setState(2764);
      fieldsClause();
    }
    setState(2768);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LINES_SYMBOL) {
      setState(2767);
      linesClause();
    }
    setState(2770);
    loadDataFileTail();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DataOrXmlContext ------------------------------------------------------------------

MySQLParser::DataOrXmlContext::DataOrXmlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DataOrXmlContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataOrXmlContext::XML_SYMBOL() {
  return getToken(MySQLParser::XML_SYMBOL, 0);
}


size_t MySQLParser::DataOrXmlContext::getRuleIndex() const {
  return MySQLParser::RuleDataOrXml;
}

void MySQLParser::DataOrXmlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDataOrXml(this);
}

void MySQLParser::DataOrXmlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDataOrXml(this);
}


antlrcpp::Any MySQLParser::DataOrXmlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDataOrXml(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DataOrXmlContext* MySQLParser::dataOrXml() {
  DataOrXmlContext *_localctx = _tracker.createInstance<DataOrXmlContext>(_ctx, getState());
  enterRule(_localctx, 254, MySQLParser::RuleDataOrXml);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2775);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 265, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2772);
      match(MySQLParser::DATA_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2773);

      if (!(serverVersion >= 50500)) throw FailedPredicateException(this, "serverVersion >= 50500");
      setState(2774);
      match(MySQLParser::XML_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XmlRowsIdentifiedByContext ------------------------------------------------------------------

MySQLParser::XmlRowsIdentifiedByContext::XmlRowsIdentifiedByContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::XmlRowsIdentifiedByContext::ROWS_SYMBOL() {
  return getToken(MySQLParser::ROWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XmlRowsIdentifiedByContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XmlRowsIdentifiedByContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::XmlRowsIdentifiedByContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}


size_t MySQLParser::XmlRowsIdentifiedByContext::getRuleIndex() const {
  return MySQLParser::RuleXmlRowsIdentifiedBy;
}

void MySQLParser::XmlRowsIdentifiedByContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXmlRowsIdentifiedBy(this);
}

void MySQLParser::XmlRowsIdentifiedByContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXmlRowsIdentifiedBy(this);
}


antlrcpp::Any MySQLParser::XmlRowsIdentifiedByContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitXmlRowsIdentifiedBy(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::XmlRowsIdentifiedByContext* MySQLParser::xmlRowsIdentifiedBy() {
  XmlRowsIdentifiedByContext *_localctx = _tracker.createInstance<XmlRowsIdentifiedByContext>(_ctx, getState());
  enterRule(_localctx, 256, MySQLParser::RuleXmlRowsIdentifiedBy);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2777);

    if (!(serverVersion >= 50500)) throw FailedPredicateException(this, "serverVersion >= 50500");
    setState(2778);
    match(MySQLParser::ROWS_SYMBOL);
    setState(2779);
    match(MySQLParser::IDENTIFIED_SYMBOL);
    setState(2780);
    match(MySQLParser::BY_SYMBOL);
    setState(2781);
    textString();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoadDataFileTailContext ------------------------------------------------------------------

MySQLParser::LoadDataFileTailContext::LoadDataFileTailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LoadDataFileTailContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LoadDataFileTailContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

MySQLParser::LoadDataFileTargetListContext* MySQLParser::LoadDataFileTailContext::loadDataFileTargetList() {
  return getRuleContext<MySQLParser::LoadDataFileTargetListContext>(0);
}

tree::TerminalNode* MySQLParser::LoadDataFileTailContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

MySQLParser::UpdateListContext* MySQLParser::LoadDataFileTailContext::updateList() {
  return getRuleContext<MySQLParser::UpdateListContext>(0);
}

tree::TerminalNode* MySQLParser::LoadDataFileTailContext::LINES_SYMBOL() {
  return getToken(MySQLParser::LINES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LoadDataFileTailContext::ROWS_SYMBOL() {
  return getToken(MySQLParser::ROWS_SYMBOL, 0);
}


size_t MySQLParser::LoadDataFileTailContext::getRuleIndex() const {
  return MySQLParser::RuleLoadDataFileTail;
}

void MySQLParser::LoadDataFileTailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoadDataFileTail(this);
}

void MySQLParser::LoadDataFileTailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoadDataFileTail(this);
}


antlrcpp::Any MySQLParser::LoadDataFileTailContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLoadDataFileTail(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LoadDataFileTailContext* MySQLParser::loadDataFileTail() {
  LoadDataFileTailContext *_localctx = _tracker.createInstance<LoadDataFileTailContext>(_ctx, getState());
  enterRule(_localctx, 258, MySQLParser::RuleLoadDataFileTail);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2786);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::IGNORE_SYMBOL) {
      setState(2783);
      match(MySQLParser::IGNORE_SYMBOL);
      setState(2784);
      match(MySQLParser::INT_NUMBER);
      setState(2785);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::ROWS_SYMBOL || _la == MySQLParser::LINES_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(2789);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(2788);
      loadDataFileTargetList();
    }
    setState(2793);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::SET_SYMBOL) {
      setState(2791);
      match(MySQLParser::SET_SYMBOL);
      setState(2792);
      updateList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoadDataFileTargetListContext ------------------------------------------------------------------

MySQLParser::LoadDataFileTargetListContext::LoadDataFileTargetListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LoadDataFileTargetListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LoadDataFileTargetListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::FieldOrVariableListContext* MySQLParser::LoadDataFileTargetListContext::fieldOrVariableList() {
  return getRuleContext<MySQLParser::FieldOrVariableListContext>(0);
}


size_t MySQLParser::LoadDataFileTargetListContext::getRuleIndex() const {
  return MySQLParser::RuleLoadDataFileTargetList;
}

void MySQLParser::LoadDataFileTargetListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoadDataFileTargetList(this);
}

void MySQLParser::LoadDataFileTargetListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoadDataFileTargetList(this);
}


antlrcpp::Any MySQLParser::LoadDataFileTargetListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLoadDataFileTargetList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LoadDataFileTargetListContext* MySQLParser::loadDataFileTargetList() {
  LoadDataFileTargetListContext *_localctx = _tracker.createInstance<LoadDataFileTargetListContext>(_ctx, getState());
  enterRule(_localctx, 260, MySQLParser::RuleLoadDataFileTargetList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2795);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(2797);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 269, _ctx)) {
    case 1: {
      setState(2796);
      fieldOrVariableList();
      break;
    }

    }
    setState(2799);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldOrVariableListContext ------------------------------------------------------------------

MySQLParser::FieldOrVariableListContext::FieldOrVariableListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::ColumnRefContext *> MySQLParser::FieldOrVariableListContext::columnRef() {
  return getRuleContexts<MySQLParser::ColumnRefContext>();
}

MySQLParser::ColumnRefContext* MySQLParser::FieldOrVariableListContext::columnRef(size_t i) {
  return getRuleContext<MySQLParser::ColumnRefContext>(i);
}

std::vector<MySQLParser::UserVariableContext *> MySQLParser::FieldOrVariableListContext::userVariable() {
  return getRuleContexts<MySQLParser::UserVariableContext>();
}

MySQLParser::UserVariableContext* MySQLParser::FieldOrVariableListContext::userVariable(size_t i) {
  return getRuleContext<MySQLParser::UserVariableContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::FieldOrVariableListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::FieldOrVariableListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::FieldOrVariableListContext::getRuleIndex() const {
  return MySQLParser::RuleFieldOrVariableList;
}

void MySQLParser::FieldOrVariableListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldOrVariableList(this);
}

void MySQLParser::FieldOrVariableListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldOrVariableList(this);
}


antlrcpp::Any MySQLParser::FieldOrVariableListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFieldOrVariableList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FieldOrVariableListContext* MySQLParser::fieldOrVariableList() {
  FieldOrVariableListContext *_localctx = _tracker.createInstance<FieldOrVariableListContext>(_ctx, getState());
  enterRule(_localctx, 262, MySQLParser::RuleFieldOrVariableList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2803);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 270, _ctx)) {
    case 1: {
      setState(2801);
      columnRef();
      break;
    }

    case 2: {
      setState(2802);
      userVariable();
      break;
    }

    }
    setState(2812);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(2805);
      match(MySQLParser::COMMA_SYMBOL);
      setState(2808);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 271, _ctx)) {
      case 1: {
        setState(2806);
        columnRef();
        break;
      }

      case 2: {
        setState(2807);
        userVariable();
        break;
      }

      }
      setState(2814);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplaceStatementContext ------------------------------------------------------------------

MySQLParser::ReplaceStatementContext::ReplaceStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ReplaceStatementContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::ReplaceStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::InsertFromConstructorContext* MySQLParser::ReplaceStatementContext::insertFromConstructor() {
  return getRuleContext<MySQLParser::InsertFromConstructorContext>(0);
}

tree::TerminalNode* MySQLParser::ReplaceStatementContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

MySQLParser::UpdateListContext* MySQLParser::ReplaceStatementContext::updateList() {
  return getRuleContext<MySQLParser::UpdateListContext>(0);
}

MySQLParser::InsertQueryExpressionContext* MySQLParser::ReplaceStatementContext::insertQueryExpression() {
  return getRuleContext<MySQLParser::InsertQueryExpressionContext>(0);
}

tree::TerminalNode* MySQLParser::ReplaceStatementContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

MySQLParser::UsePartitionContext* MySQLParser::ReplaceStatementContext::usePartition() {
  return getRuleContext<MySQLParser::UsePartitionContext>(0);
}

tree::TerminalNode* MySQLParser::ReplaceStatementContext::LOW_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::LOW_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReplaceStatementContext::DELAYED_SYMBOL() {
  return getToken(MySQLParser::DELAYED_SYMBOL, 0);
}


size_t MySQLParser::ReplaceStatementContext::getRuleIndex() const {
  return MySQLParser::RuleReplaceStatement;
}

void MySQLParser::ReplaceStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplaceStatement(this);
}

void MySQLParser::ReplaceStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplaceStatement(this);
}


antlrcpp::Any MySQLParser::ReplaceStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitReplaceStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ReplaceStatementContext* MySQLParser::replaceStatement() {
  ReplaceStatementContext *_localctx = _tracker.createInstance<ReplaceStatementContext>(_ctx, getState());
  enterRule(_localctx, 264, MySQLParser::RuleReplaceStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2815);
    match(MySQLParser::REPLACE_SYMBOL);
    setState(2817);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 273, _ctx)) {
    case 1: {
      setState(2816);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::DELAYED_SYMBOL || _la == MySQLParser::LOW_PRIORITY_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
    setState(2820);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 274, _ctx)) {
    case 1: {
      setState(2819);
      match(MySQLParser::INTO_SYMBOL);
      break;
    }

    }
    setState(2822);
    tableRef();
    setState(2824);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 275, _ctx)) {
    case 1: {
      setState(2823);
      usePartition();
      break;
    }

    }
    setState(2830);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 276, _ctx)) {
    case 1: {
      setState(2826);
      insertFromConstructor();
      break;
    }

    case 2: {
      setState(2827);
      match(MySQLParser::SET_SYMBOL);
      setState(2828);
      updateList();
      break;
    }

    case 3: {
      setState(2829);
      insertQueryExpression();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectStatementContext ------------------------------------------------------------------

MySQLParser::SelectStatementContext::SelectStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryExpressionContext* MySQLParser::SelectStatementContext::queryExpression() {
  return getRuleContext<MySQLParser::QueryExpressionContext>(0);
}

MySQLParser::QueryExpressionParensContext* MySQLParser::SelectStatementContext::queryExpressionParens() {
  return getRuleContext<MySQLParser::QueryExpressionParensContext>(0);
}

MySQLParser::SelectStatementWithIntoContext* MySQLParser::SelectStatementContext::selectStatementWithInto() {
  return getRuleContext<MySQLParser::SelectStatementWithIntoContext>(0);
}


size_t MySQLParser::SelectStatementContext::getRuleIndex() const {
  return MySQLParser::RuleSelectStatement;
}

void MySQLParser::SelectStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectStatement(this);
}

void MySQLParser::SelectStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectStatement(this);
}


antlrcpp::Any MySQLParser::SelectStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSelectStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SelectStatementContext* MySQLParser::selectStatement() {
  SelectStatementContext *_localctx = _tracker.createInstance<SelectStatementContext>(_ctx, getState());
  enterRule(_localctx, 266, MySQLParser::RuleSelectStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2835);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 277, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2832);
      queryExpression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2833);
      queryExpressionParens();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2834);
      selectStatementWithInto();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectStatementWithIntoContext ------------------------------------------------------------------

MySQLParser::SelectStatementWithIntoContext::SelectStatementWithIntoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SelectStatementWithIntoContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::SelectStatementWithIntoContext* MySQLParser::SelectStatementWithIntoContext::selectStatementWithInto() {
  return getRuleContext<MySQLParser::SelectStatementWithIntoContext>(0);
}

tree::TerminalNode* MySQLParser::SelectStatementWithIntoContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::QueryExpressionContext* MySQLParser::SelectStatementWithIntoContext::queryExpression() {
  return getRuleContext<MySQLParser::QueryExpressionContext>(0);
}

MySQLParser::IntoClauseContext* MySQLParser::SelectStatementWithIntoContext::intoClause() {
  return getRuleContext<MySQLParser::IntoClauseContext>(0);
}


size_t MySQLParser::SelectStatementWithIntoContext::getRuleIndex() const {
  return MySQLParser::RuleSelectStatementWithInto;
}

void MySQLParser::SelectStatementWithIntoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectStatementWithInto(this);
}

void MySQLParser::SelectStatementWithIntoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectStatementWithInto(this);
}


antlrcpp::Any MySQLParser::SelectStatementWithIntoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSelectStatementWithInto(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SelectStatementWithIntoContext* MySQLParser::selectStatementWithInto() {
  SelectStatementWithIntoContext *_localctx = _tracker.createInstance<SelectStatementWithIntoContext>(_ctx, getState());
  enterRule(_localctx, 268, MySQLParser::RuleSelectStatementWithInto);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2844);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 278, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2837);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(2838);
      selectStatementWithInto();
      setState(2839);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2841);
      queryExpression();
      setState(2842);
      intoClause();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryExpressionContext ------------------------------------------------------------------

MySQLParser::QueryExpressionContext::QueryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryExpressionBodyContext* MySQLParser::QueryExpressionContext::queryExpressionBody() {
  return getRuleContext<MySQLParser::QueryExpressionBodyContext>(0);
}

MySQLParser::QueryExpressionParensContext* MySQLParser::QueryExpressionContext::queryExpressionParens() {
  return getRuleContext<MySQLParser::QueryExpressionParensContext>(0);
}

MySQLParser::WithClauseContext* MySQLParser::QueryExpressionContext::withClause() {
  return getRuleContext<MySQLParser::WithClauseContext>(0);
}

MySQLParser::ProcedureAnalyseClauseContext* MySQLParser::QueryExpressionContext::procedureAnalyseClause() {
  return getRuleContext<MySQLParser::ProcedureAnalyseClauseContext>(0);
}

MySQLParser::LockingClauseContext* MySQLParser::QueryExpressionContext::lockingClause() {
  return getRuleContext<MySQLParser::LockingClauseContext>(0);
}

MySQLParser::OrderClauseContext* MySQLParser::QueryExpressionContext::orderClause() {
  return getRuleContext<MySQLParser::OrderClauseContext>(0);
}

MySQLParser::LimitClauseContext* MySQLParser::QueryExpressionContext::limitClause() {
  return getRuleContext<MySQLParser::LimitClauseContext>(0);
}


size_t MySQLParser::QueryExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleQueryExpression;
}

void MySQLParser::QueryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryExpression(this);
}

void MySQLParser::QueryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryExpression(this);
}


antlrcpp::Any MySQLParser::QueryExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitQueryExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::QueryExpressionContext* MySQLParser::queryExpression() {
  QueryExpressionContext *_localctx = _tracker.createInstance<QueryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 270, MySQLParser::RuleQueryExpression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2880);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 288, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2848);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 279, _ctx)) {
      case 1: {
        setState(2846);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(2847);
        withClause();
        break;
      }

      }
      setState(2865);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 284, _ctx)) {
      case 1: {
        setState(2850);
        queryExpressionBody(0);
        setState(2852);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 280, _ctx)) {
        case 1: {
          setState(2851);
          orderClause();
          break;
        }

        }
        setState(2855);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 281, _ctx)) {
        case 1: {
          setState(2854);
          limitClause();
          break;
        }

        }
        break;
      }

      case 2: {
        setState(2857);
        queryExpressionParens();
        setState(2863);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::ORDER_SYMBOL: {
            setState(2858);
            orderClause();
            setState(2860);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 282, _ctx)) {
            case 1: {
              setState(2859);
              limitClause();
              break;
            }

            }
            break;
          }

          case MySQLParser::LIMIT_SYMBOL: {
            setState(2862);
            limitClause();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      }
      setState(2869);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 285, _ctx)) {
      case 1: {
        setState(2867);

        if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
        setState(2868);
        procedureAnalyseClause();
        break;
      }

      }
      setState(2872);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FOR_SYMBOL

      || _la == MySQLParser::LOCK_SYMBOL) {
        setState(2871);
        lockingClause();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2874);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(2875);
      withClause();
      setState(2876);
      queryExpressionParens();
      setState(2878);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FOR_SYMBOL

      || _la == MySQLParser::LOCK_SYMBOL) {
        setState(2877);
        lockingClause();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryExpressionBodyContext ------------------------------------------------------------------

MySQLParser::QueryExpressionBodyContext::QueryExpressionBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QuerySpecificationContext* MySQLParser::QueryExpressionBodyContext::querySpecification() {
  return getRuleContext<MySQLParser::QuerySpecificationContext>(0);
}

std::vector<MySQLParser::QueryExpressionParensContext *> MySQLParser::QueryExpressionBodyContext::queryExpressionParens() {
  return getRuleContexts<MySQLParser::QueryExpressionParensContext>();
}

MySQLParser::QueryExpressionParensContext* MySQLParser::QueryExpressionBodyContext::queryExpressionParens(size_t i) {
  return getRuleContext<MySQLParser::QueryExpressionParensContext>(i);
}

tree::TerminalNode* MySQLParser::QueryExpressionBodyContext::UNION_SYMBOL() {
  return getToken(MySQLParser::UNION_SYMBOL, 0);
}

MySQLParser::UnionOptionContext* MySQLParser::QueryExpressionBodyContext::unionOption() {
  return getRuleContext<MySQLParser::UnionOptionContext>(0);
}

MySQLParser::QueryExpressionBodyContext* MySQLParser::QueryExpressionBodyContext::queryExpressionBody() {
  return getRuleContext<MySQLParser::QueryExpressionBodyContext>(0);
}


size_t MySQLParser::QueryExpressionBodyContext::getRuleIndex() const {
  return MySQLParser::RuleQueryExpressionBody;
}

void MySQLParser::QueryExpressionBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryExpressionBody(this);
}

void MySQLParser::QueryExpressionBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryExpressionBody(this);
}


antlrcpp::Any MySQLParser::QueryExpressionBodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitQueryExpressionBody(this);
  else
    return visitor->visitChildren(this);
}


MySQLParser::QueryExpressionBodyContext* MySQLParser::queryExpressionBody() {
   return queryExpressionBody(0);
}

MySQLParser::QueryExpressionBodyContext* MySQLParser::queryExpressionBody(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  MySQLParser::QueryExpressionBodyContext *_localctx = _tracker.createInstance<QueryExpressionBodyContext>(_ctx, parentState);
  MySQLParser::QueryExpressionBodyContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 272;
  enterRecursionRule(_localctx, 272, MySQLParser::RuleQueryExpressionBody, precedence);

    size_t _la = 0;

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2893);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::SELECT_SYMBOL: {
        setState(2883);
        querySpecification();
        break;
      }

      case MySQLParser::OPEN_PAR_SYMBOL: {
        setState(2884);
        queryExpressionParens();
        setState(2885);
        match(MySQLParser::UNION_SYMBOL);
        setState(2887);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ALL_SYMBOL

        || _la == MySQLParser::DISTINCT_SYMBOL) {
          setState(2886);
          unionOption();
        }
        setState(2891);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::SELECT_SYMBOL: {
            setState(2889);
            querySpecification();
            break;
          }

          case MySQLParser::OPEN_PAR_SYMBOL: {
            setState(2890);
            queryExpressionParens();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(2906);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 294, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<QueryExpressionBodyContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleQueryExpressionBody);
        setState(2895);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(2896);
        match(MySQLParser::UNION_SYMBOL);
        setState(2898);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ALL_SYMBOL

        || _la == MySQLParser::DISTINCT_SYMBOL) {
          setState(2897);
          unionOption();
        }
        setState(2902);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::SELECT_SYMBOL: {
            setState(2900);
            querySpecification();
            break;
          }

          case MySQLParser::OPEN_PAR_SYMBOL: {
            setState(2901);
            queryExpressionParens();
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(2908);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 294, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- QueryExpressionParensContext ------------------------------------------------------------------

MySQLParser::QueryExpressionParensContext::QueryExpressionParensContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::QueryExpressionParensContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::QueryExpressionParensContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::QueryExpressionParensContext* MySQLParser::QueryExpressionParensContext::queryExpressionParens() {
  return getRuleContext<MySQLParser::QueryExpressionParensContext>(0);
}

MySQLParser::QueryExpressionContext* MySQLParser::QueryExpressionParensContext::queryExpression() {
  return getRuleContext<MySQLParser::QueryExpressionContext>(0);
}


size_t MySQLParser::QueryExpressionParensContext::getRuleIndex() const {
  return MySQLParser::RuleQueryExpressionParens;
}

void MySQLParser::QueryExpressionParensContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryExpressionParens(this);
}

void MySQLParser::QueryExpressionParensContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryExpressionParens(this);
}


antlrcpp::Any MySQLParser::QueryExpressionParensContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitQueryExpressionParens(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::QueryExpressionParensContext* MySQLParser::queryExpressionParens() {
  QueryExpressionParensContext *_localctx = _tracker.createInstance<QueryExpressionParensContext>(_ctx, getState());
  enterRule(_localctx, 274, MySQLParser::RuleQueryExpressionParens);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2909);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(2912);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 295, _ctx)) {
    case 1: {
      setState(2910);
      queryExpressionParens();
      break;
    }

    case 2: {
      setState(2911);
      queryExpression();
      break;
    }

    }
    setState(2914);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuerySpecificationContext ------------------------------------------------------------------

MySQLParser::QuerySpecificationContext::QuerySpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::QuerySpecificationContext::SELECT_SYMBOL() {
  return getToken(MySQLParser::SELECT_SYMBOL, 0);
}

MySQLParser::SelectItemListContext* MySQLParser::QuerySpecificationContext::selectItemList() {
  return getRuleContext<MySQLParser::SelectItemListContext>(0);
}

std::vector<MySQLParser::SelectOptionContext *> MySQLParser::QuerySpecificationContext::selectOption() {
  return getRuleContexts<MySQLParser::SelectOptionContext>();
}

MySQLParser::SelectOptionContext* MySQLParser::QuerySpecificationContext::selectOption(size_t i) {
  return getRuleContext<MySQLParser::SelectOptionContext>(i);
}

MySQLParser::IntoClauseContext* MySQLParser::QuerySpecificationContext::intoClause() {
  return getRuleContext<MySQLParser::IntoClauseContext>(0);
}

MySQLParser::FromClauseContext* MySQLParser::QuerySpecificationContext::fromClause() {
  return getRuleContext<MySQLParser::FromClauseContext>(0);
}

MySQLParser::WhereClauseContext* MySQLParser::QuerySpecificationContext::whereClause() {
  return getRuleContext<MySQLParser::WhereClauseContext>(0);
}

MySQLParser::GroupByClauseContext* MySQLParser::QuerySpecificationContext::groupByClause() {
  return getRuleContext<MySQLParser::GroupByClauseContext>(0);
}

MySQLParser::HavingClauseContext* MySQLParser::QuerySpecificationContext::havingClause() {
  return getRuleContext<MySQLParser::HavingClauseContext>(0);
}

MySQLParser::WindowClauseContext* MySQLParser::QuerySpecificationContext::windowClause() {
  return getRuleContext<MySQLParser::WindowClauseContext>(0);
}


size_t MySQLParser::QuerySpecificationContext::getRuleIndex() const {
  return MySQLParser::RuleQuerySpecification;
}

void MySQLParser::QuerySpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuerySpecification(this);
}

void MySQLParser::QuerySpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuerySpecification(this);
}


antlrcpp::Any MySQLParser::QuerySpecificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitQuerySpecification(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::QuerySpecificationContext* MySQLParser::querySpecification() {
  QuerySpecificationContext *_localctx = _tracker.createInstance<QuerySpecificationContext>(_ctx, getState());
  enterRule(_localctx, 276, MySQLParser::RuleQuerySpecification);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2916);
    match(MySQLParser::SELECT_SYMBOL);
    setState(2920);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 296, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2917);
        selectOption(); 
      }
      setState(2922);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 296, _ctx);
    }
    setState(2923);
    selectItemList();
    setState(2925);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 297, _ctx)) {
    case 1: {
      setState(2924);
      intoClause();
      break;
    }

    }
    setState(2928);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 298, _ctx)) {
    case 1: {
      setState(2927);
      fromClause();
      break;
    }

    }
    setState(2931);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 299, _ctx)) {
    case 1: {
      setState(2930);
      whereClause();
      break;
    }

    }
    setState(2934);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 300, _ctx)) {
    case 1: {
      setState(2933);
      groupByClause();
      break;
    }

    }
    setState(2937);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 301, _ctx)) {
    case 1: {
      setState(2936);
      havingClause();
      break;
    }

    }
    setState(2941);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 302, _ctx)) {
    case 1: {
      setState(2939);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(2940);
      windowClause();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubqueryContext ------------------------------------------------------------------

MySQLParser::SubqueryContext::SubqueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryExpressionParensContext* MySQLParser::SubqueryContext::queryExpressionParens() {
  return getRuleContext<MySQLParser::QueryExpressionParensContext>(0);
}


size_t MySQLParser::SubqueryContext::getRuleIndex() const {
  return MySQLParser::RuleSubquery;
}

void MySQLParser::SubqueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubquery(this);
}

void MySQLParser::SubqueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubquery(this);
}


antlrcpp::Any MySQLParser::SubqueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSubquery(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SubqueryContext* MySQLParser::subquery() {
  SubqueryContext *_localctx = _tracker.createInstance<SubqueryContext>(_ctx, getState());
  enterRule(_localctx, 278, MySQLParser::RuleSubquery);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2943);
    queryExpressionParens();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuerySpecOptionContext ------------------------------------------------------------------

MySQLParser::QuerySpecOptionContext::QuerySpecOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::QuerySpecOptionContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::QuerySpecOptionContext::DISTINCT_SYMBOL() {
  return getToken(MySQLParser::DISTINCT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::QuerySpecOptionContext::STRAIGHT_JOIN_SYMBOL() {
  return getToken(MySQLParser::STRAIGHT_JOIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::QuerySpecOptionContext::HIGH_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::HIGH_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::QuerySpecOptionContext::SQL_SMALL_RESULT_SYMBOL() {
  return getToken(MySQLParser::SQL_SMALL_RESULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::QuerySpecOptionContext::SQL_BIG_RESULT_SYMBOL() {
  return getToken(MySQLParser::SQL_BIG_RESULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::QuerySpecOptionContext::SQL_BUFFER_RESULT_SYMBOL() {
  return getToken(MySQLParser::SQL_BUFFER_RESULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::QuerySpecOptionContext::SQL_CALC_FOUND_ROWS_SYMBOL() {
  return getToken(MySQLParser::SQL_CALC_FOUND_ROWS_SYMBOL, 0);
}


size_t MySQLParser::QuerySpecOptionContext::getRuleIndex() const {
  return MySQLParser::RuleQuerySpecOption;
}

void MySQLParser::QuerySpecOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuerySpecOption(this);
}

void MySQLParser::QuerySpecOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuerySpecOption(this);
}


antlrcpp::Any MySQLParser::QuerySpecOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitQuerySpecOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::QuerySpecOptionContext* MySQLParser::querySpecOption() {
  QuerySpecOptionContext *_localctx = _tracker.createInstance<QuerySpecOptionContext>(_ctx, getState());
  enterRule(_localctx, 280, MySQLParser::RuleQuerySpecOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2945);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::SQL_BUFFER_RESULT_SYMBOL || _la == MySQLParser::ALL_SYMBOL

    || _la == MySQLParser::DISTINCT_SYMBOL || _la == MySQLParser::HIGH_PRIORITY_SYMBOL || ((((_la - 628) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 628)) & ((1ULL << (MySQLParser::SQL_BIG_RESULT_SYMBOL - 628))
      | (1ULL << (MySQLParser::SQL_CALC_FOUND_ROWS_SYMBOL - 628))
      | (1ULL << (MySQLParser::SQL_SMALL_RESULT_SYMBOL - 628))
      | (1ULL << (MySQLParser::STRAIGHT_JOIN_SYMBOL - 628)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LimitClauseContext ------------------------------------------------------------------

MySQLParser::LimitClauseContext::LimitClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LimitClauseContext::LIMIT_SYMBOL() {
  return getToken(MySQLParser::LIMIT_SYMBOL, 0);
}

MySQLParser::LimitOptionsContext* MySQLParser::LimitClauseContext::limitOptions() {
  return getRuleContext<MySQLParser::LimitOptionsContext>(0);
}


size_t MySQLParser::LimitClauseContext::getRuleIndex() const {
  return MySQLParser::RuleLimitClause;
}

void MySQLParser::LimitClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLimitClause(this);
}

void MySQLParser::LimitClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLimitClause(this);
}


antlrcpp::Any MySQLParser::LimitClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLimitClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LimitClauseContext* MySQLParser::limitClause() {
  LimitClauseContext *_localctx = _tracker.createInstance<LimitClauseContext>(_ctx, getState());
  enterRule(_localctx, 282, MySQLParser::RuleLimitClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2947);
    match(MySQLParser::LIMIT_SYMBOL);
    setState(2948);
    limitOptions();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleLimitClauseContext ------------------------------------------------------------------

MySQLParser::SimpleLimitClauseContext::SimpleLimitClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SimpleLimitClauseContext::LIMIT_SYMBOL() {
  return getToken(MySQLParser::LIMIT_SYMBOL, 0);
}

MySQLParser::LimitOptionContext* MySQLParser::SimpleLimitClauseContext::limitOption() {
  return getRuleContext<MySQLParser::LimitOptionContext>(0);
}


size_t MySQLParser::SimpleLimitClauseContext::getRuleIndex() const {
  return MySQLParser::RuleSimpleLimitClause;
}

void MySQLParser::SimpleLimitClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleLimitClause(this);
}

void MySQLParser::SimpleLimitClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleLimitClause(this);
}


antlrcpp::Any MySQLParser::SimpleLimitClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleLimitClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SimpleLimitClauseContext* MySQLParser::simpleLimitClause() {
  SimpleLimitClauseContext *_localctx = _tracker.createInstance<SimpleLimitClauseContext>(_ctx, getState());
  enterRule(_localctx, 284, MySQLParser::RuleSimpleLimitClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2950);
    match(MySQLParser::LIMIT_SYMBOL);
    setState(2951);
    limitOption();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LimitOptionsContext ------------------------------------------------------------------

MySQLParser::LimitOptionsContext::LimitOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::LimitOptionContext *> MySQLParser::LimitOptionsContext::limitOption() {
  return getRuleContexts<MySQLParser::LimitOptionContext>();
}

MySQLParser::LimitOptionContext* MySQLParser::LimitOptionsContext::limitOption(size_t i) {
  return getRuleContext<MySQLParser::LimitOptionContext>(i);
}

tree::TerminalNode* MySQLParser::LimitOptionsContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LimitOptionsContext::OFFSET_SYMBOL() {
  return getToken(MySQLParser::OFFSET_SYMBOL, 0);
}


size_t MySQLParser::LimitOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleLimitOptions;
}

void MySQLParser::LimitOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLimitOptions(this);
}

void MySQLParser::LimitOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLimitOptions(this);
}


antlrcpp::Any MySQLParser::LimitOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLimitOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LimitOptionsContext* MySQLParser::limitOptions() {
  LimitOptionsContext *_localctx = _tracker.createInstance<LimitOptionsContext>(_ctx, getState());
  enterRule(_localctx, 286, MySQLParser::RuleLimitOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2953);
    limitOption();
    setState(2956);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 303, _ctx)) {
    case 1: {
      setState(2954);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::OFFSET_SYMBOL || _la == MySQLParser::COMMA_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2955);
      limitOption();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LimitOptionContext ------------------------------------------------------------------

MySQLParser::LimitOptionContext::LimitOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::LimitOptionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::LimitOptionContext::PARAM_MARKER() {
  return getToken(MySQLParser::PARAM_MARKER, 0);
}

tree::TerminalNode* MySQLParser::LimitOptionContext::ULONGLONG_NUMBER() {
  return getToken(MySQLParser::ULONGLONG_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::LimitOptionContext::LONG_NUMBER() {
  return getToken(MySQLParser::LONG_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::LimitOptionContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}


size_t MySQLParser::LimitOptionContext::getRuleIndex() const {
  return MySQLParser::RuleLimitOption;
}

void MySQLParser::LimitOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLimitOption(this);
}

void MySQLParser::LimitOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLimitOption(this);
}


antlrcpp::Any MySQLParser::LimitOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLimitOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LimitOptionContext* MySQLParser::limitOption() {
  LimitOptionContext *_localctx = _tracker.createInstance<LimitOptionContext>(_ctx, getState());
  enterRule(_localctx, 288, MySQLParser::RuleLimitOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2960);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 304, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2958);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2959);
      _la = _input->LA(1);
      if (!(((((_la - 380) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 380)) & ((1ULL << (MySQLParser::INT_NUMBER - 380))
        | (1ULL << (MySQLParser::LONG_NUMBER - 380))
        | (1ULL << (MySQLParser::ULONGLONG_NUMBER - 380))
        | (1ULL << (MySQLParser::PARAM_MARKER - 380)))) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntoClauseContext ------------------------------------------------------------------

MySQLParser::IntoClauseContext::IntoClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IntoClauseContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntoClauseContext::OUTFILE_SYMBOL() {
  return getToken(MySQLParser::OUTFILE_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::IntoClauseContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::IntoClauseContext::DUMPFILE_SYMBOL() {
  return getToken(MySQLParser::DUMPFILE_SYMBOL, 0);
}

std::vector<MySQLParser::TextOrIdentifierContext *> MySQLParser::IntoClauseContext::textOrIdentifier() {
  return getRuleContexts<MySQLParser::TextOrIdentifierContext>();
}

MySQLParser::TextOrIdentifierContext* MySQLParser::IntoClauseContext::textOrIdentifier(size_t i) {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(i);
}

std::vector<MySQLParser::UserVariableContext *> MySQLParser::IntoClauseContext::userVariable() {
  return getRuleContexts<MySQLParser::UserVariableContext>();
}

MySQLParser::UserVariableContext* MySQLParser::IntoClauseContext::userVariable(size_t i) {
  return getRuleContext<MySQLParser::UserVariableContext>(i);
}

MySQLParser::CharsetClauseContext* MySQLParser::IntoClauseContext::charsetClause() {
  return getRuleContext<MySQLParser::CharsetClauseContext>(0);
}

MySQLParser::FieldsClauseContext* MySQLParser::IntoClauseContext::fieldsClause() {
  return getRuleContext<MySQLParser::FieldsClauseContext>(0);
}

MySQLParser::LinesClauseContext* MySQLParser::IntoClauseContext::linesClause() {
  return getRuleContext<MySQLParser::LinesClauseContext>(0);
}

std::vector<tree::TerminalNode *> MySQLParser::IntoClauseContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::IntoClauseContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::IntoClauseContext::getRuleIndex() const {
  return MySQLParser::RuleIntoClause;
}

void MySQLParser::IntoClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntoClause(this);
}

void MySQLParser::IntoClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntoClause(this);
}


antlrcpp::Any MySQLParser::IntoClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIntoClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IntoClauseContext* MySQLParser::intoClause() {
  IntoClauseContext *_localctx = _tracker.createInstance<IntoClauseContext>(_ctx, getState());
  enterRule(_localctx, 290, MySQLParser::RuleIntoClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2962);
    match(MySQLParser::INTO_SYMBOL);
    setState(2990);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 311, _ctx)) {
    case 1: {
      setState(2963);
      match(MySQLParser::OUTFILE_SYMBOL);
      setState(2964);
      textStringLiteral();
      setState(2966);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 305, _ctx)) {
      case 1: {
        setState(2965);
        charsetClause();
        break;
      }

      }
      setState(2969);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 306, _ctx)) {
      case 1: {
        setState(2968);
        fieldsClause();
        break;
      }

      }
      setState(2972);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 307, _ctx)) {
      case 1: {
        setState(2971);
        linesClause();
        break;
      }

      }
      break;
    }

    case 2: {
      setState(2974);
      match(MySQLParser::DUMPFILE_SYMBOL);
      setState(2975);
      textStringLiteral();
      break;
    }

    case 3: {
      setState(2978);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 308, _ctx)) {
      case 1: {
        setState(2976);
        textOrIdentifier();
        break;
      }

      case 2: {
        setState(2977);
        userVariable();
        break;
      }

      }
      setState(2987);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 310, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2980);
          match(MySQLParser::COMMA_SYMBOL);
          setState(2983);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 309, _ctx)) {
          case 1: {
            setState(2981);
            textOrIdentifier();
            break;
          }

          case 2: {
            setState(2982);
            userVariable();
            break;
          }

          } 
        }
        setState(2989);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 310, _ctx);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureAnalyseClauseContext ------------------------------------------------------------------

MySQLParser::ProcedureAnalyseClauseContext::ProcedureAnalyseClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ProcedureAnalyseClauseContext::PROCEDURE_SYMBOL() {
  return getToken(MySQLParser::PROCEDURE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProcedureAnalyseClauseContext::ANALYSE_SYMBOL() {
  return getToken(MySQLParser::ANALYSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProcedureAnalyseClauseContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProcedureAnalyseClauseContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::ProcedureAnalyseClauseContext::INT_NUMBER() {
  return getTokens(MySQLParser::INT_NUMBER);
}

tree::TerminalNode* MySQLParser::ProcedureAnalyseClauseContext::INT_NUMBER(size_t i) {
  return getToken(MySQLParser::INT_NUMBER, i);
}

tree::TerminalNode* MySQLParser::ProcedureAnalyseClauseContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}


size_t MySQLParser::ProcedureAnalyseClauseContext::getRuleIndex() const {
  return MySQLParser::RuleProcedureAnalyseClause;
}

void MySQLParser::ProcedureAnalyseClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureAnalyseClause(this);
}

void MySQLParser::ProcedureAnalyseClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureAnalyseClause(this);
}


antlrcpp::Any MySQLParser::ProcedureAnalyseClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitProcedureAnalyseClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ProcedureAnalyseClauseContext* MySQLParser::procedureAnalyseClause() {
  ProcedureAnalyseClauseContext *_localctx = _tracker.createInstance<ProcedureAnalyseClauseContext>(_ctx, getState());
  enterRule(_localctx, 292, MySQLParser::RuleProcedureAnalyseClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2992);
    match(MySQLParser::PROCEDURE_SYMBOL);
    setState(2993);
    match(MySQLParser::ANALYSE_SYMBOL);
    setState(2994);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3000);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::INT_NUMBER) {
      setState(2995);
      match(MySQLParser::INT_NUMBER);
      setState(2998);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(2996);
        match(MySQLParser::COMMA_SYMBOL);
        setState(2997);
        match(MySQLParser::INT_NUMBER);
      }
    }
    setState(3002);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HavingClauseContext ------------------------------------------------------------------

MySQLParser::HavingClauseContext::HavingClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::HavingClauseContext::HAVING_SYMBOL() {
  return getToken(MySQLParser::HAVING_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::HavingClauseContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}


size_t MySQLParser::HavingClauseContext::getRuleIndex() const {
  return MySQLParser::RuleHavingClause;
}

void MySQLParser::HavingClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHavingClause(this);
}

void MySQLParser::HavingClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHavingClause(this);
}


antlrcpp::Any MySQLParser::HavingClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitHavingClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::HavingClauseContext* MySQLParser::havingClause() {
  HavingClauseContext *_localctx = _tracker.createInstance<HavingClauseContext>(_ctx, getState());
  enterRule(_localctx, 294, MySQLParser::RuleHavingClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3004);
    match(MySQLParser::HAVING_SYMBOL);
    setState(3005);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowClauseContext ------------------------------------------------------------------

MySQLParser::WindowClauseContext::WindowClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WindowClauseContext::WINDOW_SYMBOL() {
  return getToken(MySQLParser::WINDOW_SYMBOL, 0);
}

std::vector<MySQLParser::WindowDefinitionContext *> MySQLParser::WindowClauseContext::windowDefinition() {
  return getRuleContexts<MySQLParser::WindowDefinitionContext>();
}

MySQLParser::WindowDefinitionContext* MySQLParser::WindowClauseContext::windowDefinition(size_t i) {
  return getRuleContext<MySQLParser::WindowDefinitionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::WindowClauseContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::WindowClauseContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::WindowClauseContext::getRuleIndex() const {
  return MySQLParser::RuleWindowClause;
}

void MySQLParser::WindowClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowClause(this);
}

void MySQLParser::WindowClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowClause(this);
}


antlrcpp::Any MySQLParser::WindowClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitWindowClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowClauseContext* MySQLParser::windowClause() {
  WindowClauseContext *_localctx = _tracker.createInstance<WindowClauseContext>(_ctx, getState());
  enterRule(_localctx, 296, MySQLParser::RuleWindowClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3007);
    match(MySQLParser::WINDOW_SYMBOL);
    setState(3008);
    windowDefinition();
    setState(3013);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 314, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3009);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3010);
        windowDefinition(); 
      }
      setState(3015);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 314, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowDefinitionContext ------------------------------------------------------------------

MySQLParser::WindowDefinitionContext::WindowDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::WindowNameContext* MySQLParser::WindowDefinitionContext::windowName() {
  return getRuleContext<MySQLParser::WindowNameContext>(0);
}

tree::TerminalNode* MySQLParser::WindowDefinitionContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::WindowSpecContext* MySQLParser::WindowDefinitionContext::windowSpec() {
  return getRuleContext<MySQLParser::WindowSpecContext>(0);
}


size_t MySQLParser::WindowDefinitionContext::getRuleIndex() const {
  return MySQLParser::RuleWindowDefinition;
}

void MySQLParser::WindowDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowDefinition(this);
}

void MySQLParser::WindowDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowDefinition(this);
}


antlrcpp::Any MySQLParser::WindowDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitWindowDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowDefinitionContext* MySQLParser::windowDefinition() {
  WindowDefinitionContext *_localctx = _tracker.createInstance<WindowDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 298, MySQLParser::RuleWindowDefinition);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3016);
    windowName();
    setState(3017);
    match(MySQLParser::AS_SYMBOL);
    setState(3018);
    windowSpec();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowSpecContext ------------------------------------------------------------------

MySQLParser::WindowSpecContext::WindowSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WindowSpecContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::WindowSpecDetailsContext* MySQLParser::WindowSpecContext::windowSpecDetails() {
  return getRuleContext<MySQLParser::WindowSpecDetailsContext>(0);
}

tree::TerminalNode* MySQLParser::WindowSpecContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::WindowSpecContext::getRuleIndex() const {
  return MySQLParser::RuleWindowSpec;
}

void MySQLParser::WindowSpecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowSpec(this);
}

void MySQLParser::WindowSpecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowSpec(this);
}


antlrcpp::Any MySQLParser::WindowSpecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitWindowSpec(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowSpecContext* MySQLParser::windowSpec() {
  WindowSpecContext *_localctx = _tracker.createInstance<WindowSpecContext>(_ctx, getState());
  enterRule(_localctx, 300, MySQLParser::RuleWindowSpec);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3020);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3021);
    windowSpecDetails();
    setState(3022);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowSpecDetailsContext ------------------------------------------------------------------

MySQLParser::WindowSpecDetailsContext::WindowSpecDetailsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::WindowNameContext* MySQLParser::WindowSpecDetailsContext::windowName() {
  return getRuleContext<MySQLParser::WindowNameContext>(0);
}

tree::TerminalNode* MySQLParser::WindowSpecDetailsContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowSpecDetailsContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::OrderListContext* MySQLParser::WindowSpecDetailsContext::orderList() {
  return getRuleContext<MySQLParser::OrderListContext>(0);
}

MySQLParser::OrderClauseContext* MySQLParser::WindowSpecDetailsContext::orderClause() {
  return getRuleContext<MySQLParser::OrderClauseContext>(0);
}

MySQLParser::WindowFrameClauseContext* MySQLParser::WindowSpecDetailsContext::windowFrameClause() {
  return getRuleContext<MySQLParser::WindowFrameClauseContext>(0);
}


size_t MySQLParser::WindowSpecDetailsContext::getRuleIndex() const {
  return MySQLParser::RuleWindowSpecDetails;
}

void MySQLParser::WindowSpecDetailsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowSpecDetails(this);
}

void MySQLParser::WindowSpecDetailsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowSpecDetails(this);
}


antlrcpp::Any MySQLParser::WindowSpecDetailsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitWindowSpecDetails(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowSpecDetailsContext* MySQLParser::windowSpecDetails() {
  WindowSpecDetailsContext *_localctx = _tracker.createInstance<WindowSpecDetailsContext>(_ctx, getState());
  enterRule(_localctx, 302, MySQLParser::RuleWindowSpecDetails);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3025);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 315, _ctx)) {
    case 1: {
      setState(3024);
      windowName();
      break;
    }

    }
    setState(3030);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::PARTITION_SYMBOL) {
      setState(3027);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(3028);
      match(MySQLParser::BY_SYMBOL);
      setState(3029);
      orderList();
    }
    setState(3033);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ORDER_SYMBOL) {
      setState(3032);
      orderClause();
    }
    setState(3036);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ROWS_SYMBOL || _la == MySQLParser::RANGE_SYMBOL || _la == MySQLParser::GROUPS_SYMBOL) {
      setState(3035);
      windowFrameClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFrameClauseContext ------------------------------------------------------------------

MySQLParser::WindowFrameClauseContext::WindowFrameClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::WindowFrameUnitsContext* MySQLParser::WindowFrameClauseContext::windowFrameUnits() {
  return getRuleContext<MySQLParser::WindowFrameUnitsContext>(0);
}

MySQLParser::WindowFrameExtentContext* MySQLParser::WindowFrameClauseContext::windowFrameExtent() {
  return getRuleContext<MySQLParser::WindowFrameExtentContext>(0);
}

MySQLParser::WindowFrameExclusionContext* MySQLParser::WindowFrameClauseContext::windowFrameExclusion() {
  return getRuleContext<MySQLParser::WindowFrameExclusionContext>(0);
}


size_t MySQLParser::WindowFrameClauseContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFrameClause;
}

void MySQLParser::WindowFrameClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFrameClause(this);
}

void MySQLParser::WindowFrameClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFrameClause(this);
}


antlrcpp::Any MySQLParser::WindowFrameClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitWindowFrameClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowFrameClauseContext* MySQLParser::windowFrameClause() {
  WindowFrameClauseContext *_localctx = _tracker.createInstance<WindowFrameClauseContext>(_ctx, getState());
  enterRule(_localctx, 304, MySQLParser::RuleWindowFrameClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3038);
    windowFrameUnits();
    setState(3039);
    windowFrameExtent();
    setState(3041);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::EXCLUDE_SYMBOL) {
      setState(3040);
      windowFrameExclusion();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFrameUnitsContext ------------------------------------------------------------------

MySQLParser::WindowFrameUnitsContext::WindowFrameUnitsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WindowFrameUnitsContext::ROWS_SYMBOL() {
  return getToken(MySQLParser::ROWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameUnitsContext::RANGE_SYMBOL() {
  return getToken(MySQLParser::RANGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameUnitsContext::GROUPS_SYMBOL() {
  return getToken(MySQLParser::GROUPS_SYMBOL, 0);
}


size_t MySQLParser::WindowFrameUnitsContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFrameUnits;
}

void MySQLParser::WindowFrameUnitsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFrameUnits(this);
}

void MySQLParser::WindowFrameUnitsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFrameUnits(this);
}


antlrcpp::Any MySQLParser::WindowFrameUnitsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitWindowFrameUnits(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowFrameUnitsContext* MySQLParser::windowFrameUnits() {
  WindowFrameUnitsContext *_localctx = _tracker.createInstance<WindowFrameUnitsContext>(_ctx, getState());
  enterRule(_localctx, 306, MySQLParser::RuleWindowFrameUnits);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3043);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::ROWS_SYMBOL || _la == MySQLParser::RANGE_SYMBOL || _la == MySQLParser::GROUPS_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFrameExtentContext ------------------------------------------------------------------

MySQLParser::WindowFrameExtentContext::WindowFrameExtentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::WindowFrameStartContext* MySQLParser::WindowFrameExtentContext::windowFrameStart() {
  return getRuleContext<MySQLParser::WindowFrameStartContext>(0);
}

MySQLParser::WindowFrameBetweenContext* MySQLParser::WindowFrameExtentContext::windowFrameBetween() {
  return getRuleContext<MySQLParser::WindowFrameBetweenContext>(0);
}


size_t MySQLParser::WindowFrameExtentContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFrameExtent;
}

void MySQLParser::WindowFrameExtentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFrameExtent(this);
}

void MySQLParser::WindowFrameExtentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFrameExtent(this);
}


antlrcpp::Any MySQLParser::WindowFrameExtentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitWindowFrameExtent(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowFrameExtentContext* MySQLParser::windowFrameExtent() {
  WindowFrameExtentContext *_localctx = _tracker.createInstance<WindowFrameExtentContext>(_ctx, getState());
  enterRule(_localctx, 308, MySQLParser::RuleWindowFrameExtent);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3047);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CURRENT_SYMBOL:
      case MySQLParser::INT_NUMBER:
      case MySQLParser::LONG_NUMBER:
      case MySQLParser::ULONGLONG_NUMBER:
      case MySQLParser::PARAM_MARKER:
      case MySQLParser::DECIMAL_NUMBER:
      case MySQLParser::FLOAT_NUMBER:
      case MySQLParser::INTERVAL_SYMBOL:
      case MySQLParser::UNBOUNDED_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3045);
        windowFrameStart();
        break;
      }

      case MySQLParser::BETWEEN_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3046);
        windowFrameBetween();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFrameStartContext ------------------------------------------------------------------

MySQLParser::WindowFrameStartContext::WindowFrameStartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WindowFrameStartContext::UNBOUNDED_SYMBOL() {
  return getToken(MySQLParser::UNBOUNDED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameStartContext::PRECEDING_SYMBOL() {
  return getToken(MySQLParser::PRECEDING_SYMBOL, 0);
}

MySQLParser::Ulonglong_numberContext* MySQLParser::WindowFrameStartContext::ulonglong_number() {
  return getRuleContext<MySQLParser::Ulonglong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::WindowFrameStartContext::PARAM_MARKER() {
  return getToken(MySQLParser::PARAM_MARKER, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameStartContext::INTERVAL_SYMBOL() {
  return getToken(MySQLParser::INTERVAL_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::WindowFrameStartContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::IntervalContext* MySQLParser::WindowFrameStartContext::interval() {
  return getRuleContext<MySQLParser::IntervalContext>(0);
}

tree::TerminalNode* MySQLParser::WindowFrameStartContext::CURRENT_SYMBOL() {
  return getToken(MySQLParser::CURRENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameStartContext::ROW_SYMBOL() {
  return getToken(MySQLParser::ROW_SYMBOL, 0);
}


size_t MySQLParser::WindowFrameStartContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFrameStart;
}

void MySQLParser::WindowFrameStartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFrameStart(this);
}

void MySQLParser::WindowFrameStartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFrameStart(this);
}


antlrcpp::Any MySQLParser::WindowFrameStartContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitWindowFrameStart(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowFrameStartContext* MySQLParser::windowFrameStart() {
  WindowFrameStartContext *_localctx = _tracker.createInstance<WindowFrameStartContext>(_ctx, getState());
  enterRule(_localctx, 310, MySQLParser::RuleWindowFrameStart);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3063);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::UNBOUNDED_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3049);
        match(MySQLParser::UNBOUNDED_SYMBOL);
        setState(3050);
        match(MySQLParser::PRECEDING_SYMBOL);
        break;
      }

      case MySQLParser::INT_NUMBER:
      case MySQLParser::LONG_NUMBER:
      case MySQLParser::ULONGLONG_NUMBER:
      case MySQLParser::DECIMAL_NUMBER:
      case MySQLParser::FLOAT_NUMBER: {
        enterOuterAlt(_localctx, 2);
        setState(3051);
        ulonglong_number();
        setState(3052);
        match(MySQLParser::PRECEDING_SYMBOL);
        break;
      }

      case MySQLParser::PARAM_MARKER: {
        enterOuterAlt(_localctx, 3);
        setState(3054);
        match(MySQLParser::PARAM_MARKER);
        setState(3055);
        match(MySQLParser::PRECEDING_SYMBOL);
        break;
      }

      case MySQLParser::INTERVAL_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(3056);
        match(MySQLParser::INTERVAL_SYMBOL);
        setState(3057);
        expr(0);
        setState(3058);
        interval();
        setState(3059);
        match(MySQLParser::PRECEDING_SYMBOL);
        break;
      }

      case MySQLParser::CURRENT_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(3061);
        match(MySQLParser::CURRENT_SYMBOL);
        setState(3062);
        match(MySQLParser::ROW_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFrameBetweenContext ------------------------------------------------------------------

MySQLParser::WindowFrameBetweenContext::WindowFrameBetweenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WindowFrameBetweenContext::BETWEEN_SYMBOL() {
  return getToken(MySQLParser::BETWEEN_SYMBOL, 0);
}

std::vector<MySQLParser::WindowFrameBoundContext *> MySQLParser::WindowFrameBetweenContext::windowFrameBound() {
  return getRuleContexts<MySQLParser::WindowFrameBoundContext>();
}

MySQLParser::WindowFrameBoundContext* MySQLParser::WindowFrameBetweenContext::windowFrameBound(size_t i) {
  return getRuleContext<MySQLParser::WindowFrameBoundContext>(i);
}

tree::TerminalNode* MySQLParser::WindowFrameBetweenContext::AND_SYMBOL() {
  return getToken(MySQLParser::AND_SYMBOL, 0);
}


size_t MySQLParser::WindowFrameBetweenContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFrameBetween;
}

void MySQLParser::WindowFrameBetweenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFrameBetween(this);
}

void MySQLParser::WindowFrameBetweenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFrameBetween(this);
}


antlrcpp::Any MySQLParser::WindowFrameBetweenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitWindowFrameBetween(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowFrameBetweenContext* MySQLParser::windowFrameBetween() {
  WindowFrameBetweenContext *_localctx = _tracker.createInstance<WindowFrameBetweenContext>(_ctx, getState());
  enterRule(_localctx, 312, MySQLParser::RuleWindowFrameBetween);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3065);
    match(MySQLParser::BETWEEN_SYMBOL);
    setState(3066);
    windowFrameBound();
    setState(3067);
    match(MySQLParser::AND_SYMBOL);
    setState(3068);
    windowFrameBound();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFrameBoundContext ------------------------------------------------------------------

MySQLParser::WindowFrameBoundContext::WindowFrameBoundContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::WindowFrameStartContext* MySQLParser::WindowFrameBoundContext::windowFrameStart() {
  return getRuleContext<MySQLParser::WindowFrameStartContext>(0);
}

tree::TerminalNode* MySQLParser::WindowFrameBoundContext::UNBOUNDED_SYMBOL() {
  return getToken(MySQLParser::UNBOUNDED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameBoundContext::FOLLOWING_SYMBOL() {
  return getToken(MySQLParser::FOLLOWING_SYMBOL, 0);
}

MySQLParser::Ulonglong_numberContext* MySQLParser::WindowFrameBoundContext::ulonglong_number() {
  return getRuleContext<MySQLParser::Ulonglong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::WindowFrameBoundContext::PARAM_MARKER() {
  return getToken(MySQLParser::PARAM_MARKER, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameBoundContext::INTERVAL_SYMBOL() {
  return getToken(MySQLParser::INTERVAL_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::WindowFrameBoundContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::IntervalContext* MySQLParser::WindowFrameBoundContext::interval() {
  return getRuleContext<MySQLParser::IntervalContext>(0);
}


size_t MySQLParser::WindowFrameBoundContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFrameBound;
}

void MySQLParser::WindowFrameBoundContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFrameBound(this);
}

void MySQLParser::WindowFrameBoundContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFrameBound(this);
}


antlrcpp::Any MySQLParser::WindowFrameBoundContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitWindowFrameBound(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowFrameBoundContext* MySQLParser::windowFrameBound() {
  WindowFrameBoundContext *_localctx = _tracker.createInstance<WindowFrameBoundContext>(_ctx, getState());
  enterRule(_localctx, 314, MySQLParser::RuleWindowFrameBound);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3083);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 322, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3070);
      windowFrameStart();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3071);
      match(MySQLParser::UNBOUNDED_SYMBOL);
      setState(3072);
      match(MySQLParser::FOLLOWING_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3073);
      ulonglong_number();
      setState(3074);
      match(MySQLParser::FOLLOWING_SYMBOL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3076);
      match(MySQLParser::PARAM_MARKER);
      setState(3077);
      match(MySQLParser::FOLLOWING_SYMBOL);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3078);
      match(MySQLParser::INTERVAL_SYMBOL);
      setState(3079);
      expr(0);
      setState(3080);
      interval();
      setState(3081);
      match(MySQLParser::FOLLOWING_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFrameExclusionContext ------------------------------------------------------------------

MySQLParser::WindowFrameExclusionContext::WindowFrameExclusionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WindowFrameExclusionContext::EXCLUDE_SYMBOL() {
  return getToken(MySQLParser::EXCLUDE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameExclusionContext::CURRENT_SYMBOL() {
  return getToken(MySQLParser::CURRENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameExclusionContext::ROW_SYMBOL() {
  return getToken(MySQLParser::ROW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameExclusionContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameExclusionContext::TIES_SYMBOL() {
  return getToken(MySQLParser::TIES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameExclusionContext::NO_SYMBOL() {
  return getToken(MySQLParser::NO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameExclusionContext::OTHERS_SYMBOL() {
  return getToken(MySQLParser::OTHERS_SYMBOL, 0);
}


size_t MySQLParser::WindowFrameExclusionContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFrameExclusion;
}

void MySQLParser::WindowFrameExclusionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFrameExclusion(this);
}

void MySQLParser::WindowFrameExclusionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFrameExclusion(this);
}


antlrcpp::Any MySQLParser::WindowFrameExclusionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitWindowFrameExclusion(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowFrameExclusionContext* MySQLParser::windowFrameExclusion() {
  WindowFrameExclusionContext *_localctx = _tracker.createInstance<WindowFrameExclusionContext>(_ctx, getState());
  enterRule(_localctx, 316, MySQLParser::RuleWindowFrameExclusion);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3085);
    match(MySQLParser::EXCLUDE_SYMBOL);
    setState(3092);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CURRENT_SYMBOL: {
        setState(3086);
        match(MySQLParser::CURRENT_SYMBOL);
        setState(3087);
        match(MySQLParser::ROW_SYMBOL);
        break;
      }

      case MySQLParser::GROUP_SYMBOL: {
        setState(3088);
        match(MySQLParser::GROUP_SYMBOL);
        break;
      }

      case MySQLParser::TIES_SYMBOL: {
        setState(3089);
        match(MySQLParser::TIES_SYMBOL);
        break;
      }

      case MySQLParser::NO_SYMBOL: {
        setState(3090);
        match(MySQLParser::NO_SYMBOL);
        setState(3091);
        match(MySQLParser::OTHERS_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WithClauseContext ------------------------------------------------------------------

MySQLParser::WithClauseContext::WithClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WithClauseContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

std::vector<MySQLParser::CommonTableExpressionContext *> MySQLParser::WithClauseContext::commonTableExpression() {
  return getRuleContexts<MySQLParser::CommonTableExpressionContext>();
}

MySQLParser::CommonTableExpressionContext* MySQLParser::WithClauseContext::commonTableExpression(size_t i) {
  return getRuleContext<MySQLParser::CommonTableExpressionContext>(i);
}

tree::TerminalNode* MySQLParser::WithClauseContext::RECURSIVE_SYMBOL() {
  return getToken(MySQLParser::RECURSIVE_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::WithClauseContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::WithClauseContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::WithClauseContext::getRuleIndex() const {
  return MySQLParser::RuleWithClause;
}

void MySQLParser::WithClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWithClause(this);
}

void MySQLParser::WithClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWithClause(this);
}


antlrcpp::Any MySQLParser::WithClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitWithClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WithClauseContext* MySQLParser::withClause() {
  WithClauseContext *_localctx = _tracker.createInstance<WithClauseContext>(_ctx, getState());
  enterRule(_localctx, 318, MySQLParser::RuleWithClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3094);
    match(MySQLParser::WITH_SYMBOL);
    setState(3096);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 324, _ctx)) {
    case 1: {
      setState(3095);
      match(MySQLParser::RECURSIVE_SYMBOL);
      break;
    }

    }
    setState(3098);
    commonTableExpression();
    setState(3103);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(3099);
      match(MySQLParser::COMMA_SYMBOL);
      setState(3100);
      commonTableExpression();
      setState(3105);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommonTableExpressionContext ------------------------------------------------------------------

MySQLParser::CommonTableExpressionContext::CommonTableExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::CommonTableExpressionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::CommonTableExpressionContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::SubqueryContext* MySQLParser::CommonTableExpressionContext::subquery() {
  return getRuleContext<MySQLParser::SubqueryContext>(0);
}

MySQLParser::ColumnInternalRefListContext* MySQLParser::CommonTableExpressionContext::columnInternalRefList() {
  return getRuleContext<MySQLParser::ColumnInternalRefListContext>(0);
}


size_t MySQLParser::CommonTableExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleCommonTableExpression;
}

void MySQLParser::CommonTableExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommonTableExpression(this);
}

void MySQLParser::CommonTableExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommonTableExpression(this);
}


antlrcpp::Any MySQLParser::CommonTableExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCommonTableExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CommonTableExpressionContext* MySQLParser::commonTableExpression() {
  CommonTableExpressionContext *_localctx = _tracker.createInstance<CommonTableExpressionContext>(_ctx, getState());
  enterRule(_localctx, 320, MySQLParser::RuleCommonTableExpression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3106);
    identifier();
    setState(3108);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(3107);
      columnInternalRefList();
    }
    setState(3110);
    match(MySQLParser::AS_SYMBOL);
    setState(3111);
    subquery();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupByClauseContext ------------------------------------------------------------------

MySQLParser::GroupByClauseContext::GroupByClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::GroupByClauseContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GroupByClauseContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::OrderListContext* MySQLParser::GroupByClauseContext::orderList() {
  return getRuleContext<MySQLParser::OrderListContext>(0);
}

MySQLParser::OlapOptionContext* MySQLParser::GroupByClauseContext::olapOption() {
  return getRuleContext<MySQLParser::OlapOptionContext>(0);
}


size_t MySQLParser::GroupByClauseContext::getRuleIndex() const {
  return MySQLParser::RuleGroupByClause;
}

void MySQLParser::GroupByClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupByClause(this);
}

void MySQLParser::GroupByClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupByClause(this);
}


antlrcpp::Any MySQLParser::GroupByClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitGroupByClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GroupByClauseContext* MySQLParser::groupByClause() {
  GroupByClauseContext *_localctx = _tracker.createInstance<GroupByClauseContext>(_ctx, getState());
  enterRule(_localctx, 322, MySQLParser::RuleGroupByClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3113);
    match(MySQLParser::GROUP_SYMBOL);
    setState(3114);
    match(MySQLParser::BY_SYMBOL);
    setState(3115);
    orderList();
    setState(3117);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 327, _ctx)) {
    case 1: {
      setState(3116);
      olapOption();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OlapOptionContext ------------------------------------------------------------------

MySQLParser::OlapOptionContext::OlapOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::OlapOptionContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OlapOptionContext::ROLLUP_SYMBOL() {
  return getToken(MySQLParser::ROLLUP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OlapOptionContext::CUBE_SYMBOL() {
  return getToken(MySQLParser::CUBE_SYMBOL, 0);
}


size_t MySQLParser::OlapOptionContext::getRuleIndex() const {
  return MySQLParser::RuleOlapOption;
}

void MySQLParser::OlapOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOlapOption(this);
}

void MySQLParser::OlapOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOlapOption(this);
}


antlrcpp::Any MySQLParser::OlapOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitOlapOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OlapOptionContext* MySQLParser::olapOption() {
  OlapOptionContext *_localctx = _tracker.createInstance<OlapOptionContext>(_ctx, getState());
  enterRule(_localctx, 324, MySQLParser::RuleOlapOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3124);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 328, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3119);
      match(MySQLParser::WITH_SYMBOL);
      setState(3120);
      match(MySQLParser::ROLLUP_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3121);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(3122);
      match(MySQLParser::WITH_SYMBOL);
      setState(3123);
      match(MySQLParser::CUBE_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OrderClauseContext ------------------------------------------------------------------

MySQLParser::OrderClauseContext::OrderClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::OrderClauseContext::ORDER_SYMBOL() {
  return getToken(MySQLParser::ORDER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OrderClauseContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::OrderListContext* MySQLParser::OrderClauseContext::orderList() {
  return getRuleContext<MySQLParser::OrderListContext>(0);
}


size_t MySQLParser::OrderClauseContext::getRuleIndex() const {
  return MySQLParser::RuleOrderClause;
}

void MySQLParser::OrderClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrderClause(this);
}

void MySQLParser::OrderClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrderClause(this);
}


antlrcpp::Any MySQLParser::OrderClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitOrderClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OrderClauseContext* MySQLParser::orderClause() {
  OrderClauseContext *_localctx = _tracker.createInstance<OrderClauseContext>(_ctx, getState());
  enterRule(_localctx, 326, MySQLParser::RuleOrderClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3126);
    match(MySQLParser::ORDER_SYMBOL);
    setState(3127);
    match(MySQLParser::BY_SYMBOL);
    setState(3128);
    orderList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DirectionContext ------------------------------------------------------------------

MySQLParser::DirectionContext::DirectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DirectionContext::ASC_SYMBOL() {
  return getToken(MySQLParser::ASC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DirectionContext::DESC_SYMBOL() {
  return getToken(MySQLParser::DESC_SYMBOL, 0);
}


size_t MySQLParser::DirectionContext::getRuleIndex() const {
  return MySQLParser::RuleDirection;
}

void MySQLParser::DirectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDirection(this);
}

void MySQLParser::DirectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDirection(this);
}


antlrcpp::Any MySQLParser::DirectionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDirection(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DirectionContext* MySQLParser::direction() {
  DirectionContext *_localctx = _tracker.createInstance<DirectionContext>(_ctx, getState());
  enterRule(_localctx, 328, MySQLParser::RuleDirection);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3130);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::ASC_SYMBOL

    || _la == MySQLParser::DESC_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FromClauseContext ------------------------------------------------------------------

MySQLParser::FromClauseContext::FromClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::FromClauseContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FromClauseContext::DUAL_SYMBOL() {
  return getToken(MySQLParser::DUAL_SYMBOL, 0);
}

MySQLParser::TableReferenceListContext* MySQLParser::FromClauseContext::tableReferenceList() {
  return getRuleContext<MySQLParser::TableReferenceListContext>(0);
}


size_t MySQLParser::FromClauseContext::getRuleIndex() const {
  return MySQLParser::RuleFromClause;
}

void MySQLParser::FromClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromClause(this);
}

void MySQLParser::FromClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromClause(this);
}


antlrcpp::Any MySQLParser::FromClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFromClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FromClauseContext* MySQLParser::fromClause() {
  FromClauseContext *_localctx = _tracker.createInstance<FromClauseContext>(_ctx, getState());
  enterRule(_localctx, 330, MySQLParser::RuleFromClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3132);
    match(MySQLParser::FROM_SYMBOL);
    setState(3135);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 329, _ctx)) {
    case 1: {
      setState(3133);
      match(MySQLParser::DUAL_SYMBOL);
      break;
    }

    case 2: {
      setState(3134);
      tableReferenceList();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableReferenceListContext ------------------------------------------------------------------

MySQLParser::TableReferenceListContext::TableReferenceListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TableReferenceContext *> MySQLParser::TableReferenceListContext::tableReference() {
  return getRuleContexts<MySQLParser::TableReferenceContext>();
}

MySQLParser::TableReferenceContext* MySQLParser::TableReferenceListContext::tableReference(size_t i) {
  return getRuleContext<MySQLParser::TableReferenceContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::TableReferenceListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::TableReferenceListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::TableReferenceListContext::getRuleIndex() const {
  return MySQLParser::RuleTableReferenceList;
}

void MySQLParser::TableReferenceListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableReferenceList(this);
}

void MySQLParser::TableReferenceListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableReferenceList(this);
}


antlrcpp::Any MySQLParser::TableReferenceListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTableReferenceList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableReferenceListContext* MySQLParser::tableReferenceList() {
  TableReferenceListContext *_localctx = _tracker.createInstance<TableReferenceListContext>(_ctx, getState());
  enterRule(_localctx, 332, MySQLParser::RuleTableReferenceList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3137);
    tableReference();
    setState(3142);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 330, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3138);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3139);
        tableReference(); 
      }
      setState(3144);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 330, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectOptionContext ------------------------------------------------------------------

MySQLParser::SelectOptionContext::SelectOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QuerySpecOptionContext* MySQLParser::SelectOptionContext::querySpecOption() {
  return getRuleContext<MySQLParser::QuerySpecOptionContext>(0);
}

tree::TerminalNode* MySQLParser::SelectOptionContext::SQL_NO_CACHE_SYMBOL() {
  return getToken(MySQLParser::SQL_NO_CACHE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SelectOptionContext::SQL_CACHE_SYMBOL() {
  return getToken(MySQLParser::SQL_CACHE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SelectOptionContext::MAX_STATEMENT_TIME_SYMBOL() {
  return getToken(MySQLParser::MAX_STATEMENT_TIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SelectOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::SelectOptionContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}


size_t MySQLParser::SelectOptionContext::getRuleIndex() const {
  return MySQLParser::RuleSelectOption;
}

void MySQLParser::SelectOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectOption(this);
}

void MySQLParser::SelectOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectOption(this);
}


antlrcpp::Any MySQLParser::SelectOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSelectOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SelectOptionContext* MySQLParser::selectOption() {
  SelectOptionContext *_localctx = _tracker.createInstance<SelectOptionContext>(_ctx, getState());
  enterRule(_localctx, 334, MySQLParser::RuleSelectOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3153);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 331, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3145);
      querySpecOption();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3146);
      match(MySQLParser::SQL_NO_CACHE_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3147);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(3148);
      match(MySQLParser::SQL_CACHE_SYMBOL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3149);

      if (!(serverVersion >= 50704 && serverVersion < 50708)) throw FailedPredicateException(this, "serverVersion >= 50704 && serverVersion < 50708");
      setState(3150);
      match(MySQLParser::MAX_STATEMENT_TIME_SYMBOL);
      setState(3151);
      match(MySQLParser::EQUAL_OPERATOR);
      setState(3152);
      real_ulong_number();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockingClauseContext ------------------------------------------------------------------

MySQLParser::LockingClauseContext::LockingClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LockingClauseContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

MySQLParser::LockStrenghContext* MySQLParser::LockingClauseContext::lockStrengh() {
  return getRuleContext<MySQLParser::LockStrenghContext>(0);
}

tree::TerminalNode* MySQLParser::LockingClauseContext::OF_SYMBOL() {
  return getToken(MySQLParser::OF_SYMBOL, 0);
}

MySQLParser::TableAliasRefListContext* MySQLParser::LockingClauseContext::tableAliasRefList() {
  return getRuleContext<MySQLParser::TableAliasRefListContext>(0);
}

MySQLParser::LockedRowActionContext* MySQLParser::LockingClauseContext::lockedRowAction() {
  return getRuleContext<MySQLParser::LockedRowActionContext>(0);
}

tree::TerminalNode* MySQLParser::LockingClauseContext::LOCK_SYMBOL() {
  return getToken(MySQLParser::LOCK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockingClauseContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockingClauseContext::SHARE_SYMBOL() {
  return getToken(MySQLParser::SHARE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockingClauseContext::MODE_SYMBOL() {
  return getToken(MySQLParser::MODE_SYMBOL, 0);
}


size_t MySQLParser::LockingClauseContext::getRuleIndex() const {
  return MySQLParser::RuleLockingClause;
}

void MySQLParser::LockingClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockingClause(this);
}

void MySQLParser::LockingClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockingClause(this);
}


antlrcpp::Any MySQLParser::LockingClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLockingClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LockingClauseContext* MySQLParser::lockingClause() {
  LockingClauseContext *_localctx = _tracker.createInstance<LockingClauseContext>(_ctx, getState());
  enterRule(_localctx, 336, MySQLParser::RuleLockingClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3170);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::FOR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3155);
        match(MySQLParser::FOR_SYMBOL);
        setState(3156);
        lockStrengh();
        setState(3160);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 332, _ctx)) {
        case 1: {
          setState(3157);

          if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
          setState(3158);
          match(MySQLParser::OF_SYMBOL);
          setState(3159);
          tableAliasRefList();
          break;
        }

        }
        setState(3164);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 333, _ctx)) {
        case 1: {
          setState(3162);

          if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
          setState(3163);
          lockedRowAction();
          break;
        }

        }
        break;
      }

      case MySQLParser::LOCK_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3166);
        match(MySQLParser::LOCK_SYMBOL);
        setState(3167);
        match(MySQLParser::IN_SYMBOL);
        setState(3168);
        match(MySQLParser::SHARE_SYMBOL);
        setState(3169);
        match(MySQLParser::MODE_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockStrenghContext ------------------------------------------------------------------

MySQLParser::LockStrenghContext::LockStrenghContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LockStrenghContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockStrenghContext::SHARE_SYMBOL() {
  return getToken(MySQLParser::SHARE_SYMBOL, 0);
}


size_t MySQLParser::LockStrenghContext::getRuleIndex() const {
  return MySQLParser::RuleLockStrengh;
}

void MySQLParser::LockStrenghContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockStrengh(this);
}

void MySQLParser::LockStrenghContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockStrengh(this);
}


antlrcpp::Any MySQLParser::LockStrenghContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLockStrengh(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LockStrenghContext* MySQLParser::lockStrengh() {
  LockStrenghContext *_localctx = _tracker.createInstance<LockStrenghContext>(_ctx, getState());
  enterRule(_localctx, 338, MySQLParser::RuleLockStrengh);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3175);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 335, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3172);
      match(MySQLParser::UPDATE_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3173);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(3174);
      match(MySQLParser::SHARE_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockedRowActionContext ------------------------------------------------------------------

MySQLParser::LockedRowActionContext::LockedRowActionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LockedRowActionContext::SKIP_SYMBOL() {
  return getToken(MySQLParser::SKIP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockedRowActionContext::LOCKED_SYMBOL() {
  return getToken(MySQLParser::LOCKED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockedRowActionContext::NOWAIT_SYMBOL() {
  return getToken(MySQLParser::NOWAIT_SYMBOL, 0);
}


size_t MySQLParser::LockedRowActionContext::getRuleIndex() const {
  return MySQLParser::RuleLockedRowAction;
}

void MySQLParser::LockedRowActionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockedRowAction(this);
}

void MySQLParser::LockedRowActionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockedRowAction(this);
}


antlrcpp::Any MySQLParser::LockedRowActionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLockedRowAction(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LockedRowActionContext* MySQLParser::lockedRowAction() {
  LockedRowActionContext *_localctx = _tracker.createInstance<LockedRowActionContext>(_ctx, getState());
  enterRule(_localctx, 340, MySQLParser::RuleLockedRowAction);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3180);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::SKIP_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3177);
        match(MySQLParser::SKIP_SYMBOL);
        setState(3178);
        match(MySQLParser::LOCKED_SYMBOL);
        break;
      }

      case MySQLParser::NOWAIT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3179);
        match(MySQLParser::NOWAIT_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectItemListContext ------------------------------------------------------------------

MySQLParser::SelectItemListContext::SelectItemListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::SelectItemContext *> MySQLParser::SelectItemListContext::selectItem() {
  return getRuleContexts<MySQLParser::SelectItemContext>();
}

MySQLParser::SelectItemContext* MySQLParser::SelectItemListContext::selectItem(size_t i) {
  return getRuleContext<MySQLParser::SelectItemContext>(i);
}

tree::TerminalNode* MySQLParser::SelectItemListContext::MULT_OPERATOR() {
  return getToken(MySQLParser::MULT_OPERATOR, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::SelectItemListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::SelectItemListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::SelectItemListContext::getRuleIndex() const {
  return MySQLParser::RuleSelectItemList;
}

void MySQLParser::SelectItemListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectItemList(this);
}

void MySQLParser::SelectItemListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectItemList(this);
}


antlrcpp::Any MySQLParser::SelectItemListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSelectItemList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SelectItemListContext* MySQLParser::selectItemList() {
  SelectItemListContext *_localctx = _tracker.createInstance<SelectItemListContext>(_ctx, getState());
  enterRule(_localctx, 342, MySQLParser::RuleSelectItemList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3184);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 337, _ctx)) {
    case 1: {
      setState(3182);
      selectItem();
      break;
    }

    case 2: {
      setState(3183);
      match(MySQLParser::MULT_OPERATOR);
      break;
    }

    }
    setState(3190);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 338, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3186);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3187);
        selectItem(); 
      }
      setState(3192);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 338, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectItemContext ------------------------------------------------------------------

MySQLParser::SelectItemContext::SelectItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableWildContext* MySQLParser::SelectItemContext::tableWild() {
  return getRuleContext<MySQLParser::TableWildContext>(0);
}

MySQLParser::ExprContext* MySQLParser::SelectItemContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::SelectAliasContext* MySQLParser::SelectItemContext::selectAlias() {
  return getRuleContext<MySQLParser::SelectAliasContext>(0);
}


size_t MySQLParser::SelectItemContext::getRuleIndex() const {
  return MySQLParser::RuleSelectItem;
}

void MySQLParser::SelectItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectItem(this);
}

void MySQLParser::SelectItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectItem(this);
}


antlrcpp::Any MySQLParser::SelectItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSelectItem(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SelectItemContext* MySQLParser::selectItem() {
  SelectItemContext *_localctx = _tracker.createInstance<SelectItemContext>(_ctx, getState());
  enterRule(_localctx, 344, MySQLParser::RuleSelectItem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3198);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 340, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3193);
      tableWild();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3194);
      expr(0);
      setState(3196);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 339, _ctx)) {
      case 1: {
        setState(3195);
        selectAlias();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectAliasContext ------------------------------------------------------------------

MySQLParser::SelectAliasContext::SelectAliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::SelectAliasContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::SelectAliasContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::SelectAliasContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}


size_t MySQLParser::SelectAliasContext::getRuleIndex() const {
  return MySQLParser::RuleSelectAlias;
}

void MySQLParser::SelectAliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectAlias(this);
}

void MySQLParser::SelectAliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectAlias(this);
}


antlrcpp::Any MySQLParser::SelectAliasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSelectAlias(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SelectAliasContext* MySQLParser::selectAlias() {
  SelectAliasContext *_localctx = _tracker.createInstance<SelectAliasContext>(_ctx, getState());
  enterRule(_localctx, 346, MySQLParser::RuleSelectAlias);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3201);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 341, _ctx)) {
    case 1: {
      setState(3200);
      match(MySQLParser::AS_SYMBOL);
      break;
    }

    }
    setState(3205);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 342, _ctx)) {
    case 1: {
      setState(3203);
      identifier();
      break;
    }

    case 2: {
      setState(3204);
      textStringLiteral();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhereClauseContext ------------------------------------------------------------------

MySQLParser::WhereClauseContext::WhereClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WhereClauseContext::WHERE_SYMBOL() {
  return getToken(MySQLParser::WHERE_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::WhereClauseContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}


size_t MySQLParser::WhereClauseContext::getRuleIndex() const {
  return MySQLParser::RuleWhereClause;
}

void MySQLParser::WhereClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhereClause(this);
}

void MySQLParser::WhereClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhereClause(this);
}


antlrcpp::Any MySQLParser::WhereClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitWhereClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WhereClauseContext* MySQLParser::whereClause() {
  WhereClauseContext *_localctx = _tracker.createInstance<WhereClauseContext>(_ctx, getState());
  enterRule(_localctx, 348, MySQLParser::RuleWhereClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3207);
    match(MySQLParser::WHERE_SYMBOL);
    setState(3208);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableReferenceContext ------------------------------------------------------------------

MySQLParser::TableReferenceContext::TableReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableFactorContext* MySQLParser::TableReferenceContext::tableFactor() {
  return getRuleContext<MySQLParser::TableFactorContext>(0);
}

tree::TerminalNode* MySQLParser::TableReferenceContext::OPEN_CURLY_SYMBOL() {
  return getToken(MySQLParser::OPEN_CURLY_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::TableReferenceContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::EscapedTableReferenceContext* MySQLParser::TableReferenceContext::escapedTableReference() {
  return getRuleContext<MySQLParser::EscapedTableReferenceContext>(0);
}

tree::TerminalNode* MySQLParser::TableReferenceContext::CLOSE_CURLY_SYMBOL() {
  return getToken(MySQLParser::CLOSE_CURLY_SYMBOL, 0);
}

std::vector<MySQLParser::JoinedTableContext *> MySQLParser::TableReferenceContext::joinedTable() {
  return getRuleContexts<MySQLParser::JoinedTableContext>();
}

MySQLParser::JoinedTableContext* MySQLParser::TableReferenceContext::joinedTable(size_t i) {
  return getRuleContext<MySQLParser::JoinedTableContext>(i);
}


size_t MySQLParser::TableReferenceContext::getRuleIndex() const {
  return MySQLParser::RuleTableReference;
}

void MySQLParser::TableReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableReference(this);
}

void MySQLParser::TableReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableReference(this);
}


antlrcpp::Any MySQLParser::TableReferenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTableReference(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableReferenceContext* MySQLParser::tableReference() {
  TableReferenceContext *_localctx = _tracker.createInstance<TableReferenceContext>(_ctx, getState());
  enterRule(_localctx, 350, MySQLParser::RuleTableReference);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3216);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 343, _ctx)) {
    case 1: {
      setState(3210);
      tableFactor();
      break;
    }

    case 2: {
      setState(3211);
      match(MySQLParser::OPEN_CURLY_SYMBOL);
      setState(3212);
      identifier();
      setState(3213);
      escapedTableReference();
      setState(3214);
      match(MySQLParser::CLOSE_CURLY_SYMBOL);
      break;
    }

    }
    setState(3221);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 344, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3218);
        joinedTable(); 
      }
      setState(3223);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 344, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EscapedTableReferenceContext ------------------------------------------------------------------

MySQLParser::EscapedTableReferenceContext::EscapedTableReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableFactorContext* MySQLParser::EscapedTableReferenceContext::tableFactor() {
  return getRuleContext<MySQLParser::TableFactorContext>(0);
}

std::vector<MySQLParser::JoinedTableContext *> MySQLParser::EscapedTableReferenceContext::joinedTable() {
  return getRuleContexts<MySQLParser::JoinedTableContext>();
}

MySQLParser::JoinedTableContext* MySQLParser::EscapedTableReferenceContext::joinedTable(size_t i) {
  return getRuleContext<MySQLParser::JoinedTableContext>(i);
}


size_t MySQLParser::EscapedTableReferenceContext::getRuleIndex() const {
  return MySQLParser::RuleEscapedTableReference;
}

void MySQLParser::EscapedTableReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEscapedTableReference(this);
}

void MySQLParser::EscapedTableReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEscapedTableReference(this);
}


antlrcpp::Any MySQLParser::EscapedTableReferenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitEscapedTableReference(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::EscapedTableReferenceContext* MySQLParser::escapedTableReference() {
  EscapedTableReferenceContext *_localctx = _tracker.createInstance<EscapedTableReferenceContext>(_ctx, getState());
  enterRule(_localctx, 352, MySQLParser::RuleEscapedTableReference);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3224);
    tableFactor();
    setState(3228);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::CROSS_SYMBOL

    || _la == MySQLParser::INNER_SYMBOL || ((((_la - 534) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 534)) & ((1ULL << (MySQLParser::JOIN_SYMBOL - 534))
      | (1ULL << (MySQLParser::LEFT_SYMBOL - 534))
      | (1ULL << (MySQLParser::NATURAL_SYMBOL - 534)))) != 0) || _la == MySQLParser::RIGHT_SYMBOL

    || _la == MySQLParser::STRAIGHT_JOIN_SYMBOL) {
      setState(3225);
      joinedTable();
      setState(3230);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JoinedTableContext ------------------------------------------------------------------

MySQLParser::JoinedTableContext::JoinedTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::InnerJoinTypeContext* MySQLParser::JoinedTableContext::innerJoinType() {
  return getRuleContext<MySQLParser::InnerJoinTypeContext>(0);
}

MySQLParser::TableReferenceContext* MySQLParser::JoinedTableContext::tableReference() {
  return getRuleContext<MySQLParser::TableReferenceContext>(0);
}

tree::TerminalNode* MySQLParser::JoinedTableContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::JoinedTableContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::JoinedTableContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

MySQLParser::IdentifierListWithParenthesesContext* MySQLParser::JoinedTableContext::identifierListWithParentheses() {
  return getRuleContext<MySQLParser::IdentifierListWithParenthesesContext>(0);
}

MySQLParser::OuterJoinTypeContext* MySQLParser::JoinedTableContext::outerJoinType() {
  return getRuleContext<MySQLParser::OuterJoinTypeContext>(0);
}

MySQLParser::NaturalJoinTypeContext* MySQLParser::JoinedTableContext::naturalJoinType() {
  return getRuleContext<MySQLParser::NaturalJoinTypeContext>(0);
}

MySQLParser::TableFactorContext* MySQLParser::JoinedTableContext::tableFactor() {
  return getRuleContext<MySQLParser::TableFactorContext>(0);
}


size_t MySQLParser::JoinedTableContext::getRuleIndex() const {
  return MySQLParser::RuleJoinedTable;
}

void MySQLParser::JoinedTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoinedTable(this);
}

void MySQLParser::JoinedTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoinedTable(this);
}


antlrcpp::Any MySQLParser::JoinedTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitJoinedTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::JoinedTableContext* MySQLParser::joinedTable() {
  JoinedTableContext *_localctx = _tracker.createInstance<JoinedTableContext>(_ctx, getState());
  enterRule(_localctx, 354, MySQLParser::RuleJoinedTable);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3250);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CROSS_SYMBOL:
      case MySQLParser::INNER_SYMBOL:
      case MySQLParser::JOIN_SYMBOL:
      case MySQLParser::STRAIGHT_JOIN_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3231);
        innerJoinType();
        setState(3232);
        tableReference();
        setState(3237);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 346, _ctx)) {
        case 1: {
          setState(3233);
          match(MySQLParser::ON_SYMBOL);
          setState(3234);
          expr(0);
          break;
        }

        case 2: {
          setState(3235);
          match(MySQLParser::USING_SYMBOL);
          setState(3236);
          identifierListWithParentheses();
          break;
        }

        }
        break;
      }

      case MySQLParser::LEFT_SYMBOL:
      case MySQLParser::RIGHT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3239);
        outerJoinType();
        setState(3240);
        tableReference();
        setState(3245);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::ON_SYMBOL: {
            setState(3241);
            match(MySQLParser::ON_SYMBOL);
            setState(3242);
            expr(0);
            break;
          }

          case MySQLParser::USING_SYMBOL: {
            setState(3243);
            match(MySQLParser::USING_SYMBOL);
            setState(3244);
            identifierListWithParentheses();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case MySQLParser::NATURAL_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(3247);
        naturalJoinType();
        setState(3248);
        tableFactor();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NaturalJoinTypeContext ------------------------------------------------------------------

MySQLParser::NaturalJoinTypeContext::NaturalJoinTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::NaturalJoinTypeContext::NATURAL_SYMBOL() {
  return getToken(MySQLParser::NATURAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NaturalJoinTypeContext::JOIN_SYMBOL() {
  return getToken(MySQLParser::JOIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NaturalJoinTypeContext::INNER_SYMBOL() {
  return getToken(MySQLParser::INNER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NaturalJoinTypeContext::LEFT_SYMBOL() {
  return getToken(MySQLParser::LEFT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NaturalJoinTypeContext::RIGHT_SYMBOL() {
  return getToken(MySQLParser::RIGHT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NaturalJoinTypeContext::OUTER_SYMBOL() {
  return getToken(MySQLParser::OUTER_SYMBOL, 0);
}


size_t MySQLParser::NaturalJoinTypeContext::getRuleIndex() const {
  return MySQLParser::RuleNaturalJoinType;
}

void MySQLParser::NaturalJoinTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNaturalJoinType(this);
}

void MySQLParser::NaturalJoinTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNaturalJoinType(this);
}


antlrcpp::Any MySQLParser::NaturalJoinTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitNaturalJoinType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::NaturalJoinTypeContext* MySQLParser::naturalJoinType() {
  NaturalJoinTypeContext *_localctx = _tracker.createInstance<NaturalJoinTypeContext>(_ctx, getState());
  enterRule(_localctx, 356, MySQLParser::RuleNaturalJoinType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3263);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 351, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3252);
      match(MySQLParser::NATURAL_SYMBOL);
      setState(3254);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::INNER_SYMBOL) {
        setState(3253);
        match(MySQLParser::INNER_SYMBOL);
      }
      setState(3256);
      match(MySQLParser::JOIN_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3257);
      match(MySQLParser::NATURAL_SYMBOL);
      setState(3258);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::LEFT_SYMBOL || _la == MySQLParser::RIGHT_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3260);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::OUTER_SYMBOL) {
        setState(3259);
        match(MySQLParser::OUTER_SYMBOL);
      }
      setState(3262);
      match(MySQLParser::JOIN_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InnerJoinTypeContext ------------------------------------------------------------------

MySQLParser::InnerJoinTypeContext::InnerJoinTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::InnerJoinTypeContext::JOIN_SYMBOL() {
  return getToken(MySQLParser::JOIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InnerJoinTypeContext::INNER_SYMBOL() {
  return getToken(MySQLParser::INNER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InnerJoinTypeContext::CROSS_SYMBOL() {
  return getToken(MySQLParser::CROSS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InnerJoinTypeContext::STRAIGHT_JOIN_SYMBOL() {
  return getToken(MySQLParser::STRAIGHT_JOIN_SYMBOL, 0);
}


size_t MySQLParser::InnerJoinTypeContext::getRuleIndex() const {
  return MySQLParser::RuleInnerJoinType;
}

void MySQLParser::InnerJoinTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInnerJoinType(this);
}

void MySQLParser::InnerJoinTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInnerJoinType(this);
}


antlrcpp::Any MySQLParser::InnerJoinTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitInnerJoinType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InnerJoinTypeContext* MySQLParser::innerJoinType() {
  InnerJoinTypeContext *_localctx = _tracker.createInstance<InnerJoinTypeContext>(_ctx, getState());
  enterRule(_localctx, 358, MySQLParser::RuleInnerJoinType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3270);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CROSS_SYMBOL:
      case MySQLParser::INNER_SYMBOL:
      case MySQLParser::JOIN_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3266);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::CROSS_SYMBOL

        || _la == MySQLParser::INNER_SYMBOL) {
          setState(3265);
          dynamic_cast<InnerJoinTypeContext *>(_localctx)->type = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::CROSS_SYMBOL

          || _la == MySQLParser::INNER_SYMBOL)) {
            dynamic_cast<InnerJoinTypeContext *>(_localctx)->type = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(3268);
        match(MySQLParser::JOIN_SYMBOL);
        break;
      }

      case MySQLParser::STRAIGHT_JOIN_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3269);
        dynamic_cast<InnerJoinTypeContext *>(_localctx)->type = match(MySQLParser::STRAIGHT_JOIN_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OuterJoinTypeContext ------------------------------------------------------------------

MySQLParser::OuterJoinTypeContext::OuterJoinTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::OuterJoinTypeContext::JOIN_SYMBOL() {
  return getToken(MySQLParser::JOIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OuterJoinTypeContext::LEFT_SYMBOL() {
  return getToken(MySQLParser::LEFT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OuterJoinTypeContext::RIGHT_SYMBOL() {
  return getToken(MySQLParser::RIGHT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OuterJoinTypeContext::OUTER_SYMBOL() {
  return getToken(MySQLParser::OUTER_SYMBOL, 0);
}


size_t MySQLParser::OuterJoinTypeContext::getRuleIndex() const {
  return MySQLParser::RuleOuterJoinType;
}

void MySQLParser::OuterJoinTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOuterJoinType(this);
}

void MySQLParser::OuterJoinTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOuterJoinType(this);
}


antlrcpp::Any MySQLParser::OuterJoinTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitOuterJoinType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OuterJoinTypeContext* MySQLParser::outerJoinType() {
  OuterJoinTypeContext *_localctx = _tracker.createInstance<OuterJoinTypeContext>(_ctx, getState());
  enterRule(_localctx, 360, MySQLParser::RuleOuterJoinType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3272);
    dynamic_cast<OuterJoinTypeContext *>(_localctx)->type = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::LEFT_SYMBOL || _la == MySQLParser::RIGHT_SYMBOL)) {
      dynamic_cast<OuterJoinTypeContext *>(_localctx)->type = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(3274);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OUTER_SYMBOL) {
      setState(3273);
      match(MySQLParser::OUTER_SYMBOL);
    }
    setState(3276);
    match(MySQLParser::JOIN_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableFactorContext ------------------------------------------------------------------

MySQLParser::TableFactorContext::TableFactorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SingleTableContext* MySQLParser::TableFactorContext::singleTable() {
  return getRuleContext<MySQLParser::SingleTableContext>(0);
}

MySQLParser::SingleTableParensContext* MySQLParser::TableFactorContext::singleTableParens() {
  return getRuleContext<MySQLParser::SingleTableParensContext>(0);
}

MySQLParser::DerivedTableContext* MySQLParser::TableFactorContext::derivedTable() {
  return getRuleContext<MySQLParser::DerivedTableContext>(0);
}

MySQLParser::TableReferenceListParensContext* MySQLParser::TableFactorContext::tableReferenceListParens() {
  return getRuleContext<MySQLParser::TableReferenceListParensContext>(0);
}

MySQLParser::TableFunctionContext* MySQLParser::TableFactorContext::tableFunction() {
  return getRuleContext<MySQLParser::TableFunctionContext>(0);
}


size_t MySQLParser::TableFactorContext::getRuleIndex() const {
  return MySQLParser::RuleTableFactor;
}

void MySQLParser::TableFactorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableFactor(this);
}

void MySQLParser::TableFactorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableFactor(this);
}


antlrcpp::Any MySQLParser::TableFactorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTableFactor(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableFactorContext* MySQLParser::tableFactor() {
  TableFactorContext *_localctx = _tracker.createInstance<TableFactorContext>(_ctx, getState());
  enterRule(_localctx, 362, MySQLParser::RuleTableFactor);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3284);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 355, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3278);
      singleTable();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3279);
      singleTableParens();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3280);
      derivedTable();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3281);
      tableReferenceListParens();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3282);

      if (!(serverVersion >= 80004)) throw FailedPredicateException(this, "serverVersion >= 80004");
      setState(3283);
      tableFunction();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SingleTableContext ------------------------------------------------------------------

MySQLParser::SingleTableContext::SingleTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext* MySQLParser::SingleTableContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::UsePartitionContext* MySQLParser::SingleTableContext::usePartition() {
  return getRuleContext<MySQLParser::UsePartitionContext>(0);
}

MySQLParser::TableAliasContext* MySQLParser::SingleTableContext::tableAlias() {
  return getRuleContext<MySQLParser::TableAliasContext>(0);
}

MySQLParser::IndexHintListContext* MySQLParser::SingleTableContext::indexHintList() {
  return getRuleContext<MySQLParser::IndexHintListContext>(0);
}


size_t MySQLParser::SingleTableContext::getRuleIndex() const {
  return MySQLParser::RuleSingleTable;
}

void MySQLParser::SingleTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingleTable(this);
}

void MySQLParser::SingleTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingleTable(this);
}


antlrcpp::Any MySQLParser::SingleTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSingleTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SingleTableContext* MySQLParser::singleTable() {
  SingleTableContext *_localctx = _tracker.createInstance<SingleTableContext>(_ctx, getState());
  enterRule(_localctx, 364, MySQLParser::RuleSingleTable);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3286);
    tableRef();
    setState(3288);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 356, _ctx)) {
    case 1: {
      setState(3287);
      usePartition();
      break;
    }

    }
    setState(3291);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 357, _ctx)) {
    case 1: {
      setState(3290);
      tableAlias();
      break;
    }

    }
    setState(3294);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 358, _ctx)) {
    case 1: {
      setState(3293);
      indexHintList();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SingleTableParensContext ------------------------------------------------------------------

MySQLParser::SingleTableParensContext::SingleTableParensContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SingleTableParensContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SingleTableParensContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::SingleTableContext* MySQLParser::SingleTableParensContext::singleTable() {
  return getRuleContext<MySQLParser::SingleTableContext>(0);
}

MySQLParser::SingleTableParensContext* MySQLParser::SingleTableParensContext::singleTableParens() {
  return getRuleContext<MySQLParser::SingleTableParensContext>(0);
}


size_t MySQLParser::SingleTableParensContext::getRuleIndex() const {
  return MySQLParser::RuleSingleTableParens;
}

void MySQLParser::SingleTableParensContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingleTableParens(this);
}

void MySQLParser::SingleTableParensContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingleTableParens(this);
}


antlrcpp::Any MySQLParser::SingleTableParensContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSingleTableParens(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SingleTableParensContext* MySQLParser::singleTableParens() {
  SingleTableParensContext *_localctx = _tracker.createInstance<SingleTableParensContext>(_ctx, getState());
  enterRule(_localctx, 366, MySQLParser::RuleSingleTableParens);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3296);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3299);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 359, _ctx)) {
    case 1: {
      setState(3297);
      singleTable();
      break;
    }

    case 2: {
      setState(3298);
      singleTableParens();
      break;
    }

    }
    setState(3301);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DerivedTableContext ------------------------------------------------------------------

MySQLParser::DerivedTableContext::DerivedTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SubqueryContext* MySQLParser::DerivedTableContext::subquery() {
  return getRuleContext<MySQLParser::SubqueryContext>(0);
}

MySQLParser::TableAliasContext* MySQLParser::DerivedTableContext::tableAlias() {
  return getRuleContext<MySQLParser::TableAliasContext>(0);
}

MySQLParser::ColumnInternalRefListContext* MySQLParser::DerivedTableContext::columnInternalRefList() {
  return getRuleContext<MySQLParser::ColumnInternalRefListContext>(0);
}

tree::TerminalNode* MySQLParser::DerivedTableContext::LATERAL_SYMBOL() {
  return getToken(MySQLParser::LATERAL_SYMBOL, 0);
}


size_t MySQLParser::DerivedTableContext::getRuleIndex() const {
  return MySQLParser::RuleDerivedTable;
}

void MySQLParser::DerivedTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDerivedTable(this);
}

void MySQLParser::DerivedTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDerivedTable(this);
}


antlrcpp::Any MySQLParser::DerivedTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDerivedTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DerivedTableContext* MySQLParser::derivedTable() {
  DerivedTableContext *_localctx = _tracker.createInstance<DerivedTableContext>(_ctx, getState());
  enterRule(_localctx, 368, MySQLParser::RuleDerivedTable);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3320);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 364, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3303);
      subquery();
      setState(3305);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 360, _ctx)) {
      case 1: {
        setState(3304);
        tableAlias();
        break;
      }

      }
      setState(3309);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 361, _ctx)) {
      case 1: {
        setState(3307);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(3308);
        columnInternalRefList();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3311);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(3312);
      match(MySQLParser::LATERAL_SYMBOL);
      setState(3313);
      subquery();
      setState(3315);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 362, _ctx)) {
      case 1: {
        setState(3314);
        tableAlias();
        break;
      }

      }
      setState(3318);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 363, _ctx)) {
      case 1: {
        setState(3317);
        columnInternalRefList();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableReferenceListParensContext ------------------------------------------------------------------

MySQLParser::TableReferenceListParensContext::TableReferenceListParensContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TableReferenceListParensContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TableReferenceListParensContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::TableReferenceListContext* MySQLParser::TableReferenceListParensContext::tableReferenceList() {
  return getRuleContext<MySQLParser::TableReferenceListContext>(0);
}

MySQLParser::TableReferenceListParensContext* MySQLParser::TableReferenceListParensContext::tableReferenceListParens() {
  return getRuleContext<MySQLParser::TableReferenceListParensContext>(0);
}


size_t MySQLParser::TableReferenceListParensContext::getRuleIndex() const {
  return MySQLParser::RuleTableReferenceListParens;
}

void MySQLParser::TableReferenceListParensContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableReferenceListParens(this);
}

void MySQLParser::TableReferenceListParensContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableReferenceListParens(this);
}


antlrcpp::Any MySQLParser::TableReferenceListParensContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTableReferenceListParens(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableReferenceListParensContext* MySQLParser::tableReferenceListParens() {
  TableReferenceListParensContext *_localctx = _tracker.createInstance<TableReferenceListParensContext>(_ctx, getState());
  enterRule(_localctx, 370, MySQLParser::RuleTableReferenceListParens);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3322);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3325);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 365, _ctx)) {
    case 1: {
      setState(3323);
      tableReferenceList();
      break;
    }

    case 2: {
      setState(3324);
      tableReferenceListParens();
      break;
    }

    }
    setState(3327);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableFunctionContext ------------------------------------------------------------------

MySQLParser::TableFunctionContext::TableFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TableFunctionContext::JSON_TABLE_SYMBOL() {
  return getToken(MySQLParser::JSON_TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TableFunctionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::TableFunctionContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::TableFunctionContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::TableFunctionContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

MySQLParser::ColumnsClauseContext* MySQLParser::TableFunctionContext::columnsClause() {
  return getRuleContext<MySQLParser::ColumnsClauseContext>(0);
}

tree::TerminalNode* MySQLParser::TableFunctionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::TableAliasContext* MySQLParser::TableFunctionContext::tableAlias() {
  return getRuleContext<MySQLParser::TableAliasContext>(0);
}


size_t MySQLParser::TableFunctionContext::getRuleIndex() const {
  return MySQLParser::RuleTableFunction;
}

void MySQLParser::TableFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableFunction(this);
}

void MySQLParser::TableFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableFunction(this);
}


antlrcpp::Any MySQLParser::TableFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTableFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableFunctionContext* MySQLParser::tableFunction() {
  TableFunctionContext *_localctx = _tracker.createInstance<TableFunctionContext>(_ctx, getState());
  enterRule(_localctx, 372, MySQLParser::RuleTableFunction);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3329);
    match(MySQLParser::JSON_TABLE_SYMBOL);
    setState(3330);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3331);
    expr(0);
    setState(3332);
    match(MySQLParser::COMMA_SYMBOL);
    setState(3333);
    textStringLiteral();
    setState(3334);
    columnsClause();
    setState(3335);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
    setState(3337);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 366, _ctx)) {
    case 1: {
      setState(3336);
      tableAlias();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnsClauseContext ------------------------------------------------------------------

MySQLParser::ColumnsClauseContext::ColumnsClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ColumnsClauseContext::COLUMNS_SYMBOL() {
  return getToken(MySQLParser::COLUMNS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnsClauseContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::JtColumnContext *> MySQLParser::ColumnsClauseContext::jtColumn() {
  return getRuleContexts<MySQLParser::JtColumnContext>();
}

MySQLParser::JtColumnContext* MySQLParser::ColumnsClauseContext::jtColumn(size_t i) {
  return getRuleContext<MySQLParser::JtColumnContext>(i);
}

tree::TerminalNode* MySQLParser::ColumnsClauseContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::ColumnsClauseContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ColumnsClauseContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ColumnsClauseContext::getRuleIndex() const {
  return MySQLParser::RuleColumnsClause;
}

void MySQLParser::ColumnsClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnsClause(this);
}

void MySQLParser::ColumnsClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnsClause(this);
}


antlrcpp::Any MySQLParser::ColumnsClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitColumnsClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ColumnsClauseContext* MySQLParser::columnsClause() {
  ColumnsClauseContext *_localctx = _tracker.createInstance<ColumnsClauseContext>(_ctx, getState());
  enterRule(_localctx, 374, MySQLParser::RuleColumnsClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3339);
    match(MySQLParser::COLUMNS_SYMBOL);
    setState(3340);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3341);
    jtColumn();
    setState(3346);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(3342);
      match(MySQLParser::COMMA_SYMBOL);
      setState(3343);
      jtColumn();
      setState(3348);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3349);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JtColumnContext ------------------------------------------------------------------

MySQLParser::JtColumnContext::JtColumnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::JtColumnContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::JtColumnContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::JtColumnContext::ORDINALITY_SYMBOL() {
  return getToken(MySQLParser::ORDINALITY_SYMBOL, 0);
}

MySQLParser::DataTypeContext* MySQLParser::JtColumnContext::dataType() {
  return getRuleContext<MySQLParser::DataTypeContext>(0);
}

tree::TerminalNode* MySQLParser::JtColumnContext::PATH_SYMBOL() {
  return getToken(MySQLParser::PATH_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::JtColumnContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

MySQLParser::CollateContext* MySQLParser::JtColumnContext::collate() {
  return getRuleContext<MySQLParser::CollateContext>(0);
}

tree::TerminalNode* MySQLParser::JtColumnContext::EXISTS_SYMBOL() {
  return getToken(MySQLParser::EXISTS_SYMBOL, 0);
}

MySQLParser::OnEmptyOrErrorContext* MySQLParser::JtColumnContext::onEmptyOrError() {
  return getRuleContext<MySQLParser::OnEmptyOrErrorContext>(0);
}

tree::TerminalNode* MySQLParser::JtColumnContext::NESTED_SYMBOL() {
  return getToken(MySQLParser::NESTED_SYMBOL, 0);
}

MySQLParser::ColumnsClauseContext* MySQLParser::JtColumnContext::columnsClause() {
  return getRuleContext<MySQLParser::ColumnsClauseContext>(0);
}


size_t MySQLParser::JtColumnContext::getRuleIndex() const {
  return MySQLParser::RuleJtColumn;
}

void MySQLParser::JtColumnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJtColumn(this);
}

void MySQLParser::JtColumnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJtColumn(this);
}


antlrcpp::Any MySQLParser::JtColumnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitJtColumn(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::JtColumnContext* MySQLParser::jtColumn() {
  JtColumnContext *_localctx = _tracker.createInstance<JtColumnContext>(_ctx, getState());
  enterRule(_localctx, 376, MySQLParser::RuleJtColumn);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3374);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 371, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3351);
      identifier();
      setState(3352);
      match(MySQLParser::FOR_SYMBOL);
      setState(3353);
      match(MySQLParser::ORDINALITY_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3355);
      identifier();
      setState(3356);
      dataType();
      setState(3359);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 368, _ctx)) {
      case 1: {
        setState(3357);

        if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
        setState(3358);
        collate();
        break;
      }

      }
      setState(3362);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EXISTS_SYMBOL) {
        setState(3361);
        match(MySQLParser::EXISTS_SYMBOL);
      }
      setState(3364);
      match(MySQLParser::PATH_SYMBOL);
      setState(3365);
      textStringLiteral();
      setState(3367);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::ERROR_SYMBOL || _la == MySQLParser::DEFAULT_SYMBOL || _la == MySQLParser::NULL_SYMBOL) {
        setState(3366);
        onEmptyOrError();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3369);
      match(MySQLParser::NESTED_SYMBOL);
      setState(3370);
      match(MySQLParser::PATH_SYMBOL);
      setState(3371);
      textStringLiteral();
      setState(3372);
      columnsClause();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnEmptyOrErrorContext ------------------------------------------------------------------

MySQLParser::OnEmptyOrErrorContext::OnEmptyOrErrorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::OnEmptyContext* MySQLParser::OnEmptyOrErrorContext::onEmpty() {
  return getRuleContext<MySQLParser::OnEmptyContext>(0);
}

MySQLParser::OnErrorContext* MySQLParser::OnEmptyOrErrorContext::onError() {
  return getRuleContext<MySQLParser::OnErrorContext>(0);
}


size_t MySQLParser::OnEmptyOrErrorContext::getRuleIndex() const {
  return MySQLParser::RuleOnEmptyOrError;
}

void MySQLParser::OnEmptyOrErrorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnEmptyOrError(this);
}

void MySQLParser::OnEmptyOrErrorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnEmptyOrError(this);
}


antlrcpp::Any MySQLParser::OnEmptyOrErrorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitOnEmptyOrError(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OnEmptyOrErrorContext* MySQLParser::onEmptyOrError() {
  OnEmptyOrErrorContext *_localctx = _tracker.createInstance<OnEmptyOrErrorContext>(_ctx, getState());
  enterRule(_localctx, 378, MySQLParser::RuleOnEmptyOrError);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3384);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 374, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3376);
      onEmpty();
      setState(3378);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::ERROR_SYMBOL || _la == MySQLParser::DEFAULT_SYMBOL || _la == MySQLParser::NULL_SYMBOL) {
        setState(3377);
        onError();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3380);
      onError();
      setState(3382);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::ERROR_SYMBOL || _la == MySQLParser::DEFAULT_SYMBOL || _la == MySQLParser::NULL_SYMBOL) {
        setState(3381);
        onEmpty();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnEmptyContext ------------------------------------------------------------------

MySQLParser::OnEmptyContext::OnEmptyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::JtOnResponseContext* MySQLParser::OnEmptyContext::jtOnResponse() {
  return getRuleContext<MySQLParser::JtOnResponseContext>(0);
}

tree::TerminalNode* MySQLParser::OnEmptyContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OnEmptyContext::EMPTY_SYMBOL() {
  return getToken(MySQLParser::EMPTY_SYMBOL, 0);
}


size_t MySQLParser::OnEmptyContext::getRuleIndex() const {
  return MySQLParser::RuleOnEmpty;
}

void MySQLParser::OnEmptyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnEmpty(this);
}

void MySQLParser::OnEmptyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnEmpty(this);
}


antlrcpp::Any MySQLParser::OnEmptyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitOnEmpty(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OnEmptyContext* MySQLParser::onEmpty() {
  OnEmptyContext *_localctx = _tracker.createInstance<OnEmptyContext>(_ctx, getState());
  enterRule(_localctx, 380, MySQLParser::RuleOnEmpty);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3386);
    jtOnResponse();
    setState(3387);
    match(MySQLParser::ON_SYMBOL);
    setState(3388);
    match(MySQLParser::EMPTY_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnErrorContext ------------------------------------------------------------------

MySQLParser::OnErrorContext::OnErrorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::JtOnResponseContext* MySQLParser::OnErrorContext::jtOnResponse() {
  return getRuleContext<MySQLParser::JtOnResponseContext>(0);
}

tree::TerminalNode* MySQLParser::OnErrorContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OnErrorContext::ERROR_SYMBOL() {
  return getToken(MySQLParser::ERROR_SYMBOL, 0);
}


size_t MySQLParser::OnErrorContext::getRuleIndex() const {
  return MySQLParser::RuleOnError;
}

void MySQLParser::OnErrorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnError(this);
}

void MySQLParser::OnErrorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnError(this);
}


antlrcpp::Any MySQLParser::OnErrorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitOnError(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OnErrorContext* MySQLParser::onError() {
  OnErrorContext *_localctx = _tracker.createInstance<OnErrorContext>(_ctx, getState());
  enterRule(_localctx, 382, MySQLParser::RuleOnError);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3390);
    jtOnResponse();
    setState(3391);
    match(MySQLParser::ON_SYMBOL);
    setState(3392);
    match(MySQLParser::ERROR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JtOnResponseContext ------------------------------------------------------------------

MySQLParser::JtOnResponseContext::JtOnResponseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::JtOnResponseContext::ERROR_SYMBOL() {
  return getToken(MySQLParser::ERROR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::JtOnResponseContext::NULL_SYMBOL() {
  return getToken(MySQLParser::NULL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::JtOnResponseContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::JtOnResponseContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}


size_t MySQLParser::JtOnResponseContext::getRuleIndex() const {
  return MySQLParser::RuleJtOnResponse;
}

void MySQLParser::JtOnResponseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJtOnResponse(this);
}

void MySQLParser::JtOnResponseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJtOnResponse(this);
}


antlrcpp::Any MySQLParser::JtOnResponseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitJtOnResponse(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::JtOnResponseContext* MySQLParser::jtOnResponse() {
  JtOnResponseContext *_localctx = _tracker.createInstance<JtOnResponseContext>(_ctx, getState());
  enterRule(_localctx, 384, MySQLParser::RuleJtOnResponse);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3398);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ERROR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3394);
        match(MySQLParser::ERROR_SYMBOL);
        break;
      }

      case MySQLParser::NULL_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3395);
        match(MySQLParser::NULL_SYMBOL);
        break;
      }

      case MySQLParser::DEFAULT_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(3396);
        match(MySQLParser::DEFAULT_SYMBOL);
        setState(3397);
        textStringLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnionOptionContext ------------------------------------------------------------------

MySQLParser::UnionOptionContext::UnionOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::UnionOptionContext::DISTINCT_SYMBOL() {
  return getToken(MySQLParser::DISTINCT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::UnionOptionContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}


size_t MySQLParser::UnionOptionContext::getRuleIndex() const {
  return MySQLParser::RuleUnionOption;
}

void MySQLParser::UnionOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnionOption(this);
}

void MySQLParser::UnionOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnionOption(this);
}


antlrcpp::Any MySQLParser::UnionOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitUnionOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UnionOptionContext* MySQLParser::unionOption() {
  UnionOptionContext *_localctx = _tracker.createInstance<UnionOptionContext>(_ctx, getState());
  enterRule(_localctx, 386, MySQLParser::RuleUnionOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3400);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::ALL_SYMBOL

    || _la == MySQLParser::DISTINCT_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableAliasContext ------------------------------------------------------------------

MySQLParser::TableAliasContext::TableAliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::TableAliasContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::TableAliasContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TableAliasContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::TableAliasContext::getRuleIndex() const {
  return MySQLParser::RuleTableAlias;
}

void MySQLParser::TableAliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableAlias(this);
}

void MySQLParser::TableAliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableAlias(this);
}


antlrcpp::Any MySQLParser::TableAliasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTableAlias(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableAliasContext* MySQLParser::tableAlias() {
  TableAliasContext *_localctx = _tracker.createInstance<TableAliasContext>(_ctx, getState());
  enterRule(_localctx, 388, MySQLParser::RuleTableAlias);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3403);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 376, _ctx)) {
    case 1: {
      setState(3402);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::EQUAL_OPERATOR

      || _la == MySQLParser::AS_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
    setState(3405);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexHintListContext ------------------------------------------------------------------

MySQLParser::IndexHintListContext::IndexHintListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::IndexHintContext *> MySQLParser::IndexHintListContext::indexHint() {
  return getRuleContexts<MySQLParser::IndexHintContext>();
}

MySQLParser::IndexHintContext* MySQLParser::IndexHintListContext::indexHint(size_t i) {
  return getRuleContext<MySQLParser::IndexHintContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::IndexHintListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::IndexHintListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::IndexHintListContext::getRuleIndex() const {
  return MySQLParser::RuleIndexHintList;
}

void MySQLParser::IndexHintListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexHintList(this);
}

void MySQLParser::IndexHintListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexHintList(this);
}


antlrcpp::Any MySQLParser::IndexHintListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIndexHintList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexHintListContext* MySQLParser::indexHintList() {
  IndexHintListContext *_localctx = _tracker.createInstance<IndexHintListContext>(_ctx, getState());
  enterRule(_localctx, 390, MySQLParser::RuleIndexHintList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3407);
    indexHint();
    setState(3412);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 377, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3408);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3409);
        indexHint(); 
      }
      setState(3414);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 377, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexHintContext ------------------------------------------------------------------

MySQLParser::IndexHintContext::IndexHintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IndexHintTypeContext* MySQLParser::IndexHintContext::indexHintType() {
  return getRuleContext<MySQLParser::IndexHintTypeContext>(0);
}

MySQLParser::KeyOrIndexContext* MySQLParser::IndexHintContext::keyOrIndex() {
  return getRuleContext<MySQLParser::KeyOrIndexContext>(0);
}

tree::TerminalNode* MySQLParser::IndexHintContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::IndexListContext* MySQLParser::IndexHintContext::indexList() {
  return getRuleContext<MySQLParser::IndexListContext>(0);
}

tree::TerminalNode* MySQLParser::IndexHintContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::IndexHintClauseContext* MySQLParser::IndexHintContext::indexHintClause() {
  return getRuleContext<MySQLParser::IndexHintClauseContext>(0);
}

tree::TerminalNode* MySQLParser::IndexHintContext::USE_SYMBOL() {
  return getToken(MySQLParser::USE_SYMBOL, 0);
}


size_t MySQLParser::IndexHintContext::getRuleIndex() const {
  return MySQLParser::RuleIndexHint;
}

void MySQLParser::IndexHintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexHint(this);
}

void MySQLParser::IndexHintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexHint(this);
}


antlrcpp::Any MySQLParser::IndexHintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIndexHint(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexHintContext* MySQLParser::indexHint() {
  IndexHintContext *_localctx = _tracker.createInstance<IndexHintContext>(_ctx, getState());
  enterRule(_localctx, 392, MySQLParser::RuleIndexHint);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3435);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::FORCE_SYMBOL:
      case MySQLParser::IGNORE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3415);
        indexHintType();
        setState(3416);
        keyOrIndex();
        setState(3418);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::FOR_SYMBOL) {
          setState(3417);
          indexHintClause();
        }
        setState(3420);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(3421);
        indexList();
        setState(3422);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::USE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3424);
        match(MySQLParser::USE_SYMBOL);
        setState(3425);
        keyOrIndex();
        setState(3427);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::FOR_SYMBOL) {
          setState(3426);
          indexHintClause();
        }
        setState(3429);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(3431);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 380, _ctx)) {
        case 1: {
          setState(3430);
          indexList();
          break;
        }

        }
        setState(3433);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexHintTypeContext ------------------------------------------------------------------

MySQLParser::IndexHintTypeContext::IndexHintTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IndexHintTypeContext::FORCE_SYMBOL() {
  return getToken(MySQLParser::FORCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IndexHintTypeContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}


size_t MySQLParser::IndexHintTypeContext::getRuleIndex() const {
  return MySQLParser::RuleIndexHintType;
}

void MySQLParser::IndexHintTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexHintType(this);
}

void MySQLParser::IndexHintTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexHintType(this);
}


antlrcpp::Any MySQLParser::IndexHintTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIndexHintType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexHintTypeContext* MySQLParser::indexHintType() {
  IndexHintTypeContext *_localctx = _tracker.createInstance<IndexHintTypeContext>(_ctx, getState());
  enterRule(_localctx, 394, MySQLParser::RuleIndexHintType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3437);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::FORCE_SYMBOL

    || _la == MySQLParser::IGNORE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyOrIndexContext ------------------------------------------------------------------

MySQLParser::KeyOrIndexContext::KeyOrIndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::KeyOrIndexContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::KeyOrIndexContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}


size_t MySQLParser::KeyOrIndexContext::getRuleIndex() const {
  return MySQLParser::RuleKeyOrIndex;
}

void MySQLParser::KeyOrIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyOrIndex(this);
}

void MySQLParser::KeyOrIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyOrIndex(this);
}


antlrcpp::Any MySQLParser::KeyOrIndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitKeyOrIndex(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::KeyOrIndexContext* MySQLParser::keyOrIndex() {
  KeyOrIndexContext *_localctx = _tracker.createInstance<KeyOrIndexContext>(_ctx, getState());
  enterRule(_localctx, 396, MySQLParser::RuleKeyOrIndex);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3439);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::INDEX_SYMBOL

    || _la == MySQLParser::KEY_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintKeyTypeContext ------------------------------------------------------------------

MySQLParser::ConstraintKeyTypeContext::ConstraintKeyTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ConstraintKeyTypeContext::PRIMARY_SYMBOL() {
  return getToken(MySQLParser::PRIMARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ConstraintKeyTypeContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ConstraintKeyTypeContext::UNIQUE_SYMBOL() {
  return getToken(MySQLParser::UNIQUE_SYMBOL, 0);
}

MySQLParser::KeyOrIndexContext* MySQLParser::ConstraintKeyTypeContext::keyOrIndex() {
  return getRuleContext<MySQLParser::KeyOrIndexContext>(0);
}


size_t MySQLParser::ConstraintKeyTypeContext::getRuleIndex() const {
  return MySQLParser::RuleConstraintKeyType;
}

void MySQLParser::ConstraintKeyTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraintKeyType(this);
}

void MySQLParser::ConstraintKeyTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraintKeyType(this);
}


antlrcpp::Any MySQLParser::ConstraintKeyTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitConstraintKeyType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ConstraintKeyTypeContext* MySQLParser::constraintKeyType() {
  ConstraintKeyTypeContext *_localctx = _tracker.createInstance<ConstraintKeyTypeContext>(_ctx, getState());
  enterRule(_localctx, 398, MySQLParser::RuleConstraintKeyType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3447);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::PRIMARY_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3441);
        match(MySQLParser::PRIMARY_SYMBOL);
        setState(3442);
        match(MySQLParser::KEY_SYMBOL);
        break;
      }

      case MySQLParser::UNIQUE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3443);
        match(MySQLParser::UNIQUE_SYMBOL);
        setState(3445);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::INDEX_SYMBOL

        || _la == MySQLParser::KEY_SYMBOL) {
          setState(3444);
          keyOrIndex();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexHintClauseContext ------------------------------------------------------------------

MySQLParser::IndexHintClauseContext::IndexHintClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IndexHintClauseContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IndexHintClauseContext::JOIN_SYMBOL() {
  return getToken(MySQLParser::JOIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IndexHintClauseContext::ORDER_SYMBOL() {
  return getToken(MySQLParser::ORDER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IndexHintClauseContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IndexHintClauseContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}


size_t MySQLParser::IndexHintClauseContext::getRuleIndex() const {
  return MySQLParser::RuleIndexHintClause;
}

void MySQLParser::IndexHintClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexHintClause(this);
}

void MySQLParser::IndexHintClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexHintClause(this);
}


antlrcpp::Any MySQLParser::IndexHintClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIndexHintClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexHintClauseContext* MySQLParser::indexHintClause() {
  IndexHintClauseContext *_localctx = _tracker.createInstance<IndexHintClauseContext>(_ctx, getState());
  enterRule(_localctx, 400, MySQLParser::RuleIndexHintClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3449);
    match(MySQLParser::FOR_SYMBOL);
    setState(3455);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::JOIN_SYMBOL: {
        setState(3450);
        match(MySQLParser::JOIN_SYMBOL);
        break;
      }

      case MySQLParser::ORDER_SYMBOL: {
        setState(3451);
        match(MySQLParser::ORDER_SYMBOL);
        setState(3452);
        match(MySQLParser::BY_SYMBOL);
        break;
      }

      case MySQLParser::GROUP_SYMBOL: {
        setState(3453);
        match(MySQLParser::GROUP_SYMBOL);
        setState(3454);
        match(MySQLParser::BY_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexListContext ------------------------------------------------------------------

MySQLParser::IndexListContext::IndexListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::IndexListElementContext *> MySQLParser::IndexListContext::indexListElement() {
  return getRuleContexts<MySQLParser::IndexListElementContext>();
}

MySQLParser::IndexListElementContext* MySQLParser::IndexListContext::indexListElement(size_t i) {
  return getRuleContext<MySQLParser::IndexListElementContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::IndexListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::IndexListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::IndexListContext::getRuleIndex() const {
  return MySQLParser::RuleIndexList;
}

void MySQLParser::IndexListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexList(this);
}

void MySQLParser::IndexListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexList(this);
}


antlrcpp::Any MySQLParser::IndexListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIndexList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexListContext* MySQLParser::indexList() {
  IndexListContext *_localctx = _tracker.createInstance<IndexListContext>(_ctx, getState());
  enterRule(_localctx, 402, MySQLParser::RuleIndexList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3457);
    indexListElement();
    setState(3462);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(3458);
      match(MySQLParser::COMMA_SYMBOL);
      setState(3459);
      indexListElement();
      setState(3464);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexListElementContext ------------------------------------------------------------------

MySQLParser::IndexListElementContext::IndexListElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::IndexListElementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::IndexListElementContext::PRIMARY_SYMBOL() {
  return getToken(MySQLParser::PRIMARY_SYMBOL, 0);
}


size_t MySQLParser::IndexListElementContext::getRuleIndex() const {
  return MySQLParser::RuleIndexListElement;
}

void MySQLParser::IndexListElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexListElement(this);
}

void MySQLParser::IndexListElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexListElement(this);
}


antlrcpp::Any MySQLParser::IndexListElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIndexListElement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexListElementContext* MySQLParser::indexListElement() {
  IndexListElementContext *_localctx = _tracker.createInstance<IndexListElementContext>(_ctx, getState());
  enterRule(_localctx, 404, MySQLParser::RuleIndexListElement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3467);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 386, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3465);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3466);
      match(MySQLParser::PRIMARY_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UpdateStatementContext ------------------------------------------------------------------

MySQLParser::UpdateStatementContext::UpdateStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::UpdateStatementContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

MySQLParser::TableReferenceListContext* MySQLParser::UpdateStatementContext::tableReferenceList() {
  return getRuleContext<MySQLParser::TableReferenceListContext>(0);
}

tree::TerminalNode* MySQLParser::UpdateStatementContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

MySQLParser::UpdateListContext* MySQLParser::UpdateStatementContext::updateList() {
  return getRuleContext<MySQLParser::UpdateListContext>(0);
}

MySQLParser::WithClauseContext* MySQLParser::UpdateStatementContext::withClause() {
  return getRuleContext<MySQLParser::WithClauseContext>(0);
}

tree::TerminalNode* MySQLParser::UpdateStatementContext::LOW_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::LOW_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::UpdateStatementContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

MySQLParser::WhereClauseContext* MySQLParser::UpdateStatementContext::whereClause() {
  return getRuleContext<MySQLParser::WhereClauseContext>(0);
}

MySQLParser::OrderClauseContext* MySQLParser::UpdateStatementContext::orderClause() {
  return getRuleContext<MySQLParser::OrderClauseContext>(0);
}

MySQLParser::SimpleLimitClauseContext* MySQLParser::UpdateStatementContext::simpleLimitClause() {
  return getRuleContext<MySQLParser::SimpleLimitClauseContext>(0);
}


size_t MySQLParser::UpdateStatementContext::getRuleIndex() const {
  return MySQLParser::RuleUpdateStatement;
}

void MySQLParser::UpdateStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdateStatement(this);
}

void MySQLParser::UpdateStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdateStatement(this);
}


antlrcpp::Any MySQLParser::UpdateStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitUpdateStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UpdateStatementContext* MySQLParser::updateStatement() {
  UpdateStatementContext *_localctx = _tracker.createInstance<UpdateStatementContext>(_ctx, getState());
  enterRule(_localctx, 406, MySQLParser::RuleUpdateStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3471);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 387, _ctx)) {
    case 1: {
      setState(3469);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(3470);
      withClause();
      break;
    }

    }
    setState(3473);
    match(MySQLParser::UPDATE_SYMBOL);
    setState(3475);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 388, _ctx)) {
    case 1: {
      setState(3474);
      match(MySQLParser::LOW_PRIORITY_SYMBOL);
      break;
    }

    }
    setState(3478);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 389, _ctx)) {
    case 1: {
      setState(3477);
      match(MySQLParser::IGNORE_SYMBOL);
      break;
    }

    }
    setState(3480);
    tableReferenceList();
    setState(3481);
    match(MySQLParser::SET_SYMBOL);
    setState(3482);
    updateList();
    setState(3484);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::WHERE_SYMBOL) {
      setState(3483);
      whereClause();
    }
    setState(3487);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ORDER_SYMBOL) {
      setState(3486);
      orderClause();
    }
    setState(3490);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LIMIT_SYMBOL) {
      setState(3489);
      simpleLimitClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransactionOrLockingStatementContext ------------------------------------------------------------------

MySQLParser::TransactionOrLockingStatementContext::TransactionOrLockingStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TransactionStatementContext* MySQLParser::TransactionOrLockingStatementContext::transactionStatement() {
  return getRuleContext<MySQLParser::TransactionStatementContext>(0);
}

MySQLParser::SavepointStatementContext* MySQLParser::TransactionOrLockingStatementContext::savepointStatement() {
  return getRuleContext<MySQLParser::SavepointStatementContext>(0);
}

MySQLParser::LockStatementContext* MySQLParser::TransactionOrLockingStatementContext::lockStatement() {
  return getRuleContext<MySQLParser::LockStatementContext>(0);
}

MySQLParser::XaStatementContext* MySQLParser::TransactionOrLockingStatementContext::xaStatement() {
  return getRuleContext<MySQLParser::XaStatementContext>(0);
}


size_t MySQLParser::TransactionOrLockingStatementContext::getRuleIndex() const {
  return MySQLParser::RuleTransactionOrLockingStatement;
}

void MySQLParser::TransactionOrLockingStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransactionOrLockingStatement(this);
}

void MySQLParser::TransactionOrLockingStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransactionOrLockingStatement(this);
}


antlrcpp::Any MySQLParser::TransactionOrLockingStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTransactionOrLockingStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TransactionOrLockingStatementContext* MySQLParser::transactionOrLockingStatement() {
  TransactionOrLockingStatementContext *_localctx = _tracker.createInstance<TransactionOrLockingStatementContext>(_ctx, getState());
  enterRule(_localctx, 408, MySQLParser::RuleTransactionOrLockingStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3496);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 393, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3492);
      transactionStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3493);
      savepointStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3494);
      lockStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3495);
      xaStatement();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransactionStatementContext ------------------------------------------------------------------

MySQLParser::TransactionStatementContext::TransactionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TransactionStatementContext::START_SYMBOL() {
  return getToken(MySQLParser::START_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TransactionStatementContext::TRANSACTION_SYMBOL() {
  return getToken(MySQLParser::TRANSACTION_SYMBOL, 0);
}

std::vector<MySQLParser::TransactionCharacteristicContext *> MySQLParser::TransactionStatementContext::transactionCharacteristic() {
  return getRuleContexts<MySQLParser::TransactionCharacteristicContext>();
}

MySQLParser::TransactionCharacteristicContext* MySQLParser::TransactionStatementContext::transactionCharacteristic(size_t i) {
  return getRuleContext<MySQLParser::TransactionCharacteristicContext>(i);
}

tree::TerminalNode* MySQLParser::TransactionStatementContext::COMMIT_SYMBOL() {
  return getToken(MySQLParser::COMMIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TransactionStatementContext::WORK_SYMBOL() {
  return getToken(MySQLParser::WORK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TransactionStatementContext::AND_SYMBOL() {
  return getToken(MySQLParser::AND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TransactionStatementContext::CHAIN_SYMBOL() {
  return getToken(MySQLParser::CHAIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TransactionStatementContext::RELEASE_SYMBOL() {
  return getToken(MySQLParser::RELEASE_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::TransactionStatementContext::NO_SYMBOL() {
  return getTokens(MySQLParser::NO_SYMBOL);
}

tree::TerminalNode* MySQLParser::TransactionStatementContext::NO_SYMBOL(size_t i) {
  return getToken(MySQLParser::NO_SYMBOL, i);
}


size_t MySQLParser::TransactionStatementContext::getRuleIndex() const {
  return MySQLParser::RuleTransactionStatement;
}

void MySQLParser::TransactionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransactionStatement(this);
}

void MySQLParser::TransactionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransactionStatement(this);
}


antlrcpp::Any MySQLParser::TransactionStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTransactionStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TransactionStatementContext* MySQLParser::transactionStatement() {
  TransactionStatementContext *_localctx = _tracker.createInstance<TransactionStatementContext>(_ctx, getState());
  enterRule(_localctx, 410, MySQLParser::RuleTransactionStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(3523);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::START_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3498);
        match(MySQLParser::START_SYMBOL);
        setState(3499);
        match(MySQLParser::TRANSACTION_SYMBOL);
        setState(3503);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 394, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(3500);
            transactionCharacteristic(); 
          }
          setState(3505);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 394, _ctx);
        }
        break;
      }

      case MySQLParser::COMMIT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3506);
        match(MySQLParser::COMMIT_SYMBOL);
        setState(3508);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::WORK_SYMBOL) {
          setState(3507);
          match(MySQLParser::WORK_SYMBOL);
        }
        setState(3515);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::AND_SYMBOL) {
          setState(3510);
          match(MySQLParser::AND_SYMBOL);
          setState(3512);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLParser::NO_SYMBOL) {
            setState(3511);
            match(MySQLParser::NO_SYMBOL);
          }
          setState(3514);
          match(MySQLParser::CHAIN_SYMBOL);
        }
        setState(3521);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::NO_SYMBOL || _la == MySQLParser::RELEASE_SYMBOL) {
          setState(3518);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLParser::NO_SYMBOL) {
            setState(3517);
            match(MySQLParser::NO_SYMBOL);
          }
          setState(3520);
          match(MySQLParser::RELEASE_SYMBOL);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BeginWorkContext ------------------------------------------------------------------

MySQLParser::BeginWorkContext::BeginWorkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::BeginWorkContext::BEGIN_SYMBOL() {
  return getToken(MySQLParser::BEGIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::BeginWorkContext::WORK_SYMBOL() {
  return getToken(MySQLParser::WORK_SYMBOL, 0);
}


size_t MySQLParser::BeginWorkContext::getRuleIndex() const {
  return MySQLParser::RuleBeginWork;
}

void MySQLParser::BeginWorkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBeginWork(this);
}

void MySQLParser::BeginWorkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBeginWork(this);
}


antlrcpp::Any MySQLParser::BeginWorkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitBeginWork(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::BeginWorkContext* MySQLParser::beginWork() {
  BeginWorkContext *_localctx = _tracker.createInstance<BeginWorkContext>(_ctx, getState());
  enterRule(_localctx, 412, MySQLParser::RuleBeginWork);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3525);
    match(MySQLParser::BEGIN_SYMBOL);
    setState(3527);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::WORK_SYMBOL) {
      setState(3526);
      match(MySQLParser::WORK_SYMBOL);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransactionCharacteristicContext ------------------------------------------------------------------

MySQLParser::TransactionCharacteristicContext::TransactionCharacteristicContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TransactionCharacteristicContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TransactionCharacteristicContext::CONSISTENT_SYMBOL() {
  return getToken(MySQLParser::CONSISTENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TransactionCharacteristicContext::SNAPSHOT_SYMBOL() {
  return getToken(MySQLParser::SNAPSHOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TransactionCharacteristicContext::READ_SYMBOL() {
  return getToken(MySQLParser::READ_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TransactionCharacteristicContext::WRITE_SYMBOL() {
  return getToken(MySQLParser::WRITE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TransactionCharacteristicContext::ONLY_SYMBOL() {
  return getToken(MySQLParser::ONLY_SYMBOL, 0);
}


size_t MySQLParser::TransactionCharacteristicContext::getRuleIndex() const {
  return MySQLParser::RuleTransactionCharacteristic;
}

void MySQLParser::TransactionCharacteristicContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransactionCharacteristic(this);
}

void MySQLParser::TransactionCharacteristicContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransactionCharacteristic(this);
}


antlrcpp::Any MySQLParser::TransactionCharacteristicContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTransactionCharacteristic(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TransactionCharacteristicContext* MySQLParser::transactionCharacteristic() {
  TransactionCharacteristicContext *_localctx = _tracker.createInstance<TransactionCharacteristicContext>(_ctx, getState());
  enterRule(_localctx, 414, MySQLParser::RuleTransactionCharacteristic);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3535);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 402, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3529);
      match(MySQLParser::WITH_SYMBOL);
      setState(3530);
      match(MySQLParser::CONSISTENT_SYMBOL);
      setState(3531);
      match(MySQLParser::SNAPSHOT_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3532);

      if (!(serverVersion >= 50605)) throw FailedPredicateException(this, "serverVersion >= 50605");
      setState(3533);
      match(MySQLParser::READ_SYMBOL);
      setState(3534);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::ONLY_SYMBOL || _la == MySQLParser::WRITE_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetTransactionCharacteristicContext ------------------------------------------------------------------

MySQLParser::SetTransactionCharacteristicContext::SetTransactionCharacteristicContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SetTransactionCharacteristicContext::ISOLATION_SYMBOL() {
  return getToken(MySQLParser::ISOLATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetTransactionCharacteristicContext::LEVEL_SYMBOL() {
  return getToken(MySQLParser::LEVEL_SYMBOL, 0);
}

MySQLParser::IsolationLevelContext* MySQLParser::SetTransactionCharacteristicContext::isolationLevel() {
  return getRuleContext<MySQLParser::IsolationLevelContext>(0);
}

tree::TerminalNode* MySQLParser::SetTransactionCharacteristicContext::READ_SYMBOL() {
  return getToken(MySQLParser::READ_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetTransactionCharacteristicContext::WRITE_SYMBOL() {
  return getToken(MySQLParser::WRITE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetTransactionCharacteristicContext::ONLY_SYMBOL() {
  return getToken(MySQLParser::ONLY_SYMBOL, 0);
}


size_t MySQLParser::SetTransactionCharacteristicContext::getRuleIndex() const {
  return MySQLParser::RuleSetTransactionCharacteristic;
}

void MySQLParser::SetTransactionCharacteristicContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetTransactionCharacteristic(this);
}

void MySQLParser::SetTransactionCharacteristicContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetTransactionCharacteristic(this);
}


antlrcpp::Any MySQLParser::SetTransactionCharacteristicContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSetTransactionCharacteristic(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SetTransactionCharacteristicContext* MySQLParser::setTransactionCharacteristic() {
  SetTransactionCharacteristicContext *_localctx = _tracker.createInstance<SetTransactionCharacteristicContext>(_ctx, getState());
  enterRule(_localctx, 416, MySQLParser::RuleSetTransactionCharacteristic);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3543);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 403, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3537);
      match(MySQLParser::ISOLATION_SYMBOL);
      setState(3538);
      match(MySQLParser::LEVEL_SYMBOL);
      setState(3539);
      isolationLevel();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3540);

      if (!(serverVersion >= 50605)) throw FailedPredicateException(this, "serverVersion >= 50605");
      setState(3541);
      match(MySQLParser::READ_SYMBOL);
      setState(3542);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::ONLY_SYMBOL || _la == MySQLParser::WRITE_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IsolationLevelContext ------------------------------------------------------------------

MySQLParser::IsolationLevelContext::IsolationLevelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IsolationLevelContext::REPEATABLE_SYMBOL() {
  return getToken(MySQLParser::REPEATABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IsolationLevelContext::READ_SYMBOL() {
  return getToken(MySQLParser::READ_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IsolationLevelContext::COMMITTED_SYMBOL() {
  return getToken(MySQLParser::COMMITTED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IsolationLevelContext::UNCOMMITTED_SYMBOL() {
  return getToken(MySQLParser::UNCOMMITTED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IsolationLevelContext::SERIALIZABLE_SYMBOL() {
  return getToken(MySQLParser::SERIALIZABLE_SYMBOL, 0);
}


size_t MySQLParser::IsolationLevelContext::getRuleIndex() const {
  return MySQLParser::RuleIsolationLevel;
}

void MySQLParser::IsolationLevelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIsolationLevel(this);
}

void MySQLParser::IsolationLevelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIsolationLevel(this);
}


antlrcpp::Any MySQLParser::IsolationLevelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIsolationLevel(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IsolationLevelContext* MySQLParser::isolationLevel() {
  IsolationLevelContext *_localctx = _tracker.createInstance<IsolationLevelContext>(_ctx, getState());
  enterRule(_localctx, 418, MySQLParser::RuleIsolationLevel);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3550);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::REPEATABLE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3545);
        match(MySQLParser::REPEATABLE_SYMBOL);
        setState(3546);
        match(MySQLParser::READ_SYMBOL);
        break;
      }

      case MySQLParser::READ_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3547);
        match(MySQLParser::READ_SYMBOL);
        setState(3548);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::COMMITTED_SYMBOL || _la == MySQLParser::UNCOMMITTED_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case MySQLParser::SERIALIZABLE_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(3549);
        match(MySQLParser::SERIALIZABLE_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SavepointStatementContext ------------------------------------------------------------------

MySQLParser::SavepointStatementContext::SavepointStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SavepointStatementContext::SAVEPOINT_SYMBOL() {
  return getToken(MySQLParser::SAVEPOINT_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::SavepointStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::SavepointStatementContext::ROLLBACK_SYMBOL() {
  return getToken(MySQLParser::ROLLBACK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SavepointStatementContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SavepointStatementContext::WORK_SYMBOL() {
  return getToken(MySQLParser::WORK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SavepointStatementContext::AND_SYMBOL() {
  return getToken(MySQLParser::AND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SavepointStatementContext::CHAIN_SYMBOL() {
  return getToken(MySQLParser::CHAIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SavepointStatementContext::RELEASE_SYMBOL() {
  return getToken(MySQLParser::RELEASE_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::SavepointStatementContext::NO_SYMBOL() {
  return getTokens(MySQLParser::NO_SYMBOL);
}

tree::TerminalNode* MySQLParser::SavepointStatementContext::NO_SYMBOL(size_t i) {
  return getToken(MySQLParser::NO_SYMBOL, i);
}


size_t MySQLParser::SavepointStatementContext::getRuleIndex() const {
  return MySQLParser::RuleSavepointStatement;
}

void MySQLParser::SavepointStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSavepointStatement(this);
}

void MySQLParser::SavepointStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSavepointStatement(this);
}


antlrcpp::Any MySQLParser::SavepointStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSavepointStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SavepointStatementContext* MySQLParser::savepointStatement() {
  SavepointStatementContext *_localctx = _tracker.createInstance<SavepointStatementContext>(_ctx, getState());
  enterRule(_localctx, 420, MySQLParser::RuleSavepointStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3581);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::SAVEPOINT_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3552);
        match(MySQLParser::SAVEPOINT_SYMBOL);
        setState(3553);
        identifier();
        break;
      }

      case MySQLParser::ROLLBACK_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3554);
        match(MySQLParser::ROLLBACK_SYMBOL);
        setState(3556);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::WORK_SYMBOL) {
          setState(3555);
          match(MySQLParser::WORK_SYMBOL);
        }
        setState(3576);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::TO_SYMBOL: {
            setState(3558);
            match(MySQLParser::TO_SYMBOL);
            setState(3560);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 406, _ctx)) {
            case 1: {
              setState(3559);
              match(MySQLParser::SAVEPOINT_SYMBOL);
              break;
            }

            }
            setState(3562);
            identifier();
            break;
          }

          case MySQLParser::EOF:
          case MySQLParser::NO_SYMBOL:
          case MySQLParser::SEMICOLON_SYMBOL:
          case MySQLParser::AND_SYMBOL:
          case MySQLParser::RELEASE_SYMBOL: {
            setState(3568);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::AND_SYMBOL) {
              setState(3563);
              match(MySQLParser::AND_SYMBOL);
              setState(3565);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == MySQLParser::NO_SYMBOL) {
                setState(3564);
                match(MySQLParser::NO_SYMBOL);
              }
              setState(3567);
              match(MySQLParser::CHAIN_SYMBOL);
            }
            setState(3574);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::NO_SYMBOL || _la == MySQLParser::RELEASE_SYMBOL) {
              setState(3571);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == MySQLParser::NO_SYMBOL) {
                setState(3570);
                match(MySQLParser::NO_SYMBOL);
              }
              setState(3573);
              match(MySQLParser::RELEASE_SYMBOL);
            }
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case MySQLParser::RELEASE_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(3578);
        match(MySQLParser::RELEASE_SYMBOL);
        setState(3579);
        match(MySQLParser::SAVEPOINT_SYMBOL);
        setState(3580);
        identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockStatementContext ------------------------------------------------------------------

MySQLParser::LockStatementContext::LockStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LockStatementContext::LOCK_SYMBOL() {
  return getToken(MySQLParser::LOCK_SYMBOL, 0);
}

std::vector<MySQLParser::LockItemContext *> MySQLParser::LockStatementContext::lockItem() {
  return getRuleContexts<MySQLParser::LockItemContext>();
}

MySQLParser::LockItemContext* MySQLParser::LockStatementContext::lockItem(size_t i) {
  return getRuleContext<MySQLParser::LockItemContext>(i);
}

tree::TerminalNode* MySQLParser::LockStatementContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockStatementContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::LockStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::LockStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

tree::TerminalNode* MySQLParser::LockStatementContext::INSTANCE_SYMBOL() {
  return getToken(MySQLParser::INSTANCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockStatementContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockStatementContext::BACKUP_SYMBOL() {
  return getToken(MySQLParser::BACKUP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockStatementContext::UNLOCK_SYMBOL() {
  return getToken(MySQLParser::UNLOCK_SYMBOL, 0);
}


size_t MySQLParser::LockStatementContext::getRuleIndex() const {
  return MySQLParser::RuleLockStatement;
}

void MySQLParser::LockStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockStatement(this);
}

void MySQLParser::LockStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockStatement(this);
}


antlrcpp::Any MySQLParser::LockStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLockStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LockStatementContext* MySQLParser::lockStatement() {
  LockStatementContext *_localctx = _tracker.createInstance<LockStatementContext>(_ctx, getState());
  enterRule(_localctx, 422, MySQLParser::RuleLockStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3605);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 415, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3583);
      match(MySQLParser::LOCK_SYMBOL);
      setState(3584);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::TABLES_SYMBOL || _la == MySQLParser::TABLE_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3585);
      lockItem();
      setState(3590);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(3586);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3587);
        lockItem();
        setState(3592);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3593);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(3594);
      match(MySQLParser::LOCK_SYMBOL);
      setState(3595);
      match(MySQLParser::INSTANCE_SYMBOL);
      setState(3596);
      match(MySQLParser::FOR_SYMBOL);
      setState(3597);
      match(MySQLParser::BACKUP_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3598);
      match(MySQLParser::UNLOCK_SYMBOL);
      setState(3603);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 414, _ctx)) {
      case 1: {
        setState(3599);
        match(MySQLParser::TABLES_SYMBOL);
        break;
      }

      case 2: {
        setState(3600);
        match(MySQLParser::TABLE_SYMBOL);
        break;
      }

      case 3: {
        setState(3601);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(3602);
        match(MySQLParser::INSTANCE_SYMBOL);
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockItemContext ------------------------------------------------------------------

MySQLParser::LockItemContext::LockItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext* MySQLParser::LockItemContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::LockOptionContext* MySQLParser::LockItemContext::lockOption() {
  return getRuleContext<MySQLParser::LockOptionContext>(0);
}

MySQLParser::TableAliasContext* MySQLParser::LockItemContext::tableAlias() {
  return getRuleContext<MySQLParser::TableAliasContext>(0);
}


size_t MySQLParser::LockItemContext::getRuleIndex() const {
  return MySQLParser::RuleLockItem;
}

void MySQLParser::LockItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockItem(this);
}

void MySQLParser::LockItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockItem(this);
}


antlrcpp::Any MySQLParser::LockItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLockItem(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LockItemContext* MySQLParser::lockItem() {
  LockItemContext *_localctx = _tracker.createInstance<LockItemContext>(_ctx, getState());
  enterRule(_localctx, 424, MySQLParser::RuleLockItem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3607);
    tableRef();
    setState(3609);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 416, _ctx)) {
    case 1: {
      setState(3608);
      tableAlias();
      break;
    }

    }
    setState(3611);
    lockOption();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockOptionContext ------------------------------------------------------------------

MySQLParser::LockOptionContext::LockOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LockOptionContext::READ_SYMBOL() {
  return getToken(MySQLParser::READ_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockOptionContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockOptionContext::WRITE_SYMBOL() {
  return getToken(MySQLParser::WRITE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockOptionContext::LOW_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::LOW_PRIORITY_SYMBOL, 0);
}


size_t MySQLParser::LockOptionContext::getRuleIndex() const {
  return MySQLParser::RuleLockOption;
}

void MySQLParser::LockOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockOption(this);
}

void MySQLParser::LockOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockOption(this);
}


antlrcpp::Any MySQLParser::LockOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLockOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LockOptionContext* MySQLParser::lockOption() {
  LockOptionContext *_localctx = _tracker.createInstance<LockOptionContext>(_ctx, getState());
  enterRule(_localctx, 426, MySQLParser::RuleLockOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3621);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::READ_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3613);
        match(MySQLParser::READ_SYMBOL);
        setState(3615);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LOCAL_SYMBOL) {
          setState(3614);
          match(MySQLParser::LOCAL_SYMBOL);
        }
        break;
      }

      case MySQLParser::LOW_PRIORITY_SYMBOL:
      case MySQLParser::WRITE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3618);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LOW_PRIORITY_SYMBOL) {
          setState(3617);
          match(MySQLParser::LOW_PRIORITY_SYMBOL);
        }
        setState(3620);
        match(MySQLParser::WRITE_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XaStatementContext ------------------------------------------------------------------

MySQLParser::XaStatementContext::XaStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::XaStatementContext::XA_SYMBOL() {
  return getToken(MySQLParser::XA_SYMBOL, 0);
}

MySQLParser::XidContext* MySQLParser::XaStatementContext::xid() {
  return getRuleContext<MySQLParser::XidContext>(0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::PREPARE_SYMBOL() {
  return getToken(MySQLParser::PREPARE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::COMMIT_SYMBOL() {
  return getToken(MySQLParser::COMMIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::ROLLBACK_SYMBOL() {
  return getToken(MySQLParser::ROLLBACK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::RECOVER_SYMBOL() {
  return getToken(MySQLParser::RECOVER_SYMBOL, 0);
}

MySQLParser::XaConvertContext* MySQLParser::XaStatementContext::xaConvert() {
  return getRuleContext<MySQLParser::XaConvertContext>(0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::START_SYMBOL() {
  return getToken(MySQLParser::START_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::BEGIN_SYMBOL() {
  return getToken(MySQLParser::BEGIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::SUSPEND_SYMBOL() {
  return getToken(MySQLParser::SUSPEND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::ONE_SYMBOL() {
  return getToken(MySQLParser::ONE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::PHASE_SYMBOL() {
  return getToken(MySQLParser::PHASE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::JOIN_SYMBOL() {
  return getToken(MySQLParser::JOIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::RESUME_SYMBOL() {
  return getToken(MySQLParser::RESUME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::MIGRATE_SYMBOL() {
  return getToken(MySQLParser::MIGRATE_SYMBOL, 0);
}


size_t MySQLParser::XaStatementContext::getRuleIndex() const {
  return MySQLParser::RuleXaStatement;
}

void MySQLParser::XaStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXaStatement(this);
}

void MySQLParser::XaStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXaStatement(this);
}


antlrcpp::Any MySQLParser::XaStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitXaStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::XaStatementContext* MySQLParser::xaStatement() {
  XaStatementContext *_localctx = _tracker.createInstance<XaStatementContext>(_ctx, getState());
  enterRule(_localctx, 428, MySQLParser::RuleXaStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3623);
    match(MySQLParser::XA_SYMBOL);
    setState(3650);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::BEGIN_SYMBOL:
      case MySQLParser::START_SYMBOL: {
        setState(3624);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::BEGIN_SYMBOL

        || _la == MySQLParser::START_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3625);
        xid();
        setState(3627);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::RESUME_SYMBOL || _la == MySQLParser::JOIN_SYMBOL) {
          setState(3626);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::RESUME_SYMBOL || _la == MySQLParser::JOIN_SYMBOL)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        break;
      }

      case MySQLParser::END_SYMBOL: {
        setState(3629);
        match(MySQLParser::END_SYMBOL);
        setState(3630);
        xid();
        setState(3636);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::SUSPEND_SYMBOL) {
          setState(3631);
          match(MySQLParser::SUSPEND_SYMBOL);
          setState(3634);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLParser::FOR_SYMBOL) {
            setState(3632);
            match(MySQLParser::FOR_SYMBOL);
            setState(3633);
            match(MySQLParser::MIGRATE_SYMBOL);
          }
        }
        break;
      }

      case MySQLParser::PREPARE_SYMBOL: {
        setState(3638);
        match(MySQLParser::PREPARE_SYMBOL);
        setState(3639);
        xid();
        break;
      }

      case MySQLParser::COMMIT_SYMBOL: {
        setState(3640);
        match(MySQLParser::COMMIT_SYMBOL);
        setState(3641);
        xid();
        setState(3644);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ONE_SYMBOL) {
          setState(3642);
          match(MySQLParser::ONE_SYMBOL);
          setState(3643);
          match(MySQLParser::PHASE_SYMBOL);
        }
        break;
      }

      case MySQLParser::ROLLBACK_SYMBOL: {
        setState(3646);
        match(MySQLParser::ROLLBACK_SYMBOL);
        setState(3647);
        xid();
        break;
      }

      case MySQLParser::RECOVER_SYMBOL: {
        setState(3648);
        match(MySQLParser::RECOVER_SYMBOL);
        setState(3649);
        xaConvert();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XaConvertContext ------------------------------------------------------------------

MySQLParser::XaConvertContext::XaConvertContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::XaConvertContext::CONVERT_SYMBOL() {
  return getToken(MySQLParser::CONVERT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaConvertContext::XID_SYMBOL() {
  return getToken(MySQLParser::XID_SYMBOL, 0);
}


size_t MySQLParser::XaConvertContext::getRuleIndex() const {
  return MySQLParser::RuleXaConvert;
}

void MySQLParser::XaConvertContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXaConvert(this);
}

void MySQLParser::XaConvertContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXaConvert(this);
}


antlrcpp::Any MySQLParser::XaConvertContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitXaConvert(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::XaConvertContext* MySQLParser::xaConvert() {
  XaConvertContext *_localctx = _tracker.createInstance<XaConvertContext>(_ctx, getState());
  enterRule(_localctx, 430, MySQLParser::RuleXaConvert);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3658);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 426, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3652);

      if (!(serverVersion >= 50704)) throw FailedPredicateException(this, "serverVersion >= 50704");
      setState(3655);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::CONVERT_SYMBOL) {
        setState(3653);
        match(MySQLParser::CONVERT_SYMBOL);
        setState(3654);
        match(MySQLParser::XID_SYMBOL);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);

      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XidContext ------------------------------------------------------------------

MySQLParser::XidContext::XidContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TextStringContext *> MySQLParser::XidContext::textString() {
  return getRuleContexts<MySQLParser::TextStringContext>();
}

MySQLParser::TextStringContext* MySQLParser::XidContext::textString(size_t i) {
  return getRuleContext<MySQLParser::TextStringContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::XidContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::XidContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

MySQLParser::Ulong_numberContext* MySQLParser::XidContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}


size_t MySQLParser::XidContext::getRuleIndex() const {
  return MySQLParser::RuleXid;
}

void MySQLParser::XidContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXid(this);
}

void MySQLParser::XidContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXid(this);
}


antlrcpp::Any MySQLParser::XidContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitXid(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::XidContext* MySQLParser::xid() {
  XidContext *_localctx = _tracker.createInstance<XidContext>(_ctx, getState());
  enterRule(_localctx, 432, MySQLParser::RuleXid);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3660);
    textString();
    setState(3667);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::COMMA_SYMBOL) {
      setState(3661);
      match(MySQLParser::COMMA_SYMBOL);
      setState(3662);
      textString();
      setState(3665);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(3663);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3664);
        ulong_number();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplicationStatementContext ------------------------------------------------------------------

MySQLParser::ReplicationStatementContext::ReplicationStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ReplicationStatementContext::PURGE_SYMBOL() {
  return getToken(MySQLParser::PURGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReplicationStatementContext::LOGS_SYMBOL() {
  return getToken(MySQLParser::LOGS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReplicationStatementContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReplicationStatementContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReplicationStatementContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::ReplicationStatementContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::ReplicationStatementContext::BEFORE_SYMBOL() {
  return getToken(MySQLParser::BEFORE_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::ReplicationStatementContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::ChangeMasterContext* MySQLParser::ReplicationStatementContext::changeMaster() {
  return getRuleContext<MySQLParser::ChangeMasterContext>(0);
}

tree::TerminalNode* MySQLParser::ReplicationStatementContext::RESET_SYMBOL() {
  return getToken(MySQLParser::RESET_SYMBOL, 0);
}

std::vector<MySQLParser::ResetOptionContext *> MySQLParser::ReplicationStatementContext::resetOption() {
  return getRuleContexts<MySQLParser::ResetOptionContext>();
}

MySQLParser::ResetOptionContext* MySQLParser::ReplicationStatementContext::resetOption(size_t i) {
  return getRuleContext<MySQLParser::ResetOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ReplicationStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ReplicationStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

tree::TerminalNode* MySQLParser::ReplicationStatementContext::PERSIST_SYMBOL() {
  return getToken(MySQLParser::PERSIST_SYMBOL, 0);
}

MySQLParser::IfExistsContext* MySQLParser::ReplicationStatementContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}

MySQLParser::IdentifierContext* MySQLParser::ReplicationStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::SlaveContext* MySQLParser::ReplicationStatementContext::slave() {
  return getRuleContext<MySQLParser::SlaveContext>(0);
}

MySQLParser::ChangeReplicationContext* MySQLParser::ReplicationStatementContext::changeReplication() {
  return getRuleContext<MySQLParser::ChangeReplicationContext>(0);
}

MySQLParser::ReplicationLoadContext* MySQLParser::ReplicationStatementContext::replicationLoad() {
  return getRuleContext<MySQLParser::ReplicationLoadContext>(0);
}

MySQLParser::GroupReplicationContext* MySQLParser::ReplicationStatementContext::groupReplication() {
  return getRuleContext<MySQLParser::GroupReplicationContext>(0);
}


size_t MySQLParser::ReplicationStatementContext::getRuleIndex() const {
  return MySQLParser::RuleReplicationStatement;
}

void MySQLParser::ReplicationStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplicationStatement(this);
}

void MySQLParser::ReplicationStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplicationStatement(this);
}


antlrcpp::Any MySQLParser::ReplicationStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitReplicationStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ReplicationStatementContext* MySQLParser::replicationStatement() {
  ReplicationStatementContext *_localctx = _tracker.createInstance<ReplicationStatementContext>(_ctx, getState());
  enterRule(_localctx, 434, MySQLParser::RuleReplicationStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3703);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 432, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3669);
      match(MySQLParser::PURGE_SYMBOL);
      setState(3670);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::MASTER_SYMBOL || _la == MySQLParser::BINARY_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3671);
      match(MySQLParser::LOGS_SYMBOL);
      setState(3676);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::TO_SYMBOL: {
          setState(3672);
          match(MySQLParser::TO_SYMBOL);
          setState(3673);
          textLiteral();
          break;
        }

        case MySQLParser::BEFORE_SYMBOL: {
          setState(3674);
          match(MySQLParser::BEFORE_SYMBOL);
          setState(3675);
          expr(0);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3678);
      changeMaster();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3679);
      match(MySQLParser::RESET_SYMBOL);
      setState(3680);
      resetOption();
      setState(3685);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(3681);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3682);
        resetOption();
        setState(3687);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3688);

      if (!(serverVersion > 80000)) throw FailedPredicateException(this, "serverVersion > 80000");
      setState(3689);
      match(MySQLParser::RESET_SYMBOL);
      setState(3690);
      match(MySQLParser::PERSIST_SYMBOL);
      setState(3694);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::IF_SYMBOL) {
        setState(3691);
        ifExists();
        setState(3692);
        identifier();
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3696);
      slave();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3697);

      if (!(serverVersion >= 50700)) throw FailedPredicateException(this, "serverVersion >= 50700");
      setState(3698);
      changeReplication();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3699);

      if (!(serverVersion < 50500)) throw FailedPredicateException(this, "serverVersion < 50500");
      setState(3700);
      replicationLoad();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(3701);

      if (!(serverVersion > 50706)) throw FailedPredicateException(this, "serverVersion > 50706");
      setState(3702);
      groupReplication();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResetOptionContext ------------------------------------------------------------------

MySQLParser::ResetOptionContext::ResetOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ResetOptionContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

MySQLParser::MasterResetOptionsContext* MySQLParser::ResetOptionContext::masterResetOptions() {
  return getRuleContext<MySQLParser::MasterResetOptionsContext>(0);
}

tree::TerminalNode* MySQLParser::ResetOptionContext::CACHE_SYMBOL() {
  return getToken(MySQLParser::CACHE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ResetOptionContext::QUERY_SYMBOL() {
  return getToken(MySQLParser::QUERY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ResetOptionContext::SLAVE_SYMBOL() {
  return getToken(MySQLParser::SLAVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ResetOptionContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

MySQLParser::ChannelContext* MySQLParser::ResetOptionContext::channel() {
  return getRuleContext<MySQLParser::ChannelContext>(0);
}


size_t MySQLParser::ResetOptionContext::getRuleIndex() const {
  return MySQLParser::RuleResetOption;
}

void MySQLParser::ResetOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResetOption(this);
}

void MySQLParser::ResetOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResetOption(this);
}


antlrcpp::Any MySQLParser::ResetOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitResetOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ResetOptionContext* MySQLParser::resetOption() {
  ResetOptionContext *_localctx = _tracker.createInstance<ResetOptionContext>(_ctx, getState());
  enterRule(_localctx, 436, MySQLParser::RuleResetOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3719);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 436, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3705);
      dynamic_cast<ResetOptionContext *>(_localctx)->option = match(MySQLParser::MASTER_SYMBOL);
      setState(3707);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 433, _ctx)) {
      case 1: {
        setState(3706);
        masterResetOptions();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3709);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(3710);
      dynamic_cast<ResetOptionContext *>(_localctx)->option = match(MySQLParser::QUERY_SYMBOL);
      setState(3711);
      match(MySQLParser::CACHE_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3712);
      dynamic_cast<ResetOptionContext *>(_localctx)->option = match(MySQLParser::SLAVE_SYMBOL);
      setState(3714);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 434, _ctx)) {
      case 1: {
        setState(3713);
        match(MySQLParser::ALL_SYMBOL);
        break;
      }

      }
      setState(3717);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 435, _ctx)) {
      case 1: {
        setState(3716);
        channel();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MasterResetOptionsContext ------------------------------------------------------------------

MySQLParser::MasterResetOptionsContext::MasterResetOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::MasterResetOptionsContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::MasterResetOptionsContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}


size_t MySQLParser::MasterResetOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleMasterResetOptions;
}

void MySQLParser::MasterResetOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMasterResetOptions(this);
}

void MySQLParser::MasterResetOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMasterResetOptions(this);
}


antlrcpp::Any MySQLParser::MasterResetOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitMasterResetOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::MasterResetOptionsContext* MySQLParser::masterResetOptions() {
  MasterResetOptionsContext *_localctx = _tracker.createInstance<MasterResetOptionsContext>(_ctx, getState());
  enterRule(_localctx, 438, MySQLParser::RuleMasterResetOptions);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3721);

    if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
    setState(3722);
    match(MySQLParser::TO_SYMBOL);
    setState(3723);
    real_ulong_number();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplicationLoadContext ------------------------------------------------------------------

MySQLParser::ReplicationLoadContext::ReplicationLoadContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ReplicationLoadContext::LOAD_SYMBOL() {
  return getToken(MySQLParser::LOAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReplicationLoadContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReplicationLoadContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReplicationLoadContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReplicationLoadContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::ReplicationLoadContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}


size_t MySQLParser::ReplicationLoadContext::getRuleIndex() const {
  return MySQLParser::RuleReplicationLoad;
}

void MySQLParser::ReplicationLoadContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplicationLoad(this);
}

void MySQLParser::ReplicationLoadContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplicationLoad(this);
}


antlrcpp::Any MySQLParser::ReplicationLoadContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitReplicationLoad(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ReplicationLoadContext* MySQLParser::replicationLoad() {
  ReplicationLoadContext *_localctx = _tracker.createInstance<ReplicationLoadContext>(_ctx, getState());
  enterRule(_localctx, 440, MySQLParser::RuleReplicationLoad);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3725);
    match(MySQLParser::LOAD_SYMBOL);
    setState(3729);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::DATA_SYMBOL: {
        setState(3726);
        match(MySQLParser::DATA_SYMBOL);
        break;
      }

      case MySQLParser::TABLE_SYMBOL: {
        setState(3727);
        match(MySQLParser::TABLE_SYMBOL);
        setState(3728);
        tableRef();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(3731);
    match(MySQLParser::FROM_SYMBOL);
    setState(3732);
    match(MySQLParser::MASTER_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeMasterContext ------------------------------------------------------------------

MySQLParser::ChangeMasterContext::ChangeMasterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ChangeMasterContext::CHANGE_SYMBOL() {
  return getToken(MySQLParser::CHANGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ChangeMasterContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ChangeMasterContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::ChangeMasterOptionsContext* MySQLParser::ChangeMasterContext::changeMasterOptions() {
  return getRuleContext<MySQLParser::ChangeMasterOptionsContext>(0);
}

MySQLParser::ChannelContext* MySQLParser::ChangeMasterContext::channel() {
  return getRuleContext<MySQLParser::ChannelContext>(0);
}


size_t MySQLParser::ChangeMasterContext::getRuleIndex() const {
  return MySQLParser::RuleChangeMaster;
}

void MySQLParser::ChangeMasterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeMaster(this);
}

void MySQLParser::ChangeMasterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeMaster(this);
}


antlrcpp::Any MySQLParser::ChangeMasterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitChangeMaster(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeMasterContext* MySQLParser::changeMaster() {
  ChangeMasterContext *_localctx = _tracker.createInstance<ChangeMasterContext>(_ctx, getState());
  enterRule(_localctx, 442, MySQLParser::RuleChangeMaster);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3734);
    match(MySQLParser::CHANGE_SYMBOL);
    setState(3735);
    match(MySQLParser::MASTER_SYMBOL);
    setState(3736);
    match(MySQLParser::TO_SYMBOL);
    setState(3737);
    changeMasterOptions();
    setState(3739);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 438, _ctx)) {
    case 1: {
      setState(3738);
      channel();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeMasterOptionsContext ------------------------------------------------------------------

MySQLParser::ChangeMasterOptionsContext::ChangeMasterOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::MasterOptionContext *> MySQLParser::ChangeMasterOptionsContext::masterOption() {
  return getRuleContexts<MySQLParser::MasterOptionContext>();
}

MySQLParser::MasterOptionContext* MySQLParser::ChangeMasterOptionsContext::masterOption(size_t i) {
  return getRuleContext<MySQLParser::MasterOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ChangeMasterOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ChangeMasterOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ChangeMasterOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleChangeMasterOptions;
}

void MySQLParser::ChangeMasterOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeMasterOptions(this);
}

void MySQLParser::ChangeMasterOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeMasterOptions(this);
}


antlrcpp::Any MySQLParser::ChangeMasterOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitChangeMasterOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeMasterOptionsContext* MySQLParser::changeMasterOptions() {
  ChangeMasterOptionsContext *_localctx = _tracker.createInstance<ChangeMasterOptionsContext>(_ctx, getState());
  enterRule(_localctx, 444, MySQLParser::RuleChangeMasterOptions);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3741);
    masterOption();
    setState(3746);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 439, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3742);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3743);
        masterOption(); 
      }
      setState(3748);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 439, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MasterOptionContext ------------------------------------------------------------------

MySQLParser::MasterOptionContext::MasterOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_HOST_SYMBOL() {
  return getToken(MySQLParser::MASTER_HOST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TextStringNoLinebreakContext* MySQLParser::MasterOptionContext::textStringNoLinebreak() {
  return getRuleContext<MySQLParser::TextStringNoLinebreakContext>(0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_BIND_SYMBOL() {
  return getToken(MySQLParser::MASTER_BIND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_USER_SYMBOL() {
  return getToken(MySQLParser::MASTER_USER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_PASSWORD_SYMBOL() {
  return getToken(MySQLParser::MASTER_PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_PORT_SYMBOL() {
  return getToken(MySQLParser::MASTER_PORT_SYMBOL, 0);
}

MySQLParser::Ulong_numberContext* MySQLParser::MasterOptionContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_CONNECT_RETRY_SYMBOL() {
  return getToken(MySQLParser::MASTER_CONNECT_RETRY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_RETRY_COUNT_SYMBOL() {
  return getToken(MySQLParser::MASTER_RETRY_COUNT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_DELAY_SYMBOL() {
  return getToken(MySQLParser::MASTER_DELAY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_SSL_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_SSL_CA_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_TLS_VERSION_SYMBOL() {
  return getToken(MySQLParser::MASTER_TLS_VERSION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_SSL_CAPATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CAPATH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_SSL_CERT_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CERT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_SSL_CIPHER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CIPHER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_SSL_KEY_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_SSL_CRL_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CRL_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::MasterOptionContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_SSL_CRLPATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CRLPATH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_PUBLIC_KEY_PATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_PUBLIC_KEY_PATH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::GET_MASTER_PUBLIC_KEY_SYM() {
  return getToken(MySQLParser::GET_MASTER_PUBLIC_KEY_SYM, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_HEARTBEAT_PERIOD_SYMBOL() {
  return getToken(MySQLParser::MASTER_HEARTBEAT_PERIOD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::IGNORE_SERVER_IDS_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SERVER_IDS_SYMBOL, 0);
}

MySQLParser::ServerIdListContext* MySQLParser::MasterOptionContext::serverIdList() {
  return getRuleContext<MySQLParser::ServerIdListContext>(0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_AUTO_POSITION_SYMBOL() {
  return getToken(MySQLParser::MASTER_AUTO_POSITION_SYMBOL, 0);
}

MySQLParser::MasterFileDefContext* MySQLParser::MasterOptionContext::masterFileDef() {
  return getRuleContext<MySQLParser::MasterFileDefContext>(0);
}


size_t MySQLParser::MasterOptionContext::getRuleIndex() const {
  return MySQLParser::RuleMasterOption;
}

void MySQLParser::MasterOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMasterOption(this);
}

void MySQLParser::MasterOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMasterOption(this);
}


antlrcpp::Any MySQLParser::MasterOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitMasterOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::MasterOptionContext* MySQLParser::masterOption() {
  MasterOptionContext *_localctx = _tracker.createInstance<MasterOptionContext>(_ctx, getState());
  enterRule(_localctx, 446, MySQLParser::RuleMasterOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3819);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::MASTER_HOST_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3749);
        match(MySQLParser::MASTER_HOST_SYMBOL);
        setState(3750);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3751);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_BIND_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3752);
        match(MySQLParser::MASTER_BIND_SYMBOL);
        setState(3753);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3754);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_USER_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(3755);
        match(MySQLParser::MASTER_USER_SYMBOL);
        setState(3756);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3757);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_PASSWORD_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(3758);
        match(MySQLParser::MASTER_PASSWORD_SYMBOL);
        setState(3759);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3760);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_PORT_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(3761);
        match(MySQLParser::MASTER_PORT_SYMBOL);
        setState(3762);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3763);
        ulong_number();
        break;
      }

      case MySQLParser::MASTER_CONNECT_RETRY_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(3764);
        match(MySQLParser::MASTER_CONNECT_RETRY_SYMBOL);
        setState(3765);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3766);
        ulong_number();
        break;
      }

      case MySQLParser::MASTER_RETRY_COUNT_SYMBOL: {
        enterOuterAlt(_localctx, 7);
        setState(3767);
        match(MySQLParser::MASTER_RETRY_COUNT_SYMBOL);
        setState(3768);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3769);
        ulong_number();
        break;
      }

      case MySQLParser::MASTER_DELAY_SYMBOL: {
        enterOuterAlt(_localctx, 8);
        setState(3770);
        match(MySQLParser::MASTER_DELAY_SYMBOL);
        setState(3771);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3772);
        ulong_number();
        break;
      }

      case MySQLParser::MASTER_SSL_SYMBOL: {
        enterOuterAlt(_localctx, 9);
        setState(3773);
        match(MySQLParser::MASTER_SSL_SYMBOL);
        setState(3774);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3775);
        ulong_number();
        break;
      }

      case MySQLParser::MASTER_SSL_CA_SYMBOL: {
        enterOuterAlt(_localctx, 10);
        setState(3776);
        match(MySQLParser::MASTER_SSL_CA_SYMBOL);
        setState(3777);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3778);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_TLS_VERSION_SYMBOL: {
        enterOuterAlt(_localctx, 11);
        setState(3779);
        match(MySQLParser::MASTER_TLS_VERSION_SYMBOL);
        setState(3780);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3781);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_SSL_CAPATH_SYMBOL: {
        enterOuterAlt(_localctx, 12);
        setState(3782);
        match(MySQLParser::MASTER_SSL_CAPATH_SYMBOL);
        setState(3783);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3784);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_SSL_CERT_SYMBOL: {
        enterOuterAlt(_localctx, 13);
        setState(3785);
        match(MySQLParser::MASTER_SSL_CERT_SYMBOL);
        setState(3786);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3787);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_SSL_CIPHER_SYMBOL: {
        enterOuterAlt(_localctx, 14);
        setState(3788);
        match(MySQLParser::MASTER_SSL_CIPHER_SYMBOL);
        setState(3789);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3790);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_SSL_KEY_SYMBOL: {
        enterOuterAlt(_localctx, 15);
        setState(3791);
        match(MySQLParser::MASTER_SSL_KEY_SYMBOL);
        setState(3792);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3793);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL: {
        enterOuterAlt(_localctx, 16);
        setState(3794);
        match(MySQLParser::MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL);
        setState(3795);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3796);
        ulong_number();
        break;
      }

      case MySQLParser::MASTER_SSL_CRL_SYMBOL: {
        enterOuterAlt(_localctx, 17);
        setState(3797);
        match(MySQLParser::MASTER_SSL_CRL_SYMBOL);
        setState(3798);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3799);
        textLiteral();
        break;
      }

      case MySQLParser::MASTER_SSL_CRLPATH_SYMBOL: {
        enterOuterAlt(_localctx, 18);
        setState(3800);
        match(MySQLParser::MASTER_SSL_CRLPATH_SYMBOL);
        setState(3801);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3802);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_PUBLIC_KEY_PATH_SYMBOL: {
        enterOuterAlt(_localctx, 19);
        setState(3803);
        match(MySQLParser::MASTER_PUBLIC_KEY_PATH_SYMBOL);
        setState(3804);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3805);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::GET_MASTER_PUBLIC_KEY_SYM: {
        enterOuterAlt(_localctx, 20);
        setState(3806);
        match(MySQLParser::GET_MASTER_PUBLIC_KEY_SYM);
        setState(3807);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3808);
        ulong_number();
        break;
      }

      case MySQLParser::MASTER_HEARTBEAT_PERIOD_SYMBOL: {
        enterOuterAlt(_localctx, 21);
        setState(3809);
        match(MySQLParser::MASTER_HEARTBEAT_PERIOD_SYMBOL);
        setState(3810);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3811);
        ulong_number();
        break;
      }

      case MySQLParser::IGNORE_SERVER_IDS_SYMBOL: {
        enterOuterAlt(_localctx, 22);
        setState(3812);
        match(MySQLParser::IGNORE_SERVER_IDS_SYMBOL);
        setState(3813);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3814);
        serverIdList();
        break;
      }

      case MySQLParser::MASTER_AUTO_POSITION_SYMBOL: {
        enterOuterAlt(_localctx, 23);
        setState(3815);
        match(MySQLParser::MASTER_AUTO_POSITION_SYMBOL);
        setState(3816);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3817);
        ulong_number();
        break;
      }

      case MySQLParser::MASTER_LOG_FILE_SYMBOL:
      case MySQLParser::MASTER_LOG_POS_SYMBOL:
      case MySQLParser::RELAY_LOG_FILE_SYMBOL:
      case MySQLParser::RELAY_LOG_POS_SYMBOL: {
        enterOuterAlt(_localctx, 24);
        setState(3818);
        masterFileDef();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MasterFileDefContext ------------------------------------------------------------------

MySQLParser::MasterFileDefContext::MasterFileDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::MasterFileDefContext::MASTER_LOG_FILE_SYMBOL() {
  return getToken(MySQLParser::MASTER_LOG_FILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterFileDefContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TextStringNoLinebreakContext* MySQLParser::MasterFileDefContext::textStringNoLinebreak() {
  return getRuleContext<MySQLParser::TextStringNoLinebreakContext>(0);
}

tree::TerminalNode* MySQLParser::MasterFileDefContext::MASTER_LOG_POS_SYMBOL() {
  return getToken(MySQLParser::MASTER_LOG_POS_SYMBOL, 0);
}

MySQLParser::Ulonglong_numberContext* MySQLParser::MasterFileDefContext::ulonglong_number() {
  return getRuleContext<MySQLParser::Ulonglong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::MasterFileDefContext::RELAY_LOG_FILE_SYMBOL() {
  return getToken(MySQLParser::RELAY_LOG_FILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterFileDefContext::RELAY_LOG_POS_SYMBOL() {
  return getToken(MySQLParser::RELAY_LOG_POS_SYMBOL, 0);
}

MySQLParser::Ulong_numberContext* MySQLParser::MasterFileDefContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}


size_t MySQLParser::MasterFileDefContext::getRuleIndex() const {
  return MySQLParser::RuleMasterFileDef;
}

void MySQLParser::MasterFileDefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMasterFileDef(this);
}

void MySQLParser::MasterFileDefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMasterFileDef(this);
}


antlrcpp::Any MySQLParser::MasterFileDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitMasterFileDef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::MasterFileDefContext* MySQLParser::masterFileDef() {
  MasterFileDefContext *_localctx = _tracker.createInstance<MasterFileDefContext>(_ctx, getState());
  enterRule(_localctx, 448, MySQLParser::RuleMasterFileDef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3833);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::MASTER_LOG_FILE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3821);
        match(MySQLParser::MASTER_LOG_FILE_SYMBOL);
        setState(3822);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3823);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_LOG_POS_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3824);
        match(MySQLParser::MASTER_LOG_POS_SYMBOL);
        setState(3825);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3826);
        ulonglong_number();
        break;
      }

      case MySQLParser::RELAY_LOG_FILE_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(3827);
        match(MySQLParser::RELAY_LOG_FILE_SYMBOL);
        setState(3828);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3829);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::RELAY_LOG_POS_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(3830);
        match(MySQLParser::RELAY_LOG_POS_SYMBOL);
        setState(3831);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3832);
        ulong_number();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ServerIdListContext ------------------------------------------------------------------

MySQLParser::ServerIdListContext::ServerIdListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ServerIdListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ServerIdListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::Ulong_numberContext *> MySQLParser::ServerIdListContext::ulong_number() {
  return getRuleContexts<MySQLParser::Ulong_numberContext>();
}

MySQLParser::Ulong_numberContext* MySQLParser::ServerIdListContext::ulong_number(size_t i) {
  return getRuleContext<MySQLParser::Ulong_numberContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ServerIdListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ServerIdListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ServerIdListContext::getRuleIndex() const {
  return MySQLParser::RuleServerIdList;
}

void MySQLParser::ServerIdListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterServerIdList(this);
}

void MySQLParser::ServerIdListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitServerIdList(this);
}


antlrcpp::Any MySQLParser::ServerIdListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitServerIdList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ServerIdListContext* MySQLParser::serverIdList() {
  ServerIdListContext *_localctx = _tracker.createInstance<ServerIdListContext>(_ctx, getState());
  enterRule(_localctx, 450, MySQLParser::RuleServerIdList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3835);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3844);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 380) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 380)) & ((1ULL << (MySQLParser::INT_NUMBER - 380))
      | (1ULL << (MySQLParser::LONG_NUMBER - 380))
      | (1ULL << (MySQLParser::ULONGLONG_NUMBER - 380))
      | (1ULL << (MySQLParser::HEX_NUMBER - 380))
      | (1ULL << (MySQLParser::DECIMAL_NUMBER - 380))
      | (1ULL << (MySQLParser::FLOAT_NUMBER - 380)))) != 0)) {
      setState(3836);
      ulong_number();
      setState(3841);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(3837);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3838);
        ulong_number();
        setState(3843);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(3846);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationContext ------------------------------------------------------------------

MySQLParser::ChangeReplicationContext::ChangeReplicationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ChangeReplicationContext::CHANGE_SYMBOL() {
  return getToken(MySQLParser::CHANGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ChangeReplicationContext::REPLICATION_SYMBOL() {
  return getToken(MySQLParser::REPLICATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ChangeReplicationContext::FILTER_SYMBOL() {
  return getToken(MySQLParser::FILTER_SYMBOL, 0);
}

std::vector<MySQLParser::FilterDefinitionContext *> MySQLParser::ChangeReplicationContext::filterDefinition() {
  return getRuleContexts<MySQLParser::FilterDefinitionContext>();
}

MySQLParser::FilterDefinitionContext* MySQLParser::ChangeReplicationContext::filterDefinition(size_t i) {
  return getRuleContext<MySQLParser::FilterDefinitionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ChangeReplicationContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ChangeReplicationContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

MySQLParser::ChannelContext* MySQLParser::ChangeReplicationContext::channel() {
  return getRuleContext<MySQLParser::ChannelContext>(0);
}


size_t MySQLParser::ChangeReplicationContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplication;
}

void MySQLParser::ChangeReplicationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplication(this);
}

void MySQLParser::ChangeReplicationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplication(this);
}


antlrcpp::Any MySQLParser::ChangeReplicationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitChangeReplication(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationContext* MySQLParser::changeReplication() {
  ChangeReplicationContext *_localctx = _tracker.createInstance<ChangeReplicationContext>(_ctx, getState());
  enterRule(_localctx, 452, MySQLParser::RuleChangeReplication);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3848);
    match(MySQLParser::CHANGE_SYMBOL);
    setState(3849);
    match(MySQLParser::REPLICATION_SYMBOL);
    setState(3850);
    match(MySQLParser::FILTER_SYMBOL);
    setState(3851);
    filterDefinition();
    setState(3856);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 444, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3852);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3853);
        filterDefinition(); 
      }
      setState(3858);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 444, _ctx);
    }
    setState(3861);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 445, _ctx)) {
    case 1: {
      setState(3859);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(3860);
      channel();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterDefinitionContext ------------------------------------------------------------------

MySQLParser::FilterDefinitionContext::FilterDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::FilterDefinitionContext::REPLICATE_DO_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_DO_DB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FilterDefinitionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::FilterDefinitionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FilterDefinitionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::FilterDbListContext* MySQLParser::FilterDefinitionContext::filterDbList() {
  return getRuleContext<MySQLParser::FilterDbListContext>(0);
}

tree::TerminalNode* MySQLParser::FilterDefinitionContext::REPLICATE_IGNORE_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_IGNORE_DB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FilterDefinitionContext::REPLICATE_DO_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_DO_TABLE_SYMBOL, 0);
}

MySQLParser::FilterTableListContext* MySQLParser::FilterDefinitionContext::filterTableList() {
  return getRuleContext<MySQLParser::FilterTableListContext>(0);
}

tree::TerminalNode* MySQLParser::FilterDefinitionContext::REPLICATE_IGNORE_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_IGNORE_TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FilterDefinitionContext::REPLICATE_WILD_DO_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_WILD_DO_TABLE_SYMBOL, 0);
}

MySQLParser::FilterStringListContext* MySQLParser::FilterDefinitionContext::filterStringList() {
  return getRuleContext<MySQLParser::FilterStringListContext>(0);
}

tree::TerminalNode* MySQLParser::FilterDefinitionContext::REPLICATE_WILD_IGNORE_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_WILD_IGNORE_TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FilterDefinitionContext::REPLICATE_REWRITE_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_REWRITE_DB_SYMBOL, 0);
}

MySQLParser::FilterDbPairListContext* MySQLParser::FilterDefinitionContext::filterDbPairList() {
  return getRuleContext<MySQLParser::FilterDbPairListContext>(0);
}


size_t MySQLParser::FilterDefinitionContext::getRuleIndex() const {
  return MySQLParser::RuleFilterDefinition;
}

void MySQLParser::FilterDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterDefinition(this);
}

void MySQLParser::FilterDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterDefinition(this);
}


antlrcpp::Any MySQLParser::FilterDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFilterDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FilterDefinitionContext* MySQLParser::filterDefinition() {
  FilterDefinitionContext *_localctx = _tracker.createInstance<FilterDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 454, MySQLParser::RuleFilterDefinition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3912);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::REPLICATE_DO_DB_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3863);
        match(MySQLParser::REPLICATE_DO_DB_SYMBOL);
        setState(3864);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3865);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(3867);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 446, _ctx)) {
        case 1: {
          setState(3866);
          filterDbList();
          break;
        }

        }
        setState(3869);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::REPLICATE_IGNORE_DB_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3870);
        match(MySQLParser::REPLICATE_IGNORE_DB_SYMBOL);
        setState(3871);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3872);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(3874);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 447, _ctx)) {
        case 1: {
          setState(3873);
          filterDbList();
          break;
        }

        }
        setState(3876);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::REPLICATE_DO_TABLE_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(3877);
        match(MySQLParser::REPLICATE_DO_TABLE_SYMBOL);
        setState(3878);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3879);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(3881);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 448, _ctx)) {
        case 1: {
          setState(3880);
          filterTableList();
          break;
        }

        }
        setState(3883);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::REPLICATE_IGNORE_TABLE_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(3884);
        match(MySQLParser::REPLICATE_IGNORE_TABLE_SYMBOL);
        setState(3885);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3886);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(3888);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 449, _ctx)) {
        case 1: {
          setState(3887);
          filterTableList();
          break;
        }

        }
        setState(3890);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::REPLICATE_WILD_DO_TABLE_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(3891);
        match(MySQLParser::REPLICATE_WILD_DO_TABLE_SYMBOL);
        setState(3892);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3893);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(3895);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 450, _ctx)) {
        case 1: {
          setState(3894);
          filterStringList();
          break;
        }

        }
        setState(3897);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::REPLICATE_WILD_IGNORE_TABLE_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(3898);
        match(MySQLParser::REPLICATE_WILD_IGNORE_TABLE_SYMBOL);
        setState(3899);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3900);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(3902);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 451, _ctx)) {
        case 1: {
          setState(3901);
          filterStringList();
          break;
        }

        }
        setState(3904);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::REPLICATE_REWRITE_DB_SYMBOL: {
        enterOuterAlt(_localctx, 7);
        setState(3905);
        match(MySQLParser::REPLICATE_REWRITE_DB_SYMBOL);
        setState(3906);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3907);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(3909);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
          setState(3908);
          filterDbPairList();
        }
        setState(3911);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterDbListContext ------------------------------------------------------------------

MySQLParser::FilterDbListContext::FilterDbListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::SchemaRefContext *> MySQLParser::FilterDbListContext::schemaRef() {
  return getRuleContexts<MySQLParser::SchemaRefContext>();
}

MySQLParser::SchemaRefContext* MySQLParser::FilterDbListContext::schemaRef(size_t i) {
  return getRuleContext<MySQLParser::SchemaRefContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::FilterDbListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::FilterDbListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::FilterDbListContext::getRuleIndex() const {
  return MySQLParser::RuleFilterDbList;
}

void MySQLParser::FilterDbListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterDbList(this);
}

void MySQLParser::FilterDbListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterDbList(this);
}


antlrcpp::Any MySQLParser::FilterDbListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFilterDbList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FilterDbListContext* MySQLParser::filterDbList() {
  FilterDbListContext *_localctx = _tracker.createInstance<FilterDbListContext>(_ctx, getState());
  enterRule(_localctx, 456, MySQLParser::RuleFilterDbList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3914);
    schemaRef();
    setState(3919);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(3915);
      match(MySQLParser::COMMA_SYMBOL);
      setState(3916);
      schemaRef();
      setState(3921);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterTableListContext ------------------------------------------------------------------

MySQLParser::FilterTableListContext::FilterTableListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::FilterTableRefContext *> MySQLParser::FilterTableListContext::filterTableRef() {
  return getRuleContexts<MySQLParser::FilterTableRefContext>();
}

MySQLParser::FilterTableRefContext* MySQLParser::FilterTableListContext::filterTableRef(size_t i) {
  return getRuleContext<MySQLParser::FilterTableRefContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::FilterTableListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::FilterTableListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::FilterTableListContext::getRuleIndex() const {
  return MySQLParser::RuleFilterTableList;
}

void MySQLParser::FilterTableListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterTableList(this);
}

void MySQLParser::FilterTableListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterTableList(this);
}


antlrcpp::Any MySQLParser::FilterTableListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFilterTableList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FilterTableListContext* MySQLParser::filterTableList() {
  FilterTableListContext *_localctx = _tracker.createInstance<FilterTableListContext>(_ctx, getState());
  enterRule(_localctx, 458, MySQLParser::RuleFilterTableList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3922);
    filterTableRef();
    setState(3927);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(3923);
      match(MySQLParser::COMMA_SYMBOL);
      setState(3924);
      filterTableRef();
      setState(3929);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterStringListContext ------------------------------------------------------------------

MySQLParser::FilterStringListContext::FilterStringListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::FilterWildDbTableStringContext *> MySQLParser::FilterStringListContext::filterWildDbTableString() {
  return getRuleContexts<MySQLParser::FilterWildDbTableStringContext>();
}

MySQLParser::FilterWildDbTableStringContext* MySQLParser::FilterStringListContext::filterWildDbTableString(size_t i) {
  return getRuleContext<MySQLParser::FilterWildDbTableStringContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::FilterStringListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::FilterStringListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::FilterStringListContext::getRuleIndex() const {
  return MySQLParser::RuleFilterStringList;
}

void MySQLParser::FilterStringListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterStringList(this);
}

void MySQLParser::FilterStringListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterStringList(this);
}


antlrcpp::Any MySQLParser::FilterStringListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFilterStringList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FilterStringListContext* MySQLParser::filterStringList() {
  FilterStringListContext *_localctx = _tracker.createInstance<FilterStringListContext>(_ctx, getState());
  enterRule(_localctx, 460, MySQLParser::RuleFilterStringList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3930);
    filterWildDbTableString();
    setState(3935);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(3931);
      match(MySQLParser::COMMA_SYMBOL);
      setState(3932);
      filterWildDbTableString();
      setState(3937);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterWildDbTableStringContext ------------------------------------------------------------------

MySQLParser::FilterWildDbTableStringContext::FilterWildDbTableStringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextStringNoLinebreakContext* MySQLParser::FilterWildDbTableStringContext::textStringNoLinebreak() {
  return getRuleContext<MySQLParser::TextStringNoLinebreakContext>(0);
}


size_t MySQLParser::FilterWildDbTableStringContext::getRuleIndex() const {
  return MySQLParser::RuleFilterWildDbTableString;
}

void MySQLParser::FilterWildDbTableStringContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterWildDbTableString(this);
}

void MySQLParser::FilterWildDbTableStringContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterWildDbTableString(this);
}


antlrcpp::Any MySQLParser::FilterWildDbTableStringContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFilterWildDbTableString(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FilterWildDbTableStringContext* MySQLParser::filterWildDbTableString() {
  FilterWildDbTableStringContext *_localctx = _tracker.createInstance<FilterWildDbTableStringContext>(_ctx, getState());
  enterRule(_localctx, 462, MySQLParser::RuleFilterWildDbTableString);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3938);
    textStringNoLinebreak();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterDbPairListContext ------------------------------------------------------------------

MySQLParser::FilterDbPairListContext::FilterDbPairListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::SchemaIdentifierPairContext *> MySQLParser::FilterDbPairListContext::schemaIdentifierPair() {
  return getRuleContexts<MySQLParser::SchemaIdentifierPairContext>();
}

MySQLParser::SchemaIdentifierPairContext* MySQLParser::FilterDbPairListContext::schemaIdentifierPair(size_t i) {
  return getRuleContext<MySQLParser::SchemaIdentifierPairContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::FilterDbPairListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::FilterDbPairListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::FilterDbPairListContext::getRuleIndex() const {
  return MySQLParser::RuleFilterDbPairList;
}

void MySQLParser::FilterDbPairListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterDbPairList(this);
}

void MySQLParser::FilterDbPairListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterDbPairList(this);
}


antlrcpp::Any MySQLParser::FilterDbPairListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFilterDbPairList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FilterDbPairListContext* MySQLParser::filterDbPairList() {
  FilterDbPairListContext *_localctx = _tracker.createInstance<FilterDbPairListContext>(_ctx, getState());
  enterRule(_localctx, 464, MySQLParser::RuleFilterDbPairList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3940);
    schemaIdentifierPair();
    setState(3945);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(3941);
      match(MySQLParser::COMMA_SYMBOL);
      setState(3942);
      schemaIdentifierPair();
      setState(3947);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SlaveContext ------------------------------------------------------------------

MySQLParser::SlaveContext::SlaveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SlaveContext::START_SYMBOL() {
  return getToken(MySQLParser::START_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SlaveContext::SLAVE_SYMBOL() {
  return getToken(MySQLParser::SLAVE_SYMBOL, 0);
}

MySQLParser::SlaveConnectionOptionsContext* MySQLParser::SlaveContext::slaveConnectionOptions() {
  return getRuleContext<MySQLParser::SlaveConnectionOptionsContext>(0);
}

MySQLParser::SlaveThreadOptionsContext* MySQLParser::SlaveContext::slaveThreadOptions() {
  return getRuleContext<MySQLParser::SlaveThreadOptionsContext>(0);
}

tree::TerminalNode* MySQLParser::SlaveContext::UNTIL_SYMBOL() {
  return getToken(MySQLParser::UNTIL_SYMBOL, 0);
}

MySQLParser::SlaveUntilOptionsContext* MySQLParser::SlaveContext::slaveUntilOptions() {
  return getRuleContext<MySQLParser::SlaveUntilOptionsContext>(0);
}

MySQLParser::ChannelContext* MySQLParser::SlaveContext::channel() {
  return getRuleContext<MySQLParser::ChannelContext>(0);
}

tree::TerminalNode* MySQLParser::SlaveContext::STOP_SYMBOL() {
  return getToken(MySQLParser::STOP_SYMBOL, 0);
}


size_t MySQLParser::SlaveContext::getRuleIndex() const {
  return MySQLParser::RuleSlave;
}

void MySQLParser::SlaveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSlave(this);
}

void MySQLParser::SlaveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSlave(this);
}


antlrcpp::Any MySQLParser::SlaveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSlave(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SlaveContext* MySQLParser::slave() {
  SlaveContext *_localctx = _tracker.createInstance<SlaveContext>(_ctx, getState());
  enterRule(_localctx, 466, MySQLParser::RuleSlave);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3969);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::START_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3948);
        match(MySQLParser::START_SYMBOL);
        setState(3949);
        match(MySQLParser::SLAVE_SYMBOL);
        setState(3951);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 458, _ctx)) {
        case 1: {
          setState(3950);
          slaveThreadOptions();
          break;
        }

        }
        setState(3955);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 459, _ctx)) {
        case 1: {
          setState(3953);
          match(MySQLParser::UNTIL_SYMBOL);
          setState(3954);
          slaveUntilOptions();
          break;
        }

        }
        setState(3957);
        slaveConnectionOptions();
        setState(3959);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 460, _ctx)) {
        case 1: {
          setState(3958);
          channel();
          break;
        }

        }
        break;
      }

      case MySQLParser::STOP_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3961);
        match(MySQLParser::STOP_SYMBOL);
        setState(3962);
        match(MySQLParser::SLAVE_SYMBOL);
        setState(3964);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 461, _ctx)) {
        case 1: {
          setState(3963);
          slaveThreadOptions();
          break;
        }

        }
        setState(3967);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 462, _ctx)) {
        case 1: {
          setState(3966);
          channel();
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SlaveUntilOptionsContext ------------------------------------------------------------------

MySQLParser::SlaveUntilOptionsContext::SlaveUntilOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::MasterFileDefContext *> MySQLParser::SlaveUntilOptionsContext::masterFileDef() {
  return getRuleContexts<MySQLParser::MasterFileDefContext>();
}

MySQLParser::MasterFileDefContext* MySQLParser::SlaveUntilOptionsContext::masterFileDef(size_t i) {
  return getRuleContext<MySQLParser::MasterFileDefContext>(i);
}

tree::TerminalNode* MySQLParser::SlaveUntilOptionsContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TextStringContext* MySQLParser::SlaveUntilOptionsContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode* MySQLParser::SlaveUntilOptionsContext::SQL_AFTER_MTS_GAPS_SYMBOL() {
  return getToken(MySQLParser::SQL_AFTER_MTS_GAPS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SlaveUntilOptionsContext::SQL_BEFORE_GTIDS_SYMBOL() {
  return getToken(MySQLParser::SQL_BEFORE_GTIDS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SlaveUntilOptionsContext::SQL_AFTER_GTIDS_SYMBOL() {
  return getToken(MySQLParser::SQL_AFTER_GTIDS_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::SlaveUntilOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::SlaveUntilOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::SlaveUntilOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleSlaveUntilOptions;
}

void MySQLParser::SlaveUntilOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSlaveUntilOptions(this);
}

void MySQLParser::SlaveUntilOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSlaveUntilOptions(this);
}


antlrcpp::Any MySQLParser::SlaveUntilOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSlaveUntilOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SlaveUntilOptionsContext* MySQLParser::slaveUntilOptions() {
  SlaveUntilOptionsContext *_localctx = _tracker.createInstance<SlaveUntilOptionsContext>(_ctx, getState());
  enterRule(_localctx, 468, MySQLParser::RuleSlaveUntilOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3978);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 464, _ctx)) {
    case 1: {
      setState(3971);
      masterFileDef();
      break;
    }

    case 2: {
      setState(3972);

      if (!(serverVersion >= 50606)) throw FailedPredicateException(this, "serverVersion >= 50606");
      setState(3973);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::SQL_AFTER_GTIDS_SYMBOL

      || _la == MySQLParser::SQL_BEFORE_GTIDS_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3974);
      match(MySQLParser::EQUAL_OPERATOR);
      setState(3975);
      textString();
      break;
    }

    case 3: {
      setState(3976);

      if (!(serverVersion >= 50606)) throw FailedPredicateException(this, "serverVersion >= 50606");
      setState(3977);
      match(MySQLParser::SQL_AFTER_MTS_GAPS_SYMBOL);
      break;
    }

    }
    setState(3984);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 465, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3980);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3981);
        masterFileDef(); 
      }
      setState(3986);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 465, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SlaveConnectionOptionsContext ------------------------------------------------------------------

MySQLParser::SlaveConnectionOptionsContext::SlaveConnectionOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SlaveConnectionOptionsContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::SlaveConnectionOptionsContext::EQUAL_OPERATOR() {
  return getTokens(MySQLParser::EQUAL_OPERATOR);
}

tree::TerminalNode* MySQLParser::SlaveConnectionOptionsContext::EQUAL_OPERATOR(size_t i) {
  return getToken(MySQLParser::EQUAL_OPERATOR, i);
}

std::vector<MySQLParser::TextStringContext *> MySQLParser::SlaveConnectionOptionsContext::textString() {
  return getRuleContexts<MySQLParser::TextStringContext>();
}

MySQLParser::TextStringContext* MySQLParser::SlaveConnectionOptionsContext::textString(size_t i) {
  return getRuleContext<MySQLParser::TextStringContext>(i);
}

tree::TerminalNode* MySQLParser::SlaveConnectionOptionsContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SlaveConnectionOptionsContext::DEFAULT_AUTH_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_AUTH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SlaveConnectionOptionsContext::PLUGIN_DIR_SYMBOL() {
  return getToken(MySQLParser::PLUGIN_DIR_SYMBOL, 0);
}


size_t MySQLParser::SlaveConnectionOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleSlaveConnectionOptions;
}

void MySQLParser::SlaveConnectionOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSlaveConnectionOptions(this);
}

void MySQLParser::SlaveConnectionOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSlaveConnectionOptions(this);
}


antlrcpp::Any MySQLParser::SlaveConnectionOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSlaveConnectionOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SlaveConnectionOptionsContext* MySQLParser::slaveConnectionOptions() {
  SlaveConnectionOptionsContext *_localctx = _tracker.createInstance<SlaveConnectionOptionsContext>(_ctx, getState());
  enterRule(_localctx, 470, MySQLParser::RuleSlaveConnectionOptions);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4009);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 470, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3987);

      if (!(serverVersion >= 50604)) throw FailedPredicateException(this, "serverVersion >= 50604");
      setState(3991);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 466, _ctx)) {
      case 1: {
        setState(3988);
        match(MySQLParser::USER_SYMBOL);
        setState(3989);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3990);
        textString();
        break;
      }

      }
      setState(3996);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 467, _ctx)) {
      case 1: {
        setState(3993);
        match(MySQLParser::PASSWORD_SYMBOL);
        setState(3994);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3995);
        textString();
        break;
      }

      }
      setState(4001);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 468, _ctx)) {
      case 1: {
        setState(3998);
        match(MySQLParser::DEFAULT_AUTH_SYMBOL);
        setState(3999);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4000);
        textString();
        break;
      }

      }
      setState(4006);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 469, _ctx)) {
      case 1: {
        setState(4003);
        match(MySQLParser::PLUGIN_DIR_SYMBOL);
        setState(4004);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4005);
        textString();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);

      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SlaveThreadOptionsContext ------------------------------------------------------------------

MySQLParser::SlaveThreadOptionsContext::SlaveThreadOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::SlaveThreadOptionContext *> MySQLParser::SlaveThreadOptionsContext::slaveThreadOption() {
  return getRuleContexts<MySQLParser::SlaveThreadOptionContext>();
}

MySQLParser::SlaveThreadOptionContext* MySQLParser::SlaveThreadOptionsContext::slaveThreadOption(size_t i) {
  return getRuleContext<MySQLParser::SlaveThreadOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::SlaveThreadOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::SlaveThreadOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::SlaveThreadOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleSlaveThreadOptions;
}

void MySQLParser::SlaveThreadOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSlaveThreadOptions(this);
}

void MySQLParser::SlaveThreadOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSlaveThreadOptions(this);
}


antlrcpp::Any MySQLParser::SlaveThreadOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSlaveThreadOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SlaveThreadOptionsContext* MySQLParser::slaveThreadOptions() {
  SlaveThreadOptionsContext *_localctx = _tracker.createInstance<SlaveThreadOptionsContext>(_ctx, getState());
  enterRule(_localctx, 472, MySQLParser::RuleSlaveThreadOptions);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4011);
    slaveThreadOption();
    setState(4016);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 471, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4012);
        match(MySQLParser::COMMA_SYMBOL);
        setState(4013);
        slaveThreadOption(); 
      }
      setState(4018);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 471, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SlaveThreadOptionContext ------------------------------------------------------------------

MySQLParser::SlaveThreadOptionContext::SlaveThreadOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SlaveThreadOptionContext::RELAY_THREAD_SYMBOL() {
  return getToken(MySQLParser::RELAY_THREAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SlaveThreadOptionContext::SQL_THREAD_SYMBOL() {
  return getToken(MySQLParser::SQL_THREAD_SYMBOL, 0);
}


size_t MySQLParser::SlaveThreadOptionContext::getRuleIndex() const {
  return MySQLParser::RuleSlaveThreadOption;
}

void MySQLParser::SlaveThreadOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSlaveThreadOption(this);
}

void MySQLParser::SlaveThreadOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSlaveThreadOption(this);
}


antlrcpp::Any MySQLParser::SlaveThreadOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSlaveThreadOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SlaveThreadOptionContext* MySQLParser::slaveThreadOption() {
  SlaveThreadOptionContext *_localctx = _tracker.createInstance<SlaveThreadOptionContext>(_ctx, getState());
  enterRule(_localctx, 474, MySQLParser::RuleSlaveThreadOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4019);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::RELAY_THREAD_SYMBOL

    || _la == MySQLParser::SQL_THREAD_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupReplicationContext ------------------------------------------------------------------

MySQLParser::GroupReplicationContext::GroupReplicationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::GroupReplicationContext::GROUP_REPLICATION_SYMBOL() {
  return getToken(MySQLParser::GROUP_REPLICATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GroupReplicationContext::START_SYMBOL() {
  return getToken(MySQLParser::START_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GroupReplicationContext::STOP_SYMBOL() {
  return getToken(MySQLParser::STOP_SYMBOL, 0);
}


size_t MySQLParser::GroupReplicationContext::getRuleIndex() const {
  return MySQLParser::RuleGroupReplication;
}

void MySQLParser::GroupReplicationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupReplication(this);
}

void MySQLParser::GroupReplicationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupReplication(this);
}


antlrcpp::Any MySQLParser::GroupReplicationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitGroupReplication(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GroupReplicationContext* MySQLParser::groupReplication() {
  GroupReplicationContext *_localctx = _tracker.createInstance<GroupReplicationContext>(_ctx, getState());
  enterRule(_localctx, 476, MySQLParser::RuleGroupReplication);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4021);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::START_SYMBOL

    || _la == MySQLParser::STOP_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(4022);
    match(MySQLParser::GROUP_REPLICATION_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PreparedStatementContext ------------------------------------------------------------------

MySQLParser::PreparedStatementContext::PreparedStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::PreparedStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::PreparedStatementContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PreparedStatementContext::PREPARE_SYMBOL() {
  return getToken(MySQLParser::PREPARE_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::PreparedStatementContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

MySQLParser::UserVariableContext* MySQLParser::PreparedStatementContext::userVariable() {
  return getRuleContext<MySQLParser::UserVariableContext>(0);
}

MySQLParser::ExecuteStatementContext* MySQLParser::PreparedStatementContext::executeStatement() {
  return getRuleContext<MySQLParser::ExecuteStatementContext>(0);
}

tree::TerminalNode* MySQLParser::PreparedStatementContext::DEALLOCATE_SYMBOL() {
  return getToken(MySQLParser::DEALLOCATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PreparedStatementContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}


size_t MySQLParser::PreparedStatementContext::getRuleIndex() const {
  return MySQLParser::RulePreparedStatement;
}

void MySQLParser::PreparedStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreparedStatement(this);
}

void MySQLParser::PreparedStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreparedStatement(this);
}


antlrcpp::Any MySQLParser::PreparedStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPreparedStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PreparedStatementContext* MySQLParser::preparedStatement() {
  PreparedStatementContext *_localctx = _tracker.createInstance<PreparedStatementContext>(_ctx, getState());
  enterRule(_localctx, 478, MySQLParser::RulePreparedStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4035);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::PREPARE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4024);
        dynamic_cast<PreparedStatementContext *>(_localctx)->type = match(MySQLParser::PREPARE_SYMBOL);
        setState(4025);
        identifier();
        setState(4026);
        match(MySQLParser::FROM_SYMBOL);
        setState(4029);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 472, _ctx)) {
        case 1: {
          setState(4027);
          textLiteral();
          break;
        }

        case 2: {
          setState(4028);
          userVariable();
          break;
        }

        }
        break;
      }

      case MySQLParser::EXECUTE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4031);
        executeStatement();
        break;
      }

      case MySQLParser::DEALLOCATE_SYMBOL:
      case MySQLParser::DROP_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(4032);
        dynamic_cast<PreparedStatementContext *>(_localctx)->type = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::DEALLOCATE_SYMBOL || _la == MySQLParser::DROP_SYMBOL)) {
          dynamic_cast<PreparedStatementContext *>(_localctx)->type = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(4033);
        match(MySQLParser::PREPARE_SYMBOL);
        setState(4034);
        identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExecuteStatementContext ------------------------------------------------------------------

MySQLParser::ExecuteStatementContext::ExecuteStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ExecuteStatementContext::EXECUTE_SYMBOL() {
  return getToken(MySQLParser::EXECUTE_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::ExecuteStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::ExecuteStatementContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

MySQLParser::ExecuteVarListContext* MySQLParser::ExecuteStatementContext::executeVarList() {
  return getRuleContext<MySQLParser::ExecuteVarListContext>(0);
}


size_t MySQLParser::ExecuteStatementContext::getRuleIndex() const {
  return MySQLParser::RuleExecuteStatement;
}

void MySQLParser::ExecuteStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecuteStatement(this);
}

void MySQLParser::ExecuteStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecuteStatement(this);
}


antlrcpp::Any MySQLParser::ExecuteStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitExecuteStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ExecuteStatementContext* MySQLParser::executeStatement() {
  ExecuteStatementContext *_localctx = _tracker.createInstance<ExecuteStatementContext>(_ctx, getState());
  enterRule(_localctx, 480, MySQLParser::RuleExecuteStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4037);
    match(MySQLParser::EXECUTE_SYMBOL);
    setState(4038);
    identifier();
    setState(4041);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::USING_SYMBOL) {
      setState(4039);
      match(MySQLParser::USING_SYMBOL);
      setState(4040);
      executeVarList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExecuteVarListContext ------------------------------------------------------------------

MySQLParser::ExecuteVarListContext::ExecuteVarListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::UserVariableContext *> MySQLParser::ExecuteVarListContext::userVariable() {
  return getRuleContexts<MySQLParser::UserVariableContext>();
}

MySQLParser::UserVariableContext* MySQLParser::ExecuteVarListContext::userVariable(size_t i) {
  return getRuleContext<MySQLParser::UserVariableContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ExecuteVarListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ExecuteVarListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ExecuteVarListContext::getRuleIndex() const {
  return MySQLParser::RuleExecuteVarList;
}

void MySQLParser::ExecuteVarListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecuteVarList(this);
}

void MySQLParser::ExecuteVarListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecuteVarList(this);
}


antlrcpp::Any MySQLParser::ExecuteVarListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitExecuteVarList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ExecuteVarListContext* MySQLParser::executeVarList() {
  ExecuteVarListContext *_localctx = _tracker.createInstance<ExecuteVarListContext>(_ctx, getState());
  enterRule(_localctx, 482, MySQLParser::RuleExecuteVarList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4043);
    userVariable();
    setState(4048);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(4044);
      match(MySQLParser::COMMA_SYMBOL);
      setState(4045);
      userVariable();
      setState(4050);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CloneStatementContext ------------------------------------------------------------------

MySQLParser::CloneStatementContext::CloneStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CloneStatementContext::CLONE_SYMBOL() {
  return getToken(MySQLParser::CLONE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CloneStatementContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CloneStatementContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CloneStatementContext::DIRECTORY_SYMBOL() {
  return getToken(MySQLParser::DIRECTORY_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::CloneStatementContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::CloneStatementContext::REMOTE_SYMBOL() {
  return getToken(MySQLParser::REMOTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CloneStatementContext::INSTANCE_SYMBOL() {
  return getToken(MySQLParser::INSTANCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CloneStatementContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

MySQLParser::UserContext* MySQLParser::CloneStatementContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

tree::TerminalNode* MySQLParser::CloneStatementContext::COLON_SYMBOL() {
  return getToken(MySQLParser::COLON_SYMBOL, 0);
}

MySQLParser::Ulong_numberContext* MySQLParser::CloneStatementContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::CloneStatementContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CloneStatementContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::EqualContext* MySQLParser::CloneStatementContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

tree::TerminalNode* MySQLParser::CloneStatementContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CloneStatementContext::REPLICATION_SYMBOL() {
  return getToken(MySQLParser::REPLICATION_SYMBOL, 0);
}

MySQLParser::DataDirSSLContext* MySQLParser::CloneStatementContext::dataDirSSL() {
  return getRuleContext<MySQLParser::DataDirSSLContext>(0);
}


size_t MySQLParser::CloneStatementContext::getRuleIndex() const {
  return MySQLParser::RuleCloneStatement;
}

void MySQLParser::CloneStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCloneStatement(this);
}

void MySQLParser::CloneStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCloneStatement(this);
}


antlrcpp::Any MySQLParser::CloneStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCloneStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CloneStatementContext* MySQLParser::cloneStatement() {
  CloneStatementContext *_localctx = _tracker.createInstance<CloneStatementContext>(_ctx, getState());
  enterRule(_localctx, 484, MySQLParser::RuleCloneStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4051);
    match(MySQLParser::CLONE_SYMBOL);
    setState(4076);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 479, _ctx)) {
    case 1: {
      setState(4052);
      match(MySQLParser::LOCAL_SYMBOL);
      setState(4053);
      match(MySQLParser::DATA_SYMBOL);
      setState(4054);
      match(MySQLParser::DIRECTORY_SYMBOL);
      setState(4056);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 476, _ctx)) {
      case 1: {
        setState(4055);
        equal();
        break;
      }

      }
      setState(4058);
      textStringLiteral();
      break;
    }

    case 2: {
      setState(4059);
      match(MySQLParser::REMOTE_SYMBOL);
      setState(4062);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FOR_SYMBOL) {
        setState(4060);
        match(MySQLParser::FOR_SYMBOL);
        setState(4061);
        match(MySQLParser::REPLICATION_SYMBOL);
      }
      break;
    }

    case 3: {
      setState(4064);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(4065);
      match(MySQLParser::INSTANCE_SYMBOL);
      setState(4066);
      match(MySQLParser::FROM_SYMBOL);
      setState(4067);
      user();
      setState(4068);
      match(MySQLParser::COLON_SYMBOL);
      setState(4069);
      ulong_number();
      setState(4070);
      match(MySQLParser::IDENTIFIED_SYMBOL);
      setState(4071);
      match(MySQLParser::BY_SYMBOL);
      setState(4072);
      textStringLiteral();
      setState(4074);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::DATA_SYMBOL || _la == MySQLParser::REQUIRE_SYMBOL) {
        setState(4073);
        dataDirSSL();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DataDirSSLContext ------------------------------------------------------------------

MySQLParser::DataDirSSLContext::DataDirSSLContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SslContext* MySQLParser::DataDirSSLContext::ssl() {
  return getRuleContext<MySQLParser::SslContext>(0);
}

tree::TerminalNode* MySQLParser::DataDirSSLContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataDirSSLContext::DIRECTORY_SYMBOL() {
  return getToken(MySQLParser::DIRECTORY_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::DataDirSSLContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

MySQLParser::EqualContext* MySQLParser::DataDirSSLContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}


size_t MySQLParser::DataDirSSLContext::getRuleIndex() const {
  return MySQLParser::RuleDataDirSSL;
}

void MySQLParser::DataDirSSLContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDataDirSSL(this);
}

void MySQLParser::DataDirSSLContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDataDirSSL(this);
}


antlrcpp::Any MySQLParser::DataDirSSLContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDataDirSSL(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DataDirSSLContext* MySQLParser::dataDirSSL() {
  DataDirSSLContext *_localctx = _tracker.createInstance<DataDirSSLContext>(_ctx, getState());
  enterRule(_localctx, 486, MySQLParser::RuleDataDirSSL);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4088);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::REQUIRE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4078);
        ssl();
        break;
      }

      case MySQLParser::DATA_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4079);
        match(MySQLParser::DATA_SYMBOL);
        setState(4080);
        match(MySQLParser::DIRECTORY_SYMBOL);
        setState(4082);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 480, _ctx)) {
        case 1: {
          setState(4081);
          equal();
          break;
        }

        }
        setState(4084);
        textStringLiteral();
        setState(4086);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::REQUIRE_SYMBOL) {
          setState(4085);
          ssl();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SslContext ------------------------------------------------------------------

MySQLParser::SslContext::SslContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SslContext::REQUIRE_SYMBOL() {
  return getToken(MySQLParser::REQUIRE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SslContext::SSL_SYMBOL() {
  return getToken(MySQLParser::SSL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SslContext::NO_SYMBOL() {
  return getToken(MySQLParser::NO_SYMBOL, 0);
}


size_t MySQLParser::SslContext::getRuleIndex() const {
  return MySQLParser::RuleSsl;
}

void MySQLParser::SslContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSsl(this);
}

void MySQLParser::SslContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSsl(this);
}


antlrcpp::Any MySQLParser::SslContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSsl(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SslContext* MySQLParser::ssl() {
  SslContext *_localctx = _tracker.createInstance<SslContext>(_ctx, getState());
  enterRule(_localctx, 488, MySQLParser::RuleSsl);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4090);
    match(MySQLParser::REQUIRE_SYMBOL);
    setState(4092);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::NO_SYMBOL) {
      setState(4091);
      match(MySQLParser::NO_SYMBOL);
    }
    setState(4094);
    match(MySQLParser::SSL_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AccountManagementStatementContext ------------------------------------------------------------------

MySQLParser::AccountManagementStatementContext::AccountManagementStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::AlterUserContext* MySQLParser::AccountManagementStatementContext::alterUser() {
  return getRuleContext<MySQLParser::AlterUserContext>(0);
}

MySQLParser::CreateUserContext* MySQLParser::AccountManagementStatementContext::createUser() {
  return getRuleContext<MySQLParser::CreateUserContext>(0);
}

MySQLParser::DropUserContext* MySQLParser::AccountManagementStatementContext::dropUser() {
  return getRuleContext<MySQLParser::DropUserContext>(0);
}

MySQLParser::GrantContext* MySQLParser::AccountManagementStatementContext::grant() {
  return getRuleContext<MySQLParser::GrantContext>(0);
}

MySQLParser::RenameUserContext* MySQLParser::AccountManagementStatementContext::renameUser() {
  return getRuleContext<MySQLParser::RenameUserContext>(0);
}

MySQLParser::RevokeContext* MySQLParser::AccountManagementStatementContext::revoke() {
  return getRuleContext<MySQLParser::RevokeContext>(0);
}

MySQLParser::SetPasswordContext* MySQLParser::AccountManagementStatementContext::setPassword() {
  return getRuleContext<MySQLParser::SetPasswordContext>(0);
}

MySQLParser::SetRoleContext* MySQLParser::AccountManagementStatementContext::setRole() {
  return getRuleContext<MySQLParser::SetRoleContext>(0);
}


size_t MySQLParser::AccountManagementStatementContext::getRuleIndex() const {
  return MySQLParser::RuleAccountManagementStatement;
}

void MySQLParser::AccountManagementStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAccountManagementStatement(this);
}

void MySQLParser::AccountManagementStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAccountManagementStatement(this);
}


antlrcpp::Any MySQLParser::AccountManagementStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAccountManagementStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AccountManagementStatementContext* MySQLParser::accountManagementStatement() {
  AccountManagementStatementContext *_localctx = _tracker.createInstance<AccountManagementStatementContext>(_ctx, getState());
  enterRule(_localctx, 490, MySQLParser::RuleAccountManagementStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4106);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 484, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4096);

      if (!(serverVersion >= 50606)) throw FailedPredicateException(this, "serverVersion >= 50606");
      setState(4097);
      alterUser();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4098);
      createUser();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4099);
      dropUser();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4100);
      grant();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4101);
      renameUser();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4102);
      revoke();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4103);
      setPassword();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4104);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(4105);
      setRole();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterUserContext ------------------------------------------------------------------

MySQLParser::AlterUserContext::AlterUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterUserContext::ALTER_SYMBOL() {
  return getToken(MySQLParser::ALTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterUserContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

MySQLParser::AlterUserTailContext* MySQLParser::AlterUserContext::alterUserTail() {
  return getRuleContext<MySQLParser::AlterUserTailContext>(0);
}

MySQLParser::IfExistsContext* MySQLParser::AlterUserContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}


size_t MySQLParser::AlterUserContext::getRuleIndex() const {
  return MySQLParser::RuleAlterUser;
}

void MySQLParser::AlterUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterUser(this);
}

void MySQLParser::AlterUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterUser(this);
}


antlrcpp::Any MySQLParser::AlterUserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterUser(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterUserContext* MySQLParser::alterUser() {
  AlterUserContext *_localctx = _tracker.createInstance<AlterUserContext>(_ctx, getState());
  enterRule(_localctx, 492, MySQLParser::RuleAlterUser);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4108);
    match(MySQLParser::ALTER_SYMBOL);
    setState(4109);
    match(MySQLParser::USER_SYMBOL);
    setState(4112);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 485, _ctx)) {
    case 1: {
      setState(4110);

      if (!(serverVersion >= 50706)) throw FailedPredicateException(this, "serverVersion >= 50706");
      setState(4111);
      ifExists();
      break;
    }

    }
    setState(4114);
    alterUserTail();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterUserTailContext ------------------------------------------------------------------

MySQLParser::AlterUserTailContext::AlterUserTailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CreateUserTailContext* MySQLParser::AlterUserTailContext::createUserTail() {
  return getRuleContext<MySQLParser::CreateUserTailContext>(0);
}

MySQLParser::CreateUserListContext* MySQLParser::AlterUserTailContext::createUserList() {
  return getRuleContext<MySQLParser::CreateUserListContext>(0);
}

MySQLParser::AlterUserListContext* MySQLParser::AlterUserTailContext::alterUserList() {
  return getRuleContext<MySQLParser::AlterUserListContext>(0);
}

tree::TerminalNode* MySQLParser::AlterUserTailContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

MySQLParser::ParenthesesContext* MySQLParser::AlterUserTailContext::parentheses() {
  return getRuleContext<MySQLParser::ParenthesesContext>(0);
}

tree::TerminalNode* MySQLParser::AlterUserTailContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterUserTailContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::AlterUserTailContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

MySQLParser::ReplacePasswordContext* MySQLParser::AlterUserTailContext::replacePassword() {
  return getRuleContext<MySQLParser::ReplacePasswordContext>(0);
}

MySQLParser::RetainCurrentPasswordContext* MySQLParser::AlterUserTailContext::retainCurrentPassword() {
  return getRuleContext<MySQLParser::RetainCurrentPasswordContext>(0);
}

MySQLParser::DiscardOldPasswordContext* MySQLParser::AlterUserTailContext::discardOldPassword() {
  return getRuleContext<MySQLParser::DiscardOldPasswordContext>(0);
}

MySQLParser::UserContext* MySQLParser::AlterUserTailContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

tree::TerminalNode* MySQLParser::AlterUserTailContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterUserTailContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterUserTailContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterUserTailContext::NONE_SYMBOL() {
  return getToken(MySQLParser::NONE_SYMBOL, 0);
}

MySQLParser::RoleListContext* MySQLParser::AlterUserTailContext::roleList() {
  return getRuleContext<MySQLParser::RoleListContext>(0);
}


size_t MySQLParser::AlterUserTailContext::getRuleIndex() const {
  return MySQLParser::RuleAlterUserTail;
}

void MySQLParser::AlterUserTailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterUserTail(this);
}

void MySQLParser::AlterUserTailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterUserTail(this);
}


antlrcpp::Any MySQLParser::AlterUserTailContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterUserTail(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterUserTailContext* MySQLParser::alterUserTail() {
  AlterUserTailContext *_localctx = _tracker.createInstance<AlterUserTailContext>(_ctx, getState());
  enterRule(_localctx, 494, MySQLParser::RuleAlterUserTail);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4152);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 490, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4120);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 486, _ctx)) {
      case 1: {
        setState(4116);

        if (!(serverVersion < 80014)) throw FailedPredicateException(this, "serverVersion < 80014");
        setState(4117);
        createUserList();
        break;
      }

      case 2: {
        setState(4118);

        if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
        setState(4119);
        alterUserList();
        break;
      }

      }
      setState(4122);
      createUserTail();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4124);

      if (!(serverVersion >= 50706)) throw FailedPredicateException(this, "serverVersion >= 50706");
      setState(4125);
      match(MySQLParser::USER_SYMBOL);
      setState(4126);
      parentheses();
      setState(4127);
      match(MySQLParser::IDENTIFIED_SYMBOL);
      setState(4128);
      match(MySQLParser::BY_SYMBOL);
      setState(4129);
      textString();
      setState(4132);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 487, _ctx)) {
      case 1: {
        setState(4130);

        if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
        setState(4131);
        replacePassword();
        break;
      }

      }
      setState(4136);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 488, _ctx)) {
      case 1: {
        setState(4134);

        if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
        setState(4135);
        retainCurrentPassword();
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4138);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(4139);
      match(MySQLParser::USER_SYMBOL);
      setState(4140);
      parentheses();
      setState(4141);
      discardOldPassword();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4143);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(4144);
      user();
      setState(4145);
      match(MySQLParser::DEFAULT_SYMBOL);
      setState(4146);
      match(MySQLParser::ROLE_SYMBOL);
      setState(4150);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 489, _ctx)) {
      case 1: {
        setState(4147);
        match(MySQLParser::ALL_SYMBOL);
        break;
      }

      case 2: {
        setState(4148);
        match(MySQLParser::NONE_SYMBOL);
        break;
      }

      case 3: {
        setState(4149);
        roleList();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUserContext ------------------------------------------------------------------

MySQLParser::CreateUserContext::CreateUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateUserContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateUserContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

MySQLParser::CreateUserListContext* MySQLParser::CreateUserContext::createUserList() {
  return getRuleContext<MySQLParser::CreateUserListContext>(0);
}

MySQLParser::DefaultRoleClauseContext* MySQLParser::CreateUserContext::defaultRoleClause() {
  return getRuleContext<MySQLParser::DefaultRoleClauseContext>(0);
}

MySQLParser::CreateUserTailContext* MySQLParser::CreateUserContext::createUserTail() {
  return getRuleContext<MySQLParser::CreateUserTailContext>(0);
}

MySQLParser::IfNotExistsContext* MySQLParser::CreateUserContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}


size_t MySQLParser::CreateUserContext::getRuleIndex() const {
  return MySQLParser::RuleCreateUser;
}

void MySQLParser::CreateUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUser(this);
}

void MySQLParser::CreateUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUser(this);
}


antlrcpp::Any MySQLParser::CreateUserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateUser(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateUserContext* MySQLParser::createUser() {
  CreateUserContext *_localctx = _tracker.createInstance<CreateUserContext>(_ctx, getState());
  enterRule(_localctx, 496, MySQLParser::RuleCreateUser);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4154);
    match(MySQLParser::CREATE_SYMBOL);
    setState(4155);
    match(MySQLParser::USER_SYMBOL);
    setState(4159);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 491, _ctx)) {
    case 1: {
      setState(4156);

      if (!(serverVersion >= 50706)) throw FailedPredicateException(this, "serverVersion >= 50706");
      setState(4157);
      ifNotExists();
      break;
    }

    case 2: {
      break;
    }

    }
    setState(4161);
    createUserList();
    setState(4162);
    defaultRoleClause();
    setState(4163);
    createUserTail();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUserTailContext ------------------------------------------------------------------

MySQLParser::CreateUserTailContext::CreateUserTailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RequireClauseContext* MySQLParser::CreateUserTailContext::requireClause() {
  return getRuleContext<MySQLParser::RequireClauseContext>(0);
}

MySQLParser::ConnectOptionsContext* MySQLParser::CreateUserTailContext::connectOptions() {
  return getRuleContext<MySQLParser::ConnectOptionsContext>(0);
}

MySQLParser::AccountLockPasswordExpireOptionsContext* MySQLParser::CreateUserTailContext::accountLockPasswordExpireOptions() {
  return getRuleContext<MySQLParser::AccountLockPasswordExpireOptionsContext>(0);
}


size_t MySQLParser::CreateUserTailContext::getRuleIndex() const {
  return MySQLParser::RuleCreateUserTail;
}

void MySQLParser::CreateUserTailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUserTail(this);
}

void MySQLParser::CreateUserTailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUserTail(this);
}


antlrcpp::Any MySQLParser::CreateUserTailContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateUserTail(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateUserTailContext* MySQLParser::createUserTail() {
  CreateUserTailContext *_localctx = _tracker.createInstance<CreateUserTailContext>(_ctx, getState());
  enterRule(_localctx, 498, MySQLParser::RuleCreateUserTail);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4176);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 495, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4165);

      if (!(serverVersion >= 50706)) throw FailedPredicateException(this, "serverVersion >= 50706");
      setState(4167);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::REQUIRE_SYMBOL) {
        setState(4166);
        requireClause();
      }
      setState(4170);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::WITH_SYMBOL) {
        setState(4169);
        connectOptions();
      }
      setState(4173);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::ACCOUNT_SYMBOL || _la == MySQLParser::PASSWORD_SYMBOL) {
        setState(4172);
        accountLockPasswordExpireOptions();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);

      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultRoleClauseContext ------------------------------------------------------------------

MySQLParser::DefaultRoleClauseContext::DefaultRoleClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DefaultRoleClauseContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DefaultRoleClauseContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

MySQLParser::RoleListContext* MySQLParser::DefaultRoleClauseContext::roleList() {
  return getRuleContext<MySQLParser::RoleListContext>(0);
}


size_t MySQLParser::DefaultRoleClauseContext::getRuleIndex() const {
  return MySQLParser::RuleDefaultRoleClause;
}

void MySQLParser::DefaultRoleClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultRoleClause(this);
}

void MySQLParser::DefaultRoleClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultRoleClause(this);
}


antlrcpp::Any MySQLParser::DefaultRoleClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDefaultRoleClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DefaultRoleClauseContext* MySQLParser::defaultRoleClause() {
  DefaultRoleClauseContext *_localctx = _tracker.createInstance<DefaultRoleClauseContext>(_ctx, getState());
  enterRule(_localctx, 500, MySQLParser::RuleDefaultRoleClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4185);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 497, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4178);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(4182);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 496, _ctx)) {
      case 1: {
        setState(4179);
        match(MySQLParser::DEFAULT_SYMBOL);
        setState(4180);
        match(MySQLParser::ROLE_SYMBOL);
        setState(4181);
        roleList();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);

      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RequireClauseContext ------------------------------------------------------------------

MySQLParser::RequireClauseContext::RequireClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RequireClauseContext::REQUIRE_SYMBOL() {
  return getToken(MySQLParser::REQUIRE_SYMBOL, 0);
}

MySQLParser::RequireListContext* MySQLParser::RequireClauseContext::requireList() {
  return getRuleContext<MySQLParser::RequireListContext>(0);
}

tree::TerminalNode* MySQLParser::RequireClauseContext::SSL_SYMBOL() {
  return getToken(MySQLParser::SSL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RequireClauseContext::X509_SYMBOL() {
  return getToken(MySQLParser::X509_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RequireClauseContext::NONE_SYMBOL() {
  return getToken(MySQLParser::NONE_SYMBOL, 0);
}


size_t MySQLParser::RequireClauseContext::getRuleIndex() const {
  return MySQLParser::RuleRequireClause;
}

void MySQLParser::RequireClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRequireClause(this);
}

void MySQLParser::RequireClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRequireClause(this);
}


antlrcpp::Any MySQLParser::RequireClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRequireClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RequireClauseContext* MySQLParser::requireClause() {
  RequireClauseContext *_localctx = _tracker.createInstance<RequireClauseContext>(_ctx, getState());
  enterRule(_localctx, 502, MySQLParser::RuleRequireClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4187);
    match(MySQLParser::REQUIRE_SYMBOL);
    setState(4190);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CIPHER_SYMBOL:
      case MySQLParser::ISSUER_SYMBOL:
      case MySQLParser::SUBJECT_SYMBOL: {
        setState(4188);
        requireList();
        break;
      }

      case MySQLParser::NONE_SYMBOL:
      case MySQLParser::X509_SYMBOL:
      case MySQLParser::SSL_SYMBOL: {
        setState(4189);
        dynamic_cast<RequireClauseContext *>(_localctx)->option = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::NONE_SYMBOL || _la == MySQLParser::X509_SYMBOL || _la == MySQLParser::SSL_SYMBOL)) {
          dynamic_cast<RequireClauseContext *>(_localctx)->option = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConnectOptionsContext ------------------------------------------------------------------

MySQLParser::ConnectOptionsContext::ConnectOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ConnectOptionsContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::ConnectOptionsContext::MAX_QUERIES_PER_HOUR_SYMBOL() {
  return getTokens(MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL);
}

tree::TerminalNode* MySQLParser::ConnectOptionsContext::MAX_QUERIES_PER_HOUR_SYMBOL(size_t i) {
  return getToken(MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL, i);
}

std::vector<MySQLParser::Ulong_numberContext *> MySQLParser::ConnectOptionsContext::ulong_number() {
  return getRuleContexts<MySQLParser::Ulong_numberContext>();
}

MySQLParser::Ulong_numberContext* MySQLParser::ConnectOptionsContext::ulong_number(size_t i) {
  return getRuleContext<MySQLParser::Ulong_numberContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ConnectOptionsContext::MAX_UPDATES_PER_HOUR_SYMBOL() {
  return getTokens(MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL);
}

tree::TerminalNode* MySQLParser::ConnectOptionsContext::MAX_UPDATES_PER_HOUR_SYMBOL(size_t i) {
  return getToken(MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::ConnectOptionsContext::MAX_CONNECTIONS_PER_HOUR_SYMBOL() {
  return getTokens(MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL);
}

tree::TerminalNode* MySQLParser::ConnectOptionsContext::MAX_CONNECTIONS_PER_HOUR_SYMBOL(size_t i) {
  return getToken(MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::ConnectOptionsContext::MAX_USER_CONNECTIONS_SYMBOL() {
  return getTokens(MySQLParser::MAX_USER_CONNECTIONS_SYMBOL);
}

tree::TerminalNode* MySQLParser::ConnectOptionsContext::MAX_USER_CONNECTIONS_SYMBOL(size_t i) {
  return getToken(MySQLParser::MAX_USER_CONNECTIONS_SYMBOL, i);
}


size_t MySQLParser::ConnectOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleConnectOptions;
}

void MySQLParser::ConnectOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConnectOptions(this);
}

void MySQLParser::ConnectOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConnectOptions(this);
}


antlrcpp::Any MySQLParser::ConnectOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitConnectOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ConnectOptionsContext* MySQLParser::connectOptions() {
  ConnectOptionsContext *_localctx = _tracker.createInstance<ConnectOptionsContext>(_ctx, getState());
  enterRule(_localctx, 504, MySQLParser::RuleConnectOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4192);
    match(MySQLParser::WITH_SYMBOL);
    setState(4201); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(4201);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL: {
          setState(4193);
          match(MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL);
          setState(4194);
          ulong_number();
          break;
        }

        case MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL: {
          setState(4195);
          match(MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL);
          setState(4196);
          ulong_number();
          break;
        }

        case MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL: {
          setState(4197);
          match(MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL);
          setState(4198);
          ulong_number();
          break;
        }

        case MySQLParser::MAX_USER_CONNECTIONS_SYMBOL: {
          setState(4199);
          match(MySQLParser::MAX_USER_CONNECTIONS_SYMBOL);
          setState(4200);
          ulong_number();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(4203); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 207) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 207)) & ((1ULL << (MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL - 207))
      | (1ULL << (MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL - 207))
      | (1ULL << (MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL - 207))
      | (1ULL << (MySQLParser::MAX_USER_CONNECTIONS_SYMBOL - 207)))) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AccountLockPasswordExpireOptionsContext ------------------------------------------------------------------

MySQLParser::AccountLockPasswordExpireOptionsContext::AccountLockPasswordExpireOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::ACCOUNT_SYMBOL() {
  return getToken(MySQLParser::ACCOUNT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::LOCK_SYMBOL() {
  return getToken(MySQLParser::LOCK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::UNLOCK_SYMBOL() {
  return getToken(MySQLParser::UNLOCK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::EXPIRE_SYMBOL() {
  return getToken(MySQLParser::EXPIRE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::HISTORY_SYMBOL() {
  return getToken(MySQLParser::HISTORY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::REUSE_SYMBOL() {
  return getToken(MySQLParser::REUSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::REQUIRE_SYMBOL() {
  return getToken(MySQLParser::REQUIRE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::CURRENT_SYMBOL() {
  return getToken(MySQLParser::CURRENT_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::AccountLockPasswordExpireOptionsContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::INTERVAL_SYMBOL() {
  return getToken(MySQLParser::INTERVAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::DAY_SYMBOL() {
  return getToken(MySQLParser::DAY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::NEVER_SYMBOL() {
  return getToken(MySQLParser::NEVER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::OPTIONAL_SYMBOL() {
  return getToken(MySQLParser::OPTIONAL_SYMBOL, 0);
}


size_t MySQLParser::AccountLockPasswordExpireOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleAccountLockPasswordExpireOptions;
}

void MySQLParser::AccountLockPasswordExpireOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAccountLockPasswordExpireOptions(this);
}

void MySQLParser::AccountLockPasswordExpireOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAccountLockPasswordExpireOptions(this);
}


antlrcpp::Any MySQLParser::AccountLockPasswordExpireOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAccountLockPasswordExpireOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AccountLockPasswordExpireOptionsContext* MySQLParser::accountLockPasswordExpireOptions() {
  AccountLockPasswordExpireOptionsContext *_localctx = _tracker.createInstance<AccountLockPasswordExpireOptionsContext>(_ctx, getState());
  enterRule(_localctx, 506, MySQLParser::RuleAccountLockPasswordExpireOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4237);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ACCOUNT_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4205);
        match(MySQLParser::ACCOUNT_SYMBOL);
        setState(4206);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::LOCK_SYMBOL || _la == MySQLParser::UNLOCK_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case MySQLParser::PASSWORD_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4207);
        match(MySQLParser::PASSWORD_SYMBOL);
        setState(4235);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 505, _ctx)) {
        case 1: {
          setState(4208);
          match(MySQLParser::EXPIRE_SYMBOL);
          setState(4214);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case MySQLParser::INTERVAL_SYMBOL: {
              setState(4209);
              match(MySQLParser::INTERVAL_SYMBOL);
              setState(4210);
              real_ulong_number();
              setState(4211);
              match(MySQLParser::DAY_SYMBOL);
              break;
            }

            case MySQLParser::NEVER_SYMBOL:
            case MySQLParser::DEFAULT_SYMBOL: {
              setState(4213);
              _la = _input->LA(1);
              if (!(_la == MySQLParser::NEVER_SYMBOL || _la == MySQLParser::DEFAULT_SYMBOL)) {
              _errHandler->recoverInline(this);
              }
              else {
                _errHandler->reportMatch(this);
                consume();
              }
              break;
            }

            case MySQLParser::EOF:
            case MySQLParser::SEMICOLON_SYMBOL: {
              break;
            }

          default:
            break;
          }
          break;
        }

        case 2: {
          setState(4216);
          match(MySQLParser::HISTORY_SYMBOL);
          setState(4219);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case MySQLParser::INT_NUMBER:
            case MySQLParser::LONG_NUMBER:
            case MySQLParser::ULONGLONG_NUMBER:
            case MySQLParser::HEX_NUMBER: {
              setState(4217);
              real_ulong_number();
              break;
            }

            case MySQLParser::DEFAULT_SYMBOL: {
              setState(4218);
              match(MySQLParser::DEFAULT_SYMBOL);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          break;
        }

        case 3: {
          setState(4221);
          match(MySQLParser::REUSE_SYMBOL);
          setState(4227);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case MySQLParser::INTERVAL_SYMBOL: {
              setState(4222);
              match(MySQLParser::INTERVAL_SYMBOL);
              setState(4223);
              real_ulong_number();
              setState(4224);
              match(MySQLParser::DAY_SYMBOL);
              break;
            }

            case MySQLParser::DEFAULT_SYMBOL: {
              setState(4226);
              match(MySQLParser::DEFAULT_SYMBOL);
              break;
            }

            case MySQLParser::EOF:
            case MySQLParser::SEMICOLON_SYMBOL: {
              break;
            }

          default:
            break;
          }
          break;
        }

        case 4: {
          setState(4229);

          if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
          setState(4230);
          match(MySQLParser::REQUIRE_SYMBOL);
          setState(4231);
          match(MySQLParser::CURRENT_SYMBOL);
          setState(4233);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLParser::DEFAULT_SYMBOL || _la == MySQLParser::OPTIONAL_SYMBOL) {
            setState(4232);
            _la = _input->LA(1);
            if (!(_la == MySQLParser::DEFAULT_SYMBOL || _la == MySQLParser::OPTIONAL_SYMBOL)) {
            _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
          }
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropUserContext ------------------------------------------------------------------

MySQLParser::DropUserContext::DropUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropUserContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DropUserContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

MySQLParser::UserListContext* MySQLParser::DropUserContext::userList() {
  return getRuleContext<MySQLParser::UserListContext>(0);
}

MySQLParser::IfExistsContext* MySQLParser::DropUserContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}


size_t MySQLParser::DropUserContext::getRuleIndex() const {
  return MySQLParser::RuleDropUser;
}

void MySQLParser::DropUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropUser(this);
}

void MySQLParser::DropUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropUser(this);
}


antlrcpp::Any MySQLParser::DropUserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDropUser(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropUserContext* MySQLParser::dropUser() {
  DropUserContext *_localctx = _tracker.createInstance<DropUserContext>(_ctx, getState());
  enterRule(_localctx, 508, MySQLParser::RuleDropUser);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4239);
    match(MySQLParser::DROP_SYMBOL);
    setState(4240);
    match(MySQLParser::USER_SYMBOL);
    setState(4243);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 507, _ctx)) {
    case 1: {
      setState(4241);

      if (!(serverVersion >= 50706)) throw FailedPredicateException(this, "serverVersion >= 50706");
      setState(4242);
      ifExists();
      break;
    }

    }
    setState(4245);
    userList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantContext ------------------------------------------------------------------

MySQLParser::GrantContext::GrantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::GrantContext::GRANT_SYMBOL() {
  return getTokens(MySQLParser::GRANT_SYMBOL);
}

tree::TerminalNode* MySQLParser::GrantContext::GRANT_SYMBOL(size_t i) {
  return getToken(MySQLParser::GRANT_SYMBOL, i);
}

MySQLParser::RoleOrPrivilegesListContext* MySQLParser::GrantContext::roleOrPrivilegesList() {
  return getRuleContext<MySQLParser::RoleOrPrivilegesListContext>(0);
}

tree::TerminalNode* MySQLParser::GrantContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::UserListContext* MySQLParser::GrantContext::userList() {
  return getRuleContext<MySQLParser::UserListContext>(0);
}

tree::TerminalNode* MySQLParser::GrantContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::GrantIdentifierContext* MySQLParser::GrantContext::grantIdentifier() {
  return getRuleContext<MySQLParser::GrantIdentifierContext>(0);
}

MySQLParser::GrantTargetListContext* MySQLParser::GrantContext::grantTargetList() {
  return getRuleContext<MySQLParser::GrantTargetListContext>(0);
}

tree::TerminalNode* MySQLParser::GrantContext::PROXY_SYMBOL() {
  return getToken(MySQLParser::PROXY_SYMBOL, 0);
}

MySQLParser::UserContext* MySQLParser::GrantContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

tree::TerminalNode* MySQLParser::GrantContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GrantContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GrantContext::ADMIN_SYMBOL() {
  return getToken(MySQLParser::ADMIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GrantContext::OPTION_SYMBOL() {
  return getToken(MySQLParser::OPTION_SYMBOL, 0);
}

MySQLParser::AclTypeContext* MySQLParser::GrantContext::aclType() {
  return getRuleContext<MySQLParser::AclTypeContext>(0);
}

MySQLParser::VersionedRequireClauseContext* MySQLParser::GrantContext::versionedRequireClause() {
  return getRuleContext<MySQLParser::VersionedRequireClauseContext>(0);
}

MySQLParser::GrantOptionsContext* MySQLParser::GrantContext::grantOptions() {
  return getRuleContext<MySQLParser::GrantOptionsContext>(0);
}

tree::TerminalNode* MySQLParser::GrantContext::PRIVILEGES_SYMBOL() {
  return getToken(MySQLParser::PRIVILEGES_SYMBOL, 0);
}


size_t MySQLParser::GrantContext::getRuleIndex() const {
  return MySQLParser::RuleGrant;
}

void MySQLParser::GrantContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrant(this);
}

void MySQLParser::GrantContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrant(this);
}


antlrcpp::Any MySQLParser::GrantContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitGrant(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GrantContext* MySQLParser::grant() {
  GrantContext *_localctx = _tracker.createInstance<GrantContext>(_ctx, getState());
  enterRule(_localctx, 510, MySQLParser::RuleGrant);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4247);
    match(MySQLParser::GRANT_SYMBOL);
    setState(4288);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 515, _ctx)) {
    case 1: {
      setState(4248);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(4249);
      roleOrPrivilegesList();
      setState(4250);
      match(MySQLParser::TO_SYMBOL);
      setState(4251);
      userList();
      setState(4255);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::WITH_SYMBOL) {
        setState(4252);
        match(MySQLParser::WITH_SYMBOL);
        setState(4253);
        match(MySQLParser::ADMIN_SYMBOL);
        setState(4254);
        match(MySQLParser::OPTION_SYMBOL);
      }
      break;
    }

    case 2: {
      setState(4262);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 510, _ctx)) {
      case 1: {
        setState(4257);
        roleOrPrivilegesList();
        break;
      }

      case 2: {
        setState(4258);
        match(MySQLParser::ALL_SYMBOL);
        setState(4260);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::PRIVILEGES_SYMBOL) {
          setState(4259);
          match(MySQLParser::PRIVILEGES_SYMBOL);
        }
        break;
      }

      }
      setState(4264);
      match(MySQLParser::ON_SYMBOL);
      setState(4266);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 511, _ctx)) {
      case 1: {
        setState(4265);
        aclType();
        break;
      }

      }
      setState(4268);
      grantIdentifier();
      setState(4269);
      match(MySQLParser::TO_SYMBOL);
      setState(4270);
      grantTargetList();
      setState(4272);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 512, _ctx)) {
      case 1: {
        setState(4271);
        versionedRequireClause();
        break;
      }

      }
      setState(4275);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 513, _ctx)) {
      case 1: {
        setState(4274);
        grantOptions();
        break;
      }

      }
      break;
    }

    case 3: {
      setState(4277);

      if (!(serverVersion >= 50500)) throw FailedPredicateException(this, "serverVersion >= 50500");
      setState(4278);
      match(MySQLParser::PROXY_SYMBOL);
      setState(4279);
      match(MySQLParser::ON_SYMBOL);
      setState(4280);
      user();
      setState(4281);
      match(MySQLParser::TO_SYMBOL);
      setState(4282);
      grantTargetList();
      setState(4286);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::WITH_SYMBOL) {
        setState(4283);
        match(MySQLParser::WITH_SYMBOL);
        setState(4284);
        match(MySQLParser::GRANT_SYMBOL);
        setState(4285);
        match(MySQLParser::OPTION_SYMBOL);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantTargetListContext ------------------------------------------------------------------

MySQLParser::GrantTargetListContext::GrantTargetListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CreateUserListContext* MySQLParser::GrantTargetListContext::createUserList() {
  return getRuleContext<MySQLParser::CreateUserListContext>(0);
}

MySQLParser::UserListContext* MySQLParser::GrantTargetListContext::userList() {
  return getRuleContext<MySQLParser::UserListContext>(0);
}


size_t MySQLParser::GrantTargetListContext::getRuleIndex() const {
  return MySQLParser::RuleGrantTargetList;
}

void MySQLParser::GrantTargetListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrantTargetList(this);
}

void MySQLParser::GrantTargetListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrantTargetList(this);
}


antlrcpp::Any MySQLParser::GrantTargetListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitGrantTargetList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GrantTargetListContext* MySQLParser::grantTargetList() {
  GrantTargetListContext *_localctx = _tracker.createInstance<GrantTargetListContext>(_ctx, getState());
  enterRule(_localctx, 512, MySQLParser::RuleGrantTargetList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4294);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 516, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4290);

      if (!(serverVersion < 80011)) throw FailedPredicateException(this, "serverVersion < 80011");
      setState(4291);
      createUserList();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4292);

      if (!(serverVersion >= 80011)) throw FailedPredicateException(this, "serverVersion >= 80011");
      setState(4293);
      userList();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantOptionsContext ------------------------------------------------------------------

MySQLParser::GrantOptionsContext::GrantOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::GrantOptionsContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

std::vector<MySQLParser::GrantOptionContext *> MySQLParser::GrantOptionsContext::grantOption() {
  return getRuleContexts<MySQLParser::GrantOptionContext>();
}

MySQLParser::GrantOptionContext* MySQLParser::GrantOptionsContext::grantOption(size_t i) {
  return getRuleContext<MySQLParser::GrantOptionContext>(i);
}

tree::TerminalNode* MySQLParser::GrantOptionsContext::GRANT_SYMBOL() {
  return getToken(MySQLParser::GRANT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GrantOptionsContext::OPTION_SYMBOL() {
  return getToken(MySQLParser::OPTION_SYMBOL, 0);
}


size_t MySQLParser::GrantOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleGrantOptions;
}

void MySQLParser::GrantOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrantOptions(this);
}

void MySQLParser::GrantOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrantOptions(this);
}


antlrcpp::Any MySQLParser::GrantOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitGrantOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GrantOptionsContext* MySQLParser::grantOptions() {
  GrantOptionsContext *_localctx = _tracker.createInstance<GrantOptionsContext>(_ctx, getState());
  enterRule(_localctx, 514, MySQLParser::RuleGrantOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4307);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 518, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4296);

      if (!(serverVersion < 80011)) throw FailedPredicateException(this, "serverVersion < 80011");
      setState(4297);
      match(MySQLParser::WITH_SYMBOL);
      setState(4299); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(4298);
        grantOption();
        setState(4301); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (((((_la - 207) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 207)) & ((1ULL << (MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL - 207))
        | (1ULL << (MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL - 207))
        | (1ULL << (MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL - 207))
        | (1ULL << (MySQLParser::MAX_USER_CONNECTIONS_SYMBOL - 207)))) != 0) || _la == MySQLParser::GRANT_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4303);

      if (!(serverVersion >= 80011)) throw FailedPredicateException(this, "serverVersion >= 80011");
      setState(4304);
      match(MySQLParser::WITH_SYMBOL);
      setState(4305);
      match(MySQLParser::GRANT_SYMBOL);
      setState(4306);
      match(MySQLParser::OPTION_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VersionedRequireClauseContext ------------------------------------------------------------------

MySQLParser::VersionedRequireClauseContext::VersionedRequireClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RequireClauseContext* MySQLParser::VersionedRequireClauseContext::requireClause() {
  return getRuleContext<MySQLParser::RequireClauseContext>(0);
}


size_t MySQLParser::VersionedRequireClauseContext::getRuleIndex() const {
  return MySQLParser::RuleVersionedRequireClause;
}

void MySQLParser::VersionedRequireClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVersionedRequireClause(this);
}

void MySQLParser::VersionedRequireClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVersionedRequireClause(this);
}


antlrcpp::Any MySQLParser::VersionedRequireClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitVersionedRequireClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::VersionedRequireClauseContext* MySQLParser::versionedRequireClause() {
  VersionedRequireClauseContext *_localctx = _tracker.createInstance<VersionedRequireClauseContext>(_ctx, getState());
  enterRule(_localctx, 516, MySQLParser::RuleVersionedRequireClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4309);

    if (!(serverVersion < 80011)) throw FailedPredicateException(this, "serverVersion < 80011");
    setState(4310);
    requireClause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RenameUserContext ------------------------------------------------------------------

MySQLParser::RenameUserContext::RenameUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RenameUserContext::RENAME_SYMBOL() {
  return getToken(MySQLParser::RENAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RenameUserContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

std::vector<MySQLParser::UserContext *> MySQLParser::RenameUserContext::user() {
  return getRuleContexts<MySQLParser::UserContext>();
}

MySQLParser::UserContext* MySQLParser::RenameUserContext::user(size_t i) {
  return getRuleContext<MySQLParser::UserContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::RenameUserContext::TO_SYMBOL() {
  return getTokens(MySQLParser::TO_SYMBOL);
}

tree::TerminalNode* MySQLParser::RenameUserContext::TO_SYMBOL(size_t i) {
  return getToken(MySQLParser::TO_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::RenameUserContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::RenameUserContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::RenameUserContext::getRuleIndex() const {
  return MySQLParser::RuleRenameUser;
}

void MySQLParser::RenameUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRenameUser(this);
}

void MySQLParser::RenameUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRenameUser(this);
}


antlrcpp::Any MySQLParser::RenameUserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRenameUser(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RenameUserContext* MySQLParser::renameUser() {
  RenameUserContext *_localctx = _tracker.createInstance<RenameUserContext>(_ctx, getState());
  enterRule(_localctx, 518, MySQLParser::RuleRenameUser);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4312);
    match(MySQLParser::RENAME_SYMBOL);
    setState(4313);
    match(MySQLParser::USER_SYMBOL);
    setState(4314);
    user();
    setState(4315);
    match(MySQLParser::TO_SYMBOL);
    setState(4316);
    user();
    setState(4324);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(4317);
      match(MySQLParser::COMMA_SYMBOL);
      setState(4318);
      user();
      setState(4319);
      match(MySQLParser::TO_SYMBOL);
      setState(4320);
      user();
      setState(4326);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RevokeContext ------------------------------------------------------------------

MySQLParser::RevokeContext::RevokeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RevokeContext::REVOKE_SYMBOL() {
  return getToken(MySQLParser::REVOKE_SYMBOL, 0);
}

MySQLParser::RoleOrPrivilegesListContext* MySQLParser::RevokeContext::roleOrPrivilegesList() {
  return getRuleContext<MySQLParser::RoleOrPrivilegesListContext>(0);
}

tree::TerminalNode* MySQLParser::RevokeContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

MySQLParser::UserListContext* MySQLParser::RevokeContext::userList() {
  return getRuleContext<MySQLParser::UserListContext>(0);
}

MySQLParser::OnTypeToContext* MySQLParser::RevokeContext::onTypeTo() {
  return getRuleContext<MySQLParser::OnTypeToContext>(0);
}

tree::TerminalNode* MySQLParser::RevokeContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RevokeContext::PROXY_SYMBOL() {
  return getToken(MySQLParser::PROXY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RevokeContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::UserContext* MySQLParser::RevokeContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

MySQLParser::GrantIdentifierContext* MySQLParser::RevokeContext::grantIdentifier() {
  return getRuleContext<MySQLParser::GrantIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::RevokeContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RevokeContext::GRANT_SYMBOL() {
  return getToken(MySQLParser::GRANT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RevokeContext::OPTION_SYMBOL() {
  return getToken(MySQLParser::OPTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RevokeContext::PRIVILEGES_SYMBOL() {
  return getToken(MySQLParser::PRIVILEGES_SYMBOL, 0);
}

MySQLParser::AclTypeContext* MySQLParser::RevokeContext::aclType() {
  return getRuleContext<MySQLParser::AclTypeContext>(0);
}


size_t MySQLParser::RevokeContext::getRuleIndex() const {
  return MySQLParser::RuleRevoke;
}

void MySQLParser::RevokeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRevoke(this);
}

void MySQLParser::RevokeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRevoke(this);
}


antlrcpp::Any MySQLParser::RevokeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRevoke(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RevokeContext* MySQLParser::revoke() {
  RevokeContext *_localctx = _tracker.createInstance<RevokeContext>(_ctx, getState());
  enterRule(_localctx, 520, MySQLParser::RuleRevoke);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4327);
    match(MySQLParser::REVOKE_SYMBOL);
    setState(4362);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 523, _ctx)) {
    case 1: {
      setState(4328);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(4329);
      roleOrPrivilegesList();
      setState(4330);
      match(MySQLParser::FROM_SYMBOL);
      setState(4331);
      userList();
      break;
    }

    case 2: {
      setState(4333);
      roleOrPrivilegesList();
      setState(4334);
      onTypeTo();
      setState(4335);
      match(MySQLParser::FROM_SYMBOL);
      setState(4336);
      userList();
      break;
    }

    case 3: {
      setState(4338);
      match(MySQLParser::ALL_SYMBOL);
      setState(4340);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 520, _ctx)) {
      case 1: {
        setState(4339);
        match(MySQLParser::PRIVILEGES_SYMBOL);
        break;
      }

      }
      setState(4353);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 522, _ctx)) {
      case 1: {
        setState(4342);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(4343);
        match(MySQLParser::ON_SYMBOL);
        setState(4345);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 521, _ctx)) {
        case 1: {
          setState(4344);
          aclType();
          break;
        }

        }
        setState(4347);
        grantIdentifier();
        break;
      }

      case 2: {
        setState(4348);
        match(MySQLParser::COMMA_SYMBOL);
        setState(4349);
        match(MySQLParser::GRANT_SYMBOL);
        setState(4350);
        match(MySQLParser::OPTION_SYMBOL);
        setState(4351);
        match(MySQLParser::FROM_SYMBOL);
        setState(4352);
        userList();
        break;
      }

      }
      break;
    }

    case 4: {
      setState(4355);

      if (!(serverVersion >= 50500)) throw FailedPredicateException(this, "serverVersion >= 50500");
      setState(4356);
      match(MySQLParser::PROXY_SYMBOL);
      setState(4357);
      match(MySQLParser::ON_SYMBOL);
      setState(4358);
      user();
      setState(4359);
      match(MySQLParser::FROM_SYMBOL);
      setState(4360);
      userList();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnTypeToContext ------------------------------------------------------------------

MySQLParser::OnTypeToContext::OnTypeToContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::OnTypeToContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::GrantIdentifierContext* MySQLParser::OnTypeToContext::grantIdentifier() {
  return getRuleContext<MySQLParser::GrantIdentifierContext>(0);
}

MySQLParser::AclTypeContext* MySQLParser::OnTypeToContext::aclType() {
  return getRuleContext<MySQLParser::AclTypeContext>(0);
}


size_t MySQLParser::OnTypeToContext::getRuleIndex() const {
  return MySQLParser::RuleOnTypeTo;
}

void MySQLParser::OnTypeToContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnTypeTo(this);
}

void MySQLParser::OnTypeToContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnTypeTo(this);
}


antlrcpp::Any MySQLParser::OnTypeToContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitOnTypeTo(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OnTypeToContext* MySQLParser::onTypeTo() {
  OnTypeToContext *_localctx = _tracker.createInstance<OnTypeToContext>(_ctx, getState());
  enterRule(_localctx, 522, MySQLParser::RuleOnTypeTo);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4378);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 527, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4364);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(4365);
      match(MySQLParser::ON_SYMBOL);
      setState(4367);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 524, _ctx)) {
      case 1: {
        setState(4366);
        aclType();
        break;
      }

      }
      setState(4369);
      grantIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4370);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(4376);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::ON_SYMBOL) {
        setState(4371);
        match(MySQLParser::ON_SYMBOL);
        setState(4373);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 525, _ctx)) {
        case 1: {
          setState(4372);
          aclType();
          break;
        }

        }
        setState(4375);
        grantIdentifier();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AclTypeContext ------------------------------------------------------------------

MySQLParser::AclTypeContext::AclTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AclTypeContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AclTypeContext::FUNCTION_SYMBOL() {
  return getToken(MySQLParser::FUNCTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AclTypeContext::PROCEDURE_SYMBOL() {
  return getToken(MySQLParser::PROCEDURE_SYMBOL, 0);
}


size_t MySQLParser::AclTypeContext::getRuleIndex() const {
  return MySQLParser::RuleAclType;
}

void MySQLParser::AclTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAclType(this);
}

void MySQLParser::AclTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAclType(this);
}


antlrcpp::Any MySQLParser::AclTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAclType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AclTypeContext* MySQLParser::aclType() {
  AclTypeContext *_localctx = _tracker.createInstance<AclTypeContext>(_ctx, getState());
  enterRule(_localctx, 524, MySQLParser::RuleAclType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4380);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::FUNCTION_SYMBOL || _la == MySQLParser::PROCEDURE_SYMBOL

    || _la == MySQLParser::TABLE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetPasswordContext ------------------------------------------------------------------

MySQLParser::SetPasswordContext::SetPasswordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SetPasswordContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::SetPasswordContext::PASSWORD_SYMBOL() {
  return getTokens(MySQLParser::PASSWORD_SYMBOL);
}

tree::TerminalNode* MySQLParser::SetPasswordContext::PASSWORD_SYMBOL(size_t i) {
  return getToken(MySQLParser::PASSWORD_SYMBOL, i);
}

MySQLParser::EqualContext* MySQLParser::SetPasswordContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

tree::TerminalNode* MySQLParser::SetPasswordContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::SetPasswordContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode* MySQLParser::SetPasswordContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetPasswordContext::OLD_PASSWORD_SYMBOL() {
  return getToken(MySQLParser::OLD_PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetPasswordContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

MySQLParser::UserContext* MySQLParser::SetPasswordContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

MySQLParser::ReplacePasswordContext* MySQLParser::SetPasswordContext::replacePassword() {
  return getRuleContext<MySQLParser::ReplacePasswordContext>(0);
}

MySQLParser::RetainCurrentPasswordContext* MySQLParser::SetPasswordContext::retainCurrentPassword() {
  return getRuleContext<MySQLParser::RetainCurrentPasswordContext>(0);
}


size_t MySQLParser::SetPasswordContext::getRuleIndex() const {
  return MySQLParser::RuleSetPassword;
}

void MySQLParser::SetPasswordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetPassword(this);
}

void MySQLParser::SetPasswordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetPassword(this);
}


antlrcpp::Any MySQLParser::SetPasswordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSetPassword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SetPasswordContext* MySQLParser::setPassword() {
  SetPasswordContext *_localctx = _tracker.createInstance<SetPasswordContext>(_ctx, getState());
  enterRule(_localctx, 526, MySQLParser::RuleSetPassword);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4382);
    match(MySQLParser::SET_SYMBOL);
    setState(4383);
    match(MySQLParser::PASSWORD_SYMBOL);
    setState(4386);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FOR_SYMBOL) {
      setState(4384);
      match(MySQLParser::FOR_SYMBOL);
      setState(4385);
      user();
    }
    setState(4388);
    equal();
    setState(4401);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 529, _ctx)) {
    case 1: {
      setState(4389);
      match(MySQLParser::PASSWORD_SYMBOL);
      setState(4390);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(4391);
      textString();
      setState(4392);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 2: {
      setState(4394);

      if (!(serverVersion < 50706)) throw FailedPredicateException(this, "serverVersion < 50706");
      setState(4395);
      match(MySQLParser::OLD_PASSWORD_SYMBOL);
      setState(4396);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(4397);
      textString();
      setState(4398);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 3: {
      setState(4400);
      textString();
      break;
    }

    }
    setState(4405);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 530, _ctx)) {
    case 1: {
      setState(4403);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(4404);
      replacePassword();
      break;
    }

    }
    setState(4409);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 531, _ctx)) {
    case 1: {
      setState(4407);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(4408);
      retainCurrentPassword();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleOrPrivilegesListContext ------------------------------------------------------------------

MySQLParser::RoleOrPrivilegesListContext::RoleOrPrivilegesListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::RoleOrPrivilegeContext *> MySQLParser::RoleOrPrivilegesListContext::roleOrPrivilege() {
  return getRuleContexts<MySQLParser::RoleOrPrivilegeContext>();
}

MySQLParser::RoleOrPrivilegeContext* MySQLParser::RoleOrPrivilegesListContext::roleOrPrivilege(size_t i) {
  return getRuleContext<MySQLParser::RoleOrPrivilegeContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::RoleOrPrivilegesListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegesListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::RoleOrPrivilegesListContext::getRuleIndex() const {
  return MySQLParser::RuleRoleOrPrivilegesList;
}

void MySQLParser::RoleOrPrivilegesListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleOrPrivilegesList(this);
}

void MySQLParser::RoleOrPrivilegesListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleOrPrivilegesList(this);
}


antlrcpp::Any MySQLParser::RoleOrPrivilegesListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRoleOrPrivilegesList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoleOrPrivilegesListContext* MySQLParser::roleOrPrivilegesList() {
  RoleOrPrivilegesListContext *_localctx = _tracker.createInstance<RoleOrPrivilegesListContext>(_ctx, getState());
  enterRule(_localctx, 528, MySQLParser::RuleRoleOrPrivilegesList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4411);
    roleOrPrivilege();
    setState(4416);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 532, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4412);
        match(MySQLParser::COMMA_SYMBOL);
        setState(4413);
        roleOrPrivilege(); 
      }
      setState(4418);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 532, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleOrPrivilegeContext ------------------------------------------------------------------

MySQLParser::RoleOrPrivilegeContext::RoleOrPrivilegeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RoleIdentifierOrTextContext* MySQLParser::RoleOrPrivilegeContext::roleIdentifierOrText() {
  return getRuleContext<MySQLParser::RoleIdentifierOrTextContext>(0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::AT_TEXT_SUFFIX() {
  return getToken(MySQLParser::AT_TEXT_SUFFIX, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::AT_SIGN_SYMBOL() {
  return getToken(MySQLParser::AT_SIGN_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::RoleOrPrivilegeContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

MySQLParser::ColumnInternalRefListContext* MySQLParser::RoleOrPrivilegeContext::columnInternalRefList() {
  return getRuleContext<MySQLParser::ColumnInternalRefListContext>(0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::SELECT_SYMBOL() {
  return getToken(MySQLParser::SELECT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::INSERT_SYMBOL() {
  return getToken(MySQLParser::INSERT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::REFERENCES_SYMBOL() {
  return getToken(MySQLParser::REFERENCES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::DELETE_SYMBOL() {
  return getToken(MySQLParser::DELETE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::USAGE_SYMBOL() {
  return getToken(MySQLParser::USAGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::EXECUTE_SYMBOL() {
  return getToken(MySQLParser::EXECUTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::RELOAD_SYMBOL() {
  return getToken(MySQLParser::RELOAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::SHUTDOWN_SYMBOL() {
  return getToken(MySQLParser::SHUTDOWN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::PROCESS_SYMBOL() {
  return getToken(MySQLParser::PROCESS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::FILE_SYMBOL() {
  return getToken(MySQLParser::FILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::PROXY_SYMBOL() {
  return getToken(MySQLParser::PROXY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::SUPER_SYMBOL() {
  return getToken(MySQLParser::SUPER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::EVENT_SYMBOL() {
  return getToken(MySQLParser::EVENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::TRIGGER_SYMBOL() {
  return getToken(MySQLParser::TRIGGER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::GRANT_SYMBOL() {
  return getToken(MySQLParser::GRANT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::OPTION_SYMBOL() {
  return getToken(MySQLParser::OPTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::DATABASES_SYMBOL() {
  return getToken(MySQLParser::DATABASES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::TEMPORARY_SYMBOL() {
  return getToken(MySQLParser::TEMPORARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::ROUTINE_SYMBOL() {
  return getToken(MySQLParser::ROUTINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::VIEW_SYMBOL() {
  return getToken(MySQLParser::VIEW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::LOCK_SYMBOL() {
  return getToken(MySQLParser::LOCK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::REPLICATION_SYMBOL() {
  return getToken(MySQLParser::REPLICATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::CLIENT_SYMBOL() {
  return getToken(MySQLParser::CLIENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::SLAVE_SYMBOL() {
  return getToken(MySQLParser::SLAVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::ALTER_SYMBOL() {
  return getToken(MySQLParser::ALTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}


size_t MySQLParser::RoleOrPrivilegeContext::getRuleIndex() const {
  return MySQLParser::RuleRoleOrPrivilege;
}

void MySQLParser::RoleOrPrivilegeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleOrPrivilege(this);
}

void MySQLParser::RoleOrPrivilegeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleOrPrivilege(this);
}


antlrcpp::Any MySQLParser::RoleOrPrivilegeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRoleOrPrivilege(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoleOrPrivilegeContext* MySQLParser::roleOrPrivilege() {
  RoleOrPrivilegeContext *_localctx = _tracker.createInstance<RoleOrPrivilegeContext>(_ctx, getState());
  enterRule(_localctx, 530, MySQLParser::RuleRoleOrPrivilege);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4460);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 539, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4419);

      if (!(serverVersion > 80000)) throw FailedPredicateException(this, "serverVersion > 80000");
      setState(4430);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 535, _ctx)) {
      case 1: {
        setState(4420);
        roleIdentifierOrText();
        setState(4422);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 533, _ctx)) {
        case 1: {
          setState(4421);
          columnInternalRefList();
          break;
        }

        }
        break;
      }

      case 2: {
        setState(4424);
        roleIdentifierOrText();
        setState(4428);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::AT_TEXT_SUFFIX: {
            setState(4425);
            match(MySQLParser::AT_TEXT_SUFFIX);
            break;
          }

          case MySQLParser::AT_SIGN_SYMBOL: {
            setState(4426);
            match(MySQLParser::AT_SIGN_SYMBOL);
            setState(4427);
            textOrIdentifier();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4432);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::INSERT_SYMBOL || ((((_la - 600) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 600)) & ((1ULL << (MySQLParser::REFERENCES_SYMBOL - 600))
        | (1ULL << (MySQLParser::SELECT_SYMBOL - 600))
        | (1ULL << (MySQLParser::UPDATE_SYMBOL - 600)))) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4434);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 536, _ctx)) {
      case 1: {
        setState(4433);
        columnInternalRefList();
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4436);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::EXECUTE_SYMBOL

      || _la == MySQLParser::SHUTDOWN_SYMBOL || _la == MySQLParser::EVENT_SYMBOL

      || _la == MySQLParser::FILE_SYMBOL || ((((_la - 261) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 261)) & ((1ULL << (MySQLParser::PROCESS_SYMBOL - 261))
        | (1ULL << (MySQLParser::PROXY_SYMBOL - 261))
        | (1ULL << (MySQLParser::RELOAD_SYMBOL - 261)))) != 0) || _la == MySQLParser::SUPER_SYMBOL || ((((_la - 480) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 480)) & ((1ULL << (MySQLParser::DELETE_SYMBOL - 480))
        | (1ULL << (MySQLParser::DROP_SYMBOL - 480))
        | (1ULL << (MySQLParser::INDEX_SYMBOL - 480)))) != 0) || _la == MySQLParser::TRIGGER_SYMBOL

      || _la == MySQLParser::USAGE_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4437);
      match(MySQLParser::GRANT_SYMBOL);
      setState(4438);
      match(MySQLParser::OPTION_SYMBOL);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4439);
      match(MySQLParser::SHOW_SYMBOL);
      setState(4440);
      match(MySQLParser::DATABASES_SYMBOL);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4441);
      match(MySQLParser::CREATE_SYMBOL);
      setState(4445);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 537, _ctx)) {
      case 1: {
        setState(4442);
        match(MySQLParser::TEMPORARY_SYMBOL);
        setState(4443);
        dynamic_cast<RoleOrPrivilegeContext *>(_localctx)->object = match(MySQLParser::TABLES_SYMBOL);
        break;
      }

      case 2: {
        setState(4444);
        dynamic_cast<RoleOrPrivilegeContext *>(_localctx)->object = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::ROUTINE_SYMBOL

        || _la == MySQLParser::TABLESPACE_SYMBOL || _la == MySQLParser::USER_SYMBOL

        || _la == MySQLParser::VIEW_SYMBOL)) {
          dynamic_cast<RoleOrPrivilegeContext *>(_localctx)->object = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4447);
      match(MySQLParser::LOCK_SYMBOL);
      setState(4448);
      match(MySQLParser::TABLES_SYMBOL);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4449);
      match(MySQLParser::REPLICATION_SYMBOL);
      setState(4450);
      dynamic_cast<RoleOrPrivilegeContext *>(_localctx)->object = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::SLAVE_SYMBOL

      || _la == MySQLParser::CLIENT_SYMBOL)) {
        dynamic_cast<RoleOrPrivilegeContext *>(_localctx)->object = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(4451);
      match(MySQLParser::SHOW_SYMBOL);
      setState(4452);
      match(MySQLParser::VIEW_SYMBOL);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(4453);
      match(MySQLParser::ALTER_SYMBOL);
      setState(4455);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 538, _ctx)) {
      case 1: {
        setState(4454);
        match(MySQLParser::ROUTINE_SYMBOL);
        break;
      }

      }
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(4457);

      if (!(serverVersion > 80000)) throw FailedPredicateException(this, "serverVersion > 80000");
      setState(4458);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::CREATE_SYMBOL

      || _la == MySQLParser::DROP_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4459);
      match(MySQLParser::ROLE_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantIdentifierContext ------------------------------------------------------------------

MySQLParser::GrantIdentifierContext::GrantIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::GrantIdentifierContext::MULT_OPERATOR() {
  return getTokens(MySQLParser::MULT_OPERATOR);
}

tree::TerminalNode* MySQLParser::GrantIdentifierContext::MULT_OPERATOR(size_t i) {
  return getToken(MySQLParser::MULT_OPERATOR, i);
}

tree::TerminalNode* MySQLParser::GrantIdentifierContext::DOT_SYMBOL() {
  return getToken(MySQLParser::DOT_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::GrantIdentifierContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::TableRefContext* MySQLParser::GrantIdentifierContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}


size_t MySQLParser::GrantIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleGrantIdentifier;
}

void MySQLParser::GrantIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrantIdentifier(this);
}

void MySQLParser::GrantIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrantIdentifier(this);
}


antlrcpp::Any MySQLParser::GrantIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitGrantIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GrantIdentifierContext* MySQLParser::grantIdentifier() {
  GrantIdentifierContext *_localctx = _tracker.createInstance<GrantIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 532, MySQLParser::RuleGrantIdentifier);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4473);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 542, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4462);
      match(MySQLParser::MULT_OPERATOR);
      setState(4465);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::DOT_SYMBOL) {
        setState(4463);
        match(MySQLParser::DOT_SYMBOL);
        setState(4464);
        match(MySQLParser::MULT_OPERATOR);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4467);
      identifier();
      setState(4470);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::DOT_SYMBOL) {
        setState(4468);
        match(MySQLParser::DOT_SYMBOL);
        setState(4469);
        match(MySQLParser::MULT_OPERATOR);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4472);
      tableRef();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RequireListContext ------------------------------------------------------------------

MySQLParser::RequireListContext::RequireListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::RequireListElementContext *> MySQLParser::RequireListContext::requireListElement() {
  return getRuleContexts<MySQLParser::RequireListElementContext>();
}

MySQLParser::RequireListElementContext* MySQLParser::RequireListContext::requireListElement(size_t i) {
  return getRuleContext<MySQLParser::RequireListElementContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::RequireListContext::AND_SYMBOL() {
  return getTokens(MySQLParser::AND_SYMBOL);
}

tree::TerminalNode* MySQLParser::RequireListContext::AND_SYMBOL(size_t i) {
  return getToken(MySQLParser::AND_SYMBOL, i);
}


size_t MySQLParser::RequireListContext::getRuleIndex() const {
  return MySQLParser::RuleRequireList;
}

void MySQLParser::RequireListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRequireList(this);
}

void MySQLParser::RequireListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRequireList(this);
}


antlrcpp::Any MySQLParser::RequireListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRequireList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RequireListContext* MySQLParser::requireList() {
  RequireListContext *_localctx = _tracker.createInstance<RequireListContext>(_ctx, getState());
  enterRule(_localctx, 534, MySQLParser::RuleRequireList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4475);
    requireListElement();
    setState(4482);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 544, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4477);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::AND_SYMBOL) {
          setState(4476);
          match(MySQLParser::AND_SYMBOL);
        }
        setState(4479);
        requireListElement(); 
      }
      setState(4484);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 544, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RequireListElementContext ------------------------------------------------------------------

MySQLParser::RequireListElementContext::RequireListElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextStringContext* MySQLParser::RequireListElementContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode* MySQLParser::RequireListElementContext::CIPHER_SYMBOL() {
  return getToken(MySQLParser::CIPHER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RequireListElementContext::ISSUER_SYMBOL() {
  return getToken(MySQLParser::ISSUER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RequireListElementContext::SUBJECT_SYMBOL() {
  return getToken(MySQLParser::SUBJECT_SYMBOL, 0);
}


size_t MySQLParser::RequireListElementContext::getRuleIndex() const {
  return MySQLParser::RuleRequireListElement;
}

void MySQLParser::RequireListElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRequireListElement(this);
}

void MySQLParser::RequireListElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRequireListElement(this);
}


antlrcpp::Any MySQLParser::RequireListElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRequireListElement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RequireListElementContext* MySQLParser::requireListElement() {
  RequireListElementContext *_localctx = _tracker.createInstance<RequireListElementContext>(_ctx, getState());
  enterRule(_localctx, 536, MySQLParser::RuleRequireListElement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4491);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CIPHER_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4485);
        dynamic_cast<RequireListElementContext *>(_localctx)->element = match(MySQLParser::CIPHER_SYMBOL);
        setState(4486);
        textString();
        break;
      }

      case MySQLParser::ISSUER_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4487);
        dynamic_cast<RequireListElementContext *>(_localctx)->element = match(MySQLParser::ISSUER_SYMBOL);
        setState(4488);
        textString();
        break;
      }

      case MySQLParser::SUBJECT_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(4489);
        dynamic_cast<RequireListElementContext *>(_localctx)->element = match(MySQLParser::SUBJECT_SYMBOL);
        setState(4490);
        textString();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantOptionContext ------------------------------------------------------------------

MySQLParser::GrantOptionContext::GrantOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::GrantOptionContext::OPTION_SYMBOL() {
  return getToken(MySQLParser::OPTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GrantOptionContext::GRANT_SYMBOL() {
  return getToken(MySQLParser::GRANT_SYMBOL, 0);
}

MySQLParser::Ulong_numberContext* MySQLParser::GrantOptionContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::GrantOptionContext::MAX_QUERIES_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GrantOptionContext::MAX_UPDATES_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GrantOptionContext::MAX_CONNECTIONS_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GrantOptionContext::MAX_USER_CONNECTIONS_SYMBOL() {
  return getToken(MySQLParser::MAX_USER_CONNECTIONS_SYMBOL, 0);
}


size_t MySQLParser::GrantOptionContext::getRuleIndex() const {
  return MySQLParser::RuleGrantOption;
}

void MySQLParser::GrantOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrantOption(this);
}

void MySQLParser::GrantOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrantOption(this);
}


antlrcpp::Any MySQLParser::GrantOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitGrantOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GrantOptionContext* MySQLParser::grantOption() {
  GrantOptionContext *_localctx = _tracker.createInstance<GrantOptionContext>(_ctx, getState());
  enterRule(_localctx, 538, MySQLParser::RuleGrantOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4503);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::GRANT_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4493);
        dynamic_cast<GrantOptionContext *>(_localctx)->option = match(MySQLParser::GRANT_SYMBOL);
        setState(4494);
        match(MySQLParser::OPTION_SYMBOL);
        break;
      }

      case MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4495);
        dynamic_cast<GrantOptionContext *>(_localctx)->option = match(MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL);
        setState(4496);
        ulong_number();
        break;
      }

      case MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(4497);
        dynamic_cast<GrantOptionContext *>(_localctx)->option = match(MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL);
        setState(4498);
        ulong_number();
        break;
      }

      case MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(4499);
        dynamic_cast<GrantOptionContext *>(_localctx)->option = match(MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL);
        setState(4500);
        ulong_number();
        break;
      }

      case MySQLParser::MAX_USER_CONNECTIONS_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(4501);
        dynamic_cast<GrantOptionContext *>(_localctx)->option = match(MySQLParser::MAX_USER_CONNECTIONS_SYMBOL);
        setState(4502);
        ulong_number();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetRoleContext ------------------------------------------------------------------

MySQLParser::SetRoleContext::SetRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SetRoleContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetRoleContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

std::vector<MySQLParser::RoleListContext *> MySQLParser::SetRoleContext::roleList() {
  return getRuleContexts<MySQLParser::RoleListContext>();
}

MySQLParser::RoleListContext* MySQLParser::SetRoleContext::roleList(size_t i) {
  return getRuleContext<MySQLParser::RoleListContext>(i);
}

tree::TerminalNode* MySQLParser::SetRoleContext::NONE_SYMBOL() {
  return getToken(MySQLParser::NONE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetRoleContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetRoleContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetRoleContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetRoleContext::EXCEPT_SYMBOL() {
  return getToken(MySQLParser::EXCEPT_SYMBOL, 0);
}


size_t MySQLParser::SetRoleContext::getRuleIndex() const {
  return MySQLParser::RuleSetRole;
}

void MySQLParser::SetRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetRole(this);
}

void MySQLParser::SetRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetRole(this);
}


antlrcpp::Any MySQLParser::SetRoleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSetRole(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SetRoleContext* MySQLParser::setRole() {
  SetRoleContext *_localctx = _tracker.createInstance<SetRoleContext>(_ctx, getState());
  enterRule(_localctx, 540, MySQLParser::RuleSetRole);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4528);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 549, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4505);
      match(MySQLParser::SET_SYMBOL);
      setState(4506);
      match(MySQLParser::ROLE_SYMBOL);
      setState(4507);
      roleList();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4508);
      match(MySQLParser::SET_SYMBOL);
      setState(4509);
      match(MySQLParser::ROLE_SYMBOL);
      setState(4510);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::NONE_SYMBOL || _la == MySQLParser::DEFAULT_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4511);
      match(MySQLParser::SET_SYMBOL);
      setState(4512);
      match(MySQLParser::DEFAULT_SYMBOL);
      setState(4513);
      match(MySQLParser::ROLE_SYMBOL);
      setState(4517);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 547, _ctx)) {
      case 1: {
        setState(4514);
        roleList();
        break;
      }

      case 2: {
        setState(4515);
        match(MySQLParser::NONE_SYMBOL);
        break;
      }

      case 3: {
        setState(4516);
        match(MySQLParser::ALL_SYMBOL);
        break;
      }

      }
      setState(4519);
      match(MySQLParser::TO_SYMBOL);
      setState(4520);
      roleList();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4521);
      match(MySQLParser::SET_SYMBOL);
      setState(4522);
      match(MySQLParser::ROLE_SYMBOL);
      setState(4523);
      match(MySQLParser::ALL_SYMBOL);
      setState(4526);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EXCEPT_SYMBOL) {
        setState(4524);
        match(MySQLParser::EXCEPT_SYMBOL);
        setState(4525);
        roleList();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleListContext ------------------------------------------------------------------

MySQLParser::RoleListContext::RoleListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::RoleContext *> MySQLParser::RoleListContext::role() {
  return getRuleContexts<MySQLParser::RoleContext>();
}

MySQLParser::RoleContext* MySQLParser::RoleListContext::role(size_t i) {
  return getRuleContext<MySQLParser::RoleContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::RoleListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::RoleListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::RoleListContext::getRuleIndex() const {
  return MySQLParser::RuleRoleList;
}

void MySQLParser::RoleListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleList(this);
}

void MySQLParser::RoleListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleList(this);
}


antlrcpp::Any MySQLParser::RoleListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRoleList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoleListContext* MySQLParser::roleList() {
  RoleListContext *_localctx = _tracker.createInstance<RoleListContext>(_ctx, getState());
  enterRule(_localctx, 542, MySQLParser::RuleRoleList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4530);
    role();
    setState(4535);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 550, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4531);
        match(MySQLParser::COMMA_SYMBOL);
        setState(4532);
        role(); 
      }
      setState(4537);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 550, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleContext ------------------------------------------------------------------

MySQLParser::RoleContext::RoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RoleIdentifierOrTextContext* MySQLParser::RoleContext::roleIdentifierOrText() {
  return getRuleContext<MySQLParser::RoleIdentifierOrTextContext>(0);
}

tree::TerminalNode* MySQLParser::RoleContext::AT_SIGN_SYMBOL() {
  return getToken(MySQLParser::AT_SIGN_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::RoleContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}


size_t MySQLParser::RoleContext::getRuleIndex() const {
  return MySQLParser::RuleRole;
}

void MySQLParser::RoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRole(this);
}

void MySQLParser::RoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRole(this);
}


antlrcpp::Any MySQLParser::RoleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRole(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoleContext* MySQLParser::role() {
  RoleContext *_localctx = _tracker.createInstance<RoleContext>(_ctx, getState());
  enterRule(_localctx, 544, MySQLParser::RuleRole);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4538);
    roleIdentifierOrText();
    setState(4541);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 551, _ctx)) {
    case 1: {
      setState(4539);
      match(MySQLParser::AT_SIGN_SYMBOL);
      setState(4540);
      textOrIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableAdministrationStatementContext ------------------------------------------------------------------

MySQLParser::TableAdministrationStatementContext::TableAdministrationStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TableAdministrationStatementContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

MySQLParser::TableRefListContext* MySQLParser::TableAdministrationStatementContext::tableRefList() {
  return getRuleContext<MySQLParser::TableRefListContext>(0);
}

tree::TerminalNode* MySQLParser::TableAdministrationStatementContext::ANALYZE_SYMBOL() {
  return getToken(MySQLParser::ANALYZE_SYMBOL, 0);
}

MySQLParser::NoWriteToBinLogContext* MySQLParser::TableAdministrationStatementContext::noWriteToBinLog() {
  return getRuleContext<MySQLParser::NoWriteToBinLogContext>(0);
}

tree::TerminalNode* MySQLParser::TableAdministrationStatementContext::CHECK_SYMBOL() {
  return getToken(MySQLParser::CHECK_SYMBOL, 0);
}

std::vector<MySQLParser::CheckOptionContext *> MySQLParser::TableAdministrationStatementContext::checkOption() {
  return getRuleContexts<MySQLParser::CheckOptionContext>();
}

MySQLParser::CheckOptionContext* MySQLParser::TableAdministrationStatementContext::checkOption(size_t i) {
  return getRuleContext<MySQLParser::CheckOptionContext>(i);
}

tree::TerminalNode* MySQLParser::TableAdministrationStatementContext::CHECKSUM_SYMBOL() {
  return getToken(MySQLParser::CHECKSUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TableAdministrationStatementContext::QUICK_SYMBOL() {
  return getToken(MySQLParser::QUICK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TableAdministrationStatementContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TableAdministrationStatementContext::OPTIMIZE_SYMBOL() {
  return getToken(MySQLParser::OPTIMIZE_SYMBOL, 0);
}

MySQLParser::HistogramContext* MySQLParser::TableAdministrationStatementContext::histogram() {
  return getRuleContext<MySQLParser::HistogramContext>(0);
}

tree::TerminalNode* MySQLParser::TableAdministrationStatementContext::REPAIR_SYMBOL() {
  return getToken(MySQLParser::REPAIR_SYMBOL, 0);
}

std::vector<MySQLParser::RepairTypeContext *> MySQLParser::TableAdministrationStatementContext::repairType() {
  return getRuleContexts<MySQLParser::RepairTypeContext>();
}

MySQLParser::RepairTypeContext* MySQLParser::TableAdministrationStatementContext::repairType(size_t i) {
  return getRuleContext<MySQLParser::RepairTypeContext>(i);
}


size_t MySQLParser::TableAdministrationStatementContext::getRuleIndex() const {
  return MySQLParser::RuleTableAdministrationStatement;
}

void MySQLParser::TableAdministrationStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableAdministrationStatement(this);
}

void MySQLParser::TableAdministrationStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableAdministrationStatement(this);
}


antlrcpp::Any MySQLParser::TableAdministrationStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTableAdministrationStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableAdministrationStatementContext* MySQLParser::tableAdministrationStatement() {
  TableAdministrationStatementContext *_localctx = _tracker.createInstance<TableAdministrationStatementContext>(_ctx, getState());
  enterRule(_localctx, 546, MySQLParser::RuleTableAdministrationStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4586);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ANALYZE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4543);
        dynamic_cast<TableAdministrationStatementContext *>(_localctx)->type = match(MySQLParser::ANALYZE_SYMBOL);
        setState(4545);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL) {
          setState(4544);
          noWriteToBinLog();
        }
        setState(4547);
        match(MySQLParser::TABLE_SYMBOL);
        setState(4548);
        tableRefList();
        break;
      }

      case MySQLParser::CHECK_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4549);
        dynamic_cast<TableAdministrationStatementContext *>(_localctx)->type = match(MySQLParser::CHECK_SYMBOL);
        setState(4550);
        match(MySQLParser::TABLE_SYMBOL);
        setState(4551);
        tableRefList();
        setState(4555);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (((((_la - 80) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 80)) & ((1ULL << (MySQLParser::CHANGED_SYMBOL - 80))
          | (1ULL << (MySQLParser::EXTENDED_SYMBOL - 80))
          | (1ULL << (MySQLParser::FAST_SYMBOL - 80)))) != 0) || _la == MySQLParser::MEDIUM_SYMBOL

        || _la == MySQLParser::QUICK_SYMBOL || _la == MySQLParser::FOR_SYMBOL) {
          setState(4552);
          checkOption();
          setState(4557);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MySQLParser::CHECKSUM_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(4558);
        dynamic_cast<TableAdministrationStatementContext *>(_localctx)->type = match(MySQLParser::CHECKSUM_SYMBOL);
        setState(4559);
        match(MySQLParser::TABLE_SYMBOL);
        setState(4560);
        tableRefList();
        setState(4562);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EXTENDED_SYMBOL || _la == MySQLParser::QUICK_SYMBOL) {
          setState(4561);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::EXTENDED_SYMBOL || _la == MySQLParser::QUICK_SYMBOL)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        break;
      }

      case MySQLParser::OPTIMIZE_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(4564);
        dynamic_cast<TableAdministrationStatementContext *>(_localctx)->type = match(MySQLParser::OPTIMIZE_SYMBOL);
        setState(4566);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL) {
          setState(4565);
          noWriteToBinLog();
        }
        setState(4568);
        match(MySQLParser::TABLE_SYMBOL);
        setState(4569);
        tableRefList();
        setState(4572);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 556, _ctx)) {
        case 1: {
          setState(4570);

          if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
          setState(4571);
          histogram();
          break;
        }

        }
        break;
      }

      case MySQLParser::REPAIR_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(4574);
        dynamic_cast<TableAdministrationStatementContext *>(_localctx)->type = match(MySQLParser::REPAIR_SYMBOL);
        setState(4576);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL) {
          setState(4575);
          noWriteToBinLog();
        }
        setState(4578);
        match(MySQLParser::TABLE_SYMBOL);
        setState(4579);
        tableRefList();
        setState(4583);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::EXTENDED_SYMBOL || _la == MySQLParser::QUICK_SYMBOL || _la == MySQLParser::USE_FRM_SYMBOL) {
          setState(4580);
          repairType();
          setState(4585);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HistogramContext ------------------------------------------------------------------

MySQLParser::HistogramContext::HistogramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::HistogramContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HistogramContext::HISTOGRAM_SYMBOL() {
  return getToken(MySQLParser::HISTOGRAM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HistogramContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::IdentifierListContext* MySQLParser::HistogramContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

tree::TerminalNode* MySQLParser::HistogramContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HistogramContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::HistogramContext::BUCKETS_SYMBOL() {
  return getToken(MySQLParser::BUCKETS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HistogramContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}


size_t MySQLParser::HistogramContext::getRuleIndex() const {
  return MySQLParser::RuleHistogram;
}

void MySQLParser::HistogramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHistogram(this);
}

void MySQLParser::HistogramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHistogram(this);
}


antlrcpp::Any MySQLParser::HistogramContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitHistogram(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::HistogramContext* MySQLParser::histogram() {
  HistogramContext *_localctx = _tracker.createInstance<HistogramContext>(_ctx, getState());
  enterRule(_localctx, 548, MySQLParser::RuleHistogram);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4601);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::UPDATE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4588);
        match(MySQLParser::UPDATE_SYMBOL);
        setState(4589);
        match(MySQLParser::HISTOGRAM_SYMBOL);
        setState(4590);
        match(MySQLParser::ON_SYMBOL);
        setState(4591);
        identifierList();
        setState(4595);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::WITH_SYMBOL) {
          setState(4592);
          match(MySQLParser::WITH_SYMBOL);
          setState(4593);
          match(MySQLParser::INT_NUMBER);
          setState(4594);
          match(MySQLParser::BUCKETS_SYMBOL);
        }
        break;
      }

      case MySQLParser::DROP_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4597);
        match(MySQLParser::DROP_SYMBOL);
        setState(4598);
        match(MySQLParser::HISTOGRAM_SYMBOL);
        setState(4599);
        match(MySQLParser::ON_SYMBOL);
        setState(4600);
        identifierList();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CheckOptionContext ------------------------------------------------------------------

MySQLParser::CheckOptionContext::CheckOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CheckOptionContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CheckOptionContext::UPGRADE_SYMBOL() {
  return getToken(MySQLParser::UPGRADE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CheckOptionContext::QUICK_SYMBOL() {
  return getToken(MySQLParser::QUICK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CheckOptionContext::FAST_SYMBOL() {
  return getToken(MySQLParser::FAST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CheckOptionContext::MEDIUM_SYMBOL() {
  return getToken(MySQLParser::MEDIUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CheckOptionContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CheckOptionContext::CHANGED_SYMBOL() {
  return getToken(MySQLParser::CHANGED_SYMBOL, 0);
}


size_t MySQLParser::CheckOptionContext::getRuleIndex() const {
  return MySQLParser::RuleCheckOption;
}

void MySQLParser::CheckOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCheckOption(this);
}

void MySQLParser::CheckOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCheckOption(this);
}


antlrcpp::Any MySQLParser::CheckOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCheckOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CheckOptionContext* MySQLParser::checkOption() {
  CheckOptionContext *_localctx = _tracker.createInstance<CheckOptionContext>(_ctx, getState());
  enterRule(_localctx, 550, MySQLParser::RuleCheckOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4606);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::FOR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4603);
        match(MySQLParser::FOR_SYMBOL);
        setState(4604);
        match(MySQLParser::UPGRADE_SYMBOL);
        break;
      }

      case MySQLParser::CHANGED_SYMBOL:
      case MySQLParser::EXTENDED_SYMBOL:
      case MySQLParser::FAST_SYMBOL:
      case MySQLParser::MEDIUM_SYMBOL:
      case MySQLParser::QUICK_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4605);
        _la = _input->LA(1);
        if (!(((((_la - 80) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 80)) & ((1ULL << (MySQLParser::CHANGED_SYMBOL - 80))
          | (1ULL << (MySQLParser::EXTENDED_SYMBOL - 80))
          | (1ULL << (MySQLParser::FAST_SYMBOL - 80)))) != 0) || _la == MySQLParser::MEDIUM_SYMBOL

        || _la == MySQLParser::QUICK_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RepairTypeContext ------------------------------------------------------------------

MySQLParser::RepairTypeContext::RepairTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RepairTypeContext::QUICK_SYMBOL() {
  return getToken(MySQLParser::QUICK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RepairTypeContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RepairTypeContext::USE_FRM_SYMBOL() {
  return getToken(MySQLParser::USE_FRM_SYMBOL, 0);
}


size_t MySQLParser::RepairTypeContext::getRuleIndex() const {
  return MySQLParser::RuleRepairType;
}

void MySQLParser::RepairTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRepairType(this);
}

void MySQLParser::RepairTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRepairType(this);
}


antlrcpp::Any MySQLParser::RepairTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRepairType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RepairTypeContext* MySQLParser::repairType() {
  RepairTypeContext *_localctx = _tracker.createInstance<RepairTypeContext>(_ctx, getState());
  enterRule(_localctx, 552, MySQLParser::RuleRepairType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4608);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::EXTENDED_SYMBOL || _la == MySQLParser::QUICK_SYMBOL || _la == MySQLParser::USE_FRM_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InstallUninstallStatmentContext ------------------------------------------------------------------

MySQLParser::InstallUninstallStatmentContext::InstallUninstallStatmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::InstallUninstallStatmentContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::InstallUninstallStatmentContext::SONAME_SYMBOL() {
  return getToken(MySQLParser::SONAME_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::InstallUninstallStatmentContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::InstallUninstallStatmentContext::INSTALL_SYMBOL() {
  return getToken(MySQLParser::INSTALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InstallUninstallStatmentContext::PLUGIN_SYMBOL() {
  return getToken(MySQLParser::PLUGIN_SYMBOL, 0);
}

MySQLParser::TextStringLiteralListContext* MySQLParser::InstallUninstallStatmentContext::textStringLiteralList() {
  return getRuleContext<MySQLParser::TextStringLiteralListContext>(0);
}

tree::TerminalNode* MySQLParser::InstallUninstallStatmentContext::COMPONENT_SYMBOL() {
  return getToken(MySQLParser::COMPONENT_SYMBOL, 0);
}

MySQLParser::PluginRefContext* MySQLParser::InstallUninstallStatmentContext::pluginRef() {
  return getRuleContext<MySQLParser::PluginRefContext>(0);
}

tree::TerminalNode* MySQLParser::InstallUninstallStatmentContext::UNINSTALL_SYMBOL() {
  return getToken(MySQLParser::UNINSTALL_SYMBOL, 0);
}

std::vector<MySQLParser::ComponentRefContext *> MySQLParser::InstallUninstallStatmentContext::componentRef() {
  return getRuleContexts<MySQLParser::ComponentRefContext>();
}

MySQLParser::ComponentRefContext* MySQLParser::InstallUninstallStatmentContext::componentRef(size_t i) {
  return getRuleContext<MySQLParser::ComponentRefContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::InstallUninstallStatmentContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::InstallUninstallStatmentContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::InstallUninstallStatmentContext::getRuleIndex() const {
  return MySQLParser::RuleInstallUninstallStatment;
}

void MySQLParser::InstallUninstallStatmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInstallUninstallStatment(this);
}

void MySQLParser::InstallUninstallStatmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInstallUninstallStatment(this);
}


antlrcpp::Any MySQLParser::InstallUninstallStatmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitInstallUninstallStatment(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InstallUninstallStatmentContext* MySQLParser::installUninstallStatment() {
  InstallUninstallStatmentContext *_localctx = _tracker.createInstance<InstallUninstallStatmentContext>(_ctx, getState());
  enterRule(_localctx, 554, MySQLParser::RuleInstallUninstallStatment);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4632);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 564, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4610);
      dynamic_cast<InstallUninstallStatmentContext *>(_localctx)->action = match(MySQLParser::INSTALL_SYMBOL);
      setState(4611);
      dynamic_cast<InstallUninstallStatmentContext *>(_localctx)->type = match(MySQLParser::PLUGIN_SYMBOL);
      setState(4612);
      identifier();
      setState(4613);
      match(MySQLParser::SONAME_SYMBOL);
      setState(4614);
      textStringLiteral();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4616);
      dynamic_cast<InstallUninstallStatmentContext *>(_localctx)->action = match(MySQLParser::INSTALL_SYMBOL);
      setState(4617);
      dynamic_cast<InstallUninstallStatmentContext *>(_localctx)->type = match(MySQLParser::COMPONENT_SYMBOL);
      setState(4618);
      textStringLiteralList();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4619);
      dynamic_cast<InstallUninstallStatmentContext *>(_localctx)->action = match(MySQLParser::UNINSTALL_SYMBOL);
      setState(4620);
      dynamic_cast<InstallUninstallStatmentContext *>(_localctx)->type = match(MySQLParser::PLUGIN_SYMBOL);
      setState(4621);
      pluginRef();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4622);
      dynamic_cast<InstallUninstallStatmentContext *>(_localctx)->action = match(MySQLParser::UNINSTALL_SYMBOL);
      setState(4623);
      dynamic_cast<InstallUninstallStatmentContext *>(_localctx)->type = match(MySQLParser::COMPONENT_SYMBOL);
      setState(4624);
      componentRef();
      setState(4629);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(4625);
        match(MySQLParser::COMMA_SYMBOL);
        setState(4626);
        componentRef();
        setState(4631);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetStatementContext ------------------------------------------------------------------

MySQLParser::SetStatementContext::SetStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SetStatementContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

MySQLParser::OptionValueNoOptionTypeContext* MySQLParser::SetStatementContext::optionValueNoOptionType() {
  return getRuleContext<MySQLParser::OptionValueNoOptionTypeContext>(0);
}

tree::TerminalNode* MySQLParser::SetStatementContext::TRANSACTION_SYMBOL() {
  return getToken(MySQLParser::TRANSACTION_SYMBOL, 0);
}

MySQLParser::SetTransactionCharacteristicContext* MySQLParser::SetStatementContext::setTransactionCharacteristic() {
  return getRuleContext<MySQLParser::SetTransactionCharacteristicContext>(0);
}

MySQLParser::OptionValueFollowingOptionTypeContext* MySQLParser::SetStatementContext::optionValueFollowingOptionType() {
  return getRuleContext<MySQLParser::OptionValueFollowingOptionTypeContext>(0);
}

MySQLParser::OptionTypeContext* MySQLParser::SetStatementContext::optionType() {
  return getRuleContext<MySQLParser::OptionTypeContext>(0);
}

tree::TerminalNode* MySQLParser::SetStatementContext::ONE_SHOT_SYMBOL() {
  return getToken(MySQLParser::ONE_SHOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetStatementContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

MySQLParser::OptionValueListContext* MySQLParser::SetStatementContext::optionValueList() {
  return getRuleContext<MySQLParser::OptionValueListContext>(0);
}


size_t MySQLParser::SetStatementContext::getRuleIndex() const {
  return MySQLParser::RuleSetStatement;
}

void MySQLParser::SetStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetStatement(this);
}

void MySQLParser::SetStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetStatement(this);
}


antlrcpp::Any MySQLParser::SetStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSetStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SetStatementContext* MySQLParser::setStatement() {
  SetStatementContext *_localctx = _tracker.createInstance<SetStatementContext>(_ctx, getState());
  enterRule(_localctx, 556, MySQLParser::RuleSetStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4634);
    match(MySQLParser::SET_SYMBOL);
    setState(4655);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 570, _ctx)) {
    case 1: {
      setState(4636);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 565, _ctx)) {
      case 1: {
        setState(4635);
        optionType();
        break;
      }

      }
      setState(4645);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 567, _ctx)) {
      case 1: {
        setState(4638);
        match(MySQLParser::TRANSACTION_SYMBOL);
        setState(4639);
        setTransactionCharacteristic();
        break;
      }

      case 2: {
        setState(4640);
        optionValueFollowingOptionType();
        setState(4643);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::COMMA_SYMBOL) {
          setState(4641);
          match(MySQLParser::COMMA_SYMBOL);
          setState(4642);
          optionValueList();
        }
        break;
      }

      }
      break;
    }

    case 2: {
      setState(4648);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 568, _ctx)) {
      case 1: {
        setState(4647);
        match(MySQLParser::ONE_SHOT_SYMBOL);
        break;
      }

      }
      setState(4650);
      optionValueNoOptionType();
      setState(4653);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(4651);
        match(MySQLParser::COMMA_SYMBOL);
        setState(4652);
        optionValueList();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionValueNoOptionTypeContext ------------------------------------------------------------------

MySQLParser::OptionValueNoOptionTypeContext::OptionValueNoOptionTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::InternalVariableNameContext* MySQLParser::OptionValueNoOptionTypeContext::internalVariableName() {
  return getRuleContext<MySQLParser::InternalVariableNameContext>(0);
}

MySQLParser::EqualContext* MySQLParser::OptionValueNoOptionTypeContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

MySQLParser::SetExprOrDefaultContext* MySQLParser::OptionValueNoOptionTypeContext::setExprOrDefault() {
  return getRuleContext<MySQLParser::SetExprOrDefaultContext>(0);
}

MySQLParser::CharsetClauseContext* MySQLParser::OptionValueNoOptionTypeContext::charsetClause() {
  return getRuleContext<MySQLParser::CharsetClauseContext>(0);
}

MySQLParser::UserVariableContext* MySQLParser::OptionValueNoOptionTypeContext::userVariable() {
  return getRuleContext<MySQLParser::UserVariableContext>(0);
}

MySQLParser::ExprContext* MySQLParser::OptionValueNoOptionTypeContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::SetSystemVariableContext* MySQLParser::OptionValueNoOptionTypeContext::setSystemVariable() {
  return getRuleContext<MySQLParser::SetSystemVariableContext>(0);
}

tree::TerminalNode* MySQLParser::OptionValueNoOptionTypeContext::NAMES_SYMBOL() {
  return getToken(MySQLParser::NAMES_SYMBOL, 0);
}

MySQLParser::CharsetNameContext* MySQLParser::OptionValueNoOptionTypeContext::charsetName() {
  return getRuleContext<MySQLParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySQLParser::OptionValueNoOptionTypeContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::CollateContext* MySQLParser::OptionValueNoOptionTypeContext::collate() {
  return getRuleContext<MySQLParser::CollateContext>(0);
}


size_t MySQLParser::OptionValueNoOptionTypeContext::getRuleIndex() const {
  return MySQLParser::RuleOptionValueNoOptionType;
}

void MySQLParser::OptionValueNoOptionTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionValueNoOptionType(this);
}

void MySQLParser::OptionValueNoOptionTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionValueNoOptionType(this);
}


antlrcpp::Any MySQLParser::OptionValueNoOptionTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitOptionValueNoOptionType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OptionValueNoOptionTypeContext* MySQLParser::optionValueNoOptionType() {
  OptionValueNoOptionTypeContext *_localctx = _tracker.createInstance<OptionValueNoOptionTypeContext>(_ctx, getState());
  enterRule(_localctx, 558, MySQLParser::RuleOptionValueNoOptionType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4682);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 573, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4657);
      internalVariableName();
      setState(4658);
      equal();
      setState(4659);
      setExprOrDefault();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4661);
      charsetClause();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4662);
      userVariable();
      setState(4663);
      equal();
      setState(4664);
      expr(0);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4666);
      setSystemVariable();
      setState(4667);
      equal();
      setState(4668);
      setExprOrDefault();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4670);
      match(MySQLParser::NAMES_SYMBOL);
      setState(4680);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 572, _ctx)) {
      case 1: {
        setState(4671);
        equal();
        setState(4672);
        expr(0);
        break;
      }

      case 2: {
        setState(4674);
        charsetName();
        setState(4676);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::COLLATE_SYMBOL) {
          setState(4675);
          collate();
        }
        break;
      }

      case 3: {
        setState(4678);

        if (!(serverVersion >= 80011)) throw FailedPredicateException(this, "serverVersion >= 80011");
        setState(4679);
        match(MySQLParser::DEFAULT_SYMBOL);
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetSystemVariableContext ------------------------------------------------------------------

MySQLParser::SetSystemVariableContext::SetSystemVariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SetSystemVariableContext::AT_AT_SIGN_SYMBOL() {
  return getToken(MySQLParser::AT_AT_SIGN_SYMBOL, 0);
}

MySQLParser::InternalVariableNameContext* MySQLParser::SetSystemVariableContext::internalVariableName() {
  return getRuleContext<MySQLParser::InternalVariableNameContext>(0);
}

MySQLParser::SetVarIdentTypeContext* MySQLParser::SetSystemVariableContext::setVarIdentType() {
  return getRuleContext<MySQLParser::SetVarIdentTypeContext>(0);
}


size_t MySQLParser::SetSystemVariableContext::getRuleIndex() const {
  return MySQLParser::RuleSetSystemVariable;
}

void MySQLParser::SetSystemVariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetSystemVariable(this);
}

void MySQLParser::SetSystemVariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetSystemVariable(this);
}


antlrcpp::Any MySQLParser::SetSystemVariableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSetSystemVariable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SetSystemVariableContext* MySQLParser::setSystemVariable() {
  SetSystemVariableContext *_localctx = _tracker.createInstance<SetSystemVariableContext>(_ctx, getState());
  enterRule(_localctx, 560, MySQLParser::RuleSetSystemVariable);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4684);
    match(MySQLParser::AT_AT_SIGN_SYMBOL);
    setState(4686);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 574, _ctx)) {
    case 1: {
      setState(4685);
      setVarIdentType();
      break;
    }

    }
    setState(4688);
    internalVariableName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionValueFollowingOptionTypeContext ------------------------------------------------------------------

MySQLParser::OptionValueFollowingOptionTypeContext::OptionValueFollowingOptionTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::InternalVariableNameContext* MySQLParser::OptionValueFollowingOptionTypeContext::internalVariableName() {
  return getRuleContext<MySQLParser::InternalVariableNameContext>(0);
}

MySQLParser::EqualContext* MySQLParser::OptionValueFollowingOptionTypeContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

MySQLParser::SetExprOrDefaultContext* MySQLParser::OptionValueFollowingOptionTypeContext::setExprOrDefault() {
  return getRuleContext<MySQLParser::SetExprOrDefaultContext>(0);
}


size_t MySQLParser::OptionValueFollowingOptionTypeContext::getRuleIndex() const {
  return MySQLParser::RuleOptionValueFollowingOptionType;
}

void MySQLParser::OptionValueFollowingOptionTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionValueFollowingOptionType(this);
}

void MySQLParser::OptionValueFollowingOptionTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionValueFollowingOptionType(this);
}


antlrcpp::Any MySQLParser::OptionValueFollowingOptionTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitOptionValueFollowingOptionType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OptionValueFollowingOptionTypeContext* MySQLParser::optionValueFollowingOptionType() {
  OptionValueFollowingOptionTypeContext *_localctx = _tracker.createInstance<OptionValueFollowingOptionTypeContext>(_ctx, getState());
  enterRule(_localctx, 562, MySQLParser::RuleOptionValueFollowingOptionType);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4690);
    internalVariableName();
    setState(4691);
    equal();
    setState(4692);
    setExprOrDefault();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetExprOrDefaultContext ------------------------------------------------------------------

MySQLParser::SetExprOrDefaultContext::SetExprOrDefaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ExprContext* MySQLParser::SetExprOrDefaultContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::SetExprOrDefaultContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetExprOrDefaultContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetExprOrDefaultContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetExprOrDefaultContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetExprOrDefaultContext::ROW_SYMBOL() {
  return getToken(MySQLParser::ROW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetExprOrDefaultContext::SYSTEM_SYMBOL() {
  return getToken(MySQLParser::SYSTEM_SYMBOL, 0);
}


size_t MySQLParser::SetExprOrDefaultContext::getRuleIndex() const {
  return MySQLParser::RuleSetExprOrDefault;
}

void MySQLParser::SetExprOrDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetExprOrDefault(this);
}

void MySQLParser::SetExprOrDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetExprOrDefault(this);
}


antlrcpp::Any MySQLParser::SetExprOrDefaultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSetExprOrDefault(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SetExprOrDefaultContext* MySQLParser::setExprOrDefault() {
  SetExprOrDefaultContext *_localctx = _tracker.createInstance<SetExprOrDefaultContext>(_ctx, getState());
  enterRule(_localctx, 564, MySQLParser::RuleSetExprOrDefault);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4698);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 575, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4694);
      expr(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4695);
      _la = _input->LA(1);
      if (!(((((_la - 427) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 427)) & ((1ULL << (MySQLParser::ALL_SYMBOL - 427))
        | (1ULL << (MySQLParser::BINARY_SYMBOL - 427))
        | (1ULL << (MySQLParser::DEFAULT_SYMBOL - 427)))) != 0) || _la == MySQLParser::ON_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4696);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(4697);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::ROW_SYMBOL || _la == MySQLParser::SYSTEM_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionValueListContext ------------------------------------------------------------------

MySQLParser::OptionValueListContext::OptionValueListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::OptionValueContext *> MySQLParser::OptionValueListContext::optionValue() {
  return getRuleContexts<MySQLParser::OptionValueContext>();
}

MySQLParser::OptionValueContext* MySQLParser::OptionValueListContext::optionValue(size_t i) {
  return getRuleContext<MySQLParser::OptionValueContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::OptionValueListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::OptionValueListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::OptionValueListContext::getRuleIndex() const {
  return MySQLParser::RuleOptionValueList;
}

void MySQLParser::OptionValueListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionValueList(this);
}

void MySQLParser::OptionValueListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionValueList(this);
}


antlrcpp::Any MySQLParser::OptionValueListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitOptionValueList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OptionValueListContext* MySQLParser::optionValueList() {
  OptionValueListContext *_localctx = _tracker.createInstance<OptionValueListContext>(_ctx, getState());
  enterRule(_localctx, 566, MySQLParser::RuleOptionValueList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4700);
    optionValue();
    setState(4705);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(4701);
      match(MySQLParser::COMMA_SYMBOL);
      setState(4702);
      optionValue();
      setState(4707);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionValueContext ------------------------------------------------------------------

MySQLParser::OptionValueContext::OptionValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::OptionTypeContext* MySQLParser::OptionValueContext::optionType() {
  return getRuleContext<MySQLParser::OptionTypeContext>(0);
}

MySQLParser::InternalVariableNameContext* MySQLParser::OptionValueContext::internalVariableName() {
  return getRuleContext<MySQLParser::InternalVariableNameContext>(0);
}

MySQLParser::EqualContext* MySQLParser::OptionValueContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

MySQLParser::SetExprOrDefaultContext* MySQLParser::OptionValueContext::setExprOrDefault() {
  return getRuleContext<MySQLParser::SetExprOrDefaultContext>(0);
}

MySQLParser::OptionValueNoOptionTypeContext* MySQLParser::OptionValueContext::optionValueNoOptionType() {
  return getRuleContext<MySQLParser::OptionValueNoOptionTypeContext>(0);
}


size_t MySQLParser::OptionValueContext::getRuleIndex() const {
  return MySQLParser::RuleOptionValue;
}

void MySQLParser::OptionValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionValue(this);
}

void MySQLParser::OptionValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionValue(this);
}


antlrcpp::Any MySQLParser::OptionValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitOptionValue(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OptionValueContext* MySQLParser::optionValue() {
  OptionValueContext *_localctx = _tracker.createInstance<OptionValueContext>(_ctx, getState());
  enterRule(_localctx, 568, MySQLParser::RuleOptionValue);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4714);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 577, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4708);
      optionType();
      setState(4709);
      internalVariableName();
      setState(4710);
      equal();
      setState(4711);
      setExprOrDefault();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4713);
      optionValueNoOptionType();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowStatementContext ------------------------------------------------------------------

MySQLParser::ShowStatementContext::ShowStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ShowStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::STATUS_SYMBOL() {
  return getToken(MySQLParser::STATUS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::ShowStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::EVENTS_SYMBOL() {
  return getToken(MySQLParser::EVENTS_SYMBOL, 0);
}

MySQLParser::FromOrInContext* MySQLParser::ShowStatementContext::fromOrIn() {
  return getRuleContext<MySQLParser::FromOrInContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::COUNT_SYMBOL() {
  return getToken(MySQLParser::COUNT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::MULT_OPERATOR() {
  return getToken(MySQLParser::MULT_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::CharsetContext* MySQLParser::ShowStatementContext::charset() {
  return getRuleContext<MySQLParser::CharsetContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

MySQLParser::UserContext* MySQLParser::ShowStatementContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

MySQLParser::UserListContext* MySQLParser::ShowStatementContext::userList() {
  return getRuleContext<MySQLParser::UserListContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::CODE_SYMBOL() {
  return getToken(MySQLParser::CODE_SYMBOL, 0);
}

MySQLParser::ProcedureRefContext* MySQLParser::ShowStatementContext::procedureRef() {
  return getRuleContext<MySQLParser::ProcedureRefContext>(0);
}

MySQLParser::FunctionRefContext* MySQLParser::ShowStatementContext::functionRef() {
  return getRuleContext<MySQLParser::FunctionRefContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::AUTHORS_SYMBOL() {
  return getToken(MySQLParser::AUTHORS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::DATABASES_SYMBOL() {
  return getToken(MySQLParser::DATABASES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::TRIGGERS_SYMBOL() {
  return getToken(MySQLParser::TRIGGERS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::OPEN_SYMBOL() {
  return getToken(MySQLParser::OPEN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::PLUGINS_SYMBOL() {
  return getToken(MySQLParser::PLUGINS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::MUTEX_SYMBOL() {
  return getToken(MySQLParser::MUTEX_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::LOGS_SYMBOL() {
  return getToken(MySQLParser::LOGS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::COLUMNS_SYMBOL() {
  return getToken(MySQLParser::COLUMNS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::SLAVE_SYMBOL() {
  return getToken(MySQLParser::SLAVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::ENGINES_SYMBOL() {
  return getToken(MySQLParser::ENGINES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::WARNINGS_SYMBOL() {
  return getToken(MySQLParser::WARNINGS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::ERRORS_SYMBOL() {
  return getToken(MySQLParser::ERRORS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::PROFILES_SYMBOL() {
  return getToken(MySQLParser::PROFILES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::PROFILE_SYMBOL() {
  return getToken(MySQLParser::PROFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::PROCESSLIST_SYMBOL() {
  return getToken(MySQLParser::PROCESSLIST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::COLLATION_SYMBOL() {
  return getToken(MySQLParser::COLLATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::CONTRIBUTORS_SYMBOL() {
  return getToken(MySQLParser::CONTRIBUTORS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::PRIVILEGES_SYMBOL() {
  return getToken(MySQLParser::PRIVILEGES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::GRANTS_SYMBOL() {
  return getToken(MySQLParser::GRANTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::PROCEDURE_SYMBOL() {
  return getToken(MySQLParser::PROCEDURE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::FUNCTION_SYMBOL() {
  return getToken(MySQLParser::FUNCTION_SYMBOL, 0);
}

MySQLParser::EngineRefContext* MySQLParser::ShowStatementContext::engineRef() {
  return getRuleContext<MySQLParser::EngineRefContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::HOSTS_SYMBOL() {
  return getToken(MySQLParser::HOSTS_SYMBOL, 0);
}

MySQLParser::NonBlockingContext* MySQLParser::ShowStatementContext::nonBlocking() {
  return getRuleContext<MySQLParser::NonBlockingContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::BINLOG_SYMBOL() {
  return getToken(MySQLParser::BINLOG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::RELAYLOG_SYMBOL() {
  return getToken(MySQLParser::RELAYLOG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::INDEXES_SYMBOL() {
  return getToken(MySQLParser::INDEXES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::KEYS_SYMBOL() {
  return getToken(MySQLParser::KEYS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::VARIABLES_SYMBOL() {
  return getToken(MySQLParser::VARIABLES_SYMBOL, 0);
}

MySQLParser::SchemaRefContext* MySQLParser::ShowStatementContext::schemaRef() {
  return getRuleContext<MySQLParser::SchemaRefContext>(0);
}

MySQLParser::EventRefContext* MySQLParser::ShowStatementContext::eventRef() {
  return getRuleContext<MySQLParser::EventRefContext>(0);
}

MySQLParser::TriggerRefContext* MySQLParser::ShowStatementContext::triggerRef() {
  return getRuleContext<MySQLParser::TriggerRefContext>(0);
}

MySQLParser::ViewRefContext* MySQLParser::ShowStatementContext::viewRef() {
  return getRuleContext<MySQLParser::ViewRefContext>(0);
}

MySQLParser::LikeOrWhereContext* MySQLParser::ShowStatementContext::likeOrWhere() {
  return getRuleContext<MySQLParser::LikeOrWhereContext>(0);
}

MySQLParser::ShowCommandTypeContext* MySQLParser::ShowStatementContext::showCommandType() {
  return getRuleContext<MySQLParser::ShowCommandTypeContext>(0);
}

MySQLParser::InDbContext* MySQLParser::ShowStatementContext::inDb() {
  return getRuleContext<MySQLParser::InDbContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::FULL_SYMBOL() {
  return getToken(MySQLParser::FULL_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::ShowStatementContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

MySQLParser::Ulonglong_numberContext* MySQLParser::ShowStatementContext::ulonglong_number() {
  return getRuleContext<MySQLParser::Ulonglong_numberContext>(0);
}

MySQLParser::LimitClauseContext* MySQLParser::ShowStatementContext::limitClause() {
  return getRuleContext<MySQLParser::LimitClauseContext>(0);
}

MySQLParser::ChannelContext* MySQLParser::ShowStatementContext::channel() {
  return getRuleContext<MySQLParser::ChannelContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}

MySQLParser::WhereClauseContext* MySQLParser::ShowStatementContext::whereClause() {
  return getRuleContext<MySQLParser::WhereClauseContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::STORAGE_SYMBOL() {
  return getToken(MySQLParser::STORAGE_SYMBOL, 0);
}

std::vector<MySQLParser::ProfileTypeContext *> MySQLParser::ShowStatementContext::profileType() {
  return getRuleContexts<MySQLParser::ProfileTypeContext>();
}

MySQLParser::ProfileTypeContext* MySQLParser::ShowStatementContext::profileType(size_t i) {
  return getRuleContext<MySQLParser::ProfileTypeContext>(i);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::QUERY_SYMBOL() {
  return getToken(MySQLParser::QUERY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

MySQLParser::OptionTypeContext* MySQLParser::ShowStatementContext::optionType() {
  return getRuleContext<MySQLParser::OptionTypeContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::DATABASE_SYMBOL() {
  return getToken(MySQLParser::DATABASE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::EVENT_SYMBOL() {
  return getToken(MySQLParser::EVENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::TRIGGER_SYMBOL() {
  return getToken(MySQLParser::TRIGGER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::VIEW_SYMBOL() {
  return getToken(MySQLParser::VIEW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

MySQLParser::IfNotExistsContext* MySQLParser::ShowStatementContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}

std::vector<tree::TerminalNode *> MySQLParser::ShowStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ShowStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowStatement;
}

void MySQLParser::ShowStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowStatement(this);
}

void MySQLParser::ShowStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowStatement(this);
}


antlrcpp::Any MySQLParser::ShowStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitShowStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowStatementContext* MySQLParser::showStatement() {
  ShowStatementContext *_localctx = _tracker.createInstance<ShowStatementContext>(_ctx, getState());
  enterRule(_localctx, 570, MySQLParser::RuleShowStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4716);
    match(MySQLParser::SHOW_SYMBOL);
    setState(4938);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 621, _ctx)) {
    case 1: {
      setState(4717);

      if (!(serverVersion < 50700)) throw FailedPredicateException(this, "serverVersion < 50700");
      setState(4718);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::AUTHORS_SYMBOL);
      break;
    }

    case 2: {
      setState(4719);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::DATABASES_SYMBOL);
      setState(4721);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(4720);
        likeOrWhere();
      }
      break;
    }

    case 3: {
      setState(4724);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 579, _ctx)) {
      case 1: {
        setState(4723);
        showCommandType();
        break;
      }

      }
      setState(4726);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::TABLES_SYMBOL);
      setState(4728);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FROM_SYMBOL

      || _la == MySQLParser::IN_SYMBOL) {
        setState(4727);
        inDb();
      }
      setState(4731);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(4730);
        likeOrWhere();
      }
      break;
    }

    case 4: {
      setState(4734);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FULL_SYMBOL) {
        setState(4733);
        match(MySQLParser::FULL_SYMBOL);
      }
      setState(4736);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::TRIGGERS_SYMBOL);
      setState(4738);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FROM_SYMBOL

      || _la == MySQLParser::IN_SYMBOL) {
        setState(4737);
        inDb();
      }
      setState(4741);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(4740);
        likeOrWhere();
      }
      break;
    }

    case 5: {
      setState(4743);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::EVENTS_SYMBOL);
      setState(4745);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FROM_SYMBOL

      || _la == MySQLParser::IN_SYMBOL) {
        setState(4744);
        inDb();
      }
      setState(4748);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(4747);
        likeOrWhere();
      }
      break;
    }

    case 6: {
      setState(4750);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::TABLE_SYMBOL);
      setState(4751);
      match(MySQLParser::STATUS_SYMBOL);
      setState(4753);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FROM_SYMBOL

      || _la == MySQLParser::IN_SYMBOL) {
        setState(4752);
        inDb();
      }
      setState(4756);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(4755);
        likeOrWhere();
      }
      break;
    }

    case 7: {
      setState(4758);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::OPEN_SYMBOL);
      setState(4759);
      match(MySQLParser::TABLES_SYMBOL);
      setState(4761);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FROM_SYMBOL

      || _la == MySQLParser::IN_SYMBOL) {
        setState(4760);
        inDb();
      }
      setState(4764);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(4763);
        likeOrWhere();
      }
      break;
    }

    case 8: {
      setState(4766);

      if (!(serverVersion >= 50500)) throw FailedPredicateException(this, "serverVersion >= 50500");
      setState(4767);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::PLUGINS_SYMBOL);
      break;
    }

    case 9: {
      setState(4768);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::ENGINE_SYMBOL);
      setState(4771);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 591, _ctx)) {
      case 1: {
        setState(4769);
        engineRef();
        break;
      }

      case 2: {
        setState(4770);
        match(MySQLParser::ALL_SYMBOL);
        break;
      }

      }
      setState(4773);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::LOGS_SYMBOL

      || _la == MySQLParser::MUTEX_SYMBOL || _la == MySQLParser::STATUS_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 10: {
      setState(4775);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 592, _ctx)) {
      case 1: {
        setState(4774);
        showCommandType();
        break;
      }

      }
      setState(4777);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::COLUMNS_SYMBOL);
      setState(4778);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::FROM_SYMBOL

      || _la == MySQLParser::IN_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4779);
      tableRef();
      setState(4781);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FROM_SYMBOL

      || _la == MySQLParser::IN_SYMBOL) {
        setState(4780);
        inDb();
      }
      setState(4784);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(4783);
        likeOrWhere();
      }
      break;
    }

    case 11: {
      setState(4786);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::MASTER_SYMBOL || _la == MySQLParser::BINARY_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4787);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::LOGS_SYMBOL);
      break;
    }

    case 12: {
      setState(4788);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::SLAVE_SYMBOL);
      setState(4795);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::HOSTS_SYMBOL: {
          setState(4789);
          match(MySQLParser::HOSTS_SYMBOL);
          break;
        }

        case MySQLParser::STATUS_SYMBOL: {
          setState(4790);
          match(MySQLParser::STATUS_SYMBOL);
          setState(4791);
          nonBlocking();
          setState(4793);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 595, _ctx)) {
          case 1: {
            setState(4792);
            channel();
            break;
          }

          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 13: {
      setState(4797);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::BINLOG_SYMBOL || _la == MySQLParser::RELAYLOG_SYMBOL)) {
        dynamic_cast<ShowStatementContext *>(_localctx)->value = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4798);
      match(MySQLParser::EVENTS_SYMBOL);
      setState(4801);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 597, _ctx)) {
      case 1: {
        setState(4799);
        match(MySQLParser::IN_SYMBOL);
        setState(4800);
        textString();
        break;
      }

      }
      setState(4805);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 598, _ctx)) {
      case 1: {
        setState(4803);
        match(MySQLParser::FROM_SYMBOL);
        setState(4804);
        ulonglong_number();
        break;
      }

      }
      setState(4808);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 599, _ctx)) {
      case 1: {
        setState(4807);
        limitClause();
        break;
      }

      }
      setState(4811);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 600, _ctx)) {
      case 1: {
        setState(4810);
        channel();
        break;
      }

      }
      break;
    }

    case 14: {
      setState(4815);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 601, _ctx)) {
      case 1: {
        setState(4813);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(4814);
        match(MySQLParser::EXTENDED_SYMBOL);
        break;
      }

      }
      setState(4817);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::INDEXES_SYMBOL || _la == MySQLParser::INDEX_SYMBOL

      || _la == MySQLParser::KEYS_SYMBOL)) {
        dynamic_cast<ShowStatementContext *>(_localctx)->value = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4818);
      fromOrIn();
      setState(4819);
      tableRef();
      setState(4821);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FROM_SYMBOL

      || _la == MySQLParser::IN_SYMBOL) {
        setState(4820);
        inDb();
      }
      setState(4824);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::WHERE_SYMBOL) {
        setState(4823);
        whereClause();
      }
      break;
    }

    case 15: {
      setState(4827);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::STORAGE_SYMBOL) {
        setState(4826);
        match(MySQLParser::STORAGE_SYMBOL);
      }
      setState(4829);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::ENGINES_SYMBOL);
      break;
    }

    case 16: {
      setState(4830);
      match(MySQLParser::COUNT_SYMBOL);
      setState(4831);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(4832);
      match(MySQLParser::MULT_OPERATOR);
      setState(4833);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(4834);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::ERRORS_SYMBOL || _la == MySQLParser::WARNINGS_SYMBOL)) {
        dynamic_cast<ShowStatementContext *>(_localctx)->value = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 17: {
      setState(4835);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::WARNINGS_SYMBOL);
      setState(4837);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIMIT_SYMBOL) {
        setState(4836);
        limitClause();
      }
      break;
    }

    case 18: {
      setState(4839);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::ERRORS_SYMBOL);
      setState(4841);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIMIT_SYMBOL) {
        setState(4840);
        limitClause();
      }
      break;
    }

    case 19: {
      setState(4843);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::PROFILES_SYMBOL);
      break;
    }

    case 20: {
      setState(4844);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::PROFILE_SYMBOL);
      setState(4853);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 73) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 73)) & ((1ULL << (MySQLParser::BLOCK_SYMBOL - 73))
        | (1ULL << (MySQLParser::CONTEXT_SYMBOL - 73))
        | (1ULL << (MySQLParser::CPU_SYMBOL - 73)))) != 0) || _la == MySQLParser::IPC_SYMBOL

      || _la == MySQLParser::MEMORY_SYMBOL || _la == MySQLParser::PAGE_SYMBOL || _la == MySQLParser::SOURCE_SYMBOL

      || _la == MySQLParser::SWAPS_SYMBOL || _la == MySQLParser::ALL_SYMBOL) {
        setState(4845);
        profileType();
        setState(4850);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::COMMA_SYMBOL) {
          setState(4846);
          match(MySQLParser::COMMA_SYMBOL);
          setState(4847);
          profileType();
          setState(4852);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
      }
      setState(4858);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FOR_SYMBOL) {
        setState(4855);
        match(MySQLParser::FOR_SYMBOL);
        setState(4856);
        match(MySQLParser::QUERY_SYMBOL);
        setState(4857);
        match(MySQLParser::INT_NUMBER);
      }
      setState(4861);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIMIT_SYMBOL) {
        setState(4860);
        limitClause();
      }
      break;
    }

    case 21: {
      setState(4864);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::GLOBAL_SYMBOL

      || _la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::SESSION_SYMBOL || _la == MySQLParser::PERSIST_SYMBOL

      || _la == MySQLParser::PERSIST_ONLY_SYMBOL) {
        setState(4863);
        optionType();
      }
      setState(4866);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::STATUS_SYMBOL

      || _la == MySQLParser::VARIABLES_SYMBOL)) {
        dynamic_cast<ShowStatementContext *>(_localctx)->value = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4868);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(4867);
        likeOrWhere();
      }
      break;
    }

    case 22: {
      setState(4871);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FULL_SYMBOL) {
        setState(4870);
        match(MySQLParser::FULL_SYMBOL);
      }
      setState(4873);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::PROCESSLIST_SYMBOL);
      break;
    }

    case 23: {
      setState(4874);
      charset();
      setState(4876);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(4875);
        likeOrWhere();
      }
      break;
    }

    case 24: {
      setState(4878);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::COLLATION_SYMBOL);
      setState(4880);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(4879);
        likeOrWhere();
      }
      break;
    }

    case 25: {
      setState(4882);

      if (!(serverVersion < 50700)) throw FailedPredicateException(this, "serverVersion < 50700");
      setState(4883);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::CONTRIBUTORS_SYMBOL);
      break;
    }

    case 26: {
      setState(4884);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::PRIVILEGES_SYMBOL);
      break;
    }

    case 27: {
      setState(4885);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::GRANTS_SYMBOL);
      setState(4888);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FOR_SYMBOL) {
        setState(4886);
        match(MySQLParser::FOR_SYMBOL);
        setState(4887);
        user();
      }
      break;
    }

    case 28: {
      setState(4890);

      if (!(serverVersion >= 50500)) throw FailedPredicateException(this, "serverVersion >= 50500");
      setState(4891);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::GRANTS_SYMBOL);
      setState(4892);
      match(MySQLParser::FOR_SYMBOL);
      setState(4893);
      user();
      setState(4894);
      match(MySQLParser::USING_SYMBOL);
      setState(4895);
      userList();
      break;
    }

    case 29: {
      setState(4897);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::MASTER_SYMBOL);
      setState(4898);
      match(MySQLParser::STATUS_SYMBOL);
      break;
    }

    case 30: {
      setState(4899);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::CREATE_SYMBOL);
      setState(4920);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 618, _ctx)) {
      case 1: {
        setState(4900);
        dynamic_cast<ShowStatementContext *>(_localctx)->object = match(MySQLParser::DATABASE_SYMBOL);
        setState(4902);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 617, _ctx)) {
        case 1: {
          setState(4901);
          ifNotExists();
          break;
        }

        }
        setState(4904);
        schemaRef();
        break;
      }

      case 2: {
        setState(4905);
        dynamic_cast<ShowStatementContext *>(_localctx)->object = match(MySQLParser::EVENT_SYMBOL);
        setState(4906);
        eventRef();
        break;
      }

      case 3: {
        setState(4907);
        dynamic_cast<ShowStatementContext *>(_localctx)->object = match(MySQLParser::FUNCTION_SYMBOL);
        setState(4908);
        functionRef();
        break;
      }

      case 4: {
        setState(4909);
        dynamic_cast<ShowStatementContext *>(_localctx)->object = match(MySQLParser::PROCEDURE_SYMBOL);
        setState(4910);
        procedureRef();
        break;
      }

      case 5: {
        setState(4911);
        dynamic_cast<ShowStatementContext *>(_localctx)->object = match(MySQLParser::TABLE_SYMBOL);
        setState(4912);
        tableRef();
        break;
      }

      case 6: {
        setState(4913);
        dynamic_cast<ShowStatementContext *>(_localctx)->object = match(MySQLParser::TRIGGER_SYMBOL);
        setState(4914);
        triggerRef();
        break;
      }

      case 7: {
        setState(4915);
        dynamic_cast<ShowStatementContext *>(_localctx)->object = match(MySQLParser::VIEW_SYMBOL);
        setState(4916);
        viewRef();
        break;
      }

      case 8: {
        setState(4917);

        if (!(serverVersion >= 50704)) throw FailedPredicateException(this, "serverVersion >= 50704");
        setState(4918);
        dynamic_cast<ShowStatementContext *>(_localctx)->object = match(MySQLParser::USER_SYMBOL);
        setState(4919);
        user();
        break;
      }

      }
      break;
    }

    case 31: {
      setState(4922);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::PROCEDURE_SYMBOL);
      setState(4923);
      match(MySQLParser::STATUS_SYMBOL);
      setState(4925);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(4924);
        likeOrWhere();
      }
      break;
    }

    case 32: {
      setState(4927);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::FUNCTION_SYMBOL);
      setState(4928);
      match(MySQLParser::STATUS_SYMBOL);
      setState(4930);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(4929);
        likeOrWhere();
      }
      break;
    }

    case 33: {
      setState(4932);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::PROCEDURE_SYMBOL);
      setState(4933);
      match(MySQLParser::CODE_SYMBOL);
      setState(4934);
      procedureRef();
      break;
    }

    case 34: {
      setState(4935);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::FUNCTION_SYMBOL);
      setState(4936);
      match(MySQLParser::CODE_SYMBOL);
      setState(4937);
      functionRef();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCommandTypeContext ------------------------------------------------------------------

MySQLParser::ShowCommandTypeContext::ShowCommandTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ShowCommandTypeContext::FULL_SYMBOL() {
  return getToken(MySQLParser::FULL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowCommandTypeContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}


size_t MySQLParser::ShowCommandTypeContext::getRuleIndex() const {
  return MySQLParser::RuleShowCommandType;
}

void MySQLParser::ShowCommandTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCommandType(this);
}

void MySQLParser::ShowCommandTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCommandType(this);
}


antlrcpp::Any MySQLParser::ShowCommandTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitShowCommandType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowCommandTypeContext* MySQLParser::showCommandType() {
  ShowCommandTypeContext *_localctx = _tracker.createInstance<ShowCommandTypeContext>(_ctx, getState());
  enterRule(_localctx, 572, MySQLParser::RuleShowCommandType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4946);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 623, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4940);
      match(MySQLParser::FULL_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4941);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(4942);
      match(MySQLParser::EXTENDED_SYMBOL);
      setState(4944);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FULL_SYMBOL) {
        setState(4943);
        match(MySQLParser::FULL_SYMBOL);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NonBlockingContext ------------------------------------------------------------------

MySQLParser::NonBlockingContext::NonBlockingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::NonBlockingContext::NONBLOCKING_SYMBOL() {
  return getToken(MySQLParser::NONBLOCKING_SYMBOL, 0);
}


size_t MySQLParser::NonBlockingContext::getRuleIndex() const {
  return MySQLParser::RuleNonBlocking;
}

void MySQLParser::NonBlockingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNonBlocking(this);
}

void MySQLParser::NonBlockingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNonBlocking(this);
}


antlrcpp::Any MySQLParser::NonBlockingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitNonBlocking(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::NonBlockingContext* MySQLParser::nonBlocking() {
  NonBlockingContext *_localctx = _tracker.createInstance<NonBlockingContext>(_ctx, getState());
  enterRule(_localctx, 574, MySQLParser::RuleNonBlocking);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4953);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 625, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4948);

      if (!(serverVersion >= 50700 && serverVersion < 50706)) throw FailedPredicateException(this, "serverVersion >= 50700 && serverVersion < 50706");
      setState(4950);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 624, _ctx)) {
      case 1: {
        setState(4949);
        match(MySQLParser::NONBLOCKING_SYMBOL);
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);

      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FromOrInContext ------------------------------------------------------------------

MySQLParser::FromOrInContext::FromOrInContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::FromOrInContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FromOrInContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}


size_t MySQLParser::FromOrInContext::getRuleIndex() const {
  return MySQLParser::RuleFromOrIn;
}

void MySQLParser::FromOrInContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromOrIn(this);
}

void MySQLParser::FromOrInContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromOrIn(this);
}


antlrcpp::Any MySQLParser::FromOrInContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFromOrIn(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FromOrInContext* MySQLParser::fromOrIn() {
  FromOrInContext *_localctx = _tracker.createInstance<FromOrInContext>(_ctx, getState());
  enterRule(_localctx, 576, MySQLParser::RuleFromOrIn);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4955);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::FROM_SYMBOL

    || _la == MySQLParser::IN_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InDbContext ------------------------------------------------------------------

MySQLParser::InDbContext::InDbContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::FromOrInContext* MySQLParser::InDbContext::fromOrIn() {
  return getRuleContext<MySQLParser::FromOrInContext>(0);
}

MySQLParser::IdentifierContext* MySQLParser::InDbContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::InDbContext::getRuleIndex() const {
  return MySQLParser::RuleInDb;
}

void MySQLParser::InDbContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInDb(this);
}

void MySQLParser::InDbContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInDb(this);
}


antlrcpp::Any MySQLParser::InDbContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitInDb(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InDbContext* MySQLParser::inDb() {
  InDbContext *_localctx = _tracker.createInstance<InDbContext>(_ctx, getState());
  enterRule(_localctx, 578, MySQLParser::RuleInDb);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4957);
    fromOrIn();
    setState(4958);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProfileTypeContext ------------------------------------------------------------------

MySQLParser::ProfileTypeContext::ProfileTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::BLOCK_SYMBOL() {
  return getToken(MySQLParser::BLOCK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::IO_SYMBOL() {
  return getToken(MySQLParser::IO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::CONTEXT_SYMBOL() {
  return getToken(MySQLParser::CONTEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::SWITCHES_SYMBOL() {
  return getToken(MySQLParser::SWITCHES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::PAGE_SYMBOL() {
  return getToken(MySQLParser::PAGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::FAULTS_SYMBOL() {
  return getToken(MySQLParser::FAULTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::CPU_SYMBOL() {
  return getToken(MySQLParser::CPU_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::IPC_SYMBOL() {
  return getToken(MySQLParser::IPC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::MEMORY_SYMBOL() {
  return getToken(MySQLParser::MEMORY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::SOURCE_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::SWAPS_SYMBOL() {
  return getToken(MySQLParser::SWAPS_SYMBOL, 0);
}


size_t MySQLParser::ProfileTypeContext::getRuleIndex() const {
  return MySQLParser::RuleProfileType;
}

void MySQLParser::ProfileTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProfileType(this);
}

void MySQLParser::ProfileTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProfileType(this);
}


antlrcpp::Any MySQLParser::ProfileTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitProfileType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ProfileTypeContext* MySQLParser::profileType() {
  ProfileTypeContext *_localctx = _tracker.createInstance<ProfileTypeContext>(_ctx, getState());
  enterRule(_localctx, 580, MySQLParser::RuleProfileType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4967);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::BLOCK_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4960);
        match(MySQLParser::BLOCK_SYMBOL);
        setState(4961);
        match(MySQLParser::IO_SYMBOL);
        break;
      }

      case MySQLParser::CONTEXT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4962);
        match(MySQLParser::CONTEXT_SYMBOL);
        setState(4963);
        match(MySQLParser::SWITCHES_SYMBOL);
        break;
      }

      case MySQLParser::PAGE_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(4964);
        match(MySQLParser::PAGE_SYMBOL);
        setState(4965);
        match(MySQLParser::FAULTS_SYMBOL);
        break;
      }

      case MySQLParser::CPU_SYMBOL:
      case MySQLParser::IPC_SYMBOL:
      case MySQLParser::MEMORY_SYMBOL:
      case MySQLParser::SOURCE_SYMBOL:
      case MySQLParser::SWAPS_SYMBOL:
      case MySQLParser::ALL_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(4966);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::CPU_SYMBOL

        || _la == MySQLParser::IPC_SYMBOL || _la == MySQLParser::MEMORY_SYMBOL || _la == MySQLParser::SOURCE_SYMBOL

        || _la == MySQLParser::SWAPS_SYMBOL || _la == MySQLParser::ALL_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OtherAdministrativeStatementContext ------------------------------------------------------------------

MySQLParser::OtherAdministrativeStatementContext::OtherAdministrativeStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextLiteralContext* MySQLParser::OtherAdministrativeStatementContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::BINLOG_SYMBOL() {
  return getToken(MySQLParser::BINLOG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

MySQLParser::KeyCacheListOrPartsContext* MySQLParser::OtherAdministrativeStatementContext::keyCacheListOrParts() {
  return getRuleContext<MySQLParser::KeyCacheListOrPartsContext>(0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::CACHE_SYMBOL() {
  return getToken(MySQLParser::CACHE_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::OtherAdministrativeStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::FLUSH_SYMBOL() {
  return getToken(MySQLParser::FLUSH_SYMBOL, 0);
}

MySQLParser::FlushTablesContext* MySQLParser::OtherAdministrativeStatementContext::flushTables() {
  return getRuleContext<MySQLParser::FlushTablesContext>(0);
}

std::vector<MySQLParser::FlushOptionContext *> MySQLParser::OtherAdministrativeStatementContext::flushOption() {
  return getRuleContexts<MySQLParser::FlushOptionContext>();
}

MySQLParser::FlushOptionContext* MySQLParser::OtherAdministrativeStatementContext::flushOption(size_t i) {
  return getRuleContext<MySQLParser::FlushOptionContext>(i);
}

MySQLParser::NoWriteToBinLogContext* MySQLParser::OtherAdministrativeStatementContext::noWriteToBinLog() {
  return getRuleContext<MySQLParser::NoWriteToBinLogContext>(0);
}

std::vector<tree::TerminalNode *> MySQLParser::OtherAdministrativeStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

MySQLParser::ExprContext* MySQLParser::OtherAdministrativeStatementContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::KILL_SYMBOL() {
  return getToken(MySQLParser::KILL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::CONNECTION_SYMBOL() {
  return getToken(MySQLParser::CONNECTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::QUERY_SYMBOL() {
  return getToken(MySQLParser::QUERY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

MySQLParser::PreloadTailContext* MySQLParser::OtherAdministrativeStatementContext::preloadTail() {
  return getRuleContext<MySQLParser::PreloadTailContext>(0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::LOAD_SYMBOL() {
  return getToken(MySQLParser::LOAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::SHUTDOWN_SYMBOL() {
  return getToken(MySQLParser::SHUTDOWN_SYMBOL, 0);
}


size_t MySQLParser::OtherAdministrativeStatementContext::getRuleIndex() const {
  return MySQLParser::RuleOtherAdministrativeStatement;
}

void MySQLParser::OtherAdministrativeStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOtherAdministrativeStatement(this);
}

void MySQLParser::OtherAdministrativeStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOtherAdministrativeStatement(this);
}


antlrcpp::Any MySQLParser::OtherAdministrativeStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitOtherAdministrativeStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OtherAdministrativeStatementContext* MySQLParser::otherAdministrativeStatement() {
  OtherAdministrativeStatementContext *_localctx = _tracker.createInstance<OtherAdministrativeStatementContext>(_ctx, getState());
  enterRule(_localctx, 582, MySQLParser::RuleOtherAdministrativeStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5006);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 632, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4969);
      dynamic_cast<OtherAdministrativeStatementContext *>(_localctx)->type = match(MySQLParser::BINLOG_SYMBOL);
      setState(4970);
      textLiteral();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4971);
      dynamic_cast<OtherAdministrativeStatementContext *>(_localctx)->type = match(MySQLParser::CACHE_SYMBOL);
      setState(4972);
      match(MySQLParser::INDEX_SYMBOL);
      setState(4973);
      keyCacheListOrParts();
      setState(4974);
      match(MySQLParser::IN_SYMBOL);
      setState(4977);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 627, _ctx)) {
      case 1: {
        setState(4975);
        identifier();
        break;
      }

      case 2: {
        setState(4976);
        match(MySQLParser::DEFAULT_SYMBOL);
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4979);
      dynamic_cast<OtherAdministrativeStatementContext *>(_localctx)->type = match(MySQLParser::FLUSH_SYMBOL);
      setState(4981);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 628, _ctx)) {
      case 1: {
        setState(4980);
        noWriteToBinLog();
        break;
      }

      }
      setState(4992);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 630, _ctx)) {
      case 1: {
        setState(4983);
        flushTables();
        break;
      }

      case 2: {
        setState(4984);
        flushOption();
        setState(4989);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::COMMA_SYMBOL) {
          setState(4985);
          match(MySQLParser::COMMA_SYMBOL);
          setState(4986);
          flushOption();
          setState(4991);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4994);
      dynamic_cast<OtherAdministrativeStatementContext *>(_localctx)->type = match(MySQLParser::KILL_SYMBOL);
      setState(4996);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 631, _ctx)) {
      case 1: {
        setState(4995);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::CONNECTION_SYMBOL || _la == MySQLParser::QUERY_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      }
      setState(4998);
      expr(0);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4999);
      dynamic_cast<OtherAdministrativeStatementContext *>(_localctx)->type = match(MySQLParser::LOAD_SYMBOL);
      setState(5000);
      match(MySQLParser::INDEX_SYMBOL);
      setState(5001);
      match(MySQLParser::INTO_SYMBOL);
      setState(5002);
      match(MySQLParser::CACHE_SYMBOL);
      setState(5003);
      preloadTail();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(5004);

      if (!(serverVersion >= 50709)) throw FailedPredicateException(this, "serverVersion >= 50709");
      setState(5005);
      dynamic_cast<OtherAdministrativeStatementContext *>(_localctx)->type = match(MySQLParser::SHUTDOWN_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyCacheListOrPartsContext ------------------------------------------------------------------

MySQLParser::KeyCacheListOrPartsContext::KeyCacheListOrPartsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::KeyCacheListContext* MySQLParser::KeyCacheListOrPartsContext::keyCacheList() {
  return getRuleContext<MySQLParser::KeyCacheListContext>(0);
}

MySQLParser::AssignToKeycachePartitionContext* MySQLParser::KeyCacheListOrPartsContext::assignToKeycachePartition() {
  return getRuleContext<MySQLParser::AssignToKeycachePartitionContext>(0);
}


size_t MySQLParser::KeyCacheListOrPartsContext::getRuleIndex() const {
  return MySQLParser::RuleKeyCacheListOrParts;
}

void MySQLParser::KeyCacheListOrPartsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyCacheListOrParts(this);
}

void MySQLParser::KeyCacheListOrPartsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyCacheListOrParts(this);
}


antlrcpp::Any MySQLParser::KeyCacheListOrPartsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitKeyCacheListOrParts(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::KeyCacheListOrPartsContext* MySQLParser::keyCacheListOrParts() {
  KeyCacheListOrPartsContext *_localctx = _tracker.createInstance<KeyCacheListOrPartsContext>(_ctx, getState());
  enterRule(_localctx, 584, MySQLParser::RuleKeyCacheListOrParts);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5010);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 633, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5008);
      keyCacheList();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5009);
      assignToKeycachePartition();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyCacheListContext ------------------------------------------------------------------

MySQLParser::KeyCacheListContext::KeyCacheListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::AssignToKeycacheContext *> MySQLParser::KeyCacheListContext::assignToKeycache() {
  return getRuleContexts<MySQLParser::AssignToKeycacheContext>();
}

MySQLParser::AssignToKeycacheContext* MySQLParser::KeyCacheListContext::assignToKeycache(size_t i) {
  return getRuleContext<MySQLParser::AssignToKeycacheContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::KeyCacheListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::KeyCacheListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::KeyCacheListContext::getRuleIndex() const {
  return MySQLParser::RuleKeyCacheList;
}

void MySQLParser::KeyCacheListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyCacheList(this);
}

void MySQLParser::KeyCacheListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyCacheList(this);
}


antlrcpp::Any MySQLParser::KeyCacheListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitKeyCacheList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::KeyCacheListContext* MySQLParser::keyCacheList() {
  KeyCacheListContext *_localctx = _tracker.createInstance<KeyCacheListContext>(_ctx, getState());
  enterRule(_localctx, 586, MySQLParser::RuleKeyCacheList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5012);
    assignToKeycache();
    setState(5017);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(5013);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5014);
      assignToKeycache();
      setState(5019);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignToKeycacheContext ------------------------------------------------------------------

MySQLParser::AssignToKeycacheContext::AssignToKeycacheContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext* MySQLParser::AssignToKeycacheContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::CacheKeyListContext* MySQLParser::AssignToKeycacheContext::cacheKeyList() {
  return getRuleContext<MySQLParser::CacheKeyListContext>(0);
}


size_t MySQLParser::AssignToKeycacheContext::getRuleIndex() const {
  return MySQLParser::RuleAssignToKeycache;
}

void MySQLParser::AssignToKeycacheContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignToKeycache(this);
}

void MySQLParser::AssignToKeycacheContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignToKeycache(this);
}


antlrcpp::Any MySQLParser::AssignToKeycacheContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAssignToKeycache(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AssignToKeycacheContext* MySQLParser::assignToKeycache() {
  AssignToKeycacheContext *_localctx = _tracker.createInstance<AssignToKeycacheContext>(_ctx, getState());
  enterRule(_localctx, 588, MySQLParser::RuleAssignToKeycache);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5020);
    tableRef();
    setState(5022);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::INDEX_SYMBOL

    || _la == MySQLParser::KEY_SYMBOL) {
      setState(5021);
      cacheKeyList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignToKeycachePartitionContext ------------------------------------------------------------------

MySQLParser::AssignToKeycachePartitionContext::AssignToKeycachePartitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext* MySQLParser::AssignToKeycachePartitionContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode* MySQLParser::AssignToKeycachePartitionContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AssignToKeycachePartitionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::AllOrPartitionNameListContext* MySQLParser::AssignToKeycachePartitionContext::allOrPartitionNameList() {
  return getRuleContext<MySQLParser::AllOrPartitionNameListContext>(0);
}

tree::TerminalNode* MySQLParser::AssignToKeycachePartitionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::CacheKeyListContext* MySQLParser::AssignToKeycachePartitionContext::cacheKeyList() {
  return getRuleContext<MySQLParser::CacheKeyListContext>(0);
}


size_t MySQLParser::AssignToKeycachePartitionContext::getRuleIndex() const {
  return MySQLParser::RuleAssignToKeycachePartition;
}

void MySQLParser::AssignToKeycachePartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignToKeycachePartition(this);
}

void MySQLParser::AssignToKeycachePartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignToKeycachePartition(this);
}


antlrcpp::Any MySQLParser::AssignToKeycachePartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAssignToKeycachePartition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AssignToKeycachePartitionContext* MySQLParser::assignToKeycachePartition() {
  AssignToKeycachePartitionContext *_localctx = _tracker.createInstance<AssignToKeycachePartitionContext>(_ctx, getState());
  enterRule(_localctx, 590, MySQLParser::RuleAssignToKeycachePartition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5024);
    tableRef();
    setState(5025);
    match(MySQLParser::PARTITION_SYMBOL);
    setState(5026);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(5027);
    allOrPartitionNameList();
    setState(5028);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
    setState(5030);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::INDEX_SYMBOL

    || _la == MySQLParser::KEY_SYMBOL) {
      setState(5029);
      cacheKeyList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CacheKeyListContext ------------------------------------------------------------------

MySQLParser::CacheKeyListContext::CacheKeyListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::KeyOrIndexContext* MySQLParser::CacheKeyListContext::keyOrIndex() {
  return getRuleContext<MySQLParser::KeyOrIndexContext>(0);
}

tree::TerminalNode* MySQLParser::CacheKeyListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CacheKeyListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::KeyUsageListContext* MySQLParser::CacheKeyListContext::keyUsageList() {
  return getRuleContext<MySQLParser::KeyUsageListContext>(0);
}


size_t MySQLParser::CacheKeyListContext::getRuleIndex() const {
  return MySQLParser::RuleCacheKeyList;
}

void MySQLParser::CacheKeyListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCacheKeyList(this);
}

void MySQLParser::CacheKeyListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCacheKeyList(this);
}


antlrcpp::Any MySQLParser::CacheKeyListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCacheKeyList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CacheKeyListContext* MySQLParser::cacheKeyList() {
  CacheKeyListContext *_localctx = _tracker.createInstance<CacheKeyListContext>(_ctx, getState());
  enterRule(_localctx, 592, MySQLParser::RuleCacheKeyList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5032);
    keyOrIndex();
    setState(5033);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(5035);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 637, _ctx)) {
    case 1: {
      setState(5034);
      keyUsageList();
      break;
    }

    }
    setState(5037);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyUsageElementContext ------------------------------------------------------------------

MySQLParser::KeyUsageElementContext::KeyUsageElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::KeyUsageElementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::KeyUsageElementContext::PRIMARY_SYMBOL() {
  return getToken(MySQLParser::PRIMARY_SYMBOL, 0);
}


size_t MySQLParser::KeyUsageElementContext::getRuleIndex() const {
  return MySQLParser::RuleKeyUsageElement;
}

void MySQLParser::KeyUsageElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyUsageElement(this);
}

void MySQLParser::KeyUsageElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyUsageElement(this);
}


antlrcpp::Any MySQLParser::KeyUsageElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitKeyUsageElement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::KeyUsageElementContext* MySQLParser::keyUsageElement() {
  KeyUsageElementContext *_localctx = _tracker.createInstance<KeyUsageElementContext>(_ctx, getState());
  enterRule(_localctx, 594, MySQLParser::RuleKeyUsageElement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5041);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 638, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5039);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5040);
      match(MySQLParser::PRIMARY_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyUsageListContext ------------------------------------------------------------------

MySQLParser::KeyUsageListContext::KeyUsageListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::KeyUsageElementContext *> MySQLParser::KeyUsageListContext::keyUsageElement() {
  return getRuleContexts<MySQLParser::KeyUsageElementContext>();
}

MySQLParser::KeyUsageElementContext* MySQLParser::KeyUsageListContext::keyUsageElement(size_t i) {
  return getRuleContext<MySQLParser::KeyUsageElementContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::KeyUsageListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::KeyUsageListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::KeyUsageListContext::getRuleIndex() const {
  return MySQLParser::RuleKeyUsageList;
}

void MySQLParser::KeyUsageListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyUsageList(this);
}

void MySQLParser::KeyUsageListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyUsageList(this);
}


antlrcpp::Any MySQLParser::KeyUsageListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitKeyUsageList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::KeyUsageListContext* MySQLParser::keyUsageList() {
  KeyUsageListContext *_localctx = _tracker.createInstance<KeyUsageListContext>(_ctx, getState());
  enterRule(_localctx, 596, MySQLParser::RuleKeyUsageList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5043);
    keyUsageElement();
    setState(5048);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(5044);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5045);
      keyUsageElement();
      setState(5050);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FlushOptionContext ------------------------------------------------------------------

MySQLParser::FlushOptionContext::FlushOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::FlushOptionContext::DES_KEY_FILE_SYMBOL() {
  return getToken(MySQLParser::DES_KEY_FILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushOptionContext::HOSTS_SYMBOL() {
  return getToken(MySQLParser::HOSTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushOptionContext::PRIVILEGES_SYMBOL() {
  return getToken(MySQLParser::PRIVILEGES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushOptionContext::STATUS_SYMBOL() {
  return getToken(MySQLParser::STATUS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushOptionContext::USER_RESOURCES_SYMBOL() {
  return getToken(MySQLParser::USER_RESOURCES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushOptionContext::LOGS_SYMBOL() {
  return getToken(MySQLParser::LOGS_SYMBOL, 0);
}

MySQLParser::LogTypeContext* MySQLParser::FlushOptionContext::logType() {
  return getRuleContext<MySQLParser::LogTypeContext>(0);
}

tree::TerminalNode* MySQLParser::FlushOptionContext::RELAY_SYMBOL() {
  return getToken(MySQLParser::RELAY_SYMBOL, 0);
}

MySQLParser::ChannelContext* MySQLParser::FlushOptionContext::channel() {
  return getRuleContext<MySQLParser::ChannelContext>(0);
}

tree::TerminalNode* MySQLParser::FlushOptionContext::CACHE_SYMBOL() {
  return getToken(MySQLParser::CACHE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushOptionContext::QUERY_SYMBOL() {
  return getToken(MySQLParser::QUERY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushOptionContext::OPTIMIZER_COSTS_SYMBOL() {
  return getToken(MySQLParser::OPTIMIZER_COSTS_SYMBOL, 0);
}


size_t MySQLParser::FlushOptionContext::getRuleIndex() const {
  return MySQLParser::RuleFlushOption;
}

void MySQLParser::FlushOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFlushOption(this);
}

void MySQLParser::FlushOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFlushOption(this);
}


antlrcpp::Any MySQLParser::FlushOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFlushOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FlushOptionContext* MySQLParser::flushOption() {
  FlushOptionContext *_localctx = _tracker.createInstance<FlushOptionContext>(_ctx, getState());
  enterRule(_localctx, 598, MySQLParser::RuleFlushOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5066);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 642, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5051);
      dynamic_cast<FlushOptionContext *>(_localctx)->option = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::DES_KEY_FILE_SYMBOL

      || _la == MySQLParser::HOSTS_SYMBOL || _la == MySQLParser::PRIVILEGES_SYMBOL || _la == MySQLParser::STATUS_SYMBOL

      || _la == MySQLParser::USER_RESOURCES_SYMBOL)) {
        dynamic_cast<FlushOptionContext *>(_localctx)->option = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5053);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & ((1ULL << (MySQLParser::ENGINE_SYMBOL - 128))
        | (1ULL << (MySQLParser::ERROR_SYMBOL - 128))
        | (1ULL << (MySQLParser::GENERAL_SYMBOL - 128)))) != 0) || _la == MySQLParser::SLOW_SYMBOL || _la == MySQLParser::BINARY_SYMBOL) {
        setState(5052);
        logType();
      }
      setState(5055);
      dynamic_cast<FlushOptionContext *>(_localctx)->option = match(MySQLParser::LOGS_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5056);
      dynamic_cast<FlushOptionContext *>(_localctx)->option = match(MySQLParser::RELAY_SYMBOL);
      setState(5057);
      match(MySQLParser::LOGS_SYMBOL);
      setState(5059);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 641, _ctx)) {
      case 1: {
        setState(5058);
        channel();
        break;
      }

      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5061);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(5062);
      dynamic_cast<FlushOptionContext *>(_localctx)->option = match(MySQLParser::QUERY_SYMBOL);
      setState(5063);
      match(MySQLParser::CACHE_SYMBOL);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5064);

      if (!(serverVersion >= 50706)) throw FailedPredicateException(this, "serverVersion >= 50706");
      setState(5065);
      dynamic_cast<FlushOptionContext *>(_localctx)->option = match(MySQLParser::OPTIMIZER_COSTS_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogTypeContext ------------------------------------------------------------------

MySQLParser::LogTypeContext::LogTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LogTypeContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LogTypeContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LogTypeContext::ERROR_SYMBOL() {
  return getToken(MySQLParser::ERROR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LogTypeContext::GENERAL_SYMBOL() {
  return getToken(MySQLParser::GENERAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LogTypeContext::SLOW_SYMBOL() {
  return getToken(MySQLParser::SLOW_SYMBOL, 0);
}


size_t MySQLParser::LogTypeContext::getRuleIndex() const {
  return MySQLParser::RuleLogType;
}

void MySQLParser::LogTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogType(this);
}

void MySQLParser::LogTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogType(this);
}


antlrcpp::Any MySQLParser::LogTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLogType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LogTypeContext* MySQLParser::logType() {
  LogTypeContext *_localctx = _tracker.createInstance<LogTypeContext>(_ctx, getState());
  enterRule(_localctx, 600, MySQLParser::RuleLogType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5068);
    _la = _input->LA(1);
    if (!(((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (MySQLParser::ENGINE_SYMBOL - 128))
      | (1ULL << (MySQLParser::ERROR_SYMBOL - 128))
      | (1ULL << (MySQLParser::GENERAL_SYMBOL - 128)))) != 0) || _la == MySQLParser::SLOW_SYMBOL || _la == MySQLParser::BINARY_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FlushTablesContext ------------------------------------------------------------------

MySQLParser::FlushTablesContext::FlushTablesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::FlushTablesContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushTablesContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushTablesContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushTablesContext::READ_SYMBOL() {
  return getToken(MySQLParser::READ_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushTablesContext::LOCK_SYMBOL() {
  return getToken(MySQLParser::LOCK_SYMBOL, 0);
}

MySQLParser::IdentifierListContext* MySQLParser::FlushTablesContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

MySQLParser::FlushTablesOptionsContext* MySQLParser::FlushTablesContext::flushTablesOptions() {
  return getRuleContext<MySQLParser::FlushTablesOptionsContext>(0);
}


size_t MySQLParser::FlushTablesContext::getRuleIndex() const {
  return MySQLParser::RuleFlushTables;
}

void MySQLParser::FlushTablesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFlushTables(this);
}

void MySQLParser::FlushTablesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFlushTables(this);
}


antlrcpp::Any MySQLParser::FlushTablesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFlushTables(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FlushTablesContext* MySQLParser::flushTables() {
  FlushTablesContext *_localctx = _tracker.createInstance<FlushTablesContext>(_ctx, getState());
  enterRule(_localctx, 602, MySQLParser::RuleFlushTables);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5070);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::TABLES_SYMBOL || _la == MySQLParser::TABLE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5078);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 644, _ctx)) {
    case 1: {
      setState(5071);
      match(MySQLParser::WITH_SYMBOL);
      setState(5072);
      match(MySQLParser::READ_SYMBOL);
      setState(5073);
      match(MySQLParser::LOCK_SYMBOL);
      break;
    }

    case 2: {
      setState(5074);
      identifierList();
      setState(5076);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 643, _ctx)) {
      case 1: {
        setState(5075);
        flushTablesOptions();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FlushTablesOptionsContext ------------------------------------------------------------------

MySQLParser::FlushTablesOptionsContext::FlushTablesOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::FlushTablesOptionsContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushTablesOptionsContext::EXPORT_SYMBOL() {
  return getToken(MySQLParser::EXPORT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushTablesOptionsContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushTablesOptionsContext::READ_SYMBOL() {
  return getToken(MySQLParser::READ_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushTablesOptionsContext::LOCK_SYMBOL() {
  return getToken(MySQLParser::LOCK_SYMBOL, 0);
}


size_t MySQLParser::FlushTablesOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleFlushTablesOptions;
}

void MySQLParser::FlushTablesOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFlushTablesOptions(this);
}

void MySQLParser::FlushTablesOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFlushTablesOptions(this);
}


antlrcpp::Any MySQLParser::FlushTablesOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFlushTablesOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FlushTablesOptionsContext* MySQLParser::flushTablesOptions() {
  FlushTablesOptionsContext *_localctx = _tracker.createInstance<FlushTablesOptionsContext>(_ctx, getState());
  enterRule(_localctx, 604, MySQLParser::RuleFlushTablesOptions);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5086);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 645, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5080);

      if (!(serverVersion >= 50606)) throw FailedPredicateException(this, "serverVersion >= 50606");
      setState(5081);
      match(MySQLParser::FOR_SYMBOL);
      setState(5082);
      match(MySQLParser::EXPORT_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5083);
      match(MySQLParser::WITH_SYMBOL);
      setState(5084);
      match(MySQLParser::READ_SYMBOL);
      setState(5085);
      match(MySQLParser::LOCK_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PreloadTailContext ------------------------------------------------------------------

MySQLParser::PreloadTailContext::PreloadTailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext* MySQLParser::PreloadTailContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::AdminPartitionContext* MySQLParser::PreloadTailContext::adminPartition() {
  return getRuleContext<MySQLParser::AdminPartitionContext>(0);
}

MySQLParser::CacheKeyListContext* MySQLParser::PreloadTailContext::cacheKeyList() {
  return getRuleContext<MySQLParser::CacheKeyListContext>(0);
}

tree::TerminalNode* MySQLParser::PreloadTailContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PreloadTailContext::LEAVES_SYMBOL() {
  return getToken(MySQLParser::LEAVES_SYMBOL, 0);
}

MySQLParser::PreloadListContext* MySQLParser::PreloadTailContext::preloadList() {
  return getRuleContext<MySQLParser::PreloadListContext>(0);
}


size_t MySQLParser::PreloadTailContext::getRuleIndex() const {
  return MySQLParser::RulePreloadTail;
}

void MySQLParser::PreloadTailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreloadTail(this);
}

void MySQLParser::PreloadTailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreloadTail(this);
}


antlrcpp::Any MySQLParser::PreloadTailContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPreloadTail(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PreloadTailContext* MySQLParser::preloadTail() {
  PreloadTailContext *_localctx = _tracker.createInstance<PreloadTailContext>(_ctx, getState());
  enterRule(_localctx, 606, MySQLParser::RulePreloadTail);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5098);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 648, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5088);
      tableRef();
      setState(5089);
      adminPartition();
      setState(5091);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::INDEX_SYMBOL

      || _la == MySQLParser::KEY_SYMBOL) {
        setState(5090);
        cacheKeyList();
      }
      setState(5095);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::IGNORE_SYMBOL) {
        setState(5093);
        match(MySQLParser::IGNORE_SYMBOL);
        setState(5094);
        match(MySQLParser::LEAVES_SYMBOL);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5097);
      preloadList();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PreloadListContext ------------------------------------------------------------------

MySQLParser::PreloadListContext::PreloadListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::PreloadKeysContext *> MySQLParser::PreloadListContext::preloadKeys() {
  return getRuleContexts<MySQLParser::PreloadKeysContext>();
}

MySQLParser::PreloadKeysContext* MySQLParser::PreloadListContext::preloadKeys(size_t i) {
  return getRuleContext<MySQLParser::PreloadKeysContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::PreloadListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::PreloadListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::PreloadListContext::getRuleIndex() const {
  return MySQLParser::RulePreloadList;
}

void MySQLParser::PreloadListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreloadList(this);
}

void MySQLParser::PreloadListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreloadList(this);
}


antlrcpp::Any MySQLParser::PreloadListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPreloadList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PreloadListContext* MySQLParser::preloadList() {
  PreloadListContext *_localctx = _tracker.createInstance<PreloadListContext>(_ctx, getState());
  enterRule(_localctx, 608, MySQLParser::RulePreloadList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5100);
    preloadKeys();
    setState(5105);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(5101);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5102);
      preloadKeys();
      setState(5107);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PreloadKeysContext ------------------------------------------------------------------

MySQLParser::PreloadKeysContext::PreloadKeysContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext* MySQLParser::PreloadKeysContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::CacheKeyListContext* MySQLParser::PreloadKeysContext::cacheKeyList() {
  return getRuleContext<MySQLParser::CacheKeyListContext>(0);
}

tree::TerminalNode* MySQLParser::PreloadKeysContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PreloadKeysContext::LEAVES_SYMBOL() {
  return getToken(MySQLParser::LEAVES_SYMBOL, 0);
}


size_t MySQLParser::PreloadKeysContext::getRuleIndex() const {
  return MySQLParser::RulePreloadKeys;
}

void MySQLParser::PreloadKeysContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreloadKeys(this);
}

void MySQLParser::PreloadKeysContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreloadKeys(this);
}


antlrcpp::Any MySQLParser::PreloadKeysContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPreloadKeys(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PreloadKeysContext* MySQLParser::preloadKeys() {
  PreloadKeysContext *_localctx = _tracker.createInstance<PreloadKeysContext>(_ctx, getState());
  enterRule(_localctx, 610, MySQLParser::RulePreloadKeys);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5108);
    tableRef();
    setState(5110);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::INDEX_SYMBOL

    || _la == MySQLParser::KEY_SYMBOL) {
      setState(5109);
      cacheKeyList();
    }
    setState(5114);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::IGNORE_SYMBOL) {
      setState(5112);
      match(MySQLParser::IGNORE_SYMBOL);
      setState(5113);
      match(MySQLParser::LEAVES_SYMBOL);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AdminPartitionContext ------------------------------------------------------------------

MySQLParser::AdminPartitionContext::AdminPartitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AdminPartitionContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AdminPartitionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::AllOrPartitionNameListContext* MySQLParser::AdminPartitionContext::allOrPartitionNameList() {
  return getRuleContext<MySQLParser::AllOrPartitionNameListContext>(0);
}

tree::TerminalNode* MySQLParser::AdminPartitionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::AdminPartitionContext::getRuleIndex() const {
  return MySQLParser::RuleAdminPartition;
}

void MySQLParser::AdminPartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAdminPartition(this);
}

void MySQLParser::AdminPartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAdminPartition(this);
}


antlrcpp::Any MySQLParser::AdminPartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAdminPartition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AdminPartitionContext* MySQLParser::adminPartition() {
  AdminPartitionContext *_localctx = _tracker.createInstance<AdminPartitionContext>(_ctx, getState());
  enterRule(_localctx, 612, MySQLParser::RuleAdminPartition);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5116);

    if (!(serverVersion >= 50500)) throw FailedPredicateException(this, "serverVersion >= 50500");

    setState(5117);
    match(MySQLParser::PARTITION_SYMBOL);
    setState(5118);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(5119);
    allOrPartitionNameList();
    setState(5120);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResourceGroupManagementContext ------------------------------------------------------------------

MySQLParser::ResourceGroupManagementContext::ResourceGroupManagementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CreateResourceGroupContext* MySQLParser::ResourceGroupManagementContext::createResourceGroup() {
  return getRuleContext<MySQLParser::CreateResourceGroupContext>(0);
}

MySQLParser::AlterResourceGroupContext* MySQLParser::ResourceGroupManagementContext::alterResourceGroup() {
  return getRuleContext<MySQLParser::AlterResourceGroupContext>(0);
}

MySQLParser::SetResourceGroupContext* MySQLParser::ResourceGroupManagementContext::setResourceGroup() {
  return getRuleContext<MySQLParser::SetResourceGroupContext>(0);
}

MySQLParser::DropResourceGroupContext* MySQLParser::ResourceGroupManagementContext::dropResourceGroup() {
  return getRuleContext<MySQLParser::DropResourceGroupContext>(0);
}


size_t MySQLParser::ResourceGroupManagementContext::getRuleIndex() const {
  return MySQLParser::RuleResourceGroupManagement;
}

void MySQLParser::ResourceGroupManagementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResourceGroupManagement(this);
}

void MySQLParser::ResourceGroupManagementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResourceGroupManagement(this);
}


antlrcpp::Any MySQLParser::ResourceGroupManagementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitResourceGroupManagement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ResourceGroupManagementContext* MySQLParser::resourceGroupManagement() {
  ResourceGroupManagementContext *_localctx = _tracker.createInstance<ResourceGroupManagementContext>(_ctx, getState());
  enterRule(_localctx, 614, MySQLParser::RuleResourceGroupManagement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5126);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CREATE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(5122);
        createResourceGroup();
        break;
      }

      case MySQLParser::ALTER_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(5123);
        alterResourceGroup();
        break;
      }

      case MySQLParser::SET_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(5124);
        setResourceGroup();
        break;
      }

      case MySQLParser::DROP_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(5125);
        dropResourceGroup();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateResourceGroupContext ------------------------------------------------------------------

MySQLParser::CreateResourceGroupContext::CreateResourceGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateResourceGroupContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateResourceGroupContext::RESOURCE_SYMBOL() {
  return getToken(MySQLParser::RESOURCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateResourceGroupContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::CreateResourceGroupContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::CreateResourceGroupContext::TYPE_SYMBOL() {
  return getToken(MySQLParser::TYPE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateResourceGroupContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateResourceGroupContext::SYSTEM_SYMBOL() {
  return getToken(MySQLParser::SYSTEM_SYMBOL, 0);
}

MySQLParser::EqualContext* MySQLParser::CreateResourceGroupContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

MySQLParser::ResourceGroupVcpuListContext* MySQLParser::CreateResourceGroupContext::resourceGroupVcpuList() {
  return getRuleContext<MySQLParser::ResourceGroupVcpuListContext>(0);
}

MySQLParser::ResourceGroupPriorityContext* MySQLParser::CreateResourceGroupContext::resourceGroupPriority() {
  return getRuleContext<MySQLParser::ResourceGroupPriorityContext>(0);
}

MySQLParser::ResourceGroupEnableDisableContext* MySQLParser::CreateResourceGroupContext::resourceGroupEnableDisable() {
  return getRuleContext<MySQLParser::ResourceGroupEnableDisableContext>(0);
}


size_t MySQLParser::CreateResourceGroupContext::getRuleIndex() const {
  return MySQLParser::RuleCreateResourceGroup;
}

void MySQLParser::CreateResourceGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateResourceGroup(this);
}

void MySQLParser::CreateResourceGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateResourceGroup(this);
}


antlrcpp::Any MySQLParser::CreateResourceGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateResourceGroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateResourceGroupContext* MySQLParser::createResourceGroup() {
  CreateResourceGroupContext *_localctx = _tracker.createInstance<CreateResourceGroupContext>(_ctx, getState());
  enterRule(_localctx, 616, MySQLParser::RuleCreateResourceGroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5128);
    match(MySQLParser::CREATE_SYMBOL);
    setState(5129);
    match(MySQLParser::RESOURCE_SYMBOL);
    setState(5130);
    match(MySQLParser::GROUP_SYMBOL);
    setState(5131);
    identifier();
    setState(5132);
    match(MySQLParser::TYPE_SYMBOL);
    setState(5134);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::EQUAL_OPERATOR

    || _la == MySQLParser::ASSIGN_OPERATOR) {
      setState(5133);
      equal();
    }
    setState(5136);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::USER_SYMBOL || _la == MySQLParser::SYSTEM_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5138);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::VCPU_SYMBOL) {
      setState(5137);
      resourceGroupVcpuList();
    }
    setState(5141);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::THREAD_PRIORITY_SYMBOL) {
      setState(5140);
      resourceGroupPriority();
    }
    setState(5144);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DISABLE_SYMBOL

    || _la == MySQLParser::ENABLE_SYMBOL) {
      setState(5143);
      resourceGroupEnableDisable();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResourceGroupVcpuListContext ------------------------------------------------------------------

MySQLParser::ResourceGroupVcpuListContext::ResourceGroupVcpuListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ResourceGroupVcpuListContext::VCPU_SYMBOL() {
  return getToken(MySQLParser::VCPU_SYMBOL, 0);
}

std::vector<MySQLParser::VcpuNumOrRangeContext *> MySQLParser::ResourceGroupVcpuListContext::vcpuNumOrRange() {
  return getRuleContexts<MySQLParser::VcpuNumOrRangeContext>();
}

MySQLParser::VcpuNumOrRangeContext* MySQLParser::ResourceGroupVcpuListContext::vcpuNumOrRange(size_t i) {
  return getRuleContext<MySQLParser::VcpuNumOrRangeContext>(i);
}

MySQLParser::EqualContext* MySQLParser::ResourceGroupVcpuListContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

std::vector<tree::TerminalNode *> MySQLParser::ResourceGroupVcpuListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ResourceGroupVcpuListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ResourceGroupVcpuListContext::getRuleIndex() const {
  return MySQLParser::RuleResourceGroupVcpuList;
}

void MySQLParser::ResourceGroupVcpuListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResourceGroupVcpuList(this);
}

void MySQLParser::ResourceGroupVcpuListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResourceGroupVcpuList(this);
}


antlrcpp::Any MySQLParser::ResourceGroupVcpuListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitResourceGroupVcpuList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ResourceGroupVcpuListContext* MySQLParser::resourceGroupVcpuList() {
  ResourceGroupVcpuListContext *_localctx = _tracker.createInstance<ResourceGroupVcpuListContext>(_ctx, getState());
  enterRule(_localctx, 618, MySQLParser::RuleResourceGroupVcpuList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5146);
    match(MySQLParser::VCPU_SYMBOL);
    setState(5148);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::EQUAL_OPERATOR

    || _la == MySQLParser::ASSIGN_OPERATOR) {
      setState(5147);
      equal();
    }
    setState(5150);
    vcpuNumOrRange();
    setState(5157);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::INT_NUMBER

    || _la == MySQLParser::COMMA_SYMBOL) {
      setState(5152);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(5151);
        match(MySQLParser::COMMA_SYMBOL);
      }
      setState(5154);
      vcpuNumOrRange();
      setState(5159);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VcpuNumOrRangeContext ------------------------------------------------------------------

MySQLParser::VcpuNumOrRangeContext::VcpuNumOrRangeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::VcpuNumOrRangeContext::INT_NUMBER() {
  return getTokens(MySQLParser::INT_NUMBER);
}

tree::TerminalNode* MySQLParser::VcpuNumOrRangeContext::INT_NUMBER(size_t i) {
  return getToken(MySQLParser::INT_NUMBER, i);
}

tree::TerminalNode* MySQLParser::VcpuNumOrRangeContext::MINUS_OPERATOR() {
  return getToken(MySQLParser::MINUS_OPERATOR, 0);
}


size_t MySQLParser::VcpuNumOrRangeContext::getRuleIndex() const {
  return MySQLParser::RuleVcpuNumOrRange;
}

void MySQLParser::VcpuNumOrRangeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVcpuNumOrRange(this);
}

void MySQLParser::VcpuNumOrRangeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVcpuNumOrRange(this);
}


antlrcpp::Any MySQLParser::VcpuNumOrRangeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitVcpuNumOrRange(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::VcpuNumOrRangeContext* MySQLParser::vcpuNumOrRange() {
  VcpuNumOrRangeContext *_localctx = _tracker.createInstance<VcpuNumOrRangeContext>(_ctx, getState());
  enterRule(_localctx, 620, MySQLParser::RuleVcpuNumOrRange);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5160);
    match(MySQLParser::INT_NUMBER);
    setState(5163);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::MINUS_OPERATOR) {
      setState(5161);
      match(MySQLParser::MINUS_OPERATOR);
      setState(5162);
      match(MySQLParser::INT_NUMBER);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResourceGroupPriorityContext ------------------------------------------------------------------

MySQLParser::ResourceGroupPriorityContext::ResourceGroupPriorityContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ResourceGroupPriorityContext::THREAD_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::THREAD_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ResourceGroupPriorityContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

MySQLParser::EqualContext* MySQLParser::ResourceGroupPriorityContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}


size_t MySQLParser::ResourceGroupPriorityContext::getRuleIndex() const {
  return MySQLParser::RuleResourceGroupPriority;
}

void MySQLParser::ResourceGroupPriorityContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResourceGroupPriority(this);
}

void MySQLParser::ResourceGroupPriorityContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResourceGroupPriority(this);
}


antlrcpp::Any MySQLParser::ResourceGroupPriorityContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitResourceGroupPriority(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ResourceGroupPriorityContext* MySQLParser::resourceGroupPriority() {
  ResourceGroupPriorityContext *_localctx = _tracker.createInstance<ResourceGroupPriorityContext>(_ctx, getState());
  enterRule(_localctx, 622, MySQLParser::RuleResourceGroupPriority);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5165);
    match(MySQLParser::THREAD_PRIORITY_SYMBOL);
    setState(5167);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::EQUAL_OPERATOR

    || _la == MySQLParser::ASSIGN_OPERATOR) {
      setState(5166);
      equal();
    }
    setState(5169);
    match(MySQLParser::INT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResourceGroupEnableDisableContext ------------------------------------------------------------------

MySQLParser::ResourceGroupEnableDisableContext::ResourceGroupEnableDisableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ResourceGroupEnableDisableContext::ENABLE_SYMBOL() {
  return getToken(MySQLParser::ENABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ResourceGroupEnableDisableContext::DISABLE_SYMBOL() {
  return getToken(MySQLParser::DISABLE_SYMBOL, 0);
}


size_t MySQLParser::ResourceGroupEnableDisableContext::getRuleIndex() const {
  return MySQLParser::RuleResourceGroupEnableDisable;
}

void MySQLParser::ResourceGroupEnableDisableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResourceGroupEnableDisable(this);
}

void MySQLParser::ResourceGroupEnableDisableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResourceGroupEnableDisable(this);
}


antlrcpp::Any MySQLParser::ResourceGroupEnableDisableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitResourceGroupEnableDisable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ResourceGroupEnableDisableContext* MySQLParser::resourceGroupEnableDisable() {
  ResourceGroupEnableDisableContext *_localctx = _tracker.createInstance<ResourceGroupEnableDisableContext>(_ctx, getState());
  enterRule(_localctx, 624, MySQLParser::RuleResourceGroupEnableDisable);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5171);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DISABLE_SYMBOL

    || _la == MySQLParser::ENABLE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterResourceGroupContext ------------------------------------------------------------------

MySQLParser::AlterResourceGroupContext::AlterResourceGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterResourceGroupContext::ALTER_SYMBOL() {
  return getToken(MySQLParser::ALTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterResourceGroupContext::RESOURCE_SYMBOL() {
  return getToken(MySQLParser::RESOURCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterResourceGroupContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::ResourceGroupRefContext* MySQLParser::AlterResourceGroupContext::resourceGroupRef() {
  return getRuleContext<MySQLParser::ResourceGroupRefContext>(0);
}

MySQLParser::ResourceGroupVcpuListContext* MySQLParser::AlterResourceGroupContext::resourceGroupVcpuList() {
  return getRuleContext<MySQLParser::ResourceGroupVcpuListContext>(0);
}

MySQLParser::ResourceGroupPriorityContext* MySQLParser::AlterResourceGroupContext::resourceGroupPriority() {
  return getRuleContext<MySQLParser::ResourceGroupPriorityContext>(0);
}

MySQLParser::ResourceGroupEnableDisableContext* MySQLParser::AlterResourceGroupContext::resourceGroupEnableDisable() {
  return getRuleContext<MySQLParser::ResourceGroupEnableDisableContext>(0);
}

tree::TerminalNode* MySQLParser::AlterResourceGroupContext::FORCE_SYMBOL() {
  return getToken(MySQLParser::FORCE_SYMBOL, 0);
}


size_t MySQLParser::AlterResourceGroupContext::getRuleIndex() const {
  return MySQLParser::RuleAlterResourceGroup;
}

void MySQLParser::AlterResourceGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterResourceGroup(this);
}

void MySQLParser::AlterResourceGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterResourceGroup(this);
}


antlrcpp::Any MySQLParser::AlterResourceGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterResourceGroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterResourceGroupContext* MySQLParser::alterResourceGroup() {
  AlterResourceGroupContext *_localctx = _tracker.createInstance<AlterResourceGroupContext>(_ctx, getState());
  enterRule(_localctx, 626, MySQLParser::RuleAlterResourceGroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5173);
    match(MySQLParser::ALTER_SYMBOL);
    setState(5174);
    match(MySQLParser::RESOURCE_SYMBOL);
    setState(5175);
    match(MySQLParser::GROUP_SYMBOL);
    setState(5176);
    resourceGroupRef();
    setState(5178);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::VCPU_SYMBOL) {
      setState(5177);
      resourceGroupVcpuList();
    }
    setState(5181);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::THREAD_PRIORITY_SYMBOL) {
      setState(5180);
      resourceGroupPriority();
    }
    setState(5184);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DISABLE_SYMBOL

    || _la == MySQLParser::ENABLE_SYMBOL) {
      setState(5183);
      resourceGroupEnableDisable();
    }
    setState(5187);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FORCE_SYMBOL) {
      setState(5186);
      match(MySQLParser::FORCE_SYMBOL);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetResourceGroupContext ------------------------------------------------------------------

MySQLParser::SetResourceGroupContext::SetResourceGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SetResourceGroupContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetResourceGroupContext::RESOURCE_SYMBOL() {
  return getToken(MySQLParser::RESOURCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetResourceGroupContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::SetResourceGroupContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::SetResourceGroupContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

MySQLParser::ThreadIdListContext* MySQLParser::SetResourceGroupContext::threadIdList() {
  return getRuleContext<MySQLParser::ThreadIdListContext>(0);
}


size_t MySQLParser::SetResourceGroupContext::getRuleIndex() const {
  return MySQLParser::RuleSetResourceGroup;
}

void MySQLParser::SetResourceGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetResourceGroup(this);
}

void MySQLParser::SetResourceGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetResourceGroup(this);
}


antlrcpp::Any MySQLParser::SetResourceGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSetResourceGroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SetResourceGroupContext* MySQLParser::setResourceGroup() {
  SetResourceGroupContext *_localctx = _tracker.createInstance<SetResourceGroupContext>(_ctx, getState());
  enterRule(_localctx, 628, MySQLParser::RuleSetResourceGroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5189);
    match(MySQLParser::SET_SYMBOL);
    setState(5190);
    match(MySQLParser::RESOURCE_SYMBOL);
    setState(5191);
    match(MySQLParser::GROUP_SYMBOL);
    setState(5192);
    identifier();
    setState(5195);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FOR_SYMBOL) {
      setState(5193);
      match(MySQLParser::FOR_SYMBOL);
      setState(5194);
      threadIdList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThreadIdListContext ------------------------------------------------------------------

MySQLParser::ThreadIdListContext::ThreadIdListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::Real_ulong_numberContext *> MySQLParser::ThreadIdListContext::real_ulong_number() {
  return getRuleContexts<MySQLParser::Real_ulong_numberContext>();
}

MySQLParser::Real_ulong_numberContext* MySQLParser::ThreadIdListContext::real_ulong_number(size_t i) {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ThreadIdListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ThreadIdListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ThreadIdListContext::getRuleIndex() const {
  return MySQLParser::RuleThreadIdList;
}

void MySQLParser::ThreadIdListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThreadIdList(this);
}

void MySQLParser::ThreadIdListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThreadIdList(this);
}


antlrcpp::Any MySQLParser::ThreadIdListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitThreadIdList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ThreadIdListContext* MySQLParser::threadIdList() {
  ThreadIdListContext *_localctx = _tracker.createInstance<ThreadIdListContext>(_ctx, getState());
  enterRule(_localctx, 630, MySQLParser::RuleThreadIdList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5197);
    real_ulong_number();
    setState(5204);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 380) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 380)) & ((1ULL << (MySQLParser::INT_NUMBER - 380))
      | (1ULL << (MySQLParser::LONG_NUMBER - 380))
      | (1ULL << (MySQLParser::ULONGLONG_NUMBER - 380))
      | (1ULL << (MySQLParser::COMMA_SYMBOL - 380))
      | (1ULL << (MySQLParser::HEX_NUMBER - 380)))) != 0)) {
      setState(5199);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(5198);
        match(MySQLParser::COMMA_SYMBOL);
      }
      setState(5201);
      real_ulong_number();
      setState(5206);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropResourceGroupContext ------------------------------------------------------------------

MySQLParser::DropResourceGroupContext::DropResourceGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropResourceGroupContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DropResourceGroupContext::RESOURCE_SYMBOL() {
  return getToken(MySQLParser::RESOURCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DropResourceGroupContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::ResourceGroupRefContext* MySQLParser::DropResourceGroupContext::resourceGroupRef() {
  return getRuleContext<MySQLParser::ResourceGroupRefContext>(0);
}

tree::TerminalNode* MySQLParser::DropResourceGroupContext::FORCE_SYMBOL() {
  return getToken(MySQLParser::FORCE_SYMBOL, 0);
}


size_t MySQLParser::DropResourceGroupContext::getRuleIndex() const {
  return MySQLParser::RuleDropResourceGroup;
}

void MySQLParser::DropResourceGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropResourceGroup(this);
}

void MySQLParser::DropResourceGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropResourceGroup(this);
}


antlrcpp::Any MySQLParser::DropResourceGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDropResourceGroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropResourceGroupContext* MySQLParser::dropResourceGroup() {
  DropResourceGroupContext *_localctx = _tracker.createInstance<DropResourceGroupContext>(_ctx, getState());
  enterRule(_localctx, 632, MySQLParser::RuleDropResourceGroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5207);
    match(MySQLParser::DROP_SYMBOL);
    setState(5208);
    match(MySQLParser::RESOURCE_SYMBOL);
    setState(5209);
    match(MySQLParser::GROUP_SYMBOL);
    setState(5210);
    resourceGroupRef();
    setState(5212);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FORCE_SYMBOL) {
      setState(5211);
      match(MySQLParser::FORCE_SYMBOL);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UtilityStatementContext ------------------------------------------------------------------

MySQLParser::UtilityStatementContext::UtilityStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::DescribeCommandContext* MySQLParser::UtilityStatementContext::describeCommand() {
  return getRuleContext<MySQLParser::DescribeCommandContext>(0);
}

MySQLParser::ExplainCommandContext* MySQLParser::UtilityStatementContext::explainCommand() {
  return getRuleContext<MySQLParser::ExplainCommandContext>(0);
}

MySQLParser::HelpCommandContext* MySQLParser::UtilityStatementContext::helpCommand() {
  return getRuleContext<MySQLParser::HelpCommandContext>(0);
}

MySQLParser::UseCommandContext* MySQLParser::UtilityStatementContext::useCommand() {
  return getRuleContext<MySQLParser::UseCommandContext>(0);
}

MySQLParser::RestartServerContext* MySQLParser::UtilityStatementContext::restartServer() {
  return getRuleContext<MySQLParser::RestartServerContext>(0);
}


size_t MySQLParser::UtilityStatementContext::getRuleIndex() const {
  return MySQLParser::RuleUtilityStatement;
}

void MySQLParser::UtilityStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUtilityStatement(this);
}

void MySQLParser::UtilityStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUtilityStatement(this);
}


antlrcpp::Any MySQLParser::UtilityStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitUtilityStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UtilityStatementContext* MySQLParser::utilityStatement() {
  UtilityStatementContext *_localctx = _tracker.createInstance<UtilityStatementContext>(_ctx, getState());
  enterRule(_localctx, 634, MySQLParser::RuleUtilityStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5220);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 670, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5214);
      describeCommand();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5215);
      explainCommand();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5216);
      helpCommand();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5217);
      useCommand();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5218);

      if (!(serverVersion >= 80011)) throw FailedPredicateException(this, "serverVersion >= 80011");
      setState(5219);
      restartServer();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DescribeCommandContext ------------------------------------------------------------------

MySQLParser::DescribeCommandContext::DescribeCommandContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext* MySQLParser::DescribeCommandContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode* MySQLParser::DescribeCommandContext::DESCRIBE_SYMBOL() {
  return getToken(MySQLParser::DESCRIBE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DescribeCommandContext::DESC_SYMBOL() {
  return getToken(MySQLParser::DESC_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::DescribeCommandContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

MySQLParser::ColumnRefContext* MySQLParser::DescribeCommandContext::columnRef() {
  return getRuleContext<MySQLParser::ColumnRefContext>(0);
}


size_t MySQLParser::DescribeCommandContext::getRuleIndex() const {
  return MySQLParser::RuleDescribeCommand;
}

void MySQLParser::DescribeCommandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDescribeCommand(this);
}

void MySQLParser::DescribeCommandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDescribeCommand(this);
}


antlrcpp::Any MySQLParser::DescribeCommandContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDescribeCommand(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DescribeCommandContext* MySQLParser::describeCommand() {
  DescribeCommandContext *_localctx = _tracker.createInstance<DescribeCommandContext>(_ctx, getState());
  enterRule(_localctx, 636, MySQLParser::RuleDescribeCommand);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5222);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DESC_SYMBOL

    || _la == MySQLParser::DESCRIBE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5223);
    tableRef();
    setState(5226);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 671, _ctx)) {
    case 1: {
      setState(5224);
      textString();
      break;
    }

    case 2: {
      setState(5225);
      columnRef();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExplainCommandContext ------------------------------------------------------------------

MySQLParser::ExplainCommandContext::ExplainCommandContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ExplainableStatementContext* MySQLParser::ExplainCommandContext::explainableStatement() {
  return getRuleContext<MySQLParser::ExplainableStatementContext>(0);
}

tree::TerminalNode* MySQLParser::ExplainCommandContext::DESCRIBE_SYMBOL() {
  return getToken(MySQLParser::DESCRIBE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ExplainCommandContext::DESC_SYMBOL() {
  return getToken(MySQLParser::DESC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ExplainCommandContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ExplainCommandContext::PARTITIONS_SYMBOL() {
  return getToken(MySQLParser::PARTITIONS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ExplainCommandContext::FORMAT_SYMBOL() {
  return getToken(MySQLParser::FORMAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ExplainCommandContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::ExplainCommandContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}


size_t MySQLParser::ExplainCommandContext::getRuleIndex() const {
  return MySQLParser::RuleExplainCommand;
}

void MySQLParser::ExplainCommandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExplainCommand(this);
}

void MySQLParser::ExplainCommandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExplainCommand(this);
}


antlrcpp::Any MySQLParser::ExplainCommandContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitExplainCommand(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ExplainCommandContext* MySQLParser::explainCommand() {
  ExplainCommandContext *_localctx = _tracker.createInstance<ExplainCommandContext>(_ctx, getState());
  enterRule(_localctx, 638, MySQLParser::RuleExplainCommand);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5228);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DESC_SYMBOL

    || _la == MySQLParser::DESCRIBE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5237);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 672, _ctx)) {
    case 1: {
      setState(5229);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(5230);
      match(MySQLParser::EXTENDED_SYMBOL);
      break;
    }

    case 2: {
      setState(5231);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(5232);
      match(MySQLParser::PARTITIONS_SYMBOL);
      break;
    }

    case 3: {
      setState(5233);

      if (!(serverVersion >= 50605)) throw FailedPredicateException(this, "serverVersion >= 50605");
      setState(5234);
      match(MySQLParser::FORMAT_SYMBOL);
      setState(5235);
      match(MySQLParser::EQUAL_OPERATOR);
      setState(5236);
      textOrIdentifier();
      break;
    }

    }
    setState(5239);
    explainableStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExplainableStatementContext ------------------------------------------------------------------

MySQLParser::ExplainableStatementContext::ExplainableStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SelectStatementContext* MySQLParser::ExplainableStatementContext::selectStatement() {
  return getRuleContext<MySQLParser::SelectStatementContext>(0);
}

MySQLParser::DeleteStatementContext* MySQLParser::ExplainableStatementContext::deleteStatement() {
  return getRuleContext<MySQLParser::DeleteStatementContext>(0);
}

MySQLParser::InsertStatementContext* MySQLParser::ExplainableStatementContext::insertStatement() {
  return getRuleContext<MySQLParser::InsertStatementContext>(0);
}

MySQLParser::ReplaceStatementContext* MySQLParser::ExplainableStatementContext::replaceStatement() {
  return getRuleContext<MySQLParser::ReplaceStatementContext>(0);
}

MySQLParser::UpdateStatementContext* MySQLParser::ExplainableStatementContext::updateStatement() {
  return getRuleContext<MySQLParser::UpdateStatementContext>(0);
}

tree::TerminalNode* MySQLParser::ExplainableStatementContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ExplainableStatementContext::CONNECTION_SYMBOL() {
  return getToken(MySQLParser::CONNECTION_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::ExplainableStatementContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}


size_t MySQLParser::ExplainableStatementContext::getRuleIndex() const {
  return MySQLParser::RuleExplainableStatement;
}

void MySQLParser::ExplainableStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExplainableStatement(this);
}

void MySQLParser::ExplainableStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExplainableStatement(this);
}


antlrcpp::Any MySQLParser::ExplainableStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitExplainableStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ExplainableStatementContext* MySQLParser::explainableStatement() {
  ExplainableStatementContext *_localctx = _tracker.createInstance<ExplainableStatementContext>(_ctx, getState());
  enterRule(_localctx, 640, MySQLParser::RuleExplainableStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5253);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 674, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5241);
      selectStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5242);

      if (!(serverVersion >= 50603)) throw FailedPredicateException(this, "serverVersion >= 50603");
      setState(5247);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 673, _ctx)) {
      case 1: {
        setState(5243);
        deleteStatement();
        break;
      }

      case 2: {
        setState(5244);
        insertStatement();
        break;
      }

      case 3: {
        setState(5245);
        replaceStatement();
        break;
      }

      case 4: {
        setState(5246);
        updateStatement();
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5249);

      if (!(serverVersion >= 50700)) throw FailedPredicateException(this, "serverVersion >= 50700");
      setState(5250);
      match(MySQLParser::FOR_SYMBOL);
      setState(5251);
      match(MySQLParser::CONNECTION_SYMBOL);
      setState(5252);
      real_ulong_number();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HelpCommandContext ------------------------------------------------------------------

MySQLParser::HelpCommandContext::HelpCommandContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::HelpCommandContext::HELP_SYMBOL() {
  return getToken(MySQLParser::HELP_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::HelpCommandContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}


size_t MySQLParser::HelpCommandContext::getRuleIndex() const {
  return MySQLParser::RuleHelpCommand;
}

void MySQLParser::HelpCommandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHelpCommand(this);
}

void MySQLParser::HelpCommandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHelpCommand(this);
}


antlrcpp::Any MySQLParser::HelpCommandContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitHelpCommand(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::HelpCommandContext* MySQLParser::helpCommand() {
  HelpCommandContext *_localctx = _tracker.createInstance<HelpCommandContext>(_ctx, getState());
  enterRule(_localctx, 642, MySQLParser::RuleHelpCommand);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5255);
    match(MySQLParser::HELP_SYMBOL);
    setState(5256);
    textOrIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UseCommandContext ------------------------------------------------------------------

MySQLParser::UseCommandContext::UseCommandContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::UseCommandContext::USE_SYMBOL() {
  return getToken(MySQLParser::USE_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::UseCommandContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::UseCommandContext::getRuleIndex() const {
  return MySQLParser::RuleUseCommand;
}

void MySQLParser::UseCommandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUseCommand(this);
}

void MySQLParser::UseCommandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUseCommand(this);
}


antlrcpp::Any MySQLParser::UseCommandContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitUseCommand(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UseCommandContext* MySQLParser::useCommand() {
  UseCommandContext *_localctx = _tracker.createInstance<UseCommandContext>(_ctx, getState());
  enterRule(_localctx, 644, MySQLParser::RuleUseCommand);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5258);
    match(MySQLParser::USE_SYMBOL);
    setState(5259);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RestartServerContext ------------------------------------------------------------------

MySQLParser::RestartServerContext::RestartServerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RestartServerContext::RESTART_SYMBOL() {
  return getToken(MySQLParser::RESTART_SYMBOL, 0);
}


size_t MySQLParser::RestartServerContext::getRuleIndex() const {
  return MySQLParser::RuleRestartServer;
}

void MySQLParser::RestartServerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRestartServer(this);
}

void MySQLParser::RestartServerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRestartServer(this);
}


antlrcpp::Any MySQLParser::RestartServerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRestartServer(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RestartServerContext* MySQLParser::restartServer() {
  RestartServerContext *_localctx = _tracker.createInstance<RestartServerContext>(_ctx, getState());
  enterRule(_localctx, 646, MySQLParser::RuleRestartServer);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5261);
    match(MySQLParser::RESTART_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprContext ------------------------------------------------------------------

MySQLParser::ExprContext::ExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySQLParser::ExprContext::getRuleIndex() const {
  return MySQLParser::RuleExpr;
}

void MySQLParser::ExprContext::copyFrom(ExprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- ExprOrContext ------------------------------------------------------------------

std::vector<MySQLParser::ExprContext *> MySQLParser::ExprOrContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext* MySQLParser::ExprOrContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

tree::TerminalNode* MySQLParser::ExprOrContext::OR_SYMBOL() {
  return getToken(MySQLParser::OR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ExprOrContext::LOGICAL_OR_OPERATOR() {
  return getToken(MySQLParser::LOGICAL_OR_OPERATOR, 0);
}

MySQLParser::ExprOrContext::ExprOrContext(ExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::ExprOrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprOr(this);
}
void MySQLParser::ExprOrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprOr(this);
}

antlrcpp::Any MySQLParser::ExprOrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitExprOr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ExprNotContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::ExprNotContext::NOT_SYMBOL() {
  return getToken(MySQLParser::NOT_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::ExprNotContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::ExprNotContext::ExprNotContext(ExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::ExprNotContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprNot(this);
}
void MySQLParser::ExprNotContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprNot(this);
}

antlrcpp::Any MySQLParser::ExprNotContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitExprNot(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ExprIsContext ------------------------------------------------------------------

MySQLParser::BoolPriContext* MySQLParser::ExprIsContext::boolPri() {
  return getRuleContext<MySQLParser::BoolPriContext>(0);
}

tree::TerminalNode* MySQLParser::ExprIsContext::IS_SYMBOL() {
  return getToken(MySQLParser::IS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ExprIsContext::TRUE_SYMBOL() {
  return getToken(MySQLParser::TRUE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ExprIsContext::FALSE_SYMBOL() {
  return getToken(MySQLParser::FALSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ExprIsContext::UNKNOWN_SYMBOL() {
  return getToken(MySQLParser::UNKNOWN_SYMBOL, 0);
}

MySQLParser::NotRuleContext* MySQLParser::ExprIsContext::notRule() {
  return getRuleContext<MySQLParser::NotRuleContext>(0);
}

MySQLParser::ExprIsContext::ExprIsContext(ExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::ExprIsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprIs(this);
}
void MySQLParser::ExprIsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprIs(this);
}

antlrcpp::Any MySQLParser::ExprIsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitExprIs(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ExprAndContext ------------------------------------------------------------------

std::vector<MySQLParser::ExprContext *> MySQLParser::ExprAndContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext* MySQLParser::ExprAndContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

tree::TerminalNode* MySQLParser::ExprAndContext::AND_SYMBOL() {
  return getToken(MySQLParser::AND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ExprAndContext::LOGICAL_AND_OPERATOR() {
  return getToken(MySQLParser::LOGICAL_AND_OPERATOR, 0);
}

MySQLParser::ExprAndContext::ExprAndContext(ExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::ExprAndContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprAnd(this);
}
void MySQLParser::ExprAndContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprAnd(this);
}

antlrcpp::Any MySQLParser::ExprAndContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitExprAnd(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ExprXorContext ------------------------------------------------------------------

std::vector<MySQLParser::ExprContext *> MySQLParser::ExprXorContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext* MySQLParser::ExprXorContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

tree::TerminalNode* MySQLParser::ExprXorContext::XOR_SYMBOL() {
  return getToken(MySQLParser::XOR_SYMBOL, 0);
}

MySQLParser::ExprXorContext::ExprXorContext(ExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::ExprXorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprXor(this);
}
void MySQLParser::ExprXorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprXor(this);
}

antlrcpp::Any MySQLParser::ExprXorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitExprXor(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ExprContext* MySQLParser::expr() {
   return expr(0);
}

MySQLParser::ExprContext* MySQLParser::expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  MySQLParser::ExprContext *_localctx = _tracker.createInstance<ExprContext>(_ctx, parentState);
  MySQLParser::ExprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 648;
  enterRecursionRule(_localctx, 648, MySQLParser::RuleExpr, precedence);

    size_t _la = 0;

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5274);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 677, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<ExprIsContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(5264);
      boolPri(0);
      setState(5270);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 676, _ctx)) {
      case 1: {
        setState(5265);
        match(MySQLParser::IS_SYMBOL);
        setState(5267);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::NOT2_SYMBOL || _la == MySQLParser::NOT_SYMBOL) {
          setState(5266);
          notRule();
        }
        setState(5269);
        dynamic_cast<ExprIsContext *>(_localctx)->type = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::UNKNOWN_SYMBOL || _la == MySQLParser::FALSE_SYMBOL || _la == MySQLParser::TRUE_SYMBOL)) {
          dynamic_cast<ExprIsContext *>(_localctx)->type = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<ExprNotContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5272);
      match(MySQLParser::NOT_SYMBOL);
      setState(5273);
      expr(4);
      break;
    }

    }
    _ctx->stop = _input->LT(-1);
    setState(5287);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 679, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(5285);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 678, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<ExprAndContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(5276);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(5277);
          dynamic_cast<ExprAndContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::LOGICAL_AND_OPERATOR

          || _la == MySQLParser::AND_SYMBOL)) {
            dynamic_cast<ExprAndContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(5278);
          expr(4);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<ExprXorContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(5279);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(5280);
          match(MySQLParser::XOR_SYMBOL);
          setState(5281);
          expr(3);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<ExprOrContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(5282);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(5283);
          dynamic_cast<ExprOrContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::LOGICAL_OR_OPERATOR || _la == MySQLParser::OR_SYMBOL)) {
            dynamic_cast<ExprOrContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(5284);
          expr(2);
          break;
        }

        } 
      }
      setState(5289);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 679, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- BoolPriContext ------------------------------------------------------------------

MySQLParser::BoolPriContext::BoolPriContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySQLParser::BoolPriContext::getRuleIndex() const {
  return MySQLParser::RuleBoolPri;
}

void MySQLParser::BoolPriContext::copyFrom(BoolPriContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PrimaryExprPredicateContext ------------------------------------------------------------------

MySQLParser::PredicateContext* MySQLParser::PrimaryExprPredicateContext::predicate() {
  return getRuleContext<MySQLParser::PredicateContext>(0);
}

MySQLParser::PrimaryExprPredicateContext::PrimaryExprPredicateContext(BoolPriContext *ctx) { copyFrom(ctx); }

void MySQLParser::PrimaryExprPredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryExprPredicate(this);
}
void MySQLParser::PrimaryExprPredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryExprPredicate(this);
}

antlrcpp::Any MySQLParser::PrimaryExprPredicateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPrimaryExprPredicate(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PrimaryExprCompareContext ------------------------------------------------------------------

MySQLParser::BoolPriContext* MySQLParser::PrimaryExprCompareContext::boolPri() {
  return getRuleContext<MySQLParser::BoolPriContext>(0);
}

MySQLParser::CompOpContext* MySQLParser::PrimaryExprCompareContext::compOp() {
  return getRuleContext<MySQLParser::CompOpContext>(0);
}

MySQLParser::PredicateContext* MySQLParser::PrimaryExprCompareContext::predicate() {
  return getRuleContext<MySQLParser::PredicateContext>(0);
}

MySQLParser::PrimaryExprCompareContext::PrimaryExprCompareContext(BoolPriContext *ctx) { copyFrom(ctx); }

void MySQLParser::PrimaryExprCompareContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryExprCompare(this);
}
void MySQLParser::PrimaryExprCompareContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryExprCompare(this);
}

antlrcpp::Any MySQLParser::PrimaryExprCompareContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPrimaryExprCompare(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PrimaryExprAllAnyContext ------------------------------------------------------------------

MySQLParser::BoolPriContext* MySQLParser::PrimaryExprAllAnyContext::boolPri() {
  return getRuleContext<MySQLParser::BoolPriContext>(0);
}

MySQLParser::CompOpContext* MySQLParser::PrimaryExprAllAnyContext::compOp() {
  return getRuleContext<MySQLParser::CompOpContext>(0);
}

MySQLParser::SubqueryContext* MySQLParser::PrimaryExprAllAnyContext::subquery() {
  return getRuleContext<MySQLParser::SubqueryContext>(0);
}

tree::TerminalNode* MySQLParser::PrimaryExprAllAnyContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PrimaryExprAllAnyContext::ANY_SYMBOL() {
  return getToken(MySQLParser::ANY_SYMBOL, 0);
}

MySQLParser::PrimaryExprAllAnyContext::PrimaryExprAllAnyContext(BoolPriContext *ctx) { copyFrom(ctx); }

void MySQLParser::PrimaryExprAllAnyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryExprAllAny(this);
}
void MySQLParser::PrimaryExprAllAnyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryExprAllAny(this);
}

antlrcpp::Any MySQLParser::PrimaryExprAllAnyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPrimaryExprAllAny(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PrimaryExprIsNullContext ------------------------------------------------------------------

MySQLParser::BoolPriContext* MySQLParser::PrimaryExprIsNullContext::boolPri() {
  return getRuleContext<MySQLParser::BoolPriContext>(0);
}

tree::TerminalNode* MySQLParser::PrimaryExprIsNullContext::IS_SYMBOL() {
  return getToken(MySQLParser::IS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PrimaryExprIsNullContext::NULL_SYMBOL() {
  return getToken(MySQLParser::NULL_SYMBOL, 0);
}

MySQLParser::NotRuleContext* MySQLParser::PrimaryExprIsNullContext::notRule() {
  return getRuleContext<MySQLParser::NotRuleContext>(0);
}

MySQLParser::PrimaryExprIsNullContext::PrimaryExprIsNullContext(BoolPriContext *ctx) { copyFrom(ctx); }

void MySQLParser::PrimaryExprIsNullContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryExprIsNull(this);
}
void MySQLParser::PrimaryExprIsNullContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryExprIsNull(this);
}

antlrcpp::Any MySQLParser::PrimaryExprIsNullContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPrimaryExprIsNull(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::BoolPriContext* MySQLParser::boolPri() {
   return boolPri(0);
}

MySQLParser::BoolPriContext* MySQLParser::boolPri(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  MySQLParser::BoolPriContext *_localctx = _tracker.createInstance<BoolPriContext>(_ctx, parentState);
  MySQLParser::BoolPriContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 650;
  enterRecursionRule(_localctx, 650, MySQLParser::RuleBoolPri, precedence);

    size_t _la = 0;

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    _localctx = _tracker.createInstance<PrimaryExprPredicateContext>(_localctx);
    _ctx = _localctx;
    previousContext = _localctx;

    setState(5291);
    predicate();
    _ctx->stop = _input->LT(-1);
    setState(5310);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 682, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(5308);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 681, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<PrimaryExprIsNullContext>(_tracker.createInstance<BoolPriContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleBoolPri);
          setState(5293);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(5294);
          match(MySQLParser::IS_SYMBOL);
          setState(5296);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLParser::NOT2_SYMBOL || _la == MySQLParser::NOT_SYMBOL) {
            setState(5295);
            notRule();
          }
          setState(5298);
          match(MySQLParser::NULL_SYMBOL);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<PrimaryExprCompareContext>(_tracker.createInstance<BoolPriContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleBoolPri);
          setState(5299);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(5300);
          compOp();
          setState(5301);
          predicate();
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<PrimaryExprAllAnyContext>(_tracker.createInstance<BoolPriContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleBoolPri);
          setState(5303);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(5304);
          compOp();
          setState(5305);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::ANY_SYMBOL || _la == MySQLParser::ALL_SYMBOL)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(5306);
          subquery();
          break;
        }

        } 
      }
      setState(5312);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 682, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- CompOpContext ------------------------------------------------------------------

MySQLParser::CompOpContext::CompOpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CompOpContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::CompOpContext::NULL_SAFE_EQUAL_OPERATOR() {
  return getToken(MySQLParser::NULL_SAFE_EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::CompOpContext::GREATER_OR_EQUAL_OPERATOR() {
  return getToken(MySQLParser::GREATER_OR_EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::CompOpContext::GREATER_THAN_OPERATOR() {
  return getToken(MySQLParser::GREATER_THAN_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::CompOpContext::LESS_OR_EQUAL_OPERATOR() {
  return getToken(MySQLParser::LESS_OR_EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::CompOpContext::LESS_THAN_OPERATOR() {
  return getToken(MySQLParser::LESS_THAN_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::CompOpContext::NOT_EQUAL_OPERATOR() {
  return getToken(MySQLParser::NOT_EQUAL_OPERATOR, 0);
}


size_t MySQLParser::CompOpContext::getRuleIndex() const {
  return MySQLParser::RuleCompOp;
}

void MySQLParser::CompOpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompOp(this);
}

void MySQLParser::CompOpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompOp(this);
}


antlrcpp::Any MySQLParser::CompOpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCompOp(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CompOpContext* MySQLParser::compOp() {
  CompOpContext *_localctx = _tracker.createInstance<CompOpContext>(_ctx, getState());
  enterRule(_localctx, 652, MySQLParser::RuleCompOp);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5313);
    _la = _input->LA(1);
    if (!(((((_la - 383) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 383)) & ((1ULL << (MySQLParser::EQUAL_OPERATOR - 383))
      | (1ULL << (MySQLParser::NULL_SAFE_EQUAL_OPERATOR - 383))
      | (1ULL << (MySQLParser::GREATER_OR_EQUAL_OPERATOR - 383))
      | (1ULL << (MySQLParser::GREATER_THAN_OPERATOR - 383))
      | (1ULL << (MySQLParser::LESS_OR_EQUAL_OPERATOR - 383))
      | (1ULL << (MySQLParser::LESS_THAN_OPERATOR - 383))
      | (1ULL << (MySQLParser::NOT_EQUAL_OPERATOR - 383)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PredicateContext ------------------------------------------------------------------

MySQLParser::PredicateContext::PredicateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::BitExprContext *> MySQLParser::PredicateContext::bitExpr() {
  return getRuleContexts<MySQLParser::BitExprContext>();
}

MySQLParser::BitExprContext* MySQLParser::PredicateContext::bitExpr(size_t i) {
  return getRuleContext<MySQLParser::BitExprContext>(i);
}

MySQLParser::PredicateOperationsContext* MySQLParser::PredicateContext::predicateOperations() {
  return getRuleContext<MySQLParser::PredicateOperationsContext>(0);
}

tree::TerminalNode* MySQLParser::PredicateContext::SOUNDS_SYMBOL() {
  return getToken(MySQLParser::SOUNDS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PredicateContext::LIKE_SYMBOL() {
  return getToken(MySQLParser::LIKE_SYMBOL, 0);
}

MySQLParser::NotRuleContext* MySQLParser::PredicateContext::notRule() {
  return getRuleContext<MySQLParser::NotRuleContext>(0);
}


size_t MySQLParser::PredicateContext::getRuleIndex() const {
  return MySQLParser::RulePredicate;
}

void MySQLParser::PredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicate(this);
}

void MySQLParser::PredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicate(this);
}


antlrcpp::Any MySQLParser::PredicateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPredicate(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PredicateContext* MySQLParser::predicate() {
  PredicateContext *_localctx = _tracker.createInstance<PredicateContext>(_ctx, getState());
  enterRule(_localctx, 654, MySQLParser::RulePredicate);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5315);
    bitExpr(0);
    setState(5323);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 684, _ctx)) {
    case 1: {
      setState(5317);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::NOT2_SYMBOL || _la == MySQLParser::NOT_SYMBOL) {
        setState(5316);
        notRule();
      }
      setState(5319);
      predicateOperations();
      break;
    }

    case 2: {
      setState(5320);
      match(MySQLParser::SOUNDS_SYMBOL);
      setState(5321);
      match(MySQLParser::LIKE_SYMBOL);
      setState(5322);
      bitExpr(0);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PredicateOperationsContext ------------------------------------------------------------------

MySQLParser::PredicateOperationsContext::PredicateOperationsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySQLParser::PredicateOperationsContext::getRuleIndex() const {
  return MySQLParser::RulePredicateOperations;
}

void MySQLParser::PredicateOperationsContext::copyFrom(PredicateOperationsContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PredicateExprRegexContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::PredicateExprRegexContext::REGEXP_SYMBOL() {
  return getToken(MySQLParser::REGEXP_SYMBOL, 0);
}

MySQLParser::BitExprContext* MySQLParser::PredicateExprRegexContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

MySQLParser::PredicateExprRegexContext::PredicateExprRegexContext(PredicateOperationsContext *ctx) { copyFrom(ctx); }

void MySQLParser::PredicateExprRegexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicateExprRegex(this);
}
void MySQLParser::PredicateExprRegexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicateExprRegex(this);
}

antlrcpp::Any MySQLParser::PredicateExprRegexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPredicateExprRegex(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PredicateExprBetweenContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::PredicateExprBetweenContext::BETWEEN_SYMBOL() {
  return getToken(MySQLParser::BETWEEN_SYMBOL, 0);
}

MySQLParser::BitExprContext* MySQLParser::PredicateExprBetweenContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

tree::TerminalNode* MySQLParser::PredicateExprBetweenContext::AND_SYMBOL() {
  return getToken(MySQLParser::AND_SYMBOL, 0);
}

MySQLParser::PredicateContext* MySQLParser::PredicateExprBetweenContext::predicate() {
  return getRuleContext<MySQLParser::PredicateContext>(0);
}

MySQLParser::PredicateExprBetweenContext::PredicateExprBetweenContext(PredicateOperationsContext *ctx) { copyFrom(ctx); }

void MySQLParser::PredicateExprBetweenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicateExprBetween(this);
}
void MySQLParser::PredicateExprBetweenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicateExprBetween(this);
}

antlrcpp::Any MySQLParser::PredicateExprBetweenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPredicateExprBetween(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PredicateExprInContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::PredicateExprInContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

MySQLParser::SubqueryContext* MySQLParser::PredicateExprInContext::subquery() {
  return getRuleContext<MySQLParser::SubqueryContext>(0);
}

tree::TerminalNode* MySQLParser::PredicateExprInContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprListContext* MySQLParser::PredicateExprInContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

tree::TerminalNode* MySQLParser::PredicateExprInContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::PredicateExprInContext::PredicateExprInContext(PredicateOperationsContext *ctx) { copyFrom(ctx); }

void MySQLParser::PredicateExprInContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicateExprIn(this);
}
void MySQLParser::PredicateExprInContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicateExprIn(this);
}

antlrcpp::Any MySQLParser::PredicateExprInContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPredicateExprIn(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PredicateExprLikeContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::PredicateExprLikeContext::LIKE_SYMBOL() {
  return getToken(MySQLParser::LIKE_SYMBOL, 0);
}

std::vector<MySQLParser::SimpleExprContext *> MySQLParser::PredicateExprLikeContext::simpleExpr() {
  return getRuleContexts<MySQLParser::SimpleExprContext>();
}

MySQLParser::SimpleExprContext* MySQLParser::PredicateExprLikeContext::simpleExpr(size_t i) {
  return getRuleContext<MySQLParser::SimpleExprContext>(i);
}

tree::TerminalNode* MySQLParser::PredicateExprLikeContext::ESCAPE_SYMBOL() {
  return getToken(MySQLParser::ESCAPE_SYMBOL, 0);
}

MySQLParser::PredicateExprLikeContext::PredicateExprLikeContext(PredicateOperationsContext *ctx) { copyFrom(ctx); }

void MySQLParser::PredicateExprLikeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicateExprLike(this);
}
void MySQLParser::PredicateExprLikeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicateExprLike(this);
}

antlrcpp::Any MySQLParser::PredicateExprLikeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPredicateExprLike(this);
  else
    return visitor->visitChildren(this);
}
MySQLParser::PredicateOperationsContext* MySQLParser::predicateOperations() {
  PredicateOperationsContext *_localctx = _tracker.createInstance<PredicateOperationsContext>(_ctx, getState());
  enterRule(_localctx, 656, MySQLParser::RulePredicateOperations);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5346);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::IN_SYMBOL: {
        _localctx = dynamic_cast<PredicateOperationsContext *>(_tracker.createInstance<MySQLParser::PredicateExprInContext>(_localctx));
        enterOuterAlt(_localctx, 1);
        setState(5325);
        match(MySQLParser::IN_SYMBOL);
        setState(5331);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 685, _ctx)) {
        case 1: {
          setState(5326);
          subquery();
          break;
        }

        case 2: {
          setState(5327);
          match(MySQLParser::OPEN_PAR_SYMBOL);
          setState(5328);
          exprList();
          setState(5329);
          match(MySQLParser::CLOSE_PAR_SYMBOL);
          break;
        }

        }
        break;
      }

      case MySQLParser::BETWEEN_SYMBOL: {
        _localctx = dynamic_cast<PredicateOperationsContext *>(_tracker.createInstance<MySQLParser::PredicateExprBetweenContext>(_localctx));
        enterOuterAlt(_localctx, 2);
        setState(5333);
        match(MySQLParser::BETWEEN_SYMBOL);
        setState(5334);
        bitExpr(0);
        setState(5335);
        match(MySQLParser::AND_SYMBOL);
        setState(5336);
        predicate();
        break;
      }

      case MySQLParser::LIKE_SYMBOL: {
        _localctx = dynamic_cast<PredicateOperationsContext *>(_tracker.createInstance<MySQLParser::PredicateExprLikeContext>(_localctx));
        enterOuterAlt(_localctx, 3);
        setState(5338);
        match(MySQLParser::LIKE_SYMBOL);
        setState(5339);
        simpleExpr(0);
        setState(5342);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 686, _ctx)) {
        case 1: {
          setState(5340);
          match(MySQLParser::ESCAPE_SYMBOL);
          setState(5341);
          simpleExpr(0);
          break;
        }

        }
        break;
      }

      case MySQLParser::REGEXP_SYMBOL: {
        _localctx = dynamic_cast<PredicateOperationsContext *>(_tracker.createInstance<MySQLParser::PredicateExprRegexContext>(_localctx));
        enterOuterAlt(_localctx, 4);
        setState(5344);
        match(MySQLParser::REGEXP_SYMBOL);
        setState(5345);
        bitExpr(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitExprContext ------------------------------------------------------------------

MySQLParser::BitExprContext::BitExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SimpleExprContext* MySQLParser::BitExprContext::simpleExpr() {
  return getRuleContext<MySQLParser::SimpleExprContext>(0);
}

std::vector<MySQLParser::BitExprContext *> MySQLParser::BitExprContext::bitExpr() {
  return getRuleContexts<MySQLParser::BitExprContext>();
}

MySQLParser::BitExprContext* MySQLParser::BitExprContext::bitExpr(size_t i) {
  return getRuleContext<MySQLParser::BitExprContext>(i);
}

tree::TerminalNode* MySQLParser::BitExprContext::BITWISE_XOR_OPERATOR() {
  return getToken(MySQLParser::BITWISE_XOR_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::MULT_OPERATOR() {
  return getToken(MySQLParser::MULT_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::DIV_OPERATOR() {
  return getToken(MySQLParser::DIV_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::MOD_OPERATOR() {
  return getToken(MySQLParser::MOD_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::DIV_SYMBOL() {
  return getToken(MySQLParser::DIV_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::MOD_SYMBOL() {
  return getToken(MySQLParser::MOD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::PLUS_OPERATOR() {
  return getToken(MySQLParser::PLUS_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::MINUS_OPERATOR() {
  return getToken(MySQLParser::MINUS_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::SHIFT_LEFT_OPERATOR() {
  return getToken(MySQLParser::SHIFT_LEFT_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::SHIFT_RIGHT_OPERATOR() {
  return getToken(MySQLParser::SHIFT_RIGHT_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::BITWISE_AND_OPERATOR() {
  return getToken(MySQLParser::BITWISE_AND_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::BITWISE_OR_OPERATOR() {
  return getToken(MySQLParser::BITWISE_OR_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::INTERVAL_SYMBOL() {
  return getToken(MySQLParser::INTERVAL_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::BitExprContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::IntervalContext* MySQLParser::BitExprContext::interval() {
  return getRuleContext<MySQLParser::IntervalContext>(0);
}


size_t MySQLParser::BitExprContext::getRuleIndex() const {
  return MySQLParser::RuleBitExpr;
}

void MySQLParser::BitExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitExpr(this);
}

void MySQLParser::BitExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitExpr(this);
}


antlrcpp::Any MySQLParser::BitExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitBitExpr(this);
  else
    return visitor->visitChildren(this);
}


MySQLParser::BitExprContext* MySQLParser::bitExpr() {
   return bitExpr(0);
}

MySQLParser::BitExprContext* MySQLParser::bitExpr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  MySQLParser::BitExprContext *_localctx = _tracker.createInstance<BitExprContext>(_ctx, parentState);
  MySQLParser::BitExprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 658;
  enterRecursionRule(_localctx, 658, MySQLParser::RuleBitExpr, precedence);

    size_t _la = 0;

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5349);
    simpleExpr(0);
    _ctx->stop = _input->LT(-1);
    setState(5377);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 689, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(5375);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 688, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(5351);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(5352);
          dynamic_cast<BitExprContext *>(_localctx)->op = match(MySQLParser::BITWISE_XOR_OPERATOR);
          setState(5353);
          bitExpr(8);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(5354);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(5355);
          dynamic_cast<BitExprContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(((((_la - 393) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 393)) & ((1ULL << (MySQLParser::MULT_OPERATOR - 393))
            | (1ULL << (MySQLParser::DIV_OPERATOR - 393))
            | (1ULL << (MySQLParser::MOD_OPERATOR - 393)))) != 0) || _la == MySQLParser::DIV_SYMBOL || _la == MySQLParser::MOD_SYMBOL)) {
            dynamic_cast<BitExprContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(5356);
          bitExpr(7);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(5357);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(5358);
          dynamic_cast<BitExprContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::PLUS_OPERATOR

          || _la == MySQLParser::MINUS_OPERATOR)) {
            dynamic_cast<BitExprContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(5359);
          bitExpr(6);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(5360);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(5361);
          dynamic_cast<BitExprContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::SHIFT_LEFT_OPERATOR

          || _la == MySQLParser::SHIFT_RIGHT_OPERATOR)) {
            dynamic_cast<BitExprContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(5362);
          bitExpr(4);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(5363);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(5364);
          dynamic_cast<BitExprContext *>(_localctx)->op = match(MySQLParser::BITWISE_AND_OPERATOR);
          setState(5365);
          bitExpr(3);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(5366);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(5367);
          dynamic_cast<BitExprContext *>(_localctx)->op = match(MySQLParser::BITWISE_OR_OPERATOR);
          setState(5368);
          bitExpr(2);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(5369);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(5370);
          dynamic_cast<BitExprContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::PLUS_OPERATOR

          || _la == MySQLParser::MINUS_OPERATOR)) {
            dynamic_cast<BitExprContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(5371);
          match(MySQLParser::INTERVAL_SYMBOL);
          setState(5372);
          expr(0);
          setState(5373);
          interval();
          break;
        }

        } 
      }
      setState(5379);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 689, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- SimpleExprContext ------------------------------------------------------------------

MySQLParser::SimpleExprContext::SimpleExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySQLParser::SimpleExprContext::getRuleIndex() const {
  return MySQLParser::RuleSimpleExpr;
}

void MySQLParser::SimpleExprContext::copyFrom(SimpleExprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- SimpleExprConvertContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprConvertContext::CONVERT_SYMBOL() {
  return getToken(MySQLParser::CONVERT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SimpleExprConvertContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::SimpleExprConvertContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprConvertContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

MySQLParser::CastTypeContext* MySQLParser::SimpleExprConvertContext::castType() {
  return getRuleContext<MySQLParser::CastTypeContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprConvertContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::SimpleExprConvertContext::SimpleExprConvertContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprConvertContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprConvert(this);
}
void MySQLParser::SimpleExprConvertContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprConvert(this);
}

antlrcpp::Any MySQLParser::SimpleExprConvertContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprConvert(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprVariableContext ------------------------------------------------------------------

MySQLParser::VariableContext* MySQLParser::SimpleExprVariableContext::variable() {
  return getRuleContext<MySQLParser::VariableContext>(0);
}

MySQLParser::SimpleExprVariableContext::SimpleExprVariableContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprVariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprVariable(this);
}
void MySQLParser::SimpleExprVariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprVariable(this);
}

antlrcpp::Any MySQLParser::SimpleExprVariableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprVariable(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprCastContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprCastContext::CAST_SYMBOL() {
  return getToken(MySQLParser::CAST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SimpleExprCastContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::SimpleExprCastContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprCastContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::CastTypeContext* MySQLParser::SimpleExprCastContext::castType() {
  return getRuleContext<MySQLParser::CastTypeContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprCastContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::SimpleExprCastContext::SimpleExprCastContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprCastContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprCast(this);
}
void MySQLParser::SimpleExprCastContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprCast(this);
}

antlrcpp::Any MySQLParser::SimpleExprCastContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprCast(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprUnaryContext ------------------------------------------------------------------

MySQLParser::SimpleExprContext* MySQLParser::SimpleExprUnaryContext::simpleExpr() {
  return getRuleContext<MySQLParser::SimpleExprContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprUnaryContext::PLUS_OPERATOR() {
  return getToken(MySQLParser::PLUS_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::SimpleExprUnaryContext::MINUS_OPERATOR() {
  return getToken(MySQLParser::MINUS_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::SimpleExprUnaryContext::BITWISE_NOT_OPERATOR() {
  return getToken(MySQLParser::BITWISE_NOT_OPERATOR, 0);
}

MySQLParser::SimpleExprUnaryContext::SimpleExprUnaryContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprUnaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprUnary(this);
}
void MySQLParser::SimpleExprUnaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprUnary(this);
}

antlrcpp::Any MySQLParser::SimpleExprUnaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprUnary(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprOdbcContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprOdbcContext::OPEN_CURLY_SYMBOL() {
  return getToken(MySQLParser::OPEN_CURLY_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::SimpleExprOdbcContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::ExprContext* MySQLParser::SimpleExprOdbcContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprOdbcContext::CLOSE_CURLY_SYMBOL() {
  return getToken(MySQLParser::CLOSE_CURLY_SYMBOL, 0);
}

MySQLParser::SimpleExprOdbcContext::SimpleExprOdbcContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprOdbcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprOdbc(this);
}
void MySQLParser::SimpleExprOdbcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprOdbc(this);
}

antlrcpp::Any MySQLParser::SimpleExprOdbcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprOdbc(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprRuntimeFunctionContext ------------------------------------------------------------------

MySQLParser::RuntimeFunctionCallContext* MySQLParser::SimpleExprRuntimeFunctionContext::runtimeFunctionCall() {
  return getRuleContext<MySQLParser::RuntimeFunctionCallContext>(0);
}

MySQLParser::SimpleExprRuntimeFunctionContext::SimpleExprRuntimeFunctionContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprRuntimeFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprRuntimeFunction(this);
}
void MySQLParser::SimpleExprRuntimeFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprRuntimeFunction(this);
}

antlrcpp::Any MySQLParser::SimpleExprRuntimeFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprRuntimeFunction(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprFunctionContext ------------------------------------------------------------------

MySQLParser::FunctionCallContext* MySQLParser::SimpleExprFunctionContext::functionCall() {
  return getRuleContext<MySQLParser::FunctionCallContext>(0);
}

MySQLParser::SimpleExprFunctionContext::SimpleExprFunctionContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprFunction(this);
}
void MySQLParser::SimpleExprFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprFunction(this);
}

antlrcpp::Any MySQLParser::SimpleExprFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprFunction(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprCollateContext ------------------------------------------------------------------

MySQLParser::SimpleExprContext* MySQLParser::SimpleExprCollateContext::simpleExpr() {
  return getRuleContext<MySQLParser::SimpleExprContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprCollateContext::COLLATE_SYMBOL() {
  return getToken(MySQLParser::COLLATE_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::SimpleExprCollateContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

MySQLParser::SimpleExprCollateContext::SimpleExprCollateContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprCollateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprCollate(this);
}
void MySQLParser::SimpleExprCollateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprCollate(this);
}

antlrcpp::Any MySQLParser::SimpleExprCollateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprCollate(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprMatchContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprMatchContext::MATCH_SYMBOL() {
  return getToken(MySQLParser::MATCH_SYMBOL, 0);
}

MySQLParser::IdentListArgContext* MySQLParser::SimpleExprMatchContext::identListArg() {
  return getRuleContext<MySQLParser::IdentListArgContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprMatchContext::AGAINST_SYMBOL() {
  return getToken(MySQLParser::AGAINST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SimpleExprMatchContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::BitExprContext* MySQLParser::SimpleExprMatchContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprMatchContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::FulltextOptionsContext* MySQLParser::SimpleExprMatchContext::fulltextOptions() {
  return getRuleContext<MySQLParser::FulltextOptionsContext>(0);
}

MySQLParser::SimpleExprMatchContext::SimpleExprMatchContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprMatchContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprMatch(this);
}
void MySQLParser::SimpleExprMatchContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprMatch(this);
}

antlrcpp::Any MySQLParser::SimpleExprMatchContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprMatch(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprWindowingFunctionContext ------------------------------------------------------------------

MySQLParser::WindowFunctionCallContext* MySQLParser::SimpleExprWindowingFunctionContext::windowFunctionCall() {
  return getRuleContext<MySQLParser::WindowFunctionCallContext>(0);
}

MySQLParser::SimpleExprWindowingFunctionContext::SimpleExprWindowingFunctionContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprWindowingFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprWindowingFunction(this);
}
void MySQLParser::SimpleExprWindowingFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprWindowingFunction(this);
}

antlrcpp::Any MySQLParser::SimpleExprWindowingFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprWindowingFunction(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprBinaryContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprBinaryContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

MySQLParser::SimpleExprContext* MySQLParser::SimpleExprBinaryContext::simpleExpr() {
  return getRuleContext<MySQLParser::SimpleExprContext>(0);
}

MySQLParser::SimpleExprBinaryContext::SimpleExprBinaryContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprBinaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprBinary(this);
}
void MySQLParser::SimpleExprBinaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprBinary(this);
}

antlrcpp::Any MySQLParser::SimpleExprBinaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprBinary(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprColumnRefContext ------------------------------------------------------------------

MySQLParser::ColumnRefContext* MySQLParser::SimpleExprColumnRefContext::columnRef() {
  return getRuleContext<MySQLParser::ColumnRefContext>(0);
}

MySQLParser::JsonOperatorContext* MySQLParser::SimpleExprColumnRefContext::jsonOperator() {
  return getRuleContext<MySQLParser::JsonOperatorContext>(0);
}

MySQLParser::SimpleExprColumnRefContext::SimpleExprColumnRefContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprColumnRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprColumnRef(this);
}
void MySQLParser::SimpleExprColumnRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprColumnRef(this);
}

antlrcpp::Any MySQLParser::SimpleExprColumnRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprColumnRef(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprParamMarkerContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprParamMarkerContext::PARAM_MARKER() {
  return getToken(MySQLParser::PARAM_MARKER, 0);
}

MySQLParser::SimpleExprParamMarkerContext::SimpleExprParamMarkerContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprParamMarkerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprParamMarker(this);
}
void MySQLParser::SimpleExprParamMarkerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprParamMarker(this);
}

antlrcpp::Any MySQLParser::SimpleExprParamMarkerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprParamMarker(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprSumContext ------------------------------------------------------------------

MySQLParser::SumExprContext* MySQLParser::SimpleExprSumContext::sumExpr() {
  return getRuleContext<MySQLParser::SumExprContext>(0);
}

MySQLParser::SimpleExprSumContext::SimpleExprSumContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprSumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprSum(this);
}
void MySQLParser::SimpleExprSumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprSum(this);
}

antlrcpp::Any MySQLParser::SimpleExprSumContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprSum(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprConvertUsingContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprConvertUsingContext::CONVERT_SYMBOL() {
  return getToken(MySQLParser::CONVERT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SimpleExprConvertUsingContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::SimpleExprConvertUsingContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprConvertUsingContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

MySQLParser::CharsetNameContext* MySQLParser::SimpleExprConvertUsingContext::charsetName() {
  return getRuleContext<MySQLParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprConvertUsingContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::SimpleExprConvertUsingContext::SimpleExprConvertUsingContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprConvertUsingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprConvertUsing(this);
}
void MySQLParser::SimpleExprConvertUsingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprConvertUsing(this);
}

antlrcpp::Any MySQLParser::SimpleExprConvertUsingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprConvertUsing(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprSubQueryContext ------------------------------------------------------------------

MySQLParser::SubqueryContext* MySQLParser::SimpleExprSubQueryContext::subquery() {
  return getRuleContext<MySQLParser::SubqueryContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprSubQueryContext::EXISTS_SYMBOL() {
  return getToken(MySQLParser::EXISTS_SYMBOL, 0);
}

MySQLParser::SimpleExprSubQueryContext::SimpleExprSubQueryContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprSubQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprSubQuery(this);
}
void MySQLParser::SimpleExprSubQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprSubQuery(this);
}

antlrcpp::Any MySQLParser::SimpleExprSubQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprSubQuery(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprGroupingOperationContext ------------------------------------------------------------------

MySQLParser::GroupingOperationContext* MySQLParser::SimpleExprGroupingOperationContext::groupingOperation() {
  return getRuleContext<MySQLParser::GroupingOperationContext>(0);
}

MySQLParser::SimpleExprGroupingOperationContext::SimpleExprGroupingOperationContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprGroupingOperationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprGroupingOperation(this);
}
void MySQLParser::SimpleExprGroupingOperationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprGroupingOperation(this);
}

antlrcpp::Any MySQLParser::SimpleExprGroupingOperationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprGroupingOperation(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprNotContext ------------------------------------------------------------------

MySQLParser::Not2RuleContext* MySQLParser::SimpleExprNotContext::not2Rule() {
  return getRuleContext<MySQLParser::Not2RuleContext>(0);
}

MySQLParser::SimpleExprContext* MySQLParser::SimpleExprNotContext::simpleExpr() {
  return getRuleContext<MySQLParser::SimpleExprContext>(0);
}

MySQLParser::SimpleExprNotContext::SimpleExprNotContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprNotContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprNot(this);
}
void MySQLParser::SimpleExprNotContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprNot(this);
}

antlrcpp::Any MySQLParser::SimpleExprNotContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprNot(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprValuesContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprValuesContext::VALUES_SYMBOL() {
  return getToken(MySQLParser::VALUES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SimpleExprValuesContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::SimpleIdentifierContext* MySQLParser::SimpleExprValuesContext::simpleIdentifier() {
  return getRuleContext<MySQLParser::SimpleIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprValuesContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::SimpleExprValuesContext::SimpleExprValuesContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprValuesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprValues(this);
}
void MySQLParser::SimpleExprValuesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprValues(this);
}

antlrcpp::Any MySQLParser::SimpleExprValuesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprValues(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprDefaultContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprDefaultContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SimpleExprDefaultContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::SimpleIdentifierContext* MySQLParser::SimpleExprDefaultContext::simpleIdentifier() {
  return getRuleContext<MySQLParser::SimpleIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprDefaultContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::SimpleExprDefaultContext::SimpleExprDefaultContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprDefault(this);
}
void MySQLParser::SimpleExprDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprDefault(this);
}

antlrcpp::Any MySQLParser::SimpleExprDefaultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprDefault(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprListContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprListContext* MySQLParser::SimpleExprListContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SimpleExprListContext::ROW_SYMBOL() {
  return getToken(MySQLParser::ROW_SYMBOL, 0);
}

MySQLParser::SimpleExprListContext::SimpleExprListContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprList(this);
}
void MySQLParser::SimpleExprListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprList(this);
}

antlrcpp::Any MySQLParser::SimpleExprListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprList(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprIntervalContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprIntervalContext::INTERVAL_SYMBOL() {
  return getToken(MySQLParser::INTERVAL_SYMBOL, 0);
}

std::vector<MySQLParser::ExprContext *> MySQLParser::SimpleExprIntervalContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext* MySQLParser::SimpleExprIntervalContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

MySQLParser::IntervalContext* MySQLParser::SimpleExprIntervalContext::interval() {
  return getRuleContext<MySQLParser::IntervalContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprIntervalContext::PLUS_OPERATOR() {
  return getToken(MySQLParser::PLUS_OPERATOR, 0);
}

MySQLParser::SimpleExprIntervalContext::SimpleExprIntervalContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprIntervalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprInterval(this);
}
void MySQLParser::SimpleExprIntervalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprInterval(this);
}

antlrcpp::Any MySQLParser::SimpleExprIntervalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprInterval(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprCaseContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprCaseContext::CASE_SYMBOL() {
  return getToken(MySQLParser::CASE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SimpleExprCaseContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::SimpleExprCaseContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

std::vector<MySQLParser::WhenExpressionContext *> MySQLParser::SimpleExprCaseContext::whenExpression() {
  return getRuleContexts<MySQLParser::WhenExpressionContext>();
}

MySQLParser::WhenExpressionContext* MySQLParser::SimpleExprCaseContext::whenExpression(size_t i) {
  return getRuleContext<MySQLParser::WhenExpressionContext>(i);
}

std::vector<MySQLParser::ThenExpressionContext *> MySQLParser::SimpleExprCaseContext::thenExpression() {
  return getRuleContexts<MySQLParser::ThenExpressionContext>();
}

MySQLParser::ThenExpressionContext* MySQLParser::SimpleExprCaseContext::thenExpression(size_t i) {
  return getRuleContext<MySQLParser::ThenExpressionContext>(i);
}

MySQLParser::ElseExpressionContext* MySQLParser::SimpleExprCaseContext::elseExpression() {
  return getRuleContext<MySQLParser::ElseExpressionContext>(0);
}

MySQLParser::SimpleExprCaseContext::SimpleExprCaseContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprCaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprCase(this);
}
void MySQLParser::SimpleExprCaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprCase(this);
}

antlrcpp::Any MySQLParser::SimpleExprCaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprCase(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprConcatContext ------------------------------------------------------------------

std::vector<MySQLParser::SimpleExprContext *> MySQLParser::SimpleExprConcatContext::simpleExpr() {
  return getRuleContexts<MySQLParser::SimpleExprContext>();
}

MySQLParser::SimpleExprContext* MySQLParser::SimpleExprConcatContext::simpleExpr(size_t i) {
  return getRuleContext<MySQLParser::SimpleExprContext>(i);
}

tree::TerminalNode* MySQLParser::SimpleExprConcatContext::CONCAT_PIPES_SYMBOL() {
  return getToken(MySQLParser::CONCAT_PIPES_SYMBOL, 0);
}

MySQLParser::SimpleExprConcatContext::SimpleExprConcatContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprConcatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprConcat(this);
}
void MySQLParser::SimpleExprConcatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprConcat(this);
}

antlrcpp::Any MySQLParser::SimpleExprConcatContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprConcat(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprLiteralContext ------------------------------------------------------------------

MySQLParser::LiteralContext* MySQLParser::SimpleExprLiteralContext::literal() {
  return getRuleContext<MySQLParser::LiteralContext>(0);
}

MySQLParser::SimpleExprLiteralContext::SimpleExprLiteralContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprLiteral(this);
}
void MySQLParser::SimpleExprLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprLiteral(this);
}

antlrcpp::Any MySQLParser::SimpleExprLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExprLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SimpleExprContext* MySQLParser::simpleExpr() {
   return simpleExpr(0);
}

MySQLParser::SimpleExprContext* MySQLParser::simpleExpr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  MySQLParser::SimpleExprContext *_localctx = _tracker.createInstance<SimpleExprContext>(_ctx, parentState);
  MySQLParser::SimpleExprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 660;
  enterRecursionRule(_localctx, 660, MySQLParser::RuleSimpleExpr, precedence);

    size_t _la = 0;

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5481);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 697, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<SimpleExprVariableContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(5381);
      variable();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<SimpleExprColumnRefContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5382);
      columnRef();
      setState(5384);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 690, _ctx)) {
      case 1: {
        setState(5383);
        jsonOperator();
        break;
      }

      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<SimpleExprRuntimeFunctionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5386);
      runtimeFunctionCall();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<SimpleExprFunctionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5387);
      functionCall();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<SimpleExprLiteralContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5388);
      literal();
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<SimpleExprParamMarkerContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5389);
      match(MySQLParser::PARAM_MARKER);
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<SimpleExprSumContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5390);
      sumExpr();
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<SimpleExprGroupingOperationContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5391);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(5392);
      groupingOperation();
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<SimpleExprWindowingFunctionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5393);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(5394);
      windowFunctionCall();
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<SimpleExprUnaryContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5395);
      dynamic_cast<SimpleExprUnaryContext *>(_localctx)->op = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 391) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 391)) & ((1ULL << (MySQLParser::PLUS_OPERATOR - 391))
        | (1ULL << (MySQLParser::MINUS_OPERATOR - 391))
        | (1ULL << (MySQLParser::BITWISE_NOT_OPERATOR - 391)))) != 0))) {
        dynamic_cast<SimpleExprUnaryContext *>(_localctx)->op = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5396);
      simpleExpr(14);
      break;
    }

    case 11: {
      _localctx = _tracker.createInstance<SimpleExprNotContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5397);
      not2Rule();
      setState(5398);
      simpleExpr(13);
      break;
    }

    case 12: {
      _localctx = _tracker.createInstance<SimpleExprListContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5401);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::ROW_SYMBOL) {
        setState(5400);
        match(MySQLParser::ROW_SYMBOL);
      }
      setState(5403);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5404);
      exprList();
      setState(5405);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 13: {
      _localctx = _tracker.createInstance<SimpleExprSubQueryContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5408);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EXISTS_SYMBOL) {
        setState(5407);
        match(MySQLParser::EXISTS_SYMBOL);
      }
      setState(5410);
      subquery();
      break;
    }

    case 14: {
      _localctx = _tracker.createInstance<SimpleExprOdbcContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5411);
      match(MySQLParser::OPEN_CURLY_SYMBOL);
      setState(5412);
      identifier();
      setState(5413);
      expr(0);
      setState(5414);
      match(MySQLParser::CLOSE_CURLY_SYMBOL);
      break;
    }

    case 15: {
      _localctx = _tracker.createInstance<SimpleExprMatchContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5416);
      match(MySQLParser::MATCH_SYMBOL);
      setState(5417);
      identListArg();
      setState(5418);
      match(MySQLParser::AGAINST_SYMBOL);
      setState(5419);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5420);
      bitExpr(0);
      setState(5422);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::IN_SYMBOL || _la == MySQLParser::WITH_SYMBOL) {
        setState(5421);
        fulltextOptions();
      }
      setState(5424);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 16: {
      _localctx = _tracker.createInstance<SimpleExprBinaryContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5426);
      match(MySQLParser::BINARY_SYMBOL);
      setState(5427);
      simpleExpr(8);
      break;
    }

    case 17: {
      _localctx = _tracker.createInstance<SimpleExprCastContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5428);
      match(MySQLParser::CAST_SYMBOL);
      setState(5429);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5430);
      expr(0);
      setState(5431);
      match(MySQLParser::AS_SYMBOL);
      setState(5432);
      castType();
      setState(5433);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 18: {
      _localctx = _tracker.createInstance<SimpleExprCaseContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5435);
      match(MySQLParser::CASE_SYMBOL);
      setState(5437);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 694, _ctx)) {
      case 1: {
        setState(5436);
        expr(0);
        break;
      }

      }
      setState(5442); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(5439);
        whenExpression();
        setState(5440);
        thenExpression();
        setState(5444); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == MySQLParser::WHEN_SYMBOL);
      setState(5447);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::ELSE_SYMBOL) {
        setState(5446);
        elseExpression();
      }
      setState(5449);
      match(MySQLParser::END_SYMBOL);
      break;
    }

    case 19: {
      _localctx = _tracker.createInstance<SimpleExprConvertContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5451);
      match(MySQLParser::CONVERT_SYMBOL);
      setState(5452);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5453);
      expr(0);
      setState(5454);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5455);
      castType();
      setState(5456);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 20: {
      _localctx = _tracker.createInstance<SimpleExprConvertUsingContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5458);
      match(MySQLParser::CONVERT_SYMBOL);
      setState(5459);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5460);
      expr(0);
      setState(5461);
      match(MySQLParser::USING_SYMBOL);
      setState(5462);
      charsetName();
      setState(5463);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 21: {
      _localctx = _tracker.createInstance<SimpleExprDefaultContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5465);
      match(MySQLParser::DEFAULT_SYMBOL);
      setState(5466);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5467);
      simpleIdentifier();
      setState(5468);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 22: {
      _localctx = _tracker.createInstance<SimpleExprValuesContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5470);
      match(MySQLParser::VALUES_SYMBOL);
      setState(5471);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5472);
      simpleIdentifier();
      setState(5473);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 23: {
      _localctx = _tracker.createInstance<SimpleExprIntervalContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5475);
      match(MySQLParser::INTERVAL_SYMBOL);
      setState(5476);
      expr(0);
      setState(5477);
      interval();
      setState(5478);
      match(MySQLParser::PLUS_OPERATOR);
      setState(5479);
      expr(0);
      break;
    }

    }
    _ctx->stop = _input->LT(-1);
    setState(5491);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 699, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(5489);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 698, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<SimpleExprConcatContext>(_tracker.createInstance<SimpleExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSimpleExpr);
          setState(5483);

          if (!(precpred(_ctx, 15))) throw FailedPredicateException(this, "precpred(_ctx, 15)");
          setState(5484);
          match(MySQLParser::CONCAT_PIPES_SYMBOL);
          setState(5485);
          simpleExpr(16);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<SimpleExprCollateContext>(_tracker.createInstance<SimpleExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSimpleExpr);
          setState(5486);

          if (!(precpred(_ctx, 21))) throw FailedPredicateException(this, "precpred(_ctx, 21)");
          setState(5487);
          match(MySQLParser::COLLATE_SYMBOL);
          setState(5488);
          textOrIdentifier();
          break;
        }

        } 
      }
      setState(5493);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 699, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- JsonOperatorContext ------------------------------------------------------------------

MySQLParser::JsonOperatorContext::JsonOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::JsonOperatorContext::JSON_SEPARATOR_SYMBOL() {
  return getToken(MySQLParser::JSON_SEPARATOR_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::JsonOperatorContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::JsonOperatorContext::JSON_UNQUOTED_SEPARATOR_SYMBOL() {
  return getToken(MySQLParser::JSON_UNQUOTED_SEPARATOR_SYMBOL, 0);
}


size_t MySQLParser::JsonOperatorContext::getRuleIndex() const {
  return MySQLParser::RuleJsonOperator;
}

void MySQLParser::JsonOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJsonOperator(this);
}

void MySQLParser::JsonOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJsonOperator(this);
}


antlrcpp::Any MySQLParser::JsonOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitJsonOperator(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::JsonOperatorContext* MySQLParser::jsonOperator() {
  JsonOperatorContext *_localctx = _tracker.createInstance<JsonOperatorContext>(_ctx, getState());
  enterRule(_localctx, 662, MySQLParser::RuleJsonOperator);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5500);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 700, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5494);

      if (!(serverVersion >= 50708)) throw FailedPredicateException(this, "serverVersion >= 50708");
      setState(5495);
      match(MySQLParser::JSON_SEPARATOR_SYMBOL);
      setState(5496);
      textStringLiteral();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5497);

      if (!(serverVersion >= 50713)) throw FailedPredicateException(this, "serverVersion >= 50713");
      setState(5498);
      match(MySQLParser::JSON_UNQUOTED_SEPARATOR_SYMBOL);
      setState(5499);
      textStringLiteral();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SumExprContext ------------------------------------------------------------------

MySQLParser::SumExprContext::SumExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SumExprContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::InSumExprContext* MySQLParser::SumExprContext::inSumExpr() {
  return getRuleContext<MySQLParser::InSumExprContext>(0);
}

tree::TerminalNode* MySQLParser::SumExprContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::AVG_SYMBOL() {
  return getToken(MySQLParser::AVG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::DISTINCT_SYMBOL() {
  return getToken(MySQLParser::DISTINCT_SYMBOL, 0);
}

MySQLParser::WindowingClauseContext* MySQLParser::SumExprContext::windowingClause() {
  return getRuleContext<MySQLParser::WindowingClauseContext>(0);
}

tree::TerminalNode* MySQLParser::SumExprContext::BIT_AND_SYMBOL() {
  return getToken(MySQLParser::BIT_AND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::BIT_OR_SYMBOL() {
  return getToken(MySQLParser::BIT_OR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::BIT_XOR_SYMBOL() {
  return getToken(MySQLParser::BIT_XOR_SYMBOL, 0);
}

MySQLParser::JsonFunctionContext* MySQLParser::SumExprContext::jsonFunction() {
  return getRuleContext<MySQLParser::JsonFunctionContext>(0);
}

tree::TerminalNode* MySQLParser::SumExprContext::MULT_OPERATOR() {
  return getToken(MySQLParser::MULT_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::COUNT_SYMBOL() {
  return getToken(MySQLParser::COUNT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

MySQLParser::ExprListContext* MySQLParser::SumExprContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

tree::TerminalNode* MySQLParser::SumExprContext::MIN_SYMBOL() {
  return getToken(MySQLParser::MIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::MAX_SYMBOL() {
  return getToken(MySQLParser::MAX_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::STD_SYMBOL() {
  return getToken(MySQLParser::STD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::VARIANCE_SYMBOL() {
  return getToken(MySQLParser::VARIANCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::STDDEV_SAMP_SYMBOL() {
  return getToken(MySQLParser::STDDEV_SAMP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::VAR_SAMP_SYMBOL() {
  return getToken(MySQLParser::VAR_SAMP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::SUM_SYMBOL() {
  return getToken(MySQLParser::SUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::GROUP_CONCAT_SYMBOL() {
  return getToken(MySQLParser::GROUP_CONCAT_SYMBOL, 0);
}

MySQLParser::OrderClauseContext* MySQLParser::SumExprContext::orderClause() {
  return getRuleContext<MySQLParser::OrderClauseContext>(0);
}

tree::TerminalNode* MySQLParser::SumExprContext::SEPARATOR_SYMBOL() {
  return getToken(MySQLParser::SEPARATOR_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::SumExprContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}


size_t MySQLParser::SumExprContext::getRuleIndex() const {
  return MySQLParser::RuleSumExpr;
}

void MySQLParser::SumExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSumExpr(this);
}

void MySQLParser::SumExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSumExpr(this);
}


antlrcpp::Any MySQLParser::SumExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSumExpr(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SumExprContext* MySQLParser::sumExpr() {
  SumExprContext *_localctx = _tracker.createInstance<SumExprContext>(_ctx, getState());
  enterRule(_localctx, 664, MySQLParser::RuleSumExpr);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5633);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 723, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5502);
      dynamic_cast<SumExprContext *>(_localctx)->name = match(MySQLParser::AVG_SYMBOL);
      setState(5503);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5505);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 701, _ctx)) {
      case 1: {
        setState(5504);
        match(MySQLParser::DISTINCT_SYMBOL);
        break;
      }

      }
      setState(5507);
      inSumExpr();
      setState(5508);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5511);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 702, _ctx)) {
      case 1: {
        setState(5509);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5510);
        windowingClause();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5513);
      dynamic_cast<SumExprContext *>(_localctx)->name = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 439) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 439)) & ((1ULL << (MySQLParser::BIT_AND_SYMBOL - 439))
        | (1ULL << (MySQLParser::BIT_OR_SYMBOL - 439))
        | (1ULL << (MySQLParser::BIT_XOR_SYMBOL - 439)))) != 0))) {
        dynamic_cast<SumExprContext *>(_localctx)->name = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5514);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5515);
      inSumExpr();
      setState(5516);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5519);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 703, _ctx)) {
      case 1: {
        setState(5517);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5518);
        windowingClause();
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5521);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(5522);
      jsonFunction();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5523);
      dynamic_cast<SumExprContext *>(_localctx)->name = match(MySQLParser::COUNT_SYMBOL);
      setState(5524);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5526);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::ALL_SYMBOL) {
        setState(5525);
        match(MySQLParser::ALL_SYMBOL);
      }
      setState(5528);
      match(MySQLParser::MULT_OPERATOR);
      setState(5529);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5532);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 705, _ctx)) {
      case 1: {
        setState(5530);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5531);
        windowingClause();
        break;
      }

      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5534);
      dynamic_cast<SumExprContext *>(_localctx)->name = match(MySQLParser::COUNT_SYMBOL);
      setState(5535);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5543);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 707, _ctx)) {
      case 1: {
        setState(5537);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ALL_SYMBOL) {
          setState(5536);
          match(MySQLParser::ALL_SYMBOL);
        }
        setState(5539);
        match(MySQLParser::MULT_OPERATOR);
        break;
      }

      case 2: {
        setState(5540);
        inSumExpr();
        break;
      }

      case 3: {
        setState(5541);
        match(MySQLParser::DISTINCT_SYMBOL);
        setState(5542);
        exprList();
        break;
      }

      }
      setState(5545);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5548);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 708, _ctx)) {
      case 1: {
        setState(5546);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5547);
        windowingClause();
        break;
      }

      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(5550);
      dynamic_cast<SumExprContext *>(_localctx)->name = match(MySQLParser::MIN_SYMBOL);
      setState(5551);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5553);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 709, _ctx)) {
      case 1: {
        setState(5552);
        match(MySQLParser::DISTINCT_SYMBOL);
        break;
      }

      }
      setState(5555);
      inSumExpr();
      setState(5556);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5559);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 710, _ctx)) {
      case 1: {
        setState(5557);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5558);
        windowingClause();
        break;
      }

      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(5561);
      dynamic_cast<SumExprContext *>(_localctx)->name = match(MySQLParser::MAX_SYMBOL);
      setState(5562);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5564);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 711, _ctx)) {
      case 1: {
        setState(5563);
        match(MySQLParser::DISTINCT_SYMBOL);
        break;
      }

      }
      setState(5566);
      inSumExpr();
      setState(5567);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5570);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 712, _ctx)) {
      case 1: {
        setState(5568);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5569);
        windowingClause();
        break;
      }

      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(5572);
      dynamic_cast<SumExprContext *>(_localctx)->name = match(MySQLParser::STD_SYMBOL);
      setState(5573);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5574);
      inSumExpr();
      setState(5575);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5578);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 713, _ctx)) {
      case 1: {
        setState(5576);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5577);
        windowingClause();
        break;
      }

      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(5580);
      dynamic_cast<SumExprContext *>(_localctx)->name = match(MySQLParser::VARIANCE_SYMBOL);
      setState(5581);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5582);
      inSumExpr();
      setState(5583);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5586);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 714, _ctx)) {
      case 1: {
        setState(5584);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5585);
        windowingClause();
        break;
      }

      }
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(5588);
      dynamic_cast<SumExprContext *>(_localctx)->name = match(MySQLParser::STDDEV_SAMP_SYMBOL);
      setState(5589);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5590);
      inSumExpr();
      setState(5591);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5594);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 715, _ctx)) {
      case 1: {
        setState(5592);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5593);
        windowingClause();
        break;
      }

      }
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(5596);
      dynamic_cast<SumExprContext *>(_localctx)->name = match(MySQLParser::VAR_SAMP_SYMBOL);
      setState(5597);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5598);
      inSumExpr();
      setState(5599);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5602);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 716, _ctx)) {
      case 1: {
        setState(5600);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5601);
        windowingClause();
        break;
      }

      }
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(5604);
      dynamic_cast<SumExprContext *>(_localctx)->name = match(MySQLParser::SUM_SYMBOL);
      setState(5605);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5607);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 717, _ctx)) {
      case 1: {
        setState(5606);
        match(MySQLParser::DISTINCT_SYMBOL);
        break;
      }

      }
      setState(5609);
      inSumExpr();
      setState(5610);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5613);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 718, _ctx)) {
      case 1: {
        setState(5611);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5612);
        windowingClause();
        break;
      }

      }
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(5615);
      dynamic_cast<SumExprContext *>(_localctx)->name = match(MySQLParser::GROUP_CONCAT_SYMBOL);
      setState(5616);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5618);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 719, _ctx)) {
      case 1: {
        setState(5617);
        match(MySQLParser::DISTINCT_SYMBOL);
        break;
      }

      }
      setState(5620);
      exprList();
      setState(5622);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::ORDER_SYMBOL) {
        setState(5621);
        orderClause();
      }
      setState(5626);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::SEPARATOR_SYMBOL) {
        setState(5624);
        match(MySQLParser::SEPARATOR_SYMBOL);
        setState(5625);
        textString();
      }
      setState(5628);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5631);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 722, _ctx)) {
      case 1: {
        setState(5629);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5630);
        windowingClause();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupingOperationContext ------------------------------------------------------------------

MySQLParser::GroupingOperationContext::GroupingOperationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::GroupingOperationContext::GROUPING_SYMBOL() {
  return getToken(MySQLParser::GROUPING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GroupingOperationContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprListContext* MySQLParser::GroupingOperationContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

tree::TerminalNode* MySQLParser::GroupingOperationContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::GroupingOperationContext::getRuleIndex() const {
  return MySQLParser::RuleGroupingOperation;
}

void MySQLParser::GroupingOperationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupingOperation(this);
}

void MySQLParser::GroupingOperationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupingOperation(this);
}


antlrcpp::Any MySQLParser::GroupingOperationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitGroupingOperation(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GroupingOperationContext* MySQLParser::groupingOperation() {
  GroupingOperationContext *_localctx = _tracker.createInstance<GroupingOperationContext>(_ctx, getState());
  enterRule(_localctx, 666, MySQLParser::RuleGroupingOperation);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5635);
    match(MySQLParser::GROUPING_SYMBOL);
    setState(5636);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(5637);
    exprList();
    setState(5638);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFunctionCallContext ------------------------------------------------------------------

MySQLParser::WindowFunctionCallContext::WindowFunctionCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ParenthesesContext* MySQLParser::WindowFunctionCallContext::parentheses() {
  return getRuleContext<MySQLParser::ParenthesesContext>(0);
}

MySQLParser::WindowingClauseContext* MySQLParser::WindowFunctionCallContext::windowingClause() {
  return getRuleContext<MySQLParser::WindowingClauseContext>(0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::ROW_NUMBER_SYMBOL() {
  return getToken(MySQLParser::ROW_NUMBER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::RANK_SYMBOL() {
  return getToken(MySQLParser::RANK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::DENSE_RANK_SYMBOL() {
  return getToken(MySQLParser::DENSE_RANK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::CUME_DIST_SYMBOL() {
  return getToken(MySQLParser::CUME_DIST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::PERCENT_RANK_SYMBOL() {
  return getToken(MySQLParser::PERCENT_RANK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::NTILE_SYMBOL() {
  return getToken(MySQLParser::NTILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::SimpleExprContext* MySQLParser::WindowFunctionCallContext::simpleExpr() {
  return getRuleContext<MySQLParser::SimpleExprContext>(0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::WindowFunctionCallContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::LEAD_SYMBOL() {
  return getToken(MySQLParser::LEAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::LAG_SYMBOL() {
  return getToken(MySQLParser::LAG_SYMBOL, 0);
}

MySQLParser::LeadLagInfoContext* MySQLParser::WindowFunctionCallContext::leadLagInfo() {
  return getRuleContext<MySQLParser::LeadLagInfoContext>(0);
}

MySQLParser::NullTreatmentContext* MySQLParser::WindowFunctionCallContext::nullTreatment() {
  return getRuleContext<MySQLParser::NullTreatmentContext>(0);
}

MySQLParser::ExprWithParenthesesContext* MySQLParser::WindowFunctionCallContext::exprWithParentheses() {
  return getRuleContext<MySQLParser::ExprWithParenthesesContext>(0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::FIRST_VALUE_SYMBOL() {
  return getToken(MySQLParser::FIRST_VALUE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::LAST_VALUE_SYMBOL() {
  return getToken(MySQLParser::LAST_VALUE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::NTH_VALUE_SYMBOL() {
  return getToken(MySQLParser::NTH_VALUE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::FIRST_SYMBOL() {
  return getToken(MySQLParser::FIRST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::LAST_SYMBOL() {
  return getToken(MySQLParser::LAST_SYMBOL, 0);
}


size_t MySQLParser::WindowFunctionCallContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFunctionCall;
}

void MySQLParser::WindowFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFunctionCall(this);
}

void MySQLParser::WindowFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFunctionCall(this);
}


antlrcpp::Any MySQLParser::WindowFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitWindowFunctionCall(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowFunctionCallContext* MySQLParser::windowFunctionCall() {
  WindowFunctionCallContext *_localctx = _tracker.createInstance<WindowFunctionCallContext>(_ctx, getState());
  enterRule(_localctx, 668, MySQLParser::RuleWindowFunctionCall);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5684);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CUME_DIST_SYMBOL:
      case MySQLParser::DENSE_RANK_SYMBOL:
      case MySQLParser::PERCENT_RANK_SYMBOL:
      case MySQLParser::RANK_SYMBOL:
      case MySQLParser::ROW_NUMBER_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(5640);
        _la = _input->LA(1);
        if (!(((((_la - 709) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 709)) & ((1ULL << (MySQLParser::CUME_DIST_SYMBOL - 709))
          | (1ULL << (MySQLParser::DENSE_RANK_SYMBOL - 709))
          | (1ULL << (MySQLParser::PERCENT_RANK_SYMBOL - 709))
          | (1ULL << (MySQLParser::RANK_SYMBOL - 709))
          | (1ULL << (MySQLParser::ROW_NUMBER_SYMBOL - 709)))) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(5641);
        parentheses();
        setState(5642);
        windowingClause();
        break;
      }

      case MySQLParser::NTILE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(5644);
        match(MySQLParser::NTILE_SYMBOL);
        setState(5645);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(5646);
        simpleExpr(0);
        setState(5647);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        setState(5648);
        windowingClause();
        break;
      }

      case MySQLParser::LAG_SYMBOL:
      case MySQLParser::LEAD_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(5650);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::LAG_SYMBOL

        || _la == MySQLParser::LEAD_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(5651);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(5652);
        expr(0);
        setState(5654);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::COMMA_SYMBOL) {
          setState(5653);
          leadLagInfo();
        }
        setState(5656);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        setState(5658);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::IGNORE_SYMBOL || _la == MySQLParser::RESPECT_SYMBOL) {
          setState(5657);
          nullTreatment();
        }
        setState(5660);
        windowingClause();
        break;
      }

      case MySQLParser::FIRST_VALUE_SYMBOL:
      case MySQLParser::LAST_VALUE_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(5662);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::FIRST_VALUE_SYMBOL

        || _la == MySQLParser::LAST_VALUE_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(5663);
        exprWithParentheses();
        setState(5665);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::IGNORE_SYMBOL || _la == MySQLParser::RESPECT_SYMBOL) {
          setState(5664);
          nullTreatment();
        }
        setState(5667);
        windowingClause();
        break;
      }

      case MySQLParser::NTH_VALUE_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(5669);
        match(MySQLParser::NTH_VALUE_SYMBOL);
        setState(5670);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(5671);
        expr(0);
        setState(5672);
        match(MySQLParser::COMMA_SYMBOL);
        setState(5673);
        simpleExpr(0);
        setState(5674);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        setState(5677);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::FROM_SYMBOL) {
          setState(5675);
          match(MySQLParser::FROM_SYMBOL);
          setState(5676);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::FIRST_SYMBOL

          || _la == MySQLParser::LAST_SYMBOL)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(5680);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::IGNORE_SYMBOL || _la == MySQLParser::RESPECT_SYMBOL) {
          setState(5679);
          nullTreatment();
        }
        setState(5682);
        windowingClause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowingClauseContext ------------------------------------------------------------------

MySQLParser::WindowingClauseContext::WindowingClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WindowingClauseContext::OVER_SYMBOL() {
  return getToken(MySQLParser::OVER_SYMBOL, 0);
}

MySQLParser::WindowNameContext* MySQLParser::WindowingClauseContext::windowName() {
  return getRuleContext<MySQLParser::WindowNameContext>(0);
}

MySQLParser::WindowSpecContext* MySQLParser::WindowingClauseContext::windowSpec() {
  return getRuleContext<MySQLParser::WindowSpecContext>(0);
}


size_t MySQLParser::WindowingClauseContext::getRuleIndex() const {
  return MySQLParser::RuleWindowingClause;
}

void MySQLParser::WindowingClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowingClause(this);
}

void MySQLParser::WindowingClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowingClause(this);
}


antlrcpp::Any MySQLParser::WindowingClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitWindowingClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowingClauseContext* MySQLParser::windowingClause() {
  WindowingClauseContext *_localctx = _tracker.createInstance<WindowingClauseContext>(_ctx, getState());
  enterRule(_localctx, 670, MySQLParser::RuleWindowingClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5686);
    match(MySQLParser::OVER_SYMBOL);
    setState(5689);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 730, _ctx)) {
    case 1: {
      setState(5687);
      windowName();
      break;
    }

    case 2: {
      setState(5688);
      windowSpec();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LeadLagInfoContext ------------------------------------------------------------------

MySQLParser::LeadLagInfoContext::LeadLagInfoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::LeadLagInfoContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::LeadLagInfoContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

MySQLParser::Ulonglong_numberContext* MySQLParser::LeadLagInfoContext::ulonglong_number() {
  return getRuleContext<MySQLParser::Ulonglong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::LeadLagInfoContext::PARAM_MARKER() {
  return getToken(MySQLParser::PARAM_MARKER, 0);
}

MySQLParser::ExprContext* MySQLParser::LeadLagInfoContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}


size_t MySQLParser::LeadLagInfoContext::getRuleIndex() const {
  return MySQLParser::RuleLeadLagInfo;
}

void MySQLParser::LeadLagInfoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLeadLagInfo(this);
}

void MySQLParser::LeadLagInfoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLeadLagInfo(this);
}


antlrcpp::Any MySQLParser::LeadLagInfoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLeadLagInfo(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LeadLagInfoContext* MySQLParser::leadLagInfo() {
  LeadLagInfoContext *_localctx = _tracker.createInstance<LeadLagInfoContext>(_ctx, getState());
  enterRule(_localctx, 672, MySQLParser::RuleLeadLagInfo);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5691);
    match(MySQLParser::COMMA_SYMBOL);
    setState(5694);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INT_NUMBER:
      case MySQLParser::LONG_NUMBER:
      case MySQLParser::ULONGLONG_NUMBER:
      case MySQLParser::DECIMAL_NUMBER:
      case MySQLParser::FLOAT_NUMBER: {
        setState(5692);
        ulonglong_number();
        break;
      }

      case MySQLParser::PARAM_MARKER: {
        setState(5693);
        match(MySQLParser::PARAM_MARKER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(5698);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::COMMA_SYMBOL) {
      setState(5696);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5697);
      expr(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NullTreatmentContext ------------------------------------------------------------------

MySQLParser::NullTreatmentContext::NullTreatmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::NullTreatmentContext::NULLS_SYMBOL() {
  return getToken(MySQLParser::NULLS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NullTreatmentContext::RESPECT_SYMBOL() {
  return getToken(MySQLParser::RESPECT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NullTreatmentContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}


size_t MySQLParser::NullTreatmentContext::getRuleIndex() const {
  return MySQLParser::RuleNullTreatment;
}

void MySQLParser::NullTreatmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullTreatment(this);
}

void MySQLParser::NullTreatmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullTreatment(this);
}


antlrcpp::Any MySQLParser::NullTreatmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitNullTreatment(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::NullTreatmentContext* MySQLParser::nullTreatment() {
  NullTreatmentContext *_localctx = _tracker.createInstance<NullTreatmentContext>(_ctx, getState());
  enterRule(_localctx, 674, MySQLParser::RuleNullTreatment);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5700);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::IGNORE_SYMBOL || _la == MySQLParser::RESPECT_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5701);
    match(MySQLParser::NULLS_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JsonFunctionContext ------------------------------------------------------------------

MySQLParser::JsonFunctionContext::JsonFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::JsonFunctionContext::JSON_ARRAYAGG_SYMBOL() {
  return getToken(MySQLParser::JSON_ARRAYAGG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::JsonFunctionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::InSumExprContext *> MySQLParser::JsonFunctionContext::inSumExpr() {
  return getRuleContexts<MySQLParser::InSumExprContext>();
}

MySQLParser::InSumExprContext* MySQLParser::JsonFunctionContext::inSumExpr(size_t i) {
  return getRuleContext<MySQLParser::InSumExprContext>(i);
}

tree::TerminalNode* MySQLParser::JsonFunctionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::WindowingClauseContext* MySQLParser::JsonFunctionContext::windowingClause() {
  return getRuleContext<MySQLParser::WindowingClauseContext>(0);
}

tree::TerminalNode* MySQLParser::JsonFunctionContext::JSON_OBJECTAGG_SYMBOL() {
  return getToken(MySQLParser::JSON_OBJECTAGG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::JsonFunctionContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}


size_t MySQLParser::JsonFunctionContext::getRuleIndex() const {
  return MySQLParser::RuleJsonFunction;
}

void MySQLParser::JsonFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJsonFunction(this);
}

void MySQLParser::JsonFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJsonFunction(this);
}


antlrcpp::Any MySQLParser::JsonFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitJsonFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::JsonFunctionContext* MySQLParser::jsonFunction() {
  JsonFunctionContext *_localctx = _tracker.createInstance<JsonFunctionContext>(_ctx, getState());
  enterRule(_localctx, 676, MySQLParser::RuleJsonFunction);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5719);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::JSON_ARRAYAGG_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(5703);
        match(MySQLParser::JSON_ARRAYAGG_SYMBOL);
        setState(5704);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(5705);
        inSumExpr();
        setState(5706);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        setState(5708);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 733, _ctx)) {
        case 1: {
          setState(5707);
          windowingClause();
          break;
        }

        }
        break;
      }

      case MySQLParser::JSON_OBJECTAGG_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(5710);
        match(MySQLParser::JSON_OBJECTAGG_SYMBOL);
        setState(5711);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(5712);
        inSumExpr();
        setState(5713);
        match(MySQLParser::COMMA_SYMBOL);
        setState(5714);
        inSumExpr();
        setState(5715);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        setState(5717);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 734, _ctx)) {
        case 1: {
          setState(5716);
          windowingClause();
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InSumExprContext ------------------------------------------------------------------

MySQLParser::InSumExprContext::InSumExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ExprContext* MySQLParser::InSumExprContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::InSumExprContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}


size_t MySQLParser::InSumExprContext::getRuleIndex() const {
  return MySQLParser::RuleInSumExpr;
}

void MySQLParser::InSumExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInSumExpr(this);
}

void MySQLParser::InSumExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInSumExpr(this);
}


antlrcpp::Any MySQLParser::InSumExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitInSumExpr(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InSumExprContext* MySQLParser::inSumExpr() {
  InSumExprContext *_localctx = _tracker.createInstance<InSumExprContext>(_ctx, getState());
  enterRule(_localctx, 678, MySQLParser::RuleInSumExpr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5722);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 736, _ctx)) {
    case 1: {
      setState(5721);
      match(MySQLParser::ALL_SYMBOL);
      break;
    }

    }
    setState(5724);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentListArgContext ------------------------------------------------------------------

MySQLParser::IdentListArgContext::IdentListArgContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentListContext* MySQLParser::IdentListArgContext::identList() {
  return getRuleContext<MySQLParser::IdentListContext>(0);
}

tree::TerminalNode* MySQLParser::IdentListArgContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentListArgContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::IdentListArgContext::getRuleIndex() const {
  return MySQLParser::RuleIdentListArg;
}

void MySQLParser::IdentListArgContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentListArg(this);
}

void MySQLParser::IdentListArgContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentListArg(this);
}


antlrcpp::Any MySQLParser::IdentListArgContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIdentListArg(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentListArgContext* MySQLParser::identListArg() {
  IdentListArgContext *_localctx = _tracker.createInstance<IdentListArgContext>(_ctx, getState());
  enterRule(_localctx, 680, MySQLParser::RuleIdentListArg);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5731);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 737, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5726);
      identList();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5727);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5728);
      identList();
      setState(5729);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentListContext ------------------------------------------------------------------

MySQLParser::IdentListContext::IdentListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::SimpleIdentifierContext *> MySQLParser::IdentListContext::simpleIdentifier() {
  return getRuleContexts<MySQLParser::SimpleIdentifierContext>();
}

MySQLParser::SimpleIdentifierContext* MySQLParser::IdentListContext::simpleIdentifier(size_t i) {
  return getRuleContext<MySQLParser::SimpleIdentifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::IdentListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::IdentListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::IdentListContext::getRuleIndex() const {
  return MySQLParser::RuleIdentList;
}

void MySQLParser::IdentListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentList(this);
}

void MySQLParser::IdentListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentList(this);
}


antlrcpp::Any MySQLParser::IdentListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIdentList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentListContext* MySQLParser::identList() {
  IdentListContext *_localctx = _tracker.createInstance<IdentListContext>(_ctx, getState());
  enterRule(_localctx, 682, MySQLParser::RuleIdentList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5733);
    simpleIdentifier();
    setState(5738);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(5734);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5735);
      simpleIdentifier();
      setState(5740);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FulltextOptionsContext ------------------------------------------------------------------

MySQLParser::FulltextOptionsContext::FulltextOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::FulltextOptionsContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FulltextOptionsContext::BOOLEAN_SYMBOL() {
  return getToken(MySQLParser::BOOLEAN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FulltextOptionsContext::MODE_SYMBOL() {
  return getToken(MySQLParser::MODE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FulltextOptionsContext::NATURAL_SYMBOL() {
  return getToken(MySQLParser::NATURAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FulltextOptionsContext::LANGUAGE_SYMBOL() {
  return getToken(MySQLParser::LANGUAGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FulltextOptionsContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FulltextOptionsContext::QUERY_SYMBOL() {
  return getToken(MySQLParser::QUERY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FulltextOptionsContext::EXPANSION_SYMBOL() {
  return getToken(MySQLParser::EXPANSION_SYMBOL, 0);
}


size_t MySQLParser::FulltextOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleFulltextOptions;
}

void MySQLParser::FulltextOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFulltextOptions(this);
}

void MySQLParser::FulltextOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFulltextOptions(this);
}


antlrcpp::Any MySQLParser::FulltextOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFulltextOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FulltextOptionsContext* MySQLParser::fulltextOptions() {
  FulltextOptionsContext *_localctx = _tracker.createInstance<FulltextOptionsContext>(_ctx, getState());
  enterRule(_localctx, 684, MySQLParser::RuleFulltextOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5756);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 740, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5741);
      match(MySQLParser::IN_SYMBOL);
      setState(5742);
      match(MySQLParser::BOOLEAN_SYMBOL);
      setState(5743);
      match(MySQLParser::MODE_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5744);
      match(MySQLParser::IN_SYMBOL);
      setState(5745);
      match(MySQLParser::NATURAL_SYMBOL);
      setState(5746);
      match(MySQLParser::LANGUAGE_SYMBOL);
      setState(5747);
      match(MySQLParser::MODE_SYMBOL);
      setState(5751);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::WITH_SYMBOL) {
        setState(5748);
        match(MySQLParser::WITH_SYMBOL);
        setState(5749);
        match(MySQLParser::QUERY_SYMBOL);
        setState(5750);
        match(MySQLParser::EXPANSION_SYMBOL);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5753);
      match(MySQLParser::WITH_SYMBOL);
      setState(5754);
      match(MySQLParser::QUERY_SYMBOL);
      setState(5755);
      match(MySQLParser::EXPANSION_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RuntimeFunctionCallContext ------------------------------------------------------------------

MySQLParser::RuntimeFunctionCallContext::RuntimeFunctionCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprListContext* MySQLParser::RuntimeFunctionCallContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::CHAR_SYMBOL() {
  return getToken(MySQLParser::CHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

MySQLParser::CharsetNameContext* MySQLParser::RuntimeFunctionCallContext::charsetName() {
  return getRuleContext<MySQLParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::CURRENT_USER_SYMBOL() {
  return getToken(MySQLParser::CURRENT_USER_SYMBOL, 0);
}

MySQLParser::ParenthesesContext* MySQLParser::RuntimeFunctionCallContext::parentheses() {
  return getRuleContext<MySQLParser::ParenthesesContext>(0);
}

MySQLParser::ExprWithParenthesesContext* MySQLParser::RuntimeFunctionCallContext::exprWithParentheses() {
  return getRuleContext<MySQLParser::ExprWithParenthesesContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::DATE_SYMBOL() {
  return getToken(MySQLParser::DATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::DAY_SYMBOL() {
  return getToken(MySQLParser::DAY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::HOUR_SYMBOL() {
  return getToken(MySQLParser::HOUR_SYMBOL, 0);
}

std::vector<MySQLParser::ExprContext *> MySQLParser::RuntimeFunctionCallContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext* MySQLParser::RuntimeFunctionCallContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::RuntimeFunctionCallContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::INSERT_SYMBOL() {
  return getToken(MySQLParser::INSERT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::INTERVAL_SYMBOL() {
  return getToken(MySQLParser::INTERVAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::LEFT_SYMBOL() {
  return getToken(MySQLParser::LEFT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::MINUTE_SYMBOL() {
  return getToken(MySQLParser::MINUTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::MONTH_SYMBOL() {
  return getToken(MySQLParser::MONTH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::RIGHT_SYMBOL() {
  return getToken(MySQLParser::RIGHT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::SECOND_SYMBOL() {
  return getToken(MySQLParser::SECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::TIME_SYMBOL() {
  return getToken(MySQLParser::TIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::TIMESTAMP_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_SYMBOL, 0);
}

MySQLParser::TrimFunctionContext* MySQLParser::RuntimeFunctionCallContext::trimFunction() {
  return getRuleContext<MySQLParser::TrimFunctionContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::VALUES_SYMBOL() {
  return getToken(MySQLParser::VALUES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::YEAR_SYMBOL() {
  return getToken(MySQLParser::YEAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::ADDDATE_SYMBOL() {
  return getToken(MySQLParser::ADDDATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::SUBDATE_SYMBOL() {
  return getToken(MySQLParser::SUBDATE_SYMBOL, 0);
}

MySQLParser::IntervalContext* MySQLParser::RuntimeFunctionCallContext::interval() {
  return getRuleContext<MySQLParser::IntervalContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::CURDATE_SYMBOL() {
  return getToken(MySQLParser::CURDATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::CURTIME_SYMBOL() {
  return getToken(MySQLParser::CURTIME_SYMBOL, 0);
}

MySQLParser::TimeFunctionParametersContext* MySQLParser::RuntimeFunctionCallContext::timeFunctionParameters() {
  return getRuleContext<MySQLParser::TimeFunctionParametersContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::DATE_ADD_SYMBOL() {
  return getToken(MySQLParser::DATE_ADD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::DATE_SUB_SYMBOL() {
  return getToken(MySQLParser::DATE_SUB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::EXTRACT_SYMBOL() {
  return getToken(MySQLParser::EXTRACT_SYMBOL, 0);
}

MySQLParser::DateTimeTtypeContext* MySQLParser::RuntimeFunctionCallContext::dateTimeTtype() {
  return getRuleContext<MySQLParser::DateTimeTtypeContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::GET_FORMAT_SYMBOL() {
  return getToken(MySQLParser::GET_FORMAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::NOW_SYMBOL() {
  return getToken(MySQLParser::NOW_SYMBOL, 0);
}

MySQLParser::BitExprContext* MySQLParser::RuntimeFunctionCallContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::POSITION_SYMBOL() {
  return getToken(MySQLParser::POSITION_SYMBOL, 0);
}

MySQLParser::SubstringFunctionContext* MySQLParser::RuntimeFunctionCallContext::substringFunction() {
  return getRuleContext<MySQLParser::SubstringFunctionContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::SYSDATE_SYMBOL() {
  return getToken(MySQLParser::SYSDATE_SYMBOL, 0);
}

MySQLParser::IntervalTimeStampContext* MySQLParser::RuntimeFunctionCallContext::intervalTimeStamp() {
  return getRuleContext<MySQLParser::IntervalTimeStampContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::TIMESTAMP_ADD_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_ADD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::TIMESTAMP_DIFF_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_DIFF_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::UTC_DATE_SYMBOL() {
  return getToken(MySQLParser::UTC_DATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::UTC_TIME_SYMBOL() {
  return getToken(MySQLParser::UTC_TIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::UTC_TIMESTAMP_SYMBOL() {
  return getToken(MySQLParser::UTC_TIMESTAMP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::ASCII_SYMBOL() {
  return getToken(MySQLParser::ASCII_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::CHARSET_SYMBOL() {
  return getToken(MySQLParser::CHARSET_SYMBOL, 0);
}

MySQLParser::ExprListWithParenthesesContext* MySQLParser::RuntimeFunctionCallContext::exprListWithParentheses() {
  return getRuleContext<MySQLParser::ExprListWithParenthesesContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::COALESCE_SYMBOL() {
  return getToken(MySQLParser::COALESCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::COLLATION_SYMBOL() {
  return getToken(MySQLParser::COLLATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::DATABASE_SYMBOL() {
  return getToken(MySQLParser::DATABASE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::IF_SYMBOL() {
  return getToken(MySQLParser::IF_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::FORMAT_SYMBOL() {
  return getToken(MySQLParser::FORMAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::MOD_SYMBOL() {
  return getToken(MySQLParser::MOD_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::RuntimeFunctionCallContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::OLD_PASSWORD_SYMBOL() {
  return getToken(MySQLParser::OLD_PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::QUARTER_SYMBOL() {
  return getToken(MySQLParser::QUARTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::REPEAT_SYMBOL() {
  return getToken(MySQLParser::REPEAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::REVERSE_SYMBOL() {
  return getToken(MySQLParser::REVERSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::ROW_COUNT_SYMBOL() {
  return getToken(MySQLParser::ROW_COUNT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::TRUNCATE_SYMBOL() {
  return getToken(MySQLParser::TRUNCATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::WEEK_SYMBOL() {
  return getToken(MySQLParser::WEEK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::WEIGHT_STRING_SYMBOL() {
  return getToken(MySQLParser::WEIGHT_STRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

MySQLParser::WsNumCodepointsContext* MySQLParser::RuntimeFunctionCallContext::wsNumCodepoints() {
  return getRuleContext<MySQLParser::WsNumCodepointsContext>(0);
}

std::vector<MySQLParser::Ulong_numberContext *> MySQLParser::RuntimeFunctionCallContext::ulong_number() {
  return getRuleContexts<MySQLParser::Ulong_numberContext>();
}

MySQLParser::Ulong_numberContext* MySQLParser::RuntimeFunctionCallContext::ulong_number(size_t i) {
  return getRuleContext<MySQLParser::Ulong_numberContext>(i);
}

MySQLParser::WeightStringLevelsContext* MySQLParser::RuntimeFunctionCallContext::weightStringLevels() {
  return getRuleContext<MySQLParser::WeightStringLevelsContext>(0);
}

MySQLParser::GeometryFunctionContext* MySQLParser::RuntimeFunctionCallContext::geometryFunction() {
  return getRuleContext<MySQLParser::GeometryFunctionContext>(0);
}


size_t MySQLParser::RuntimeFunctionCallContext::getRuleIndex() const {
  return MySQLParser::RuleRuntimeFunctionCall;
}

void MySQLParser::RuntimeFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRuntimeFunctionCall(this);
}

void MySQLParser::RuntimeFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRuntimeFunctionCall(this);
}


antlrcpp::Any MySQLParser::RuntimeFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRuntimeFunctionCall(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RuntimeFunctionCallContext* MySQLParser::runtimeFunctionCall() {
  RuntimeFunctionCallContext *_localctx = _tracker.createInstance<RuntimeFunctionCallContext>(_ctx, getState());
  enterRule(_localctx, 686, MySQLParser::RuleRuntimeFunctionCall);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6032);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 758, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5758);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::CHAR_SYMBOL);
      setState(5759);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5760);
      exprList();
      setState(5763);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::USING_SYMBOL) {
        setState(5761);
        match(MySQLParser::USING_SYMBOL);
        setState(5762);
        charsetName();
      }
      setState(5765);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5767);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::CURRENT_USER_SYMBOL);
      setState(5769);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 742, _ctx)) {
      case 1: {
        setState(5768);
        parentheses();
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5771);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::DATE_SYMBOL);
      setState(5772);
      exprWithParentheses();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5773);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::DAY_SYMBOL);
      setState(5774);
      exprWithParentheses();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5775);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::HOUR_SYMBOL);
      setState(5776);
      exprWithParentheses();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(5777);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::INSERT_SYMBOL);
      setState(5778);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5779);
      expr(0);
      setState(5780);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5781);
      expr(0);
      setState(5782);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5783);
      expr(0);
      setState(5784);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5785);
      expr(0);
      setState(5786);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(5788);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::INTERVAL_SYMBOL);
      setState(5789);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5790);
      expr(0);
      setState(5793); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(5791);
        match(MySQLParser::COMMA_SYMBOL);
        setState(5792);
        expr(0);
        setState(5795); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == MySQLParser::COMMA_SYMBOL);
      setState(5797);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(5799);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::LEFT_SYMBOL);
      setState(5800);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5801);
      expr(0);
      setState(5802);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5803);
      expr(0);
      setState(5804);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(5806);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::MINUTE_SYMBOL);
      setState(5807);
      exprWithParentheses();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(5808);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::MONTH_SYMBOL);
      setState(5809);
      exprWithParentheses();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(5810);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::RIGHT_SYMBOL);
      setState(5811);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5812);
      expr(0);
      setState(5813);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5814);
      expr(0);
      setState(5815);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(5817);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::SECOND_SYMBOL);
      setState(5818);
      exprWithParentheses();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(5819);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::TIME_SYMBOL);
      setState(5820);
      exprWithParentheses();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(5821);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::TIMESTAMP_SYMBOL);
      setState(5822);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5823);
      expr(0);
      setState(5826);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(5824);
        match(MySQLParser::COMMA_SYMBOL);
        setState(5825);
        expr(0);
      }
      setState(5828);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(5830);
      trimFunction();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(5831);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::USER_SYMBOL);
      setState(5832);
      parentheses();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(5833);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::VALUES_SYMBOL);
      setState(5834);
      exprWithParentheses();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(5835);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::YEAR_SYMBOL);
      setState(5836);
      exprWithParentheses();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(5837);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::ADDDATE_SYMBOL || _la == MySQLParser::SUBDATE_SYMBOL)) {
        dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5838);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5839);
      expr(0);
      setState(5840);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5846);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 745, _ctx)) {
      case 1: {
        setState(5841);
        expr(0);
        break;
      }

      case 2: {
        setState(5842);
        match(MySQLParser::INTERVAL_SYMBOL);
        setState(5843);
        expr(0);
        setState(5844);
        interval();
        break;
      }

      }
      setState(5848);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(5850);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::CURDATE_SYMBOL);
      setState(5852);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 746, _ctx)) {
      case 1: {
        setState(5851);
        parentheses();
        break;
      }

      }
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(5854);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::CURTIME_SYMBOL);
      setState(5856);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 747, _ctx)) {
      case 1: {
        setState(5855);
        timeFunctionParameters();
        break;
      }

      }
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(5858);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::DATE_ADD_SYMBOL

      || _la == MySQLParser::DATE_SUB_SYMBOL)) {
        dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5859);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5860);
      expr(0);
      setState(5861);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5862);
      match(MySQLParser::INTERVAL_SYMBOL);
      setState(5863);
      expr(0);
      setState(5864);
      interval();
      setState(5865);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(5867);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::EXTRACT_SYMBOL);
      setState(5868);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5869);
      interval();
      setState(5870);
      match(MySQLParser::FROM_SYMBOL);
      setState(5871);
      expr(0);
      setState(5872);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(5874);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::GET_FORMAT_SYMBOL);
      setState(5875);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5876);
      dateTimeTtype();
      setState(5877);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5878);
      expr(0);
      setState(5879);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(5881);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::NOW_SYMBOL);
      setState(5883);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 748, _ctx)) {
      case 1: {
        setState(5882);
        timeFunctionParameters();
        break;
      }

      }
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(5885);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::POSITION_SYMBOL);
      setState(5886);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5887);
      bitExpr(0);
      setState(5888);
      match(MySQLParser::IN_SYMBOL);
      setState(5889);
      expr(0);
      setState(5890);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(5892);
      substringFunction();
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(5893);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::SYSDATE_SYMBOL);
      setState(5895);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 749, _ctx)) {
      case 1: {
        setState(5894);
        timeFunctionParameters();
        break;
      }

      }
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(5897);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::TIMESTAMP_ADD_SYMBOL

      || _la == MySQLParser::TIMESTAMP_DIFF_SYMBOL)) {
        dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5898);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5899);
      intervalTimeStamp();
      setState(5900);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5901);
      expr(0);
      setState(5902);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5903);
      expr(0);
      setState(5904);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(5906);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::UTC_DATE_SYMBOL);
      setState(5908);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 750, _ctx)) {
      case 1: {
        setState(5907);
        parentheses();
        break;
      }

      }
      break;
    }

    case 31: {
      enterOuterAlt(_localctx, 31);
      setState(5910);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::UTC_TIME_SYMBOL);
      setState(5912);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 751, _ctx)) {
      case 1: {
        setState(5911);
        timeFunctionParameters();
        break;
      }

      }
      break;
    }

    case 32: {
      enterOuterAlt(_localctx, 32);
      setState(5914);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::UTC_TIMESTAMP_SYMBOL);
      setState(5916);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 752, _ctx)) {
      case 1: {
        setState(5915);
        timeFunctionParameters();
        break;
      }

      }
      break;
    }

    case 33: {
      enterOuterAlt(_localctx, 33);
      setState(5918);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::ASCII_SYMBOL);
      setState(5919);
      exprWithParentheses();
      break;
    }

    case 34: {
      enterOuterAlt(_localctx, 34);
      setState(5920);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::CHARSET_SYMBOL);
      setState(5921);
      exprWithParentheses();
      break;
    }

    case 35: {
      enterOuterAlt(_localctx, 35);
      setState(5922);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::COALESCE_SYMBOL);
      setState(5923);
      exprListWithParentheses();
      break;
    }

    case 36: {
      enterOuterAlt(_localctx, 36);
      setState(5924);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::COLLATION_SYMBOL);
      setState(5925);
      exprWithParentheses();
      break;
    }

    case 37: {
      enterOuterAlt(_localctx, 37);
      setState(5926);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::DATABASE_SYMBOL);
      setState(5927);
      parentheses();
      break;
    }

    case 38: {
      enterOuterAlt(_localctx, 38);
      setState(5928);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::IF_SYMBOL);
      setState(5929);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5930);
      expr(0);
      setState(5931);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5932);
      expr(0);
      setState(5933);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5934);
      expr(0);
      setState(5935);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 39: {
      enterOuterAlt(_localctx, 39);
      setState(5937);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::FORMAT_SYMBOL);
      setState(5938);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5939);
      expr(0);
      setState(5940);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5941);
      expr(0);
      setState(5944);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(5942);
        match(MySQLParser::COMMA_SYMBOL);
        setState(5943);
        expr(0);
      }
      setState(5946);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 40: {
      enterOuterAlt(_localctx, 40);
      setState(5948);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::MICROSECOND_SYMBOL);
      setState(5949);
      exprWithParentheses();
      break;
    }

    case 41: {
      enterOuterAlt(_localctx, 41);
      setState(5950);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::MOD_SYMBOL);
      setState(5951);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5952);
      expr(0);
      setState(5953);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5954);
      expr(0);
      setState(5955);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 42: {
      enterOuterAlt(_localctx, 42);
      setState(5957);

      if (!(serverVersion < 50607)) throw FailedPredicateException(this, "serverVersion < 50607");
      setState(5958);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::OLD_PASSWORD_SYMBOL);
      setState(5959);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5960);
      textLiteral();
      setState(5961);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 43: {
      enterOuterAlt(_localctx, 43);
      setState(5963);

      if (!(serverVersion < 80011)) throw FailedPredicateException(this, "serverVersion < 80011");
      setState(5964);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::PASSWORD_SYMBOL);
      setState(5965);
      exprWithParentheses();
      break;
    }

    case 44: {
      enterOuterAlt(_localctx, 44);
      setState(5966);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::QUARTER_SYMBOL);
      setState(5967);
      exprWithParentheses();
      break;
    }

    case 45: {
      enterOuterAlt(_localctx, 45);
      setState(5968);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::REPEAT_SYMBOL);
      setState(5969);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5970);
      expr(0);
      setState(5971);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5972);
      expr(0);
      setState(5973);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 46: {
      enterOuterAlt(_localctx, 46);
      setState(5975);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::REPLACE_SYMBOL);
      setState(5976);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5977);
      expr(0);
      setState(5978);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5979);
      expr(0);
      setState(5980);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5981);
      expr(0);
      setState(5982);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 47: {
      enterOuterAlt(_localctx, 47);
      setState(5984);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::REVERSE_SYMBOL);
      setState(5985);
      exprWithParentheses();
      break;
    }

    case 48: {
      enterOuterAlt(_localctx, 48);
      setState(5986);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::ROW_COUNT_SYMBOL);
      setState(5987);
      parentheses();
      break;
    }

    case 49: {
      enterOuterAlt(_localctx, 49);
      setState(5988);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::TRUNCATE_SYMBOL);
      setState(5989);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5990);
      expr(0);
      setState(5991);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5992);
      expr(0);
      setState(5993);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 50: {
      enterOuterAlt(_localctx, 50);
      setState(5995);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::WEEK_SYMBOL);
      setState(5996);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5997);
      expr(0);
      setState(6000);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(5998);
        match(MySQLParser::COMMA_SYMBOL);
        setState(5999);
        expr(0);
      }
      setState(6002);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 51: {
      enterOuterAlt(_localctx, 51);
      setState(6004);

      if (!(serverVersion >= 50600)) throw FailedPredicateException(this, "serverVersion >= 50600");
      setState(6005);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::WEIGHT_STRING_SYMBOL);
      setState(6006);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(6007);
      expr(0);
      setState(6027);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 757, _ctx)) {
      case 1: {
        setState(6011);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 755, _ctx)) {
        case 1: {
          setState(6008);
          match(MySQLParser::AS_SYMBOL);
          setState(6009);
          match(MySQLParser::CHAR_SYMBOL);
          setState(6010);
          wsNumCodepoints();
          break;
        }

        }
        setState(6015);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 756, _ctx)) {
        case 1: {
          setState(6013);

          if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
          setState(6014);
          weightStringLevels();
          break;
        }

        }
        break;
      }

      case 2: {
        setState(6017);
        match(MySQLParser::AS_SYMBOL);
        setState(6018);
        match(MySQLParser::BINARY_SYMBOL);
        setState(6019);
        wsNumCodepoints();
        break;
      }

      case 3: {
        setState(6020);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6021);
        ulong_number();
        setState(6022);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6023);
        ulong_number();
        setState(6024);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6025);
        ulong_number();
        break;
      }

      }
      setState(6029);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 52: {
      enterOuterAlt(_localctx, 52);
      setState(6031);
      geometryFunction();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GeometryFunctionContext ------------------------------------------------------------------

MySQLParser::GeometryFunctionContext::GeometryFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::GeometryFunctionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::ExprContext *> MySQLParser::GeometryFunctionContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext* MySQLParser::GeometryFunctionContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

tree::TerminalNode* MySQLParser::GeometryFunctionContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GeometryFunctionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GeometryFunctionContext::CONTAINS_SYMBOL() {
  return getToken(MySQLParser::CONTAINS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GeometryFunctionContext::GEOMETRYCOLLECTION_SYMBOL() {
  return getToken(MySQLParser::GEOMETRYCOLLECTION_SYMBOL, 0);
}

MySQLParser::ExprListContext* MySQLParser::GeometryFunctionContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

MySQLParser::ExprListWithParenthesesContext* MySQLParser::GeometryFunctionContext::exprListWithParentheses() {
  return getRuleContext<MySQLParser::ExprListWithParenthesesContext>(0);
}

tree::TerminalNode* MySQLParser::GeometryFunctionContext::LINESTRING_SYMBOL() {
  return getToken(MySQLParser::LINESTRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GeometryFunctionContext::MULTILINESTRING_SYMBOL() {
  return getToken(MySQLParser::MULTILINESTRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GeometryFunctionContext::MULTIPOINT_SYMBOL() {
  return getToken(MySQLParser::MULTIPOINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GeometryFunctionContext::MULTIPOLYGON_SYMBOL() {
  return getToken(MySQLParser::MULTIPOLYGON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GeometryFunctionContext::POINT_SYMBOL() {
  return getToken(MySQLParser::POINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GeometryFunctionContext::POLYGON_SYMBOL() {
  return getToken(MySQLParser::POLYGON_SYMBOL, 0);
}


size_t MySQLParser::GeometryFunctionContext::getRuleIndex() const {
  return MySQLParser::RuleGeometryFunction;
}

void MySQLParser::GeometryFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeometryFunction(this);
}

void MySQLParser::GeometryFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeometryFunction(this);
}


antlrcpp::Any MySQLParser::GeometryFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitGeometryFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GeometryFunctionContext* MySQLParser::geometryFunction() {
  GeometryFunctionContext *_localctx = _tracker.createInstance<GeometryFunctionContext>(_ctx, getState());
  enterRule(_localctx, 688, MySQLParser::RuleGeometryFunction);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6065);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 760, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6034);

      if (!(serverVersion < 50706)) throw FailedPredicateException(this, "serverVersion < 50706");
      setState(6035);
      dynamic_cast<GeometryFunctionContext *>(_localctx)->name = match(MySQLParser::CONTAINS_SYMBOL);
      setState(6036);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(6037);
      expr(0);
      setState(6038);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6039);
      expr(0);
      setState(6040);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6042);
      dynamic_cast<GeometryFunctionContext *>(_localctx)->name = match(MySQLParser::GEOMETRYCOLLECTION_SYMBOL);
      setState(6043);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(6045);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 759, _ctx)) {
      case 1: {
        setState(6044);
        exprList();
        break;
      }

      }
      setState(6047);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6048);
      dynamic_cast<GeometryFunctionContext *>(_localctx)->name = match(MySQLParser::LINESTRING_SYMBOL);
      setState(6049);
      exprListWithParentheses();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6050);
      dynamic_cast<GeometryFunctionContext *>(_localctx)->name = match(MySQLParser::MULTILINESTRING_SYMBOL);
      setState(6051);
      exprListWithParentheses();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6052);
      dynamic_cast<GeometryFunctionContext *>(_localctx)->name = match(MySQLParser::MULTIPOINT_SYMBOL);
      setState(6053);
      exprListWithParentheses();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6054);
      dynamic_cast<GeometryFunctionContext *>(_localctx)->name = match(MySQLParser::MULTIPOLYGON_SYMBOL);
      setState(6055);
      exprListWithParentheses();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(6056);
      dynamic_cast<GeometryFunctionContext *>(_localctx)->name = match(MySQLParser::POINT_SYMBOL);
      setState(6057);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(6058);
      expr(0);
      setState(6059);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6060);
      expr(0);
      setState(6061);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(6063);
      dynamic_cast<GeometryFunctionContext *>(_localctx)->name = match(MySQLParser::POLYGON_SYMBOL);
      setState(6064);
      exprListWithParentheses();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TimeFunctionParametersContext ------------------------------------------------------------------

MySQLParser::TimeFunctionParametersContext::TimeFunctionParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TimeFunctionParametersContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TimeFunctionParametersContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::FractionalPrecisionContext* MySQLParser::TimeFunctionParametersContext::fractionalPrecision() {
  return getRuleContext<MySQLParser::FractionalPrecisionContext>(0);
}


size_t MySQLParser::TimeFunctionParametersContext::getRuleIndex() const {
  return MySQLParser::RuleTimeFunctionParameters;
}

void MySQLParser::TimeFunctionParametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimeFunctionParameters(this);
}

void MySQLParser::TimeFunctionParametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimeFunctionParameters(this);
}


antlrcpp::Any MySQLParser::TimeFunctionParametersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTimeFunctionParameters(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TimeFunctionParametersContext* MySQLParser::timeFunctionParameters() {
  TimeFunctionParametersContext *_localctx = _tracker.createInstance<TimeFunctionParametersContext>(_ctx, getState());
  enterRule(_localctx, 690, MySQLParser::RuleTimeFunctionParameters);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6067);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(6069);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 761, _ctx)) {
    case 1: {
      setState(6068);
      fractionalPrecision();
      break;
    }

    }
    setState(6071);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FractionalPrecisionContext ------------------------------------------------------------------

MySQLParser::FractionalPrecisionContext::FractionalPrecisionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::FractionalPrecisionContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}


size_t MySQLParser::FractionalPrecisionContext::getRuleIndex() const {
  return MySQLParser::RuleFractionalPrecision;
}

void MySQLParser::FractionalPrecisionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFractionalPrecision(this);
}

void MySQLParser::FractionalPrecisionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFractionalPrecision(this);
}


antlrcpp::Any MySQLParser::FractionalPrecisionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFractionalPrecision(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FractionalPrecisionContext* MySQLParser::fractionalPrecision() {
  FractionalPrecisionContext *_localctx = _tracker.createInstance<FractionalPrecisionContext>(_ctx, getState());
  enterRule(_localctx, 692, MySQLParser::RuleFractionalPrecision);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6073);

    if (!(serverVersion >= 50604)) throw FailedPredicateException(this, "serverVersion >= 50604");
    setState(6074);
    match(MySQLParser::INT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WeightStringLevelsContext ------------------------------------------------------------------

MySQLParser::WeightStringLevelsContext::WeightStringLevelsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WeightStringLevelsContext::LEVEL_SYMBOL() {
  return getToken(MySQLParser::LEVEL_SYMBOL, 0);
}

std::vector<MySQLParser::Real_ulong_numberContext *> MySQLParser::WeightStringLevelsContext::real_ulong_number() {
  return getRuleContexts<MySQLParser::Real_ulong_numberContext>();
}

MySQLParser::Real_ulong_numberContext* MySQLParser::WeightStringLevelsContext::real_ulong_number(size_t i) {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(i);
}

tree::TerminalNode* MySQLParser::WeightStringLevelsContext::MINUS_OPERATOR() {
  return getToken(MySQLParser::MINUS_OPERATOR, 0);
}

std::vector<MySQLParser::WeightStringLevelListItemContext *> MySQLParser::WeightStringLevelsContext::weightStringLevelListItem() {
  return getRuleContexts<MySQLParser::WeightStringLevelListItemContext>();
}

MySQLParser::WeightStringLevelListItemContext* MySQLParser::WeightStringLevelsContext::weightStringLevelListItem(size_t i) {
  return getRuleContext<MySQLParser::WeightStringLevelListItemContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::WeightStringLevelsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::WeightStringLevelsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::WeightStringLevelsContext::getRuleIndex() const {
  return MySQLParser::RuleWeightStringLevels;
}

void MySQLParser::WeightStringLevelsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWeightStringLevels(this);
}

void MySQLParser::WeightStringLevelsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWeightStringLevels(this);
}


antlrcpp::Any MySQLParser::WeightStringLevelsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitWeightStringLevels(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WeightStringLevelsContext* MySQLParser::weightStringLevels() {
  WeightStringLevelsContext *_localctx = _tracker.createInstance<WeightStringLevelsContext>(_ctx, getState());
  enterRule(_localctx, 694, MySQLParser::RuleWeightStringLevels);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6076);
    match(MySQLParser::LEVEL_SYMBOL);
    setState(6089);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 763, _ctx)) {
    case 1: {
      setState(6077);
      real_ulong_number();
      setState(6078);
      match(MySQLParser::MINUS_OPERATOR);
      setState(6079);
      real_ulong_number();
      break;
    }

    case 2: {
      setState(6081);
      weightStringLevelListItem();
      setState(6086);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(6082);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6083);
        weightStringLevelListItem();
        setState(6088);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WeightStringLevelListItemContext ------------------------------------------------------------------

MySQLParser::WeightStringLevelListItemContext::WeightStringLevelListItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::Real_ulong_numberContext* MySQLParser::WeightStringLevelListItemContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::WeightStringLevelListItemContext::REVERSE_SYMBOL() {
  return getToken(MySQLParser::REVERSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WeightStringLevelListItemContext::ASC_SYMBOL() {
  return getToken(MySQLParser::ASC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WeightStringLevelListItemContext::DESC_SYMBOL() {
  return getToken(MySQLParser::DESC_SYMBOL, 0);
}


size_t MySQLParser::WeightStringLevelListItemContext::getRuleIndex() const {
  return MySQLParser::RuleWeightStringLevelListItem;
}

void MySQLParser::WeightStringLevelListItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWeightStringLevelListItem(this);
}

void MySQLParser::WeightStringLevelListItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWeightStringLevelListItem(this);
}


antlrcpp::Any MySQLParser::WeightStringLevelListItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitWeightStringLevelListItem(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WeightStringLevelListItemContext* MySQLParser::weightStringLevelListItem() {
  WeightStringLevelListItemContext *_localctx = _tracker.createInstance<WeightStringLevelListItemContext>(_ctx, getState());
  enterRule(_localctx, 696, MySQLParser::RuleWeightStringLevelListItem);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6091);
    real_ulong_number();
    setState(6097);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ASC_SYMBOL:
      case MySQLParser::DESC_SYMBOL: {
        setState(6092);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::ASC_SYMBOL

        || _la == MySQLParser::DESC_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6094);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::REVERSE_SYMBOL) {
          setState(6093);
          match(MySQLParser::REVERSE_SYMBOL);
        }
        break;
      }

      case MySQLParser::REVERSE_SYMBOL: {
        setState(6096);
        match(MySQLParser::REVERSE_SYMBOL);
        break;
      }

      case MySQLParser::COMMA_SYMBOL:
      case MySQLParser::CLOSE_PAR_SYMBOL: {
        break;
      }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DateTimeTtypeContext ------------------------------------------------------------------

MySQLParser::DateTimeTtypeContext::DateTimeTtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DateTimeTtypeContext::DATE_SYMBOL() {
  return getToken(MySQLParser::DATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DateTimeTtypeContext::TIME_SYMBOL() {
  return getToken(MySQLParser::TIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DateTimeTtypeContext::DATETIME_SYMBOL() {
  return getToken(MySQLParser::DATETIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DateTimeTtypeContext::TIMESTAMP_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_SYMBOL, 0);
}


size_t MySQLParser::DateTimeTtypeContext::getRuleIndex() const {
  return MySQLParser::RuleDateTimeTtype;
}

void MySQLParser::DateTimeTtypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDateTimeTtype(this);
}

void MySQLParser::DateTimeTtypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDateTimeTtype(this);
}


antlrcpp::Any MySQLParser::DateTimeTtypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDateTimeTtype(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DateTimeTtypeContext* MySQLParser::dateTimeTtype() {
  DateTimeTtypeContext *_localctx = _tracker.createInstance<DateTimeTtypeContext>(_ctx, getState());
  enterRule(_localctx, 698, MySQLParser::RuleDateTimeTtype);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6099);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DATETIME_SYMBOL

    || _la == MySQLParser::DATE_SYMBOL || _la == MySQLParser::TIMESTAMP_SYMBOL

    || _la == MySQLParser::TIME_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TrimFunctionContext ------------------------------------------------------------------

MySQLParser::TrimFunctionContext::TrimFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TrimFunctionContext::TRIM_SYMBOL() {
  return getToken(MySQLParser::TRIM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TrimFunctionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TrimFunctionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::ExprContext *> MySQLParser::TrimFunctionContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext* MySQLParser::TrimFunctionContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

tree::TerminalNode* MySQLParser::TrimFunctionContext::LEADING_SYMBOL() {
  return getToken(MySQLParser::LEADING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TrimFunctionContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TrimFunctionContext::TRAILING_SYMBOL() {
  return getToken(MySQLParser::TRAILING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TrimFunctionContext::BOTH_SYMBOL() {
  return getToken(MySQLParser::BOTH_SYMBOL, 0);
}


size_t MySQLParser::TrimFunctionContext::getRuleIndex() const {
  return MySQLParser::RuleTrimFunction;
}

void MySQLParser::TrimFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrimFunction(this);
}

void MySQLParser::TrimFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrimFunction(this);
}


antlrcpp::Any MySQLParser::TrimFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTrimFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TrimFunctionContext* MySQLParser::trimFunction() {
  TrimFunctionContext *_localctx = _tracker.createInstance<TrimFunctionContext>(_ctx, getState());
  enterRule(_localctx, 700, MySQLParser::RuleTrimFunction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6101);
    match(MySQLParser::TRIM_SYMBOL);
    setState(6102);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(6126);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 770, _ctx)) {
    case 1: {
      setState(6103);
      expr(0);
      setState(6106);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FROM_SYMBOL) {
        setState(6104);
        match(MySQLParser::FROM_SYMBOL);
        setState(6105);
        expr(0);
      }
      break;
    }

    case 2: {
      setState(6108);
      match(MySQLParser::LEADING_SYMBOL);
      setState(6110);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 767, _ctx)) {
      case 1: {
        setState(6109);
        expr(0);
        break;
      }

      }
      setState(6112);
      match(MySQLParser::FROM_SYMBOL);
      setState(6113);
      expr(0);
      break;
    }

    case 3: {
      setState(6114);
      match(MySQLParser::TRAILING_SYMBOL);
      setState(6116);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 768, _ctx)) {
      case 1: {
        setState(6115);
        expr(0);
        break;
      }

      }
      setState(6118);
      match(MySQLParser::FROM_SYMBOL);
      setState(6119);
      expr(0);
      break;
    }

    case 4: {
      setState(6120);
      match(MySQLParser::BOTH_SYMBOL);
      setState(6122);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 769, _ctx)) {
      case 1: {
        setState(6121);
        expr(0);
        break;
      }

      }
      setState(6124);
      match(MySQLParser::FROM_SYMBOL);
      setState(6125);
      expr(0);
      break;
    }

    }
    setState(6128);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubstringFunctionContext ------------------------------------------------------------------

MySQLParser::SubstringFunctionContext::SubstringFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SubstringFunctionContext::SUBSTRING_SYMBOL() {
  return getToken(MySQLParser::SUBSTRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SubstringFunctionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::ExprContext *> MySQLParser::SubstringFunctionContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext* MySQLParser::SubstringFunctionContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

tree::TerminalNode* MySQLParser::SubstringFunctionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::SubstringFunctionContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::SubstringFunctionContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

tree::TerminalNode* MySQLParser::SubstringFunctionContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SubstringFunctionContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}


size_t MySQLParser::SubstringFunctionContext::getRuleIndex() const {
  return MySQLParser::RuleSubstringFunction;
}

void MySQLParser::SubstringFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubstringFunction(this);
}

void MySQLParser::SubstringFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubstringFunction(this);
}


antlrcpp::Any MySQLParser::SubstringFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSubstringFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SubstringFunctionContext* MySQLParser::substringFunction() {
  SubstringFunctionContext *_localctx = _tracker.createInstance<SubstringFunctionContext>(_ctx, getState());
  enterRule(_localctx, 702, MySQLParser::RuleSubstringFunction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6130);
    match(MySQLParser::SUBSTRING_SYMBOL);
    setState(6131);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(6132);
    expr(0);
    setState(6145);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::COMMA_SYMBOL: {
        setState(6133);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6134);
        expr(0);
        setState(6137);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::COMMA_SYMBOL) {
          setState(6135);
          match(MySQLParser::COMMA_SYMBOL);
          setState(6136);
          expr(0);
        }
        break;
      }

      case MySQLParser::FROM_SYMBOL: {
        setState(6139);
        match(MySQLParser::FROM_SYMBOL);
        setState(6140);
        expr(0);
        setState(6143);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::FOR_SYMBOL) {
          setState(6141);
          match(MySQLParser::FOR_SYMBOL);
          setState(6142);
          expr(0);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(6147);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionCallContext ------------------------------------------------------------------

MySQLParser::FunctionCallContext::FunctionCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::PureIdentifierContext* MySQLParser::FunctionCallContext::pureIdentifier() {
  return getRuleContext<MySQLParser::PureIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::FunctionCallContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FunctionCallContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::UdfExprListContext* MySQLParser::FunctionCallContext::udfExprList() {
  return getRuleContext<MySQLParser::UdfExprListContext>(0);
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::FunctionCallContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

MySQLParser::ExprListContext* MySQLParser::FunctionCallContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}


size_t MySQLParser::FunctionCallContext::getRuleIndex() const {
  return MySQLParser::RuleFunctionCall;
}

void MySQLParser::FunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionCall(this);
}

void MySQLParser::FunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionCall(this);
}


antlrcpp::Any MySQLParser::FunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFunctionCall(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FunctionCallContext* MySQLParser::functionCall() {
  FunctionCallContext *_localctx = _tracker.createInstance<FunctionCallContext>(_ctx, getState());
  enterRule(_localctx, 704, MySQLParser::RuleFunctionCall);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6163);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 776, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6149);
      pureIdentifier();
      setState(6150);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(6152);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 774, _ctx)) {
      case 1: {
        setState(6151);
        udfExprList();
        break;
      }

      }
      setState(6154);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6156);
      qualifiedIdentifier();
      setState(6157);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(6159);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 775, _ctx)) {
      case 1: {
        setState(6158);
        exprList();
        break;
      }

      }
      setState(6161);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UdfExprListContext ------------------------------------------------------------------

MySQLParser::UdfExprListContext::UdfExprListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::UdfExprContext *> MySQLParser::UdfExprListContext::udfExpr() {
  return getRuleContexts<MySQLParser::UdfExprContext>();
}

MySQLParser::UdfExprContext* MySQLParser::UdfExprListContext::udfExpr(size_t i) {
  return getRuleContext<MySQLParser::UdfExprContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::UdfExprListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::UdfExprListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::UdfExprListContext::getRuleIndex() const {
  return MySQLParser::RuleUdfExprList;
}

void MySQLParser::UdfExprListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdfExprList(this);
}

void MySQLParser::UdfExprListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdfExprList(this);
}


antlrcpp::Any MySQLParser::UdfExprListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitUdfExprList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UdfExprListContext* MySQLParser::udfExprList() {
  UdfExprListContext *_localctx = _tracker.createInstance<UdfExprListContext>(_ctx, getState());
  enterRule(_localctx, 706, MySQLParser::RuleUdfExprList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6165);
    udfExpr();
    setState(6170);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(6166);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6167);
      udfExpr();
      setState(6172);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UdfExprContext ------------------------------------------------------------------

MySQLParser::UdfExprContext::UdfExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ExprContext* MySQLParser::UdfExprContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::SelectAliasContext* MySQLParser::UdfExprContext::selectAlias() {
  return getRuleContext<MySQLParser::SelectAliasContext>(0);
}


size_t MySQLParser::UdfExprContext::getRuleIndex() const {
  return MySQLParser::RuleUdfExpr;
}

void MySQLParser::UdfExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdfExpr(this);
}

void MySQLParser::UdfExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdfExpr(this);
}


antlrcpp::Any MySQLParser::UdfExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitUdfExpr(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UdfExprContext* MySQLParser::udfExpr() {
  UdfExprContext *_localctx = _tracker.createInstance<UdfExprContext>(_ctx, getState());
  enterRule(_localctx, 708, MySQLParser::RuleUdfExpr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6173);
    expr(0);
    setState(6175);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 778, _ctx)) {
    case 1: {
      setState(6174);
      selectAlias();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableContext ------------------------------------------------------------------

MySQLParser::VariableContext::VariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::UserVariableContext* MySQLParser::VariableContext::userVariable() {
  return getRuleContext<MySQLParser::UserVariableContext>(0);
}

tree::TerminalNode* MySQLParser::VariableContext::ASSIGN_OPERATOR() {
  return getToken(MySQLParser::ASSIGN_OPERATOR, 0);
}

MySQLParser::ExprContext* MySQLParser::VariableContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::SystemVariableContext* MySQLParser::VariableContext::systemVariable() {
  return getRuleContext<MySQLParser::SystemVariableContext>(0);
}


size_t MySQLParser::VariableContext::getRuleIndex() const {
  return MySQLParser::RuleVariable;
}

void MySQLParser::VariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable(this);
}

void MySQLParser::VariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable(this);
}


antlrcpp::Any MySQLParser::VariableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitVariable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::VariableContext* MySQLParser::variable() {
  VariableContext *_localctx = _tracker.createInstance<VariableContext>(_ctx, getState());
  enterRule(_localctx, 710, MySQLParser::RuleVariable);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6183);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::AT_SIGN_SYMBOL:
      case MySQLParser::AT_TEXT_SUFFIX: {
        enterOuterAlt(_localctx, 1);
        setState(6177);
        userVariable();
        setState(6180);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 779, _ctx)) {
        case 1: {
          setState(6178);
          match(MySQLParser::ASSIGN_OPERATOR);
          setState(6179);
          expr(0);
          break;
        }

        }
        break;
      }

      case MySQLParser::AT_AT_SIGN_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6182);
        systemVariable();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserVariableContext ------------------------------------------------------------------

MySQLParser::UserVariableContext::UserVariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::UserVariableContext::AT_SIGN_SYMBOL() {
  return getToken(MySQLParser::AT_SIGN_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::UserVariableContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::UserVariableContext::AT_TEXT_SUFFIX() {
  return getToken(MySQLParser::AT_TEXT_SUFFIX, 0);
}


size_t MySQLParser::UserVariableContext::getRuleIndex() const {
  return MySQLParser::RuleUserVariable;
}

void MySQLParser::UserVariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserVariable(this);
}

void MySQLParser::UserVariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserVariable(this);
}


antlrcpp::Any MySQLParser::UserVariableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitUserVariable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UserVariableContext* MySQLParser::userVariable() {
  UserVariableContext *_localctx = _tracker.createInstance<UserVariableContext>(_ctx, getState());
  enterRule(_localctx, 712, MySQLParser::RuleUserVariable);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6188);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::AT_SIGN_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(6185);
        match(MySQLParser::AT_SIGN_SYMBOL);
        setState(6186);
        textOrIdentifier();
        break;
      }

      case MySQLParser::AT_TEXT_SUFFIX: {
        enterOuterAlt(_localctx, 2);
        setState(6187);
        match(MySQLParser::AT_TEXT_SUFFIX);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SystemVariableContext ------------------------------------------------------------------

MySQLParser::SystemVariableContext::SystemVariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SystemVariableContext::AT_AT_SIGN_SYMBOL() {
  return getToken(MySQLParser::AT_AT_SIGN_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::SystemVariableContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

MySQLParser::VarIdentTypeContext* MySQLParser::SystemVariableContext::varIdentType() {
  return getRuleContext<MySQLParser::VarIdentTypeContext>(0);
}

MySQLParser::DotIdentifierContext* MySQLParser::SystemVariableContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}


size_t MySQLParser::SystemVariableContext::getRuleIndex() const {
  return MySQLParser::RuleSystemVariable;
}

void MySQLParser::SystemVariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSystemVariable(this);
}

void MySQLParser::SystemVariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSystemVariable(this);
}


antlrcpp::Any MySQLParser::SystemVariableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSystemVariable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SystemVariableContext* MySQLParser::systemVariable() {
  SystemVariableContext *_localctx = _tracker.createInstance<SystemVariableContext>(_ctx, getState());
  enterRule(_localctx, 714, MySQLParser::RuleSystemVariable);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6190);
    match(MySQLParser::AT_AT_SIGN_SYMBOL);
    setState(6192);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 782, _ctx)) {
    case 1: {
      setState(6191);
      varIdentType();
      break;
    }

    }
    setState(6194);
    textOrIdentifier();
    setState(6196);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 783, _ctx)) {
    case 1: {
      setState(6195);
      dotIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InternalVariableNameContext ------------------------------------------------------------------

MySQLParser::InternalVariableNameContext::InternalVariableNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::InternalVariableNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::DotIdentifierContext* MySQLParser::InternalVariableNameContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::InternalVariableNameContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}


size_t MySQLParser::InternalVariableNameContext::getRuleIndex() const {
  return MySQLParser::RuleInternalVariableName;
}

void MySQLParser::InternalVariableNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInternalVariableName(this);
}

void MySQLParser::InternalVariableNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInternalVariableName(this);
}


antlrcpp::Any MySQLParser::InternalVariableNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitInternalVariableName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InternalVariableNameContext* MySQLParser::internalVariableName() {
  InternalVariableNameContext *_localctx = _tracker.createInstance<InternalVariableNameContext>(_ctx, getState());
  enterRule(_localctx, 716, MySQLParser::RuleInternalVariableName);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6204);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 785, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6198);
      identifier();
      setState(6200);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::DOT_SYMBOL) {
        setState(6199);
        dotIdentifier();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6202);
      match(MySQLParser::DEFAULT_SYMBOL);
      setState(6203);
      dotIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhenExpressionContext ------------------------------------------------------------------

MySQLParser::WhenExpressionContext::WhenExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WhenExpressionContext::WHEN_SYMBOL() {
  return getToken(MySQLParser::WHEN_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::WhenExpressionContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}


size_t MySQLParser::WhenExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleWhenExpression;
}

void MySQLParser::WhenExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhenExpression(this);
}

void MySQLParser::WhenExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhenExpression(this);
}


antlrcpp::Any MySQLParser::WhenExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitWhenExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WhenExpressionContext* MySQLParser::whenExpression() {
  WhenExpressionContext *_localctx = _tracker.createInstance<WhenExpressionContext>(_ctx, getState());
  enterRule(_localctx, 718, MySQLParser::RuleWhenExpression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6206);
    match(MySQLParser::WHEN_SYMBOL);
    setState(6207);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThenExpressionContext ------------------------------------------------------------------

MySQLParser::ThenExpressionContext::ThenExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ThenExpressionContext::THEN_SYMBOL() {
  return getToken(MySQLParser::THEN_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::ThenExpressionContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}


size_t MySQLParser::ThenExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleThenExpression;
}

void MySQLParser::ThenExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThenExpression(this);
}

void MySQLParser::ThenExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThenExpression(this);
}


antlrcpp::Any MySQLParser::ThenExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitThenExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ThenExpressionContext* MySQLParser::thenExpression() {
  ThenExpressionContext *_localctx = _tracker.createInstance<ThenExpressionContext>(_ctx, getState());
  enterRule(_localctx, 720, MySQLParser::RuleThenExpression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6209);
    match(MySQLParser::THEN_SYMBOL);
    setState(6210);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElseExpressionContext ------------------------------------------------------------------

MySQLParser::ElseExpressionContext::ElseExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ElseExpressionContext::ELSE_SYMBOL() {
  return getToken(MySQLParser::ELSE_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::ElseExpressionContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}


size_t MySQLParser::ElseExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleElseExpression;
}

void MySQLParser::ElseExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElseExpression(this);
}

void MySQLParser::ElseExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElseExpression(this);
}


antlrcpp::Any MySQLParser::ElseExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitElseExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ElseExpressionContext* MySQLParser::elseExpression() {
  ElseExpressionContext *_localctx = _tracker.createInstance<ElseExpressionContext>(_ctx, getState());
  enterRule(_localctx, 722, MySQLParser::RuleElseExpression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6212);
    match(MySQLParser::ELSE_SYMBOL);
    setState(6213);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CastTypeContext ------------------------------------------------------------------

MySQLParser::CastTypeContext::CastTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CastTypeContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

MySQLParser::FieldLengthContext* MySQLParser::CastTypeContext::fieldLength() {
  return getRuleContext<MySQLParser::FieldLengthContext>(0);
}

tree::TerminalNode* MySQLParser::CastTypeContext::CHAR_SYMBOL() {
  return getToken(MySQLParser::CHAR_SYMBOL, 0);
}

MySQLParser::CharsetWithOptBinaryContext* MySQLParser::CastTypeContext::charsetWithOptBinary() {
  return getRuleContext<MySQLParser::CharsetWithOptBinaryContext>(0);
}

MySQLParser::NcharContext* MySQLParser::CastTypeContext::nchar() {
  return getRuleContext<MySQLParser::NcharContext>(0);
}

tree::TerminalNode* MySQLParser::CastTypeContext::SIGNED_SYMBOL() {
  return getToken(MySQLParser::SIGNED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CastTypeContext::INT_SYMBOL() {
  return getToken(MySQLParser::INT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CastTypeContext::UNSIGNED_SYMBOL() {
  return getToken(MySQLParser::UNSIGNED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CastTypeContext::DATE_SYMBOL() {
  return getToken(MySQLParser::DATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CastTypeContext::TIME_SYMBOL() {
  return getToken(MySQLParser::TIME_SYMBOL, 0);
}

MySQLParser::TypeDatetimePrecisionContext* MySQLParser::CastTypeContext::typeDatetimePrecision() {
  return getRuleContext<MySQLParser::TypeDatetimePrecisionContext>(0);
}

tree::TerminalNode* MySQLParser::CastTypeContext::DATETIME_SYMBOL() {
  return getToken(MySQLParser::DATETIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CastTypeContext::DECIMAL_SYMBOL() {
  return getToken(MySQLParser::DECIMAL_SYMBOL, 0);
}

MySQLParser::FloatOptionsContext* MySQLParser::CastTypeContext::floatOptions() {
  return getRuleContext<MySQLParser::FloatOptionsContext>(0);
}

tree::TerminalNode* MySQLParser::CastTypeContext::JSON_SYMBOL() {
  return getToken(MySQLParser::JSON_SYMBOL, 0);
}


size_t MySQLParser::CastTypeContext::getRuleIndex() const {
  return MySQLParser::RuleCastType;
}

void MySQLParser::CastTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCastType(this);
}

void MySQLParser::CastTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCastType(this);
}


antlrcpp::Any MySQLParser::CastTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCastType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CastTypeContext* MySQLParser::castType() {
  CastTypeContext *_localctx = _tracker.createInstance<CastTypeContext>(_ctx, getState());
  enterRule(_localctx, 724, MySQLParser::RuleCastType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6253);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 795, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6215);
      match(MySQLParser::BINARY_SYMBOL);
      setState(6217);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
        setState(6216);
        fieldLength();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6219);
      match(MySQLParser::CHAR_SYMBOL);
      setState(6221);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
        setState(6220);
        fieldLength();
      }
      setState(6224);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MySQLParser::ASCII_SYMBOL)
        | (1ULL << MySQLParser::BYTE_SYMBOL)
        | (1ULL << MySQLParser::CHARSET_SYMBOL)
        | (1ULL << MySQLParser::UNICODE_SYMBOL))) != 0) || _la == MySQLParser::BINARY_SYMBOL

      || _la == MySQLParser::CHAR_SYMBOL) {
        setState(6223);
        charsetWithOptBinary();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6226);
      nchar();
      setState(6228);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
        setState(6227);
        fieldLength();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6230);
      match(MySQLParser::SIGNED_SYMBOL);
      setState(6232);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::INT_SYMBOL) {
        setState(6231);
        match(MySQLParser::INT_SYMBOL);
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6234);
      match(MySQLParser::UNSIGNED_SYMBOL);
      setState(6236);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::INT_SYMBOL) {
        setState(6235);
        match(MySQLParser::INT_SYMBOL);
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6238);
      match(MySQLParser::DATE_SYMBOL);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(6239);
      match(MySQLParser::TIME_SYMBOL);
      setState(6241);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 792, _ctx)) {
      case 1: {
        setState(6240);
        typeDatetimePrecision();
        break;
      }

      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(6243);
      match(MySQLParser::DATETIME_SYMBOL);
      setState(6245);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 793, _ctx)) {
      case 1: {
        setState(6244);
        typeDatetimePrecision();
        break;
      }

      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(6247);
      match(MySQLParser::DECIMAL_SYMBOL);
      setState(6249);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
        setState(6248);
        floatOptions();
      }
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(6251);

      if (!(serverVersion >= 50708)) throw FailedPredicateException(this, "serverVersion >= 50708");
      setState(6252);
      match(MySQLParser::JSON_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprListContext ------------------------------------------------------------------

MySQLParser::ExprListContext::ExprListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::ExprContext *> MySQLParser::ExprListContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext* MySQLParser::ExprListContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ExprListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ExprListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ExprListContext::getRuleIndex() const {
  return MySQLParser::RuleExprList;
}

void MySQLParser::ExprListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprList(this);
}

void MySQLParser::ExprListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprList(this);
}


antlrcpp::Any MySQLParser::ExprListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitExprList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ExprListContext* MySQLParser::exprList() {
  ExprListContext *_localctx = _tracker.createInstance<ExprListContext>(_ctx, getState());
  enterRule(_localctx, 726, MySQLParser::RuleExprList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6255);
    expr(0);
    setState(6260);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(6256);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6257);
      expr(0);
      setState(6262);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharsetContext ------------------------------------------------------------------

MySQLParser::CharsetContext::CharsetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CharsetContext::CHAR_SYMBOL() {
  return getToken(MySQLParser::CHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CharsetContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CharsetContext::CHARSET_SYMBOL() {
  return getToken(MySQLParser::CHARSET_SYMBOL, 0);
}


size_t MySQLParser::CharsetContext::getRuleIndex() const {
  return MySQLParser::RuleCharset;
}

void MySQLParser::CharsetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharset(this);
}

void MySQLParser::CharsetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharset(this);
}


antlrcpp::Any MySQLParser::CharsetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCharset(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CharsetContext* MySQLParser::charset() {
  CharsetContext *_localctx = _tracker.createInstance<CharsetContext>(_ctx, getState());
  enterRule(_localctx, 728, MySQLParser::RuleCharset);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6266);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CHAR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(6263);
        match(MySQLParser::CHAR_SYMBOL);
        setState(6264);
        match(MySQLParser::SET_SYMBOL);
        break;
      }

      case MySQLParser::CHARSET_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6265);
        match(MySQLParser::CHARSET_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NotRuleContext ------------------------------------------------------------------

MySQLParser::NotRuleContext::NotRuleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::NotRuleContext::NOT_SYMBOL() {
  return getToken(MySQLParser::NOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NotRuleContext::NOT2_SYMBOL() {
  return getToken(MySQLParser::NOT2_SYMBOL, 0);
}


size_t MySQLParser::NotRuleContext::getRuleIndex() const {
  return MySQLParser::RuleNotRule;
}

void MySQLParser::NotRuleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNotRule(this);
}

void MySQLParser::NotRuleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNotRule(this);
}


antlrcpp::Any MySQLParser::NotRuleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitNotRule(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::NotRuleContext* MySQLParser::notRule() {
  NotRuleContext *_localctx = _tracker.createInstance<NotRuleContext>(_ctx, getState());
  enterRule(_localctx, 730, MySQLParser::RuleNotRule);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6268);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::NOT2_SYMBOL || _la == MySQLParser::NOT_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Not2RuleContext ------------------------------------------------------------------

MySQLParser::Not2RuleContext::Not2RuleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::Not2RuleContext::LOGICAL_NOT_OPERATOR() {
  return getToken(MySQLParser::LOGICAL_NOT_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::Not2RuleContext::NOT2_SYMBOL() {
  return getToken(MySQLParser::NOT2_SYMBOL, 0);
}


size_t MySQLParser::Not2RuleContext::getRuleIndex() const {
  return MySQLParser::RuleNot2Rule;
}

void MySQLParser::Not2RuleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNot2Rule(this);
}

void MySQLParser::Not2RuleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNot2Rule(this);
}


antlrcpp::Any MySQLParser::Not2RuleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitNot2Rule(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::Not2RuleContext* MySQLParser::not2Rule() {
  Not2RuleContext *_localctx = _tracker.createInstance<Not2RuleContext>(_ctx, getState());
  enterRule(_localctx, 732, MySQLParser::RuleNot2Rule);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6270);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::NOT2_SYMBOL

    || _la == MySQLParser::LOGICAL_NOT_OPERATOR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntervalContext ------------------------------------------------------------------

MySQLParser::IntervalContext::IntervalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IntervalTimeStampContext* MySQLParser::IntervalContext::intervalTimeStamp() {
  return getRuleContext<MySQLParser::IntervalTimeStampContext>(0);
}

tree::TerminalNode* MySQLParser::IntervalContext::SECOND_MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::SECOND_MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalContext::MINUTE_MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::MINUTE_MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalContext::MINUTE_SECOND_SYMBOL() {
  return getToken(MySQLParser::MINUTE_SECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalContext::HOUR_MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::HOUR_MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalContext::HOUR_SECOND_SYMBOL() {
  return getToken(MySQLParser::HOUR_SECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalContext::HOUR_MINUTE_SYMBOL() {
  return getToken(MySQLParser::HOUR_MINUTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalContext::DAY_MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::DAY_MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalContext::DAY_SECOND_SYMBOL() {
  return getToken(MySQLParser::DAY_SECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalContext::DAY_MINUTE_SYMBOL() {
  return getToken(MySQLParser::DAY_MINUTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalContext::DAY_HOUR_SYMBOL() {
  return getToken(MySQLParser::DAY_HOUR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalContext::YEAR_MONTH_SYMBOL() {
  return getToken(MySQLParser::YEAR_MONTH_SYMBOL, 0);
}


size_t MySQLParser::IntervalContext::getRuleIndex() const {
  return MySQLParser::RuleInterval;
}

void MySQLParser::IntervalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterval(this);
}

void MySQLParser::IntervalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterval(this);
}


antlrcpp::Any MySQLParser::IntervalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitInterval(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IntervalContext* MySQLParser::interval() {
  IntervalContext *_localctx = _tracker.createInstance<IntervalContext>(_ctx, getState());
  enterRule(_localctx, 734, MySQLParser::RuleInterval);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6274);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::DAY_SYMBOL:
      case MySQLParser::HOUR_SYMBOL:
      case MySQLParser::MICROSECOND_SYMBOL:
      case MySQLParser::MINUTE_SYMBOL:
      case MySQLParser::MONTH_SYMBOL:
      case MySQLParser::QUARTER_SYMBOL:
      case MySQLParser::SECOND_SYMBOL:
      case MySQLParser::WEEK_SYMBOL:
      case MySQLParser::YEAR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(6272);
        intervalTimeStamp();
        break;
      }

      case MySQLParser::DAY_HOUR_SYMBOL:
      case MySQLParser::DAY_MICROSECOND_SYMBOL:
      case MySQLParser::DAY_MINUTE_SYMBOL:
      case MySQLParser::DAY_SECOND_SYMBOL:
      case MySQLParser::HOUR_MICROSECOND_SYMBOL:
      case MySQLParser::HOUR_MINUTE_SYMBOL:
      case MySQLParser::HOUR_SECOND_SYMBOL:
      case MySQLParser::MINUTE_MICROSECOND_SYMBOL:
      case MySQLParser::MINUTE_SECOND_SYMBOL:
      case MySQLParser::SECOND_MICROSECOND_SYMBOL:
      case MySQLParser::YEAR_MONTH_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6273);
        _la = _input->LA(1);
        if (!(((((_la - 471) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 471)) & ((1ULL << (MySQLParser::DAY_HOUR_SYMBOL - 471))
          | (1ULL << (MySQLParser::DAY_MICROSECOND_SYMBOL - 471))
          | (1ULL << (MySQLParser::DAY_MINUTE_SYMBOL - 471))
          | (1ULL << (MySQLParser::DAY_SECOND_SYMBOL - 471))
          | (1ULL << (MySQLParser::HOUR_MICROSECOND_SYMBOL - 471))
          | (1ULL << (MySQLParser::HOUR_MINUTE_SYMBOL - 471))
          | (1ULL << (MySQLParser::HOUR_SECOND_SYMBOL - 471)))) != 0) || ((((_la - 563) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 563)) & ((1ULL << (MySQLParser::MINUTE_MICROSECOND_SYMBOL - 563))
          | (1ULL << (MySQLParser::MINUTE_SECOND_SYMBOL - 563))
          | (1ULL << (MySQLParser::SECOND_MICROSECOND_SYMBOL - 563)))) != 0) || _la == MySQLParser::YEAR_MONTH_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntervalTimeStampContext ------------------------------------------------------------------

MySQLParser::IntervalTimeStampContext::IntervalTimeStampContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IntervalTimeStampContext::MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalTimeStampContext::SECOND_SYMBOL() {
  return getToken(MySQLParser::SECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalTimeStampContext::MINUTE_SYMBOL() {
  return getToken(MySQLParser::MINUTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalTimeStampContext::HOUR_SYMBOL() {
  return getToken(MySQLParser::HOUR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalTimeStampContext::DAY_SYMBOL() {
  return getToken(MySQLParser::DAY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalTimeStampContext::WEEK_SYMBOL() {
  return getToken(MySQLParser::WEEK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalTimeStampContext::MONTH_SYMBOL() {
  return getToken(MySQLParser::MONTH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalTimeStampContext::QUARTER_SYMBOL() {
  return getToken(MySQLParser::QUARTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalTimeStampContext::YEAR_SYMBOL() {
  return getToken(MySQLParser::YEAR_SYMBOL, 0);
}


size_t MySQLParser::IntervalTimeStampContext::getRuleIndex() const {
  return MySQLParser::RuleIntervalTimeStamp;
}

void MySQLParser::IntervalTimeStampContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntervalTimeStamp(this);
}

void MySQLParser::IntervalTimeStampContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntervalTimeStamp(this);
}


antlrcpp::Any MySQLParser::IntervalTimeStampContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIntervalTimeStamp(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IntervalTimeStampContext* MySQLParser::intervalTimeStamp() {
  IntervalTimeStampContext *_localctx = _tracker.createInstance<IntervalTimeStampContext>(_ctx, getState());
  enterRule(_localctx, 736, MySQLParser::RuleIntervalTimeStamp);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6276);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DAY_SYMBOL

    || _la == MySQLParser::HOUR_SYMBOL || ((((_la - 217) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 217)) & ((1ULL << (MySQLParser::MICROSECOND_SYMBOL - 217))
      | (1ULL << (MySQLParser::MINUTE_SYMBOL - 217))
      | (1ULL << (MySQLParser::MONTH_SYMBOL - 217))
      | (1ULL << (MySQLParser::QUARTER_SYMBOL - 217)))) != 0) || _la == MySQLParser::SECOND_SYMBOL || _la == MySQLParser::WEEK_SYMBOL

    || _la == MySQLParser::YEAR_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprListWithParenthesesContext ------------------------------------------------------------------

MySQLParser::ExprListWithParenthesesContext::ExprListWithParenthesesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ExprListWithParenthesesContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprListContext* MySQLParser::ExprListWithParenthesesContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

tree::TerminalNode* MySQLParser::ExprListWithParenthesesContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::ExprListWithParenthesesContext::getRuleIndex() const {
  return MySQLParser::RuleExprListWithParentheses;
}

void MySQLParser::ExprListWithParenthesesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprListWithParentheses(this);
}

void MySQLParser::ExprListWithParenthesesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprListWithParentheses(this);
}


antlrcpp::Any MySQLParser::ExprListWithParenthesesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitExprListWithParentheses(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ExprListWithParenthesesContext* MySQLParser::exprListWithParentheses() {
  ExprListWithParenthesesContext *_localctx = _tracker.createInstance<ExprListWithParenthesesContext>(_ctx, getState());
  enterRule(_localctx, 738, MySQLParser::RuleExprListWithParentheses);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6278);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(6279);
    exprList();
    setState(6280);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprWithParenthesesContext ------------------------------------------------------------------

MySQLParser::ExprWithParenthesesContext::ExprWithParenthesesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ExprWithParenthesesContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::ExprWithParenthesesContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::ExprWithParenthesesContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::ExprWithParenthesesContext::getRuleIndex() const {
  return MySQLParser::RuleExprWithParentheses;
}

void MySQLParser::ExprWithParenthesesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprWithParentheses(this);
}

void MySQLParser::ExprWithParenthesesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprWithParentheses(this);
}


antlrcpp::Any MySQLParser::ExprWithParenthesesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitExprWithParentheses(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ExprWithParenthesesContext* MySQLParser::exprWithParentheses() {
  ExprWithParenthesesContext *_localctx = _tracker.createInstance<ExprWithParenthesesContext>(_ctx, getState());
  enterRule(_localctx, 740, MySQLParser::RuleExprWithParentheses);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6282);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(6283);
    expr(0);
    setState(6284);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OrderListContext ------------------------------------------------------------------

MySQLParser::OrderListContext::OrderListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::OrderExpressionContext *> MySQLParser::OrderListContext::orderExpression() {
  return getRuleContexts<MySQLParser::OrderExpressionContext>();
}

MySQLParser::OrderExpressionContext* MySQLParser::OrderListContext::orderExpression(size_t i) {
  return getRuleContext<MySQLParser::OrderExpressionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::OrderListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::OrderListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::OrderListContext::getRuleIndex() const {
  return MySQLParser::RuleOrderList;
}

void MySQLParser::OrderListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrderList(this);
}

void MySQLParser::OrderListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrderList(this);
}


antlrcpp::Any MySQLParser::OrderListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitOrderList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OrderListContext* MySQLParser::orderList() {
  OrderListContext *_localctx = _tracker.createInstance<OrderListContext>(_ctx, getState());
  enterRule(_localctx, 742, MySQLParser::RuleOrderList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6286);
    orderExpression();
    setState(6291);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 799, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(6287);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6288);
        orderExpression(); 
      }
      setState(6293);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 799, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OrderExpressionContext ------------------------------------------------------------------

MySQLParser::OrderExpressionContext::OrderExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ExprContext* MySQLParser::OrderExpressionContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::DirectionContext* MySQLParser::OrderExpressionContext::direction() {
  return getRuleContext<MySQLParser::DirectionContext>(0);
}


size_t MySQLParser::OrderExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleOrderExpression;
}

void MySQLParser::OrderExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrderExpression(this);
}

void MySQLParser::OrderExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrderExpression(this);
}


antlrcpp::Any MySQLParser::OrderExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitOrderExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OrderExpressionContext* MySQLParser::orderExpression() {
  OrderExpressionContext *_localctx = _tracker.createInstance<OrderExpressionContext>(_ctx, getState());
  enterRule(_localctx, 744, MySQLParser::RuleOrderExpression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6294);
    expr(0);
    setState(6296);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 800, _ctx)) {
    case 1: {
      setState(6295);
      direction();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupListContext ------------------------------------------------------------------

MySQLParser::GroupListContext::GroupListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::GroupingExpressionContext *> MySQLParser::GroupListContext::groupingExpression() {
  return getRuleContexts<MySQLParser::GroupingExpressionContext>();
}

MySQLParser::GroupingExpressionContext* MySQLParser::GroupListContext::groupingExpression(size_t i) {
  return getRuleContext<MySQLParser::GroupingExpressionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::GroupListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::GroupListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::GroupListContext::getRuleIndex() const {
  return MySQLParser::RuleGroupList;
}

void MySQLParser::GroupListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupList(this);
}

void MySQLParser::GroupListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupList(this);
}


antlrcpp::Any MySQLParser::GroupListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitGroupList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GroupListContext* MySQLParser::groupList() {
  GroupListContext *_localctx = _tracker.createInstance<GroupListContext>(_ctx, getState());
  enterRule(_localctx, 746, MySQLParser::RuleGroupList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6298);
    groupingExpression();
    setState(6303);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(6299);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6300);
      groupingExpression();
      setState(6305);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupingExpressionContext ------------------------------------------------------------------

MySQLParser::GroupingExpressionContext::GroupingExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ExprContext* MySQLParser::GroupingExpressionContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}


size_t MySQLParser::GroupingExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleGroupingExpression;
}

void MySQLParser::GroupingExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupingExpression(this);
}

void MySQLParser::GroupingExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupingExpression(this);
}


antlrcpp::Any MySQLParser::GroupingExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitGroupingExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GroupingExpressionContext* MySQLParser::groupingExpression() {
  GroupingExpressionContext *_localctx = _tracker.createInstance<GroupingExpressionContext>(_ctx, getState());
  enterRule(_localctx, 748, MySQLParser::RuleGroupingExpression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6306);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChannelContext ------------------------------------------------------------------

MySQLParser::ChannelContext::ChannelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ChannelContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ChannelContext::CHANNEL_SYMBOL() {
  return getToken(MySQLParser::CHANNEL_SYMBOL, 0);
}

MySQLParser::TextStringNoLinebreakContext* MySQLParser::ChannelContext::textStringNoLinebreak() {
  return getRuleContext<MySQLParser::TextStringNoLinebreakContext>(0);
}


size_t MySQLParser::ChannelContext::getRuleIndex() const {
  return MySQLParser::RuleChannel;
}

void MySQLParser::ChannelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChannel(this);
}

void MySQLParser::ChannelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChannel(this);
}


antlrcpp::Any MySQLParser::ChannelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitChannel(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChannelContext* MySQLParser::channel() {
  ChannelContext *_localctx = _tracker.createInstance<ChannelContext>(_ctx, getState());
  enterRule(_localctx, 750, MySQLParser::RuleChannel);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6308);

    if (!(serverVersion >= 50706)) throw FailedPredicateException(this, "serverVersion >= 50706");
    setState(6309);
    match(MySQLParser::FOR_SYMBOL);
    setState(6310);
    match(MySQLParser::CHANNEL_SYMBOL);
    setState(6311);
    textStringNoLinebreak();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompoundStatementContext ------------------------------------------------------------------

MySQLParser::CompoundStatementContext::CompoundStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SimpleStatementContext* MySQLParser::CompoundStatementContext::simpleStatement() {
  return getRuleContext<MySQLParser::SimpleStatementContext>(0);
}

MySQLParser::ReturnStatementContext* MySQLParser::CompoundStatementContext::returnStatement() {
  return getRuleContext<MySQLParser::ReturnStatementContext>(0);
}

MySQLParser::IfStatementContext* MySQLParser::CompoundStatementContext::ifStatement() {
  return getRuleContext<MySQLParser::IfStatementContext>(0);
}

MySQLParser::CaseStatementContext* MySQLParser::CompoundStatementContext::caseStatement() {
  return getRuleContext<MySQLParser::CaseStatementContext>(0);
}

MySQLParser::LabeledBlockContext* MySQLParser::CompoundStatementContext::labeledBlock() {
  return getRuleContext<MySQLParser::LabeledBlockContext>(0);
}

MySQLParser::UnlabeledBlockContext* MySQLParser::CompoundStatementContext::unlabeledBlock() {
  return getRuleContext<MySQLParser::UnlabeledBlockContext>(0);
}

MySQLParser::LabeledControlContext* MySQLParser::CompoundStatementContext::labeledControl() {
  return getRuleContext<MySQLParser::LabeledControlContext>(0);
}

MySQLParser::UnlabeledControlContext* MySQLParser::CompoundStatementContext::unlabeledControl() {
  return getRuleContext<MySQLParser::UnlabeledControlContext>(0);
}

MySQLParser::LeaveStatementContext* MySQLParser::CompoundStatementContext::leaveStatement() {
  return getRuleContext<MySQLParser::LeaveStatementContext>(0);
}

MySQLParser::IterateStatementContext* MySQLParser::CompoundStatementContext::iterateStatement() {
  return getRuleContext<MySQLParser::IterateStatementContext>(0);
}

MySQLParser::CursorOpenContext* MySQLParser::CompoundStatementContext::cursorOpen() {
  return getRuleContext<MySQLParser::CursorOpenContext>(0);
}

MySQLParser::CursorFetchContext* MySQLParser::CompoundStatementContext::cursorFetch() {
  return getRuleContext<MySQLParser::CursorFetchContext>(0);
}

MySQLParser::CursorCloseContext* MySQLParser::CompoundStatementContext::cursorClose() {
  return getRuleContext<MySQLParser::CursorCloseContext>(0);
}


size_t MySQLParser::CompoundStatementContext::getRuleIndex() const {
  return MySQLParser::RuleCompoundStatement;
}

void MySQLParser::CompoundStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompoundStatement(this);
}

void MySQLParser::CompoundStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompoundStatement(this);
}


antlrcpp::Any MySQLParser::CompoundStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCompoundStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CompoundStatementContext* MySQLParser::compoundStatement() {
  CompoundStatementContext *_localctx = _tracker.createInstance<CompoundStatementContext>(_ctx, getState());
  enterRule(_localctx, 752, MySQLParser::RuleCompoundStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6326);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 802, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6313);
      simpleStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6314);
      returnStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6315);
      ifStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6316);
      caseStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6317);
      labeledBlock();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6318);
      unlabeledBlock();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(6319);
      labeledControl();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(6320);
      unlabeledControl();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(6321);
      leaveStatement();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(6322);
      iterateStatement();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(6323);
      cursorOpen();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(6324);
      cursorFetch();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(6325);
      cursorClose();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnStatementContext ------------------------------------------------------------------

MySQLParser::ReturnStatementContext::ReturnStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ReturnStatementContext::RETURN_SYMBOL() {
  return getToken(MySQLParser::RETURN_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::ReturnStatementContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}


size_t MySQLParser::ReturnStatementContext::getRuleIndex() const {
  return MySQLParser::RuleReturnStatement;
}

void MySQLParser::ReturnStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturnStatement(this);
}

void MySQLParser::ReturnStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturnStatement(this);
}


antlrcpp::Any MySQLParser::ReturnStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitReturnStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ReturnStatementContext* MySQLParser::returnStatement() {
  ReturnStatementContext *_localctx = _tracker.createInstance<ReturnStatementContext>(_ctx, getState());
  enterRule(_localctx, 754, MySQLParser::RuleReturnStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6328);
    match(MySQLParser::RETURN_SYMBOL);
    setState(6329);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStatementContext ------------------------------------------------------------------

MySQLParser::IfStatementContext::IfStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::IfStatementContext::IF_SYMBOL() {
  return getTokens(MySQLParser::IF_SYMBOL);
}

tree::TerminalNode* MySQLParser::IfStatementContext::IF_SYMBOL(size_t i) {
  return getToken(MySQLParser::IF_SYMBOL, i);
}

MySQLParser::IfBodyContext* MySQLParser::IfStatementContext::ifBody() {
  return getRuleContext<MySQLParser::IfBodyContext>(0);
}

tree::TerminalNode* MySQLParser::IfStatementContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}


size_t MySQLParser::IfStatementContext::getRuleIndex() const {
  return MySQLParser::RuleIfStatement;
}

void MySQLParser::IfStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfStatement(this);
}

void MySQLParser::IfStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfStatement(this);
}


antlrcpp::Any MySQLParser::IfStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIfStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IfStatementContext* MySQLParser::ifStatement() {
  IfStatementContext *_localctx = _tracker.createInstance<IfStatementContext>(_ctx, getState());
  enterRule(_localctx, 756, MySQLParser::RuleIfStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6331);
    match(MySQLParser::IF_SYMBOL);
    setState(6332);
    ifBody();
    setState(6333);
    match(MySQLParser::END_SYMBOL);
    setState(6334);
    match(MySQLParser::IF_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfBodyContext ------------------------------------------------------------------

MySQLParser::IfBodyContext::IfBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ExprContext* MySQLParser::IfBodyContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::ThenStatementContext* MySQLParser::IfBodyContext::thenStatement() {
  return getRuleContext<MySQLParser::ThenStatementContext>(0);
}

tree::TerminalNode* MySQLParser::IfBodyContext::ELSEIF_SYMBOL() {
  return getToken(MySQLParser::ELSEIF_SYMBOL, 0);
}

MySQLParser::IfBodyContext* MySQLParser::IfBodyContext::ifBody() {
  return getRuleContext<MySQLParser::IfBodyContext>(0);
}

tree::TerminalNode* MySQLParser::IfBodyContext::ELSE_SYMBOL() {
  return getToken(MySQLParser::ELSE_SYMBOL, 0);
}

MySQLParser::CompoundStatementListContext* MySQLParser::IfBodyContext::compoundStatementList() {
  return getRuleContext<MySQLParser::CompoundStatementListContext>(0);
}


size_t MySQLParser::IfBodyContext::getRuleIndex() const {
  return MySQLParser::RuleIfBody;
}

void MySQLParser::IfBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfBody(this);
}

void MySQLParser::IfBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfBody(this);
}


antlrcpp::Any MySQLParser::IfBodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIfBody(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IfBodyContext* MySQLParser::ifBody() {
  IfBodyContext *_localctx = _tracker.createInstance<IfBodyContext>(_ctx, getState());
  enterRule(_localctx, 758, MySQLParser::RuleIfBody);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6336);
    expr(0);
    setState(6337);
    thenStatement();
    setState(6342);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ELSEIF_SYMBOL: {
        setState(6338);
        match(MySQLParser::ELSEIF_SYMBOL);
        setState(6339);
        ifBody();
        break;
      }

      case MySQLParser::ELSE_SYMBOL: {
        setState(6340);
        match(MySQLParser::ELSE_SYMBOL);
        setState(6341);
        compoundStatementList();
        break;
      }

      case MySQLParser::END_SYMBOL: {
        break;
      }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThenStatementContext ------------------------------------------------------------------

MySQLParser::ThenStatementContext::ThenStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ThenStatementContext::THEN_SYMBOL() {
  return getToken(MySQLParser::THEN_SYMBOL, 0);
}

MySQLParser::CompoundStatementListContext* MySQLParser::ThenStatementContext::compoundStatementList() {
  return getRuleContext<MySQLParser::CompoundStatementListContext>(0);
}


size_t MySQLParser::ThenStatementContext::getRuleIndex() const {
  return MySQLParser::RuleThenStatement;
}

void MySQLParser::ThenStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThenStatement(this);
}

void MySQLParser::ThenStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThenStatement(this);
}


antlrcpp::Any MySQLParser::ThenStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitThenStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ThenStatementContext* MySQLParser::thenStatement() {
  ThenStatementContext *_localctx = _tracker.createInstance<ThenStatementContext>(_ctx, getState());
  enterRule(_localctx, 760, MySQLParser::RuleThenStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6344);
    match(MySQLParser::THEN_SYMBOL);
    setState(6345);
    compoundStatementList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompoundStatementListContext ------------------------------------------------------------------

MySQLParser::CompoundStatementListContext::CompoundStatementListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::CompoundStatementContext *> MySQLParser::CompoundStatementListContext::compoundStatement() {
  return getRuleContexts<MySQLParser::CompoundStatementContext>();
}

MySQLParser::CompoundStatementContext* MySQLParser::CompoundStatementListContext::compoundStatement(size_t i) {
  return getRuleContext<MySQLParser::CompoundStatementContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::CompoundStatementListContext::SEMICOLON_SYMBOL() {
  return getTokens(MySQLParser::SEMICOLON_SYMBOL);
}

tree::TerminalNode* MySQLParser::CompoundStatementListContext::SEMICOLON_SYMBOL(size_t i) {
  return getToken(MySQLParser::SEMICOLON_SYMBOL, i);
}


size_t MySQLParser::CompoundStatementListContext::getRuleIndex() const {
  return MySQLParser::RuleCompoundStatementList;
}

void MySQLParser::CompoundStatementListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompoundStatementList(this);
}

void MySQLParser::CompoundStatementListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompoundStatementList(this);
}


antlrcpp::Any MySQLParser::CompoundStatementListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCompoundStatementList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CompoundStatementListContext* MySQLParser::compoundStatementList() {
  CompoundStatementListContext *_localctx = _tracker.createInstance<CompoundStatementListContext>(_ctx, getState());
  enterRule(_localctx, 762, MySQLParser::RuleCompoundStatementList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6350); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(6347);
              compoundStatement();
              setState(6348);
              match(MySQLParser::SEMICOLON_SYMBOL);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(6352); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 804, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseStatementContext ------------------------------------------------------------------

MySQLParser::CaseStatementContext::CaseStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::CaseStatementContext::CASE_SYMBOL() {
  return getTokens(MySQLParser::CASE_SYMBOL);
}

tree::TerminalNode* MySQLParser::CaseStatementContext::CASE_SYMBOL(size_t i) {
  return getToken(MySQLParser::CASE_SYMBOL, i);
}

tree::TerminalNode* MySQLParser::CaseStatementContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::CaseStatementContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

std::vector<MySQLParser::WhenExpressionContext *> MySQLParser::CaseStatementContext::whenExpression() {
  return getRuleContexts<MySQLParser::WhenExpressionContext>();
}

MySQLParser::WhenExpressionContext* MySQLParser::CaseStatementContext::whenExpression(size_t i) {
  return getRuleContext<MySQLParser::WhenExpressionContext>(i);
}

std::vector<MySQLParser::ThenStatementContext *> MySQLParser::CaseStatementContext::thenStatement() {
  return getRuleContexts<MySQLParser::ThenStatementContext>();
}

MySQLParser::ThenStatementContext* MySQLParser::CaseStatementContext::thenStatement(size_t i) {
  return getRuleContext<MySQLParser::ThenStatementContext>(i);
}

MySQLParser::ElseStatementContext* MySQLParser::CaseStatementContext::elseStatement() {
  return getRuleContext<MySQLParser::ElseStatementContext>(0);
}


size_t MySQLParser::CaseStatementContext::getRuleIndex() const {
  return MySQLParser::RuleCaseStatement;
}

void MySQLParser::CaseStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseStatement(this);
}

void MySQLParser::CaseStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseStatement(this);
}


antlrcpp::Any MySQLParser::CaseStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCaseStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CaseStatementContext* MySQLParser::caseStatement() {
  CaseStatementContext *_localctx = _tracker.createInstance<CaseStatementContext>(_ctx, getState());
  enterRule(_localctx, 764, MySQLParser::RuleCaseStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6354);
    match(MySQLParser::CASE_SYMBOL);
    setState(6356);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 805, _ctx)) {
    case 1: {
      setState(6355);
      expr(0);
      break;
    }

    }
    setState(6361); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(6358);
      whenExpression();
      setState(6359);
      thenStatement();
      setState(6363); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == MySQLParser::WHEN_SYMBOL);
    setState(6366);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ELSE_SYMBOL) {
      setState(6365);
      elseStatement();
    }
    setState(6368);
    match(MySQLParser::END_SYMBOL);
    setState(6369);
    match(MySQLParser::CASE_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElseStatementContext ------------------------------------------------------------------

MySQLParser::ElseStatementContext::ElseStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ElseStatementContext::ELSE_SYMBOL() {
  return getToken(MySQLParser::ELSE_SYMBOL, 0);
}

MySQLParser::CompoundStatementListContext* MySQLParser::ElseStatementContext::compoundStatementList() {
  return getRuleContext<MySQLParser::CompoundStatementListContext>(0);
}


size_t MySQLParser::ElseStatementContext::getRuleIndex() const {
  return MySQLParser::RuleElseStatement;
}

void MySQLParser::ElseStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElseStatement(this);
}

void MySQLParser::ElseStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElseStatement(this);
}


antlrcpp::Any MySQLParser::ElseStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitElseStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ElseStatementContext* MySQLParser::elseStatement() {
  ElseStatementContext *_localctx = _tracker.createInstance<ElseStatementContext>(_ctx, getState());
  enterRule(_localctx, 766, MySQLParser::RuleElseStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6371);
    match(MySQLParser::ELSE_SYMBOL);
    setState(6372);
    compoundStatementList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabeledBlockContext ------------------------------------------------------------------

MySQLParser::LabeledBlockContext::LabeledBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LabelContext* MySQLParser::LabeledBlockContext::label() {
  return getRuleContext<MySQLParser::LabelContext>(0);
}

MySQLParser::BeginEndBlockContext* MySQLParser::LabeledBlockContext::beginEndBlock() {
  return getRuleContext<MySQLParser::BeginEndBlockContext>(0);
}

MySQLParser::LabelRefContext* MySQLParser::LabeledBlockContext::labelRef() {
  return getRuleContext<MySQLParser::LabelRefContext>(0);
}


size_t MySQLParser::LabeledBlockContext::getRuleIndex() const {
  return MySQLParser::RuleLabeledBlock;
}

void MySQLParser::LabeledBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabeledBlock(this);
}

void MySQLParser::LabeledBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabeledBlock(this);
}


antlrcpp::Any MySQLParser::LabeledBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLabeledBlock(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LabeledBlockContext* MySQLParser::labeledBlock() {
  LabeledBlockContext *_localctx = _tracker.createInstance<LabeledBlockContext>(_ctx, getState());
  enterRule(_localctx, 768, MySQLParser::RuleLabeledBlock);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6374);
    label();
    setState(6375);
    beginEndBlock();
    setState(6377);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 808, _ctx)) {
    case 1: {
      setState(6376);
      labelRef();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnlabeledBlockContext ------------------------------------------------------------------

MySQLParser::UnlabeledBlockContext::UnlabeledBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::BeginEndBlockContext* MySQLParser::UnlabeledBlockContext::beginEndBlock() {
  return getRuleContext<MySQLParser::BeginEndBlockContext>(0);
}


size_t MySQLParser::UnlabeledBlockContext::getRuleIndex() const {
  return MySQLParser::RuleUnlabeledBlock;
}

void MySQLParser::UnlabeledBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnlabeledBlock(this);
}

void MySQLParser::UnlabeledBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnlabeledBlock(this);
}


antlrcpp::Any MySQLParser::UnlabeledBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitUnlabeledBlock(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UnlabeledBlockContext* MySQLParser::unlabeledBlock() {
  UnlabeledBlockContext *_localctx = _tracker.createInstance<UnlabeledBlockContext>(_ctx, getState());
  enterRule(_localctx, 770, MySQLParser::RuleUnlabeledBlock);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6379);
    beginEndBlock();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelContext ------------------------------------------------------------------

MySQLParser::LabelContext::LabelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LabelIdentifierContext* MySQLParser::LabelContext::labelIdentifier() {
  return getRuleContext<MySQLParser::LabelIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::LabelContext::COLON_SYMBOL() {
  return getToken(MySQLParser::COLON_SYMBOL, 0);
}


size_t MySQLParser::LabelContext::getRuleIndex() const {
  return MySQLParser::RuleLabel;
}

void MySQLParser::LabelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabel(this);
}

void MySQLParser::LabelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabel(this);
}


antlrcpp::Any MySQLParser::LabelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLabel(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LabelContext* MySQLParser::label() {
  LabelContext *_localctx = _tracker.createInstance<LabelContext>(_ctx, getState());
  enterRule(_localctx, 772, MySQLParser::RuleLabel);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6381);
    labelIdentifier();
    setState(6382);
    match(MySQLParser::COLON_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BeginEndBlockContext ------------------------------------------------------------------

MySQLParser::BeginEndBlockContext::BeginEndBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::BeginEndBlockContext::BEGIN_SYMBOL() {
  return getToken(MySQLParser::BEGIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::BeginEndBlockContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}

MySQLParser::SpDeclarationsContext* MySQLParser::BeginEndBlockContext::spDeclarations() {
  return getRuleContext<MySQLParser::SpDeclarationsContext>(0);
}

MySQLParser::CompoundStatementListContext* MySQLParser::BeginEndBlockContext::compoundStatementList() {
  return getRuleContext<MySQLParser::CompoundStatementListContext>(0);
}


size_t MySQLParser::BeginEndBlockContext::getRuleIndex() const {
  return MySQLParser::RuleBeginEndBlock;
}

void MySQLParser::BeginEndBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBeginEndBlock(this);
}

void MySQLParser::BeginEndBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBeginEndBlock(this);
}


antlrcpp::Any MySQLParser::BeginEndBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitBeginEndBlock(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::BeginEndBlockContext* MySQLParser::beginEndBlock() {
  BeginEndBlockContext *_localctx = _tracker.createInstance<BeginEndBlockContext>(_ctx, getState());
  enterRule(_localctx, 774, MySQLParser::RuleBeginEndBlock);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6384);
    match(MySQLParser::BEGIN_SYMBOL);
    setState(6386);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 809, _ctx)) {
    case 1: {
      setState(6385);
      spDeclarations();
      break;
    }

    }
    setState(6389);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 810, _ctx)) {
    case 1: {
      setState(6388);
      compoundStatementList();
      break;
    }

    }
    setState(6391);
    match(MySQLParser::END_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabeledControlContext ------------------------------------------------------------------

MySQLParser::LabeledControlContext::LabeledControlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LabelContext* MySQLParser::LabeledControlContext::label() {
  return getRuleContext<MySQLParser::LabelContext>(0);
}

MySQLParser::UnlabeledControlContext* MySQLParser::LabeledControlContext::unlabeledControl() {
  return getRuleContext<MySQLParser::UnlabeledControlContext>(0);
}

MySQLParser::LabelRefContext* MySQLParser::LabeledControlContext::labelRef() {
  return getRuleContext<MySQLParser::LabelRefContext>(0);
}


size_t MySQLParser::LabeledControlContext::getRuleIndex() const {
  return MySQLParser::RuleLabeledControl;
}

void MySQLParser::LabeledControlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabeledControl(this);
}

void MySQLParser::LabeledControlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabeledControl(this);
}


antlrcpp::Any MySQLParser::LabeledControlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLabeledControl(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LabeledControlContext* MySQLParser::labeledControl() {
  LabeledControlContext *_localctx = _tracker.createInstance<LabeledControlContext>(_ctx, getState());
  enterRule(_localctx, 776, MySQLParser::RuleLabeledControl);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6393);
    label();
    setState(6394);
    unlabeledControl();
    setState(6396);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 811, _ctx)) {
    case 1: {
      setState(6395);
      labelRef();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnlabeledControlContext ------------------------------------------------------------------

MySQLParser::UnlabeledControlContext::UnlabeledControlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LoopBlockContext* MySQLParser::UnlabeledControlContext::loopBlock() {
  return getRuleContext<MySQLParser::LoopBlockContext>(0);
}

MySQLParser::WhileDoBlockContext* MySQLParser::UnlabeledControlContext::whileDoBlock() {
  return getRuleContext<MySQLParser::WhileDoBlockContext>(0);
}

MySQLParser::RepeatUntilBlockContext* MySQLParser::UnlabeledControlContext::repeatUntilBlock() {
  return getRuleContext<MySQLParser::RepeatUntilBlockContext>(0);
}


size_t MySQLParser::UnlabeledControlContext::getRuleIndex() const {
  return MySQLParser::RuleUnlabeledControl;
}

void MySQLParser::UnlabeledControlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnlabeledControl(this);
}

void MySQLParser::UnlabeledControlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnlabeledControl(this);
}


antlrcpp::Any MySQLParser::UnlabeledControlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitUnlabeledControl(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UnlabeledControlContext* MySQLParser::unlabeledControl() {
  UnlabeledControlContext *_localctx = _tracker.createInstance<UnlabeledControlContext>(_ctx, getState());
  enterRule(_localctx, 778, MySQLParser::RuleUnlabeledControl);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6401);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::LOOP_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(6398);
        loopBlock();
        break;
      }

      case MySQLParser::WHILE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6399);
        whileDoBlock();
        break;
      }

      case MySQLParser::REPEAT_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(6400);
        repeatUntilBlock();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoopBlockContext ------------------------------------------------------------------

MySQLParser::LoopBlockContext::LoopBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::LoopBlockContext::LOOP_SYMBOL() {
  return getTokens(MySQLParser::LOOP_SYMBOL);
}

tree::TerminalNode* MySQLParser::LoopBlockContext::LOOP_SYMBOL(size_t i) {
  return getToken(MySQLParser::LOOP_SYMBOL, i);
}

MySQLParser::CompoundStatementListContext* MySQLParser::LoopBlockContext::compoundStatementList() {
  return getRuleContext<MySQLParser::CompoundStatementListContext>(0);
}

tree::TerminalNode* MySQLParser::LoopBlockContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}


size_t MySQLParser::LoopBlockContext::getRuleIndex() const {
  return MySQLParser::RuleLoopBlock;
}

void MySQLParser::LoopBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoopBlock(this);
}

void MySQLParser::LoopBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoopBlock(this);
}


antlrcpp::Any MySQLParser::LoopBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLoopBlock(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LoopBlockContext* MySQLParser::loopBlock() {
  LoopBlockContext *_localctx = _tracker.createInstance<LoopBlockContext>(_ctx, getState());
  enterRule(_localctx, 780, MySQLParser::RuleLoopBlock);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6403);
    match(MySQLParser::LOOP_SYMBOL);
    setState(6404);
    compoundStatementList();
    setState(6405);
    match(MySQLParser::END_SYMBOL);
    setState(6406);
    match(MySQLParser::LOOP_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhileDoBlockContext ------------------------------------------------------------------

MySQLParser::WhileDoBlockContext::WhileDoBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::WhileDoBlockContext::WHILE_SYMBOL() {
  return getTokens(MySQLParser::WHILE_SYMBOL);
}

tree::TerminalNode* MySQLParser::WhileDoBlockContext::WHILE_SYMBOL(size_t i) {
  return getToken(MySQLParser::WHILE_SYMBOL, i);
}

MySQLParser::ExprContext* MySQLParser::WhileDoBlockContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::WhileDoBlockContext::DO_SYMBOL() {
  return getToken(MySQLParser::DO_SYMBOL, 0);
}

MySQLParser::CompoundStatementListContext* MySQLParser::WhileDoBlockContext::compoundStatementList() {
  return getRuleContext<MySQLParser::CompoundStatementListContext>(0);
}

tree::TerminalNode* MySQLParser::WhileDoBlockContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}


size_t MySQLParser::WhileDoBlockContext::getRuleIndex() const {
  return MySQLParser::RuleWhileDoBlock;
}

void MySQLParser::WhileDoBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhileDoBlock(this);
}

void MySQLParser::WhileDoBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhileDoBlock(this);
}


antlrcpp::Any MySQLParser::WhileDoBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitWhileDoBlock(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WhileDoBlockContext* MySQLParser::whileDoBlock() {
  WhileDoBlockContext *_localctx = _tracker.createInstance<WhileDoBlockContext>(_ctx, getState());
  enterRule(_localctx, 782, MySQLParser::RuleWhileDoBlock);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6408);
    match(MySQLParser::WHILE_SYMBOL);
    setState(6409);
    expr(0);
    setState(6410);
    match(MySQLParser::DO_SYMBOL);
    setState(6411);
    compoundStatementList();
    setState(6412);
    match(MySQLParser::END_SYMBOL);
    setState(6413);
    match(MySQLParser::WHILE_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RepeatUntilBlockContext ------------------------------------------------------------------

MySQLParser::RepeatUntilBlockContext::RepeatUntilBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::RepeatUntilBlockContext::REPEAT_SYMBOL() {
  return getTokens(MySQLParser::REPEAT_SYMBOL);
}

tree::TerminalNode* MySQLParser::RepeatUntilBlockContext::REPEAT_SYMBOL(size_t i) {
  return getToken(MySQLParser::REPEAT_SYMBOL, i);
}

MySQLParser::CompoundStatementListContext* MySQLParser::RepeatUntilBlockContext::compoundStatementList() {
  return getRuleContext<MySQLParser::CompoundStatementListContext>(0);
}

tree::TerminalNode* MySQLParser::RepeatUntilBlockContext::UNTIL_SYMBOL() {
  return getToken(MySQLParser::UNTIL_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::RepeatUntilBlockContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::RepeatUntilBlockContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}


size_t MySQLParser::RepeatUntilBlockContext::getRuleIndex() const {
  return MySQLParser::RuleRepeatUntilBlock;
}

void MySQLParser::RepeatUntilBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRepeatUntilBlock(this);
}

void MySQLParser::RepeatUntilBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRepeatUntilBlock(this);
}


antlrcpp::Any MySQLParser::RepeatUntilBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRepeatUntilBlock(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RepeatUntilBlockContext* MySQLParser::repeatUntilBlock() {
  RepeatUntilBlockContext *_localctx = _tracker.createInstance<RepeatUntilBlockContext>(_ctx, getState());
  enterRule(_localctx, 784, MySQLParser::RuleRepeatUntilBlock);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6415);
    match(MySQLParser::REPEAT_SYMBOL);
    setState(6416);
    compoundStatementList();
    setState(6417);
    match(MySQLParser::UNTIL_SYMBOL);
    setState(6418);
    expr(0);
    setState(6419);
    match(MySQLParser::END_SYMBOL);
    setState(6420);
    match(MySQLParser::REPEAT_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SpDeclarationsContext ------------------------------------------------------------------

MySQLParser::SpDeclarationsContext::SpDeclarationsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::SpDeclarationContext *> MySQLParser::SpDeclarationsContext::spDeclaration() {
  return getRuleContexts<MySQLParser::SpDeclarationContext>();
}

MySQLParser::SpDeclarationContext* MySQLParser::SpDeclarationsContext::spDeclaration(size_t i) {
  return getRuleContext<MySQLParser::SpDeclarationContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::SpDeclarationsContext::SEMICOLON_SYMBOL() {
  return getTokens(MySQLParser::SEMICOLON_SYMBOL);
}

tree::TerminalNode* MySQLParser::SpDeclarationsContext::SEMICOLON_SYMBOL(size_t i) {
  return getToken(MySQLParser::SEMICOLON_SYMBOL, i);
}


size_t MySQLParser::SpDeclarationsContext::getRuleIndex() const {
  return MySQLParser::RuleSpDeclarations;
}

void MySQLParser::SpDeclarationsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpDeclarations(this);
}

void MySQLParser::SpDeclarationsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpDeclarations(this);
}


antlrcpp::Any MySQLParser::SpDeclarationsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSpDeclarations(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SpDeclarationsContext* MySQLParser::spDeclarations() {
  SpDeclarationsContext *_localctx = _tracker.createInstance<SpDeclarationsContext>(_ctx, getState());
  enterRule(_localctx, 786, MySQLParser::RuleSpDeclarations);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6425); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(6422);
              spDeclaration();
              setState(6423);
              match(MySQLParser::SEMICOLON_SYMBOL);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(6427); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 813, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SpDeclarationContext ------------------------------------------------------------------

MySQLParser::SpDeclarationContext::SpDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::VariableDeclarationContext* MySQLParser::SpDeclarationContext::variableDeclaration() {
  return getRuleContext<MySQLParser::VariableDeclarationContext>(0);
}

MySQLParser::ConditionDeclarationContext* MySQLParser::SpDeclarationContext::conditionDeclaration() {
  return getRuleContext<MySQLParser::ConditionDeclarationContext>(0);
}

MySQLParser::HandlerDeclarationContext* MySQLParser::SpDeclarationContext::handlerDeclaration() {
  return getRuleContext<MySQLParser::HandlerDeclarationContext>(0);
}

MySQLParser::CursorDeclarationContext* MySQLParser::SpDeclarationContext::cursorDeclaration() {
  return getRuleContext<MySQLParser::CursorDeclarationContext>(0);
}


size_t MySQLParser::SpDeclarationContext::getRuleIndex() const {
  return MySQLParser::RuleSpDeclaration;
}

void MySQLParser::SpDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpDeclaration(this);
}

void MySQLParser::SpDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpDeclaration(this);
}


antlrcpp::Any MySQLParser::SpDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSpDeclaration(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SpDeclarationContext* MySQLParser::spDeclaration() {
  SpDeclarationContext *_localctx = _tracker.createInstance<SpDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 788, MySQLParser::RuleSpDeclaration);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6433);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 814, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6429);
      variableDeclaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6430);
      conditionDeclaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6431);
      handlerDeclaration();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6432);
      cursorDeclaration();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationContext ------------------------------------------------------------------

MySQLParser::VariableDeclarationContext::VariableDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::VariableDeclarationContext::DECLARE_SYMBOL() {
  return getToken(MySQLParser::DECLARE_SYMBOL, 0);
}

MySQLParser::IdentifierListContext* MySQLParser::VariableDeclarationContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

MySQLParser::DataTypeContext* MySQLParser::VariableDeclarationContext::dataType() {
  return getRuleContext<MySQLParser::DataTypeContext>(0);
}

MySQLParser::CollateContext* MySQLParser::VariableDeclarationContext::collate() {
  return getRuleContext<MySQLParser::CollateContext>(0);
}

tree::TerminalNode* MySQLParser::VariableDeclarationContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::VariableDeclarationContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}


size_t MySQLParser::VariableDeclarationContext::getRuleIndex() const {
  return MySQLParser::RuleVariableDeclaration;
}

void MySQLParser::VariableDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableDeclaration(this);
}

void MySQLParser::VariableDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableDeclaration(this);
}


antlrcpp::Any MySQLParser::VariableDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitVariableDeclaration(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::VariableDeclarationContext* MySQLParser::variableDeclaration() {
  VariableDeclarationContext *_localctx = _tracker.createInstance<VariableDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 790, MySQLParser::RuleVariableDeclaration);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6435);
    match(MySQLParser::DECLARE_SYMBOL);
    setState(6436);
    identifierList();
    setState(6437);
    dataType();
    setState(6439);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::COLLATE_SYMBOL) {
      setState(6438);
      collate();
    }
    setState(6443);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFAULT_SYMBOL) {
      setState(6441);
      match(MySQLParser::DEFAULT_SYMBOL);
      setState(6442);
      expr(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionDeclarationContext ------------------------------------------------------------------

MySQLParser::ConditionDeclarationContext::ConditionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ConditionDeclarationContext::DECLARE_SYMBOL() {
  return getToken(MySQLParser::DECLARE_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::ConditionDeclarationContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::ConditionDeclarationContext::CONDITION_SYMBOL() {
  return getToken(MySQLParser::CONDITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ConditionDeclarationContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

MySQLParser::SpConditionContext* MySQLParser::ConditionDeclarationContext::spCondition() {
  return getRuleContext<MySQLParser::SpConditionContext>(0);
}


size_t MySQLParser::ConditionDeclarationContext::getRuleIndex() const {
  return MySQLParser::RuleConditionDeclaration;
}

void MySQLParser::ConditionDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditionDeclaration(this);
}

void MySQLParser::ConditionDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditionDeclaration(this);
}


antlrcpp::Any MySQLParser::ConditionDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitConditionDeclaration(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ConditionDeclarationContext* MySQLParser::conditionDeclaration() {
  ConditionDeclarationContext *_localctx = _tracker.createInstance<ConditionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 792, MySQLParser::RuleConditionDeclaration);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6445);
    match(MySQLParser::DECLARE_SYMBOL);
    setState(6446);
    identifier();
    setState(6447);
    match(MySQLParser::CONDITION_SYMBOL);
    setState(6448);
    match(MySQLParser::FOR_SYMBOL);
    setState(6449);
    spCondition();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SpConditionContext ------------------------------------------------------------------

MySQLParser::SpConditionContext::SpConditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::Ulong_numberContext* MySQLParser::SpConditionContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

MySQLParser::SqlstateContext* MySQLParser::SpConditionContext::sqlstate() {
  return getRuleContext<MySQLParser::SqlstateContext>(0);
}


size_t MySQLParser::SpConditionContext::getRuleIndex() const {
  return MySQLParser::RuleSpCondition;
}

void MySQLParser::SpConditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpCondition(this);
}

void MySQLParser::SpConditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpCondition(this);
}


antlrcpp::Any MySQLParser::SpConditionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSpCondition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SpConditionContext* MySQLParser::spCondition() {
  SpConditionContext *_localctx = _tracker.createInstance<SpConditionContext>(_ctx, getState());
  enterRule(_localctx, 794, MySQLParser::RuleSpCondition);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6453);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INT_NUMBER:
      case MySQLParser::LONG_NUMBER:
      case MySQLParser::ULONGLONG_NUMBER:
      case MySQLParser::HEX_NUMBER:
      case MySQLParser::DECIMAL_NUMBER:
      case MySQLParser::FLOAT_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(6451);
        ulong_number();
        break;
      }

      case MySQLParser::SQLSTATE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6452);
        sqlstate();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SqlstateContext ------------------------------------------------------------------

MySQLParser::SqlstateContext::SqlstateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SqlstateContext::SQLSTATE_SYMBOL() {
  return getToken(MySQLParser::SQLSTATE_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::SqlstateContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::SqlstateContext::VALUE_SYMBOL() {
  return getToken(MySQLParser::VALUE_SYMBOL, 0);
}


size_t MySQLParser::SqlstateContext::getRuleIndex() const {
  return MySQLParser::RuleSqlstate;
}

void MySQLParser::SqlstateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSqlstate(this);
}

void MySQLParser::SqlstateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSqlstate(this);
}


antlrcpp::Any MySQLParser::SqlstateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSqlstate(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SqlstateContext* MySQLParser::sqlstate() {
  SqlstateContext *_localctx = _tracker.createInstance<SqlstateContext>(_ctx, getState());
  enterRule(_localctx, 796, MySQLParser::RuleSqlstate);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6455);
    match(MySQLParser::SQLSTATE_SYMBOL);
    setState(6457);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 818, _ctx)) {
    case 1: {
      setState(6456);
      match(MySQLParser::VALUE_SYMBOL);
      break;
    }

    }
    setState(6459);
    textLiteral();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerDeclarationContext ------------------------------------------------------------------

MySQLParser::HandlerDeclarationContext::HandlerDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::HandlerDeclarationContext::DECLARE_SYMBOL() {
  return getToken(MySQLParser::DECLARE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HandlerDeclarationContext::HANDLER_SYMBOL() {
  return getToken(MySQLParser::HANDLER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HandlerDeclarationContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

std::vector<MySQLParser::HandlerConditionContext *> MySQLParser::HandlerDeclarationContext::handlerCondition() {
  return getRuleContexts<MySQLParser::HandlerConditionContext>();
}

MySQLParser::HandlerConditionContext* MySQLParser::HandlerDeclarationContext::handlerCondition(size_t i) {
  return getRuleContext<MySQLParser::HandlerConditionContext>(i);
}

MySQLParser::CompoundStatementContext* MySQLParser::HandlerDeclarationContext::compoundStatement() {
  return getRuleContext<MySQLParser::CompoundStatementContext>(0);
}

tree::TerminalNode* MySQLParser::HandlerDeclarationContext::CONTINUE_SYMBOL() {
  return getToken(MySQLParser::CONTINUE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HandlerDeclarationContext::EXIT_SYMBOL() {
  return getToken(MySQLParser::EXIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HandlerDeclarationContext::UNDO_SYMBOL() {
  return getToken(MySQLParser::UNDO_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::HandlerDeclarationContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::HandlerDeclarationContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::HandlerDeclarationContext::getRuleIndex() const {
  return MySQLParser::RuleHandlerDeclaration;
}

void MySQLParser::HandlerDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerDeclaration(this);
}

void MySQLParser::HandlerDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerDeclaration(this);
}


antlrcpp::Any MySQLParser::HandlerDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitHandlerDeclaration(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::HandlerDeclarationContext* MySQLParser::handlerDeclaration() {
  HandlerDeclarationContext *_localctx = _tracker.createInstance<HandlerDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 798, MySQLParser::RuleHandlerDeclaration);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6461);
    match(MySQLParser::DECLARE_SYMBOL);
    setState(6462);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::CONTINUE_SYMBOL

    || _la == MySQLParser::EXIT_SYMBOL || _la == MySQLParser::UNDO_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(6463);
    match(MySQLParser::HANDLER_SYMBOL);
    setState(6464);
    match(MySQLParser::FOR_SYMBOL);
    setState(6465);
    handlerCondition();
    setState(6470);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 819, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(6466);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6467);
        handlerCondition(); 
      }
      setState(6472);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 819, _ctx);
    }
    setState(6473);
    compoundStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerConditionContext ------------------------------------------------------------------

MySQLParser::HandlerConditionContext::HandlerConditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SpConditionContext* MySQLParser::HandlerConditionContext::spCondition() {
  return getRuleContext<MySQLParser::SpConditionContext>(0);
}

MySQLParser::IdentifierContext* MySQLParser::HandlerConditionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::HandlerConditionContext::SQLWARNING_SYMBOL() {
  return getToken(MySQLParser::SQLWARNING_SYMBOL, 0);
}

MySQLParser::NotRuleContext* MySQLParser::HandlerConditionContext::notRule() {
  return getRuleContext<MySQLParser::NotRuleContext>(0);
}

tree::TerminalNode* MySQLParser::HandlerConditionContext::FOUND_SYMBOL() {
  return getToken(MySQLParser::FOUND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HandlerConditionContext::SQLEXCEPTION_SYMBOL() {
  return getToken(MySQLParser::SQLEXCEPTION_SYMBOL, 0);
}


size_t MySQLParser::HandlerConditionContext::getRuleIndex() const {
  return MySQLParser::RuleHandlerCondition;
}

void MySQLParser::HandlerConditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerCondition(this);
}

void MySQLParser::HandlerConditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerCondition(this);
}


antlrcpp::Any MySQLParser::HandlerConditionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitHandlerCondition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::HandlerConditionContext* MySQLParser::handlerCondition() {
  HandlerConditionContext *_localctx = _tracker.createInstance<HandlerConditionContext>(_ctx, getState());
  enterRule(_localctx, 800, MySQLParser::RuleHandlerCondition);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6482);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 820, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6475);
      spCondition();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6476);
      identifier();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6477);
      match(MySQLParser::SQLWARNING_SYMBOL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6478);
      notRule();
      setState(6479);
      match(MySQLParser::FOUND_SYMBOL);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6481);
      match(MySQLParser::SQLEXCEPTION_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CursorDeclarationContext ------------------------------------------------------------------

MySQLParser::CursorDeclarationContext::CursorDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CursorDeclarationContext::DECLARE_SYMBOL() {
  return getToken(MySQLParser::DECLARE_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::CursorDeclarationContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::CursorDeclarationContext::CURSOR_SYMBOL() {
  return getToken(MySQLParser::CURSOR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CursorDeclarationContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

MySQLParser::SelectStatementContext* MySQLParser::CursorDeclarationContext::selectStatement() {
  return getRuleContext<MySQLParser::SelectStatementContext>(0);
}


size_t MySQLParser::CursorDeclarationContext::getRuleIndex() const {
  return MySQLParser::RuleCursorDeclaration;
}

void MySQLParser::CursorDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursorDeclaration(this);
}

void MySQLParser::CursorDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursorDeclaration(this);
}


antlrcpp::Any MySQLParser::CursorDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCursorDeclaration(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CursorDeclarationContext* MySQLParser::cursorDeclaration() {
  CursorDeclarationContext *_localctx = _tracker.createInstance<CursorDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 802, MySQLParser::RuleCursorDeclaration);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6484);
    match(MySQLParser::DECLARE_SYMBOL);
    setState(6485);
    identifier();
    setState(6486);
    match(MySQLParser::CURSOR_SYMBOL);
    setState(6487);
    match(MySQLParser::FOR_SYMBOL);
    setState(6488);
    selectStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IterateStatementContext ------------------------------------------------------------------

MySQLParser::IterateStatementContext::IterateStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IterateStatementContext::ITERATE_SYMBOL() {
  return getToken(MySQLParser::ITERATE_SYMBOL, 0);
}

MySQLParser::LabelRefContext* MySQLParser::IterateStatementContext::labelRef() {
  return getRuleContext<MySQLParser::LabelRefContext>(0);
}


size_t MySQLParser::IterateStatementContext::getRuleIndex() const {
  return MySQLParser::RuleIterateStatement;
}

void MySQLParser::IterateStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIterateStatement(this);
}

void MySQLParser::IterateStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIterateStatement(this);
}


antlrcpp::Any MySQLParser::IterateStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIterateStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IterateStatementContext* MySQLParser::iterateStatement() {
  IterateStatementContext *_localctx = _tracker.createInstance<IterateStatementContext>(_ctx, getState());
  enterRule(_localctx, 804, MySQLParser::RuleIterateStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6490);
    match(MySQLParser::ITERATE_SYMBOL);
    setState(6491);
    labelRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LeaveStatementContext ------------------------------------------------------------------

MySQLParser::LeaveStatementContext::LeaveStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LeaveStatementContext::LEAVE_SYMBOL() {
  return getToken(MySQLParser::LEAVE_SYMBOL, 0);
}

MySQLParser::LabelRefContext* MySQLParser::LeaveStatementContext::labelRef() {
  return getRuleContext<MySQLParser::LabelRefContext>(0);
}


size_t MySQLParser::LeaveStatementContext::getRuleIndex() const {
  return MySQLParser::RuleLeaveStatement;
}

void MySQLParser::LeaveStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLeaveStatement(this);
}

void MySQLParser::LeaveStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLeaveStatement(this);
}


antlrcpp::Any MySQLParser::LeaveStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLeaveStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LeaveStatementContext* MySQLParser::leaveStatement() {
  LeaveStatementContext *_localctx = _tracker.createInstance<LeaveStatementContext>(_ctx, getState());
  enterRule(_localctx, 806, MySQLParser::RuleLeaveStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6493);
    match(MySQLParser::LEAVE_SYMBOL);
    setState(6494);
    labelRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GetDiagnosticsContext ------------------------------------------------------------------

MySQLParser::GetDiagnosticsContext::GetDiagnosticsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::GetDiagnosticsContext::GET_SYMBOL() {
  return getToken(MySQLParser::GET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GetDiagnosticsContext::DIAGNOSTICS_SYMBOL() {
  return getToken(MySQLParser::DIAGNOSTICS_SYMBOL, 0);
}

std::vector<MySQLParser::StatementInformationItemContext *> MySQLParser::GetDiagnosticsContext::statementInformationItem() {
  return getRuleContexts<MySQLParser::StatementInformationItemContext>();
}

MySQLParser::StatementInformationItemContext* MySQLParser::GetDiagnosticsContext::statementInformationItem(size_t i) {
  return getRuleContext<MySQLParser::StatementInformationItemContext>(i);
}

tree::TerminalNode* MySQLParser::GetDiagnosticsContext::CONDITION_SYMBOL() {
  return getToken(MySQLParser::CONDITION_SYMBOL, 0);
}

MySQLParser::SignalAllowedExprContext* MySQLParser::GetDiagnosticsContext::signalAllowedExpr() {
  return getRuleContext<MySQLParser::SignalAllowedExprContext>(0);
}

std::vector<MySQLParser::ConditionInformationItemContext *> MySQLParser::GetDiagnosticsContext::conditionInformationItem() {
  return getRuleContexts<MySQLParser::ConditionInformationItemContext>();
}

MySQLParser::ConditionInformationItemContext* MySQLParser::GetDiagnosticsContext::conditionInformationItem(size_t i) {
  return getRuleContext<MySQLParser::ConditionInformationItemContext>(i);
}

tree::TerminalNode* MySQLParser::GetDiagnosticsContext::CURRENT_SYMBOL() {
  return getToken(MySQLParser::CURRENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GetDiagnosticsContext::STACKED_SYMBOL() {
  return getToken(MySQLParser::STACKED_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::GetDiagnosticsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::GetDiagnosticsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::GetDiagnosticsContext::getRuleIndex() const {
  return MySQLParser::RuleGetDiagnostics;
}

void MySQLParser::GetDiagnosticsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGetDiagnostics(this);
}

void MySQLParser::GetDiagnosticsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGetDiagnostics(this);
}


antlrcpp::Any MySQLParser::GetDiagnosticsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitGetDiagnostics(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GetDiagnosticsContext* MySQLParser::getDiagnostics() {
  GetDiagnosticsContext *_localctx = _tracker.createInstance<GetDiagnosticsContext>(_ctx, getState());
  enterRule(_localctx, 808, MySQLParser::RuleGetDiagnostics);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6496);
    match(MySQLParser::GET_SYMBOL);
    setState(6500);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 821, _ctx)) {
    case 1: {
      setState(6497);
      match(MySQLParser::CURRENT_SYMBOL);
      break;
    }

    case 2: {
      setState(6498);

      if (!(serverVersion >= 50700)) throw FailedPredicateException(this, "serverVersion >= 50700");
      setState(6499);
      match(MySQLParser::STACKED_SYMBOL);
      break;
    }

    }
    setState(6502);
    match(MySQLParser::DIAGNOSTICS_SYMBOL);
    setState(6521);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 824, _ctx)) {
    case 1: {
      setState(6503);
      statementInformationItem();
      setState(6508);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(6504);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6505);
        statementInformationItem();
        setState(6510);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      setState(6511);
      match(MySQLParser::CONDITION_SYMBOL);
      setState(6512);
      signalAllowedExpr();
      setState(6513);
      conditionInformationItem();
      setState(6518);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(6514);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6515);
        conditionInformationItem();
        setState(6520);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignalAllowedExprContext ------------------------------------------------------------------

MySQLParser::SignalAllowedExprContext::SignalAllowedExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LiteralContext* MySQLParser::SignalAllowedExprContext::literal() {
  return getRuleContext<MySQLParser::LiteralContext>(0);
}

MySQLParser::VariableContext* MySQLParser::SignalAllowedExprContext::variable() {
  return getRuleContext<MySQLParser::VariableContext>(0);
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::SignalAllowedExprContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}


size_t MySQLParser::SignalAllowedExprContext::getRuleIndex() const {
  return MySQLParser::RuleSignalAllowedExpr;
}

void MySQLParser::SignalAllowedExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignalAllowedExpr(this);
}

void MySQLParser::SignalAllowedExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignalAllowedExpr(this);
}


antlrcpp::Any MySQLParser::SignalAllowedExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSignalAllowedExpr(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SignalAllowedExprContext* MySQLParser::signalAllowedExpr() {
  SignalAllowedExprContext *_localctx = _tracker.createInstance<SignalAllowedExprContext>(_ctx, getState());
  enterRule(_localctx, 810, MySQLParser::RuleSignalAllowedExpr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6526);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 825, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6523);
      literal();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6524);
      variable();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6525);
      qualifiedIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementInformationItemContext ------------------------------------------------------------------

MySQLParser::StatementInformationItemContext::StatementInformationItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::StatementInformationItemContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::StatementInformationItemContext::NUMBER_SYMBOL() {
  return getToken(MySQLParser::NUMBER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::StatementInformationItemContext::ROW_COUNT_SYMBOL() {
  return getToken(MySQLParser::ROW_COUNT_SYMBOL, 0);
}

MySQLParser::VariableContext* MySQLParser::StatementInformationItemContext::variable() {
  return getRuleContext<MySQLParser::VariableContext>(0);
}

MySQLParser::IdentifierContext* MySQLParser::StatementInformationItemContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::StatementInformationItemContext::getRuleIndex() const {
  return MySQLParser::RuleStatementInformationItem;
}

void MySQLParser::StatementInformationItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatementInformationItem(this);
}

void MySQLParser::StatementInformationItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatementInformationItem(this);
}


antlrcpp::Any MySQLParser::StatementInformationItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitStatementInformationItem(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::StatementInformationItemContext* MySQLParser::statementInformationItem() {
  StatementInformationItemContext *_localctx = _tracker.createInstance<StatementInformationItemContext>(_ctx, getState());
  enterRule(_localctx, 812, MySQLParser::RuleStatementInformationItem);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6530);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 826, _ctx)) {
    case 1: {
      setState(6528);
      variable();
      break;
    }

    case 2: {
      setState(6529);
      identifier();
      break;
    }

    }
    setState(6532);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(6533);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::NUMBER_SYMBOL

    || _la == MySQLParser::ROW_COUNT_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionInformationItemContext ------------------------------------------------------------------

MySQLParser::ConditionInformationItemContext::ConditionInformationItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ConditionInformationItemContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::VariableContext* MySQLParser::ConditionInformationItemContext::variable() {
  return getRuleContext<MySQLParser::VariableContext>(0);
}

MySQLParser::IdentifierContext* MySQLParser::ConditionInformationItemContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::SignalInformationItemNameContext* MySQLParser::ConditionInformationItemContext::signalInformationItemName() {
  return getRuleContext<MySQLParser::SignalInformationItemNameContext>(0);
}

tree::TerminalNode* MySQLParser::ConditionInformationItemContext::RETURNED_SQLSTATE_SYMBOL() {
  return getToken(MySQLParser::RETURNED_SQLSTATE_SYMBOL, 0);
}


size_t MySQLParser::ConditionInformationItemContext::getRuleIndex() const {
  return MySQLParser::RuleConditionInformationItem;
}

void MySQLParser::ConditionInformationItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditionInformationItem(this);
}

void MySQLParser::ConditionInformationItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditionInformationItem(this);
}


antlrcpp::Any MySQLParser::ConditionInformationItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitConditionInformationItem(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ConditionInformationItemContext* MySQLParser::conditionInformationItem() {
  ConditionInformationItemContext *_localctx = _tracker.createInstance<ConditionInformationItemContext>(_ctx, getState());
  enterRule(_localctx, 814, MySQLParser::RuleConditionInformationItem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6537);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 827, _ctx)) {
    case 1: {
      setState(6535);
      variable();
      break;
    }

    case 2: {
      setState(6536);
      identifier();
      break;
    }

    }
    setState(6539);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(6542);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CATALOG_NAME_SYMBOL:
      case MySQLParser::CLASS_ORIGIN_SYMBOL:
      case MySQLParser::COLUMN_NAME_SYMBOL:
      case MySQLParser::CONSTRAINT_CATALOG_SYMBOL:
      case MySQLParser::CONSTRAINT_SCHEMA_SYMBOL:
      case MySQLParser::CONSTRAINT_NAME_SYMBOL:
      case MySQLParser::CURSOR_NAME_SYMBOL:
      case MySQLParser::MESSAGE_TEXT_SYMBOL:
      case MySQLParser::MYSQL_ERRNO_SYMBOL:
      case MySQLParser::SCHEMA_NAME_SYMBOL:
      case MySQLParser::SUBCLASS_ORIGIN_SYMBOL:
      case MySQLParser::TABLE_NAME_SYMBOL: {
        setState(6540);
        signalInformationItemName();
        break;
      }

      case MySQLParser::RETURNED_SQLSTATE_SYMBOL: {
        setState(6541);
        match(MySQLParser::RETURNED_SQLSTATE_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignalInformationItemNameContext ------------------------------------------------------------------

MySQLParser::SignalInformationItemNameContext::SignalInformationItemNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::CLASS_ORIGIN_SYMBOL() {
  return getToken(MySQLParser::CLASS_ORIGIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::SUBCLASS_ORIGIN_SYMBOL() {
  return getToken(MySQLParser::SUBCLASS_ORIGIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::CONSTRAINT_CATALOG_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_CATALOG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::CONSTRAINT_SCHEMA_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_SCHEMA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::CONSTRAINT_NAME_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::CATALOG_NAME_SYMBOL() {
  return getToken(MySQLParser::CATALOG_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::SCHEMA_NAME_SYMBOL() {
  return getToken(MySQLParser::SCHEMA_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::TABLE_NAME_SYMBOL() {
  return getToken(MySQLParser::TABLE_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::COLUMN_NAME_SYMBOL() {
  return getToken(MySQLParser::COLUMN_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::CURSOR_NAME_SYMBOL() {
  return getToken(MySQLParser::CURSOR_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::MESSAGE_TEXT_SYMBOL() {
  return getToken(MySQLParser::MESSAGE_TEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::MYSQL_ERRNO_SYMBOL() {
  return getToken(MySQLParser::MYSQL_ERRNO_SYMBOL, 0);
}


size_t MySQLParser::SignalInformationItemNameContext::getRuleIndex() const {
  return MySQLParser::RuleSignalInformationItemName;
}

void MySQLParser::SignalInformationItemNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignalInformationItemName(this);
}

void MySQLParser::SignalInformationItemNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignalInformationItemName(this);
}


antlrcpp::Any MySQLParser::SignalInformationItemNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSignalInformationItemName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SignalInformationItemNameContext* MySQLParser::signalInformationItemName() {
  SignalInformationItemNameContext *_localctx = _tracker.createInstance<SignalInformationItemNameContext>(_ctx, getState());
  enterRule(_localctx, 816, MySQLParser::RuleSignalInformationItemName);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6544);
    _la = _input->LA(1);
    if (!(((((_la - 78) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 78)) & ((1ULL << (MySQLParser::CATALOG_NAME_SYMBOL - 78))
      | (1ULL << (MySQLParser::CLASS_ORIGIN_SYMBOL - 78))
      | (1ULL << (MySQLParser::COLUMN_NAME_SYMBOL - 78))
      | (1ULL << (MySQLParser::CONSTRAINT_CATALOG_SYMBOL - 78))
      | (1ULL << (MySQLParser::CONSTRAINT_SCHEMA_SYMBOL - 78))
      | (1ULL << (MySQLParser::CONSTRAINT_NAME_SYMBOL - 78))
      | (1ULL << (MySQLParser::CURSOR_NAME_SYMBOL - 78)))) != 0) || _la == MySQLParser::MESSAGE_TEXT_SYMBOL

    || _la == MySQLParser::MYSQL_ERRNO_SYMBOL || ((((_la - 304) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 304)) & ((1ULL << (MySQLParser::SCHEMA_NAME_SYMBOL - 304))
      | (1ULL << (MySQLParser::SUBCLASS_ORIGIN_SYMBOL - 304))
      | (1ULL << (MySQLParser::TABLE_NAME_SYMBOL - 304)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignalStatementContext ------------------------------------------------------------------

MySQLParser::SignalStatementContext::SignalStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SignalStatementContext::SIGNAL_SYMBOL() {
  return getToken(MySQLParser::SIGNAL_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::SignalStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::SqlstateContext* MySQLParser::SignalStatementContext::sqlstate() {
  return getRuleContext<MySQLParser::SqlstateContext>(0);
}

tree::TerminalNode* MySQLParser::SignalStatementContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

std::vector<MySQLParser::SignalInformationItemContext *> MySQLParser::SignalStatementContext::signalInformationItem() {
  return getRuleContexts<MySQLParser::SignalInformationItemContext>();
}

MySQLParser::SignalInformationItemContext* MySQLParser::SignalStatementContext::signalInformationItem(size_t i) {
  return getRuleContext<MySQLParser::SignalInformationItemContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::SignalStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::SignalStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::SignalStatementContext::getRuleIndex() const {
  return MySQLParser::RuleSignalStatement;
}

void MySQLParser::SignalStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignalStatement(this);
}

void MySQLParser::SignalStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignalStatement(this);
}


antlrcpp::Any MySQLParser::SignalStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSignalStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SignalStatementContext* MySQLParser::signalStatement() {
  SignalStatementContext *_localctx = _tracker.createInstance<SignalStatementContext>(_ctx, getState());
  enterRule(_localctx, 818, MySQLParser::RuleSignalStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6546);
    match(MySQLParser::SIGNAL_SYMBOL);
    setState(6549);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 829, _ctx)) {
    case 1: {
      setState(6547);
      identifier();
      break;
    }

    case 2: {
      setState(6548);
      sqlstate();
      break;
    }

    }
    setState(6560);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::SET_SYMBOL) {
      setState(6551);
      match(MySQLParser::SET_SYMBOL);
      setState(6552);
      signalInformationItem();
      setState(6557);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(6553);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6554);
        signalInformationItem();
        setState(6559);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResignalStatementContext ------------------------------------------------------------------

MySQLParser::ResignalStatementContext::ResignalStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ResignalStatementContext::RESIGNAL_SYMBOL() {
  return getToken(MySQLParser::RESIGNAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ResignalStatementContext::SQLSTATE_SYMBOL() {
  return getToken(MySQLParser::SQLSTATE_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::ResignalStatementContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::ResignalStatementContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

std::vector<MySQLParser::SignalInformationItemContext *> MySQLParser::ResignalStatementContext::signalInformationItem() {
  return getRuleContexts<MySQLParser::SignalInformationItemContext>();
}

MySQLParser::SignalInformationItemContext* MySQLParser::ResignalStatementContext::signalInformationItem(size_t i) {
  return getRuleContext<MySQLParser::SignalInformationItemContext>(i);
}

tree::TerminalNode* MySQLParser::ResignalStatementContext::VALUE_SYMBOL() {
  return getToken(MySQLParser::VALUE_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::ResignalStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ResignalStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ResignalStatementContext::getRuleIndex() const {
  return MySQLParser::RuleResignalStatement;
}

void MySQLParser::ResignalStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResignalStatement(this);
}

void MySQLParser::ResignalStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResignalStatement(this);
}


antlrcpp::Any MySQLParser::ResignalStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitResignalStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ResignalStatementContext* MySQLParser::resignalStatement() {
  ResignalStatementContext *_localctx = _tracker.createInstance<ResignalStatementContext>(_ctx, getState());
  enterRule(_localctx, 820, MySQLParser::RuleResignalStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6562);
    match(MySQLParser::RESIGNAL_SYMBOL);
    setState(6568);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::SQLSTATE_SYMBOL) {
      setState(6563);
      match(MySQLParser::SQLSTATE_SYMBOL);
      setState(6565);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 832, _ctx)) {
      case 1: {
        setState(6564);
        match(MySQLParser::VALUE_SYMBOL);
        break;
      }

      }
      setState(6567);
      textOrIdentifier();
    }
    setState(6579);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::SET_SYMBOL) {
      setState(6570);
      match(MySQLParser::SET_SYMBOL);
      setState(6571);
      signalInformationItem();
      setState(6576);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(6572);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6573);
        signalInformationItem();
        setState(6578);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignalInformationItemContext ------------------------------------------------------------------

MySQLParser::SignalInformationItemContext::SignalInformationItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SignalInformationItemNameContext* MySQLParser::SignalInformationItemContext::signalInformationItemName() {
  return getRuleContext<MySQLParser::SignalInformationItemNameContext>(0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::SignalAllowedExprContext* MySQLParser::SignalInformationItemContext::signalAllowedExpr() {
  return getRuleContext<MySQLParser::SignalAllowedExprContext>(0);
}


size_t MySQLParser::SignalInformationItemContext::getRuleIndex() const {
  return MySQLParser::RuleSignalInformationItem;
}

void MySQLParser::SignalInformationItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignalInformationItem(this);
}

void MySQLParser::SignalInformationItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignalInformationItem(this);
}


antlrcpp::Any MySQLParser::SignalInformationItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSignalInformationItem(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SignalInformationItemContext* MySQLParser::signalInformationItem() {
  SignalInformationItemContext *_localctx = _tracker.createInstance<SignalInformationItemContext>(_ctx, getState());
  enterRule(_localctx, 822, MySQLParser::RuleSignalInformationItem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6581);
    signalInformationItemName();
    setState(6582);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(6583);
    signalAllowedExpr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CursorOpenContext ------------------------------------------------------------------

MySQLParser::CursorOpenContext::CursorOpenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CursorOpenContext::OPEN_SYMBOL() {
  return getToken(MySQLParser::OPEN_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::CursorOpenContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::CursorOpenContext::getRuleIndex() const {
  return MySQLParser::RuleCursorOpen;
}

void MySQLParser::CursorOpenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursorOpen(this);
}

void MySQLParser::CursorOpenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursorOpen(this);
}


antlrcpp::Any MySQLParser::CursorOpenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCursorOpen(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CursorOpenContext* MySQLParser::cursorOpen() {
  CursorOpenContext *_localctx = _tracker.createInstance<CursorOpenContext>(_ctx, getState());
  enterRule(_localctx, 824, MySQLParser::RuleCursorOpen);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6585);
    match(MySQLParser::OPEN_SYMBOL);
    setState(6586);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CursorCloseContext ------------------------------------------------------------------

MySQLParser::CursorCloseContext::CursorCloseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CursorCloseContext::CLOSE_SYMBOL() {
  return getToken(MySQLParser::CLOSE_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::CursorCloseContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::CursorCloseContext::getRuleIndex() const {
  return MySQLParser::RuleCursorClose;
}

void MySQLParser::CursorCloseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursorClose(this);
}

void MySQLParser::CursorCloseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursorClose(this);
}


antlrcpp::Any MySQLParser::CursorCloseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCursorClose(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CursorCloseContext* MySQLParser::cursorClose() {
  CursorCloseContext *_localctx = _tracker.createInstance<CursorCloseContext>(_ctx, getState());
  enterRule(_localctx, 826, MySQLParser::RuleCursorClose);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6588);
    match(MySQLParser::CLOSE_SYMBOL);
    setState(6589);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CursorFetchContext ------------------------------------------------------------------

MySQLParser::CursorFetchContext::CursorFetchContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CursorFetchContext::FETCH_SYMBOL() {
  return getToken(MySQLParser::FETCH_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::CursorFetchContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::CursorFetchContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

MySQLParser::IdentifierListContext* MySQLParser::CursorFetchContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

tree::TerminalNode* MySQLParser::CursorFetchContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CursorFetchContext::NEXT_SYMBOL() {
  return getToken(MySQLParser::NEXT_SYMBOL, 0);
}


size_t MySQLParser::CursorFetchContext::getRuleIndex() const {
  return MySQLParser::RuleCursorFetch;
}

void MySQLParser::CursorFetchContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursorFetch(this);
}

void MySQLParser::CursorFetchContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursorFetch(this);
}


antlrcpp::Any MySQLParser::CursorFetchContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCursorFetch(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CursorFetchContext* MySQLParser::cursorFetch() {
  CursorFetchContext *_localctx = _tracker.createInstance<CursorFetchContext>(_ctx, getState());
  enterRule(_localctx, 828, MySQLParser::RuleCursorFetch);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6591);
    match(MySQLParser::FETCH_SYMBOL);
    setState(6596);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 837, _ctx)) {
    case 1: {
      setState(6593);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::NEXT_SYMBOL) {
        setState(6592);
        match(MySQLParser::NEXT_SYMBOL);
      }
      setState(6595);
      match(MySQLParser::FROM_SYMBOL);
      break;
    }

    }
    setState(6598);
    identifier();
    setState(6599);
    match(MySQLParser::INTO_SYMBOL);
    setState(6600);
    identifierList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScheduleContext ------------------------------------------------------------------

MySQLParser::ScheduleContext::ScheduleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ScheduleContext::AT_SYMBOL() {
  return getToken(MySQLParser::AT_SYMBOL, 0);
}

std::vector<MySQLParser::ExprContext *> MySQLParser::ScheduleContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext* MySQLParser::ScheduleContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

tree::TerminalNode* MySQLParser::ScheduleContext::EVERY_SYMBOL() {
  return getToken(MySQLParser::EVERY_SYMBOL, 0);
}

MySQLParser::IntervalContext* MySQLParser::ScheduleContext::interval() {
  return getRuleContext<MySQLParser::IntervalContext>(0);
}

tree::TerminalNode* MySQLParser::ScheduleContext::STARTS_SYMBOL() {
  return getToken(MySQLParser::STARTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ScheduleContext::ENDS_SYMBOL() {
  return getToken(MySQLParser::ENDS_SYMBOL, 0);
}


size_t MySQLParser::ScheduleContext::getRuleIndex() const {
  return MySQLParser::RuleSchedule;
}

void MySQLParser::ScheduleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchedule(this);
}

void MySQLParser::ScheduleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchedule(this);
}


antlrcpp::Any MySQLParser::ScheduleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSchedule(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ScheduleContext* MySQLParser::schedule() {
  ScheduleContext *_localctx = _tracker.createInstance<ScheduleContext>(_ctx, getState());
  enterRule(_localctx, 830, MySQLParser::RuleSchedule);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6615);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::AT_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(6602);
        match(MySQLParser::AT_SYMBOL);
        setState(6603);
        expr(0);
        break;
      }

      case MySQLParser::EVERY_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6604);
        match(MySQLParser::EVERY_SYMBOL);
        setState(6605);
        expr(0);
        setState(6606);
        interval();
        setState(6609);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::STARTS_SYMBOL) {
          setState(6607);
          match(MySQLParser::STARTS_SYMBOL);
          setState(6608);
          expr(0);
        }
        setState(6613);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ENDS_SYMBOL) {
          setState(6611);
          match(MySQLParser::ENDS_SYMBOL);
          setState(6612);
          expr(0);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnDefinitionContext ------------------------------------------------------------------

MySQLParser::ColumnDefinitionContext::ColumnDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ColumnNameContext* MySQLParser::ColumnDefinitionContext::columnName() {
  return getRuleContext<MySQLParser::ColumnNameContext>(0);
}

MySQLParser::FieldDefinitionContext* MySQLParser::ColumnDefinitionContext::fieldDefinition() {
  return getRuleContext<MySQLParser::FieldDefinitionContext>(0);
}

MySQLParser::CheckOrReferencesContext* MySQLParser::ColumnDefinitionContext::checkOrReferences() {
  return getRuleContext<MySQLParser::CheckOrReferencesContext>(0);
}


size_t MySQLParser::ColumnDefinitionContext::getRuleIndex() const {
  return MySQLParser::RuleColumnDefinition;
}

void MySQLParser::ColumnDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnDefinition(this);
}

void MySQLParser::ColumnDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnDefinition(this);
}


antlrcpp::Any MySQLParser::ColumnDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitColumnDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ColumnDefinitionContext* MySQLParser::columnDefinition() {
  ColumnDefinitionContext *_localctx = _tracker.createInstance<ColumnDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 832, MySQLParser::RuleColumnDefinition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6617);
    columnName();
    setState(6618);
    fieldDefinition();
    setState(6620);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::CHECK_SYMBOL || _la == MySQLParser::REFERENCES_SYMBOL) {
      setState(6619);
      checkOrReferences();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CheckOrReferencesContext ------------------------------------------------------------------

MySQLParser::CheckOrReferencesContext::CheckOrReferencesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CheckConstraintContext* MySQLParser::CheckOrReferencesContext::checkConstraint() {
  return getRuleContext<MySQLParser::CheckConstraintContext>(0);
}

MySQLParser::ReferencesContext* MySQLParser::CheckOrReferencesContext::references() {
  return getRuleContext<MySQLParser::ReferencesContext>(0);
}


size_t MySQLParser::CheckOrReferencesContext::getRuleIndex() const {
  return MySQLParser::RuleCheckOrReferences;
}

void MySQLParser::CheckOrReferencesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCheckOrReferences(this);
}

void MySQLParser::CheckOrReferencesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCheckOrReferences(this);
}


antlrcpp::Any MySQLParser::CheckOrReferencesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCheckOrReferences(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CheckOrReferencesContext* MySQLParser::checkOrReferences() {
  CheckOrReferencesContext *_localctx = _tracker.createInstance<CheckOrReferencesContext>(_ctx, getState());
  enterRule(_localctx, 834, MySQLParser::RuleCheckOrReferences);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6624);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CHECK_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(6622);
        checkConstraint();
        break;
      }

      case MySQLParser::REFERENCES_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6623);
        references();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CheckConstraintContext ------------------------------------------------------------------

MySQLParser::CheckConstraintContext::CheckConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CheckConstraintContext::CHECK_SYMBOL() {
  return getToken(MySQLParser::CHECK_SYMBOL, 0);
}

MySQLParser::ExprWithParenthesesContext* MySQLParser::CheckConstraintContext::exprWithParentheses() {
  return getRuleContext<MySQLParser::ExprWithParenthesesContext>(0);
}


size_t MySQLParser::CheckConstraintContext::getRuleIndex() const {
  return MySQLParser::RuleCheckConstraint;
}

void MySQLParser::CheckConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCheckConstraint(this);
}

void MySQLParser::CheckConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCheckConstraint(this);
}


antlrcpp::Any MySQLParser::CheckConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCheckConstraint(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CheckConstraintContext* MySQLParser::checkConstraint() {
  CheckConstraintContext *_localctx = _tracker.createInstance<CheckConstraintContext>(_ctx, getState());
  enterRule(_localctx, 836, MySQLParser::RuleCheckConstraint);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6626);
    match(MySQLParser::CHECK_SYMBOL);
    setState(6627);
    exprWithParentheses();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableConstraintDefContext ------------------------------------------------------------------

MySQLParser::TableConstraintDefContext::TableConstraintDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::KeyListVariantsContext* MySQLParser::TableConstraintDefContext::keyListVariants() {
  return getRuleContext<MySQLParser::KeyListVariantsContext>(0);
}

tree::TerminalNode* MySQLParser::TableConstraintDefContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TableConstraintDefContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

MySQLParser::IndexNameAndTypeContext* MySQLParser::TableConstraintDefContext::indexNameAndType() {
  return getRuleContext<MySQLParser::IndexNameAndTypeContext>(0);
}

std::vector<MySQLParser::IndexOptionContext *> MySQLParser::TableConstraintDefContext::indexOption() {
  return getRuleContexts<MySQLParser::IndexOptionContext>();
}

MySQLParser::IndexOptionContext* MySQLParser::TableConstraintDefContext::indexOption(size_t i) {
  return getRuleContext<MySQLParser::IndexOptionContext>(i);
}

tree::TerminalNode* MySQLParser::TableConstraintDefContext::FULLTEXT_SYMBOL() {
  return getToken(MySQLParser::FULLTEXT_SYMBOL, 0);
}

MySQLParser::KeyOrIndexContext* MySQLParser::TableConstraintDefContext::keyOrIndex() {
  return getRuleContext<MySQLParser::KeyOrIndexContext>(0);
}

MySQLParser::IndexNameContext* MySQLParser::TableConstraintDefContext::indexName() {
  return getRuleContext<MySQLParser::IndexNameContext>(0);
}

std::vector<MySQLParser::FulltextIndexOptionContext *> MySQLParser::TableConstraintDefContext::fulltextIndexOption() {
  return getRuleContexts<MySQLParser::FulltextIndexOptionContext>();
}

MySQLParser::FulltextIndexOptionContext* MySQLParser::TableConstraintDefContext::fulltextIndexOption(size_t i) {
  return getRuleContext<MySQLParser::FulltextIndexOptionContext>(i);
}

tree::TerminalNode* MySQLParser::TableConstraintDefContext::SPATIAL_SYMBOL() {
  return getToken(MySQLParser::SPATIAL_SYMBOL, 0);
}

std::vector<MySQLParser::SpatialIndexOptionContext *> MySQLParser::TableConstraintDefContext::spatialIndexOption() {
  return getRuleContexts<MySQLParser::SpatialIndexOptionContext>();
}

MySQLParser::SpatialIndexOptionContext* MySQLParser::TableConstraintDefContext::spatialIndexOption(size_t i) {
  return getRuleContext<MySQLParser::SpatialIndexOptionContext>(i);
}

MySQLParser::KeyListContext* MySQLParser::TableConstraintDefContext::keyList() {
  return getRuleContext<MySQLParser::KeyListContext>(0);
}

MySQLParser::ReferencesContext* MySQLParser::TableConstraintDefContext::references() {
  return getRuleContext<MySQLParser::ReferencesContext>(0);
}

MySQLParser::CheckConstraintContext* MySQLParser::TableConstraintDefContext::checkConstraint() {
  return getRuleContext<MySQLParser::CheckConstraintContext>(0);
}

tree::TerminalNode* MySQLParser::TableConstraintDefContext::CONSTRAINT_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TableConstraintDefContext::FOREIGN_SYMBOL() {
  return getToken(MySQLParser::FOREIGN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TableConstraintDefContext::PRIMARY_SYMBOL() {
  return getToken(MySQLParser::PRIMARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TableConstraintDefContext::UNIQUE_SYMBOL() {
  return getToken(MySQLParser::UNIQUE_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::TableConstraintDefContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::TableConstraintDefContext::getRuleIndex() const {
  return MySQLParser::RuleTableConstraintDef;
}

void MySQLParser::TableConstraintDefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableConstraintDef(this);
}

void MySQLParser::TableConstraintDefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableConstraintDef(this);
}


antlrcpp::Any MySQLParser::TableConstraintDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTableConstraintDef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableConstraintDefContext* MySQLParser::tableConstraintDef() {
  TableConstraintDefContext *_localctx = _tracker.createInstance<TableConstraintDefContext>(_ctx, getState());
  enterRule(_localctx, 838, MySQLParser::RuleTableConstraintDef);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(6703);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INDEX_SYMBOL:
      case MySQLParser::KEY_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(6629);
        dynamic_cast<TableConstraintDefContext *>(_localctx)->type = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::INDEX_SYMBOL

        || _la == MySQLParser::KEY_SYMBOL)) {
          dynamic_cast<TableConstraintDefContext *>(_localctx)->type = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6631);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 843, _ctx)) {
        case 1: {
          setState(6630);
          indexNameAndType();
          break;
        }

        }
        setState(6633);
        keyListVariants();
        setState(6637);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 844, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(6634);
            indexOption(); 
          }
          setState(6639);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 844, _ctx);
        }
        break;
      }

      case MySQLParser::FULLTEXT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6640);
        dynamic_cast<TableConstraintDefContext *>(_localctx)->type = match(MySQLParser::FULLTEXT_SYMBOL);
        setState(6642);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 845, _ctx)) {
        case 1: {
          setState(6641);
          keyOrIndex();
          break;
        }

        }
        setState(6645);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 846, _ctx)) {
        case 1: {
          setState(6644);
          indexName();
          break;
        }

        }
        setState(6647);
        keyListVariants();
        setState(6651);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 847, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(6648);
            fulltextIndexOption(); 
          }
          setState(6653);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 847, _ctx);
        }
        break;
      }

      case MySQLParser::SPATIAL_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(6654);
        dynamic_cast<TableConstraintDefContext *>(_localctx)->type = match(MySQLParser::SPATIAL_SYMBOL);
        setState(6656);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 848, _ctx)) {
        case 1: {
          setState(6655);
          keyOrIndex();
          break;
        }

        }
        setState(6659);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 849, _ctx)) {
        case 1: {
          setState(6658);
          indexName();
          break;
        }

        }
        setState(6661);
        keyListVariants();
        setState(6665);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 850, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(6662);
            spatialIndexOption(); 
          }
          setState(6667);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 850, _ctx);
        }
        break;
      }

      case MySQLParser::CHECK_SYMBOL:
      case MySQLParser::CONSTRAINT_SYMBOL:
      case MySQLParser::FOREIGN_SYMBOL:
      case MySQLParser::PRIMARY_SYMBOL:
      case MySQLParser::UNIQUE_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(6672);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::CONSTRAINT_SYMBOL) {
          setState(6668);
          match(MySQLParser::CONSTRAINT_SYMBOL);
          setState(6670);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 851, _ctx)) {
          case 1: {
            setState(6669);
            identifier();
            break;
          }

          }
        }
        setState(6701);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::PRIMARY_SYMBOL:
          case MySQLParser::UNIQUE_SYMBOL: {
            setState(6680);
            _errHandler->sync(this);
            switch (_input->LA(1)) {
              case MySQLParser::PRIMARY_SYMBOL: {
                setState(6674);
                dynamic_cast<TableConstraintDefContext *>(_localctx)->type = match(MySQLParser::PRIMARY_SYMBOL);
                setState(6675);
                match(MySQLParser::KEY_SYMBOL);
                break;
              }

              case MySQLParser::UNIQUE_SYMBOL: {
                setState(6676);
                dynamic_cast<TableConstraintDefContext *>(_localctx)->type = match(MySQLParser::UNIQUE_SYMBOL);
                setState(6678);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 853, _ctx)) {
                case 1: {
                  setState(6677);
                  keyOrIndex();
                  break;
                }

                }
                break;
              }

            default:
              throw NoViableAltException(this);
            }
            setState(6683);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 855, _ctx)) {
            case 1: {
              setState(6682);
              indexNameAndType();
              break;
            }

            }
            setState(6685);
            keyListVariants();
            setState(6689);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 856, _ctx);
            while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
              if (alt == 1) {
                setState(6686);
                indexOption(); 
              }
              setState(6691);
              _errHandler->sync(this);
              alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 856, _ctx);
            }
            break;
          }

          case MySQLParser::FOREIGN_SYMBOL: {
            setState(6692);
            dynamic_cast<TableConstraintDefContext *>(_localctx)->type = match(MySQLParser::FOREIGN_SYMBOL);
            setState(6693);
            match(MySQLParser::KEY_SYMBOL);
            setState(6695);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 857, _ctx)) {
            case 1: {
              setState(6694);
              indexName();
              break;
            }

            }
            setState(6697);
            keyList();
            setState(6698);
            references();
            break;
          }

          case MySQLParser::CHECK_SYMBOL: {
            setState(6700);
            checkConstraint();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldDefinitionContext ------------------------------------------------------------------

MySQLParser::FieldDefinitionContext::FieldDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::DataTypeContext* MySQLParser::FieldDefinitionContext::dataType() {
  return getRuleContext<MySQLParser::DataTypeContext>(0);
}

tree::TerminalNode* MySQLParser::FieldDefinitionContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::ExprWithParenthesesContext* MySQLParser::FieldDefinitionContext::exprWithParentheses() {
  return getRuleContext<MySQLParser::ExprWithParenthesesContext>(0);
}

std::vector<MySQLParser::ColumnAttributeContext *> MySQLParser::FieldDefinitionContext::columnAttribute() {
  return getRuleContexts<MySQLParser::ColumnAttributeContext>();
}

MySQLParser::ColumnAttributeContext* MySQLParser::FieldDefinitionContext::columnAttribute(size_t i) {
  return getRuleContext<MySQLParser::ColumnAttributeContext>(i);
}

MySQLParser::CollateContext* MySQLParser::FieldDefinitionContext::collate() {
  return getRuleContext<MySQLParser::CollateContext>(0);
}

tree::TerminalNode* MySQLParser::FieldDefinitionContext::GENERATED_SYMBOL() {
  return getToken(MySQLParser::GENERATED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FieldDefinitionContext::ALWAYS_SYMBOL() {
  return getToken(MySQLParser::ALWAYS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FieldDefinitionContext::VIRTUAL_SYMBOL() {
  return getToken(MySQLParser::VIRTUAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FieldDefinitionContext::STORED_SYMBOL() {
  return getToken(MySQLParser::STORED_SYMBOL, 0);
}

std::vector<MySQLParser::GcolAttributeContext *> MySQLParser::FieldDefinitionContext::gcolAttribute() {
  return getRuleContexts<MySQLParser::GcolAttributeContext>();
}

MySQLParser::GcolAttributeContext* MySQLParser::FieldDefinitionContext::gcolAttribute(size_t i) {
  return getRuleContext<MySQLParser::GcolAttributeContext>(i);
}


size_t MySQLParser::FieldDefinitionContext::getRuleIndex() const {
  return MySQLParser::RuleFieldDefinition;
}

void MySQLParser::FieldDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldDefinition(this);
}

void MySQLParser::FieldDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldDefinition(this);
}


antlrcpp::Any MySQLParser::FieldDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFieldDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FieldDefinitionContext* MySQLParser::fieldDefinition() {
  FieldDefinitionContext *_localctx = _tracker.createInstance<FieldDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 840, MySQLParser::RuleFieldDefinition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6705);
    dataType();
    setState(6741);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 867, _ctx)) {
    case 1: {
      setState(6709);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 860, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(6706);
          columnAttribute(); 
        }
        setState(6711);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 860, _ctx);
      }
      break;
    }

    case 2: {
      setState(6712);

      if (!(serverVersion >= 50707)) throw FailedPredicateException(this, "serverVersion >= 50707");
      setState(6714);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COLLATE_SYMBOL) {
        setState(6713);
        collate();
      }
      setState(6718);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::GENERATED_SYMBOL) {
        setState(6716);
        match(MySQLParser::GENERATED_SYMBOL);
        setState(6717);
        match(MySQLParser::ALWAYS_SYMBOL);
      }
      setState(6720);
      match(MySQLParser::AS_SYMBOL);
      setState(6721);
      exprWithParentheses();
      setState(6723);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 863, _ctx)) {
      case 1: {
        setState(6722);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::STORED_SYMBOL

        || _la == MySQLParser::VIRTUAL_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      }
      setState(6739);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 866, _ctx)) {
      case 1: {
        setState(6725);

        if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
        setState(6729);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::COMMENT_SYMBOL || _la == MySQLParser::NOT2_SYMBOL || ((((_la - 536) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 536)) & ((1ULL << (MySQLParser::KEY_SYMBOL - 536))
          | (1ULL << (MySQLParser::NOT_SYMBOL - 536))
          | (1ULL << (MySQLParser::NULL_SYMBOL - 536))
          | (1ULL << (MySQLParser::PRIMARY_SYMBOL - 536)))) != 0) || _la == MySQLParser::UNIQUE_SYMBOL) {
          setState(6726);
          gcolAttribute();
          setState(6731);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case 2: {
        setState(6732);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(6736);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 865, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(6733);
            columnAttribute(); 
          }
          setState(6738);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 865, _ctx);
        }
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnAttributeContext ------------------------------------------------------------------

MySQLParser::ColumnAttributeContext::ColumnAttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::NullLiteralContext* MySQLParser::ColumnAttributeContext::nullLiteral() {
  return getRuleContext<MySQLParser::NullLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::NOT_SYMBOL() {
  return getToken(MySQLParser::NOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::SECONDARY_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::SignedLiteralContext* MySQLParser::ColumnAttributeContext::signedLiteral() {
  return getRuleContext<MySQLParser::SignedLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::NOW_SYMBOL() {
  return getToken(MySQLParser::NOW_SYMBOL, 0);
}

MySQLParser::ExprWithParenthesesContext* MySQLParser::ColumnAttributeContext::exprWithParentheses() {
  return getRuleContext<MySQLParser::ExprWithParenthesesContext>(0);
}

MySQLParser::TimeFunctionParametersContext* MySQLParser::ColumnAttributeContext::timeFunctionParameters() {
  return getRuleContext<MySQLParser::TimeFunctionParametersContext>(0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::AUTO_INCREMENT_SYMBOL() {
  return getToken(MySQLParser::AUTO_INCREMENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::VALUE_SYMBOL() {
  return getToken(MySQLParser::VALUE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::SERIAL_SYMBOL() {
  return getToken(MySQLParser::SERIAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::UNIQUE_SYMBOL() {
  return getToken(MySQLParser::UNIQUE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::PRIMARY_SYMBOL() {
  return getToken(MySQLParser::PRIMARY_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::ColumnAttributeContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

MySQLParser::CollateContext* MySQLParser::ColumnAttributeContext::collate() {
  return getRuleContext<MySQLParser::CollateContext>(0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::COLUMN_FORMAT_SYMBOL() {
  return getToken(MySQLParser::COLUMN_FORMAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::FIXED_SYMBOL() {
  return getToken(MySQLParser::FIXED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::DYNAMIC_SYMBOL() {
  return getToken(MySQLParser::DYNAMIC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::STORAGE_SYMBOL() {
  return getToken(MySQLParser::STORAGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::DISK_SYMBOL() {
  return getToken(MySQLParser::DISK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::MEMORY_SYMBOL() {
  return getToken(MySQLParser::MEMORY_SYMBOL, 0);
}

MySQLParser::Real_ulonglong_numberContext* MySQLParser::ColumnAttributeContext::real_ulonglong_number() {
  return getRuleContext<MySQLParser::Real_ulonglong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::SRID_SYMBOL() {
  return getToken(MySQLParser::SRID_SYMBOL, 0);
}


size_t MySQLParser::ColumnAttributeContext::getRuleIndex() const {
  return MySQLParser::RuleColumnAttribute;
}

void MySQLParser::ColumnAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnAttribute(this);
}

void MySQLParser::ColumnAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnAttribute(this);
}


antlrcpp::Any MySQLParser::ColumnAttributeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitColumnAttribute(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ColumnAttributeContext* MySQLParser::columnAttribute() {
  ColumnAttributeContext *_localctx = _tracker.createInstance<ColumnAttributeContext>(_ctx, getState());
  enterRule(_localctx, 842, MySQLParser::RuleColumnAttribute);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6788);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 874, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6744);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::NOT_SYMBOL) {
        setState(6743);
        match(MySQLParser::NOT_SYMBOL);
      }
      setState(6746);
      nullLiteral();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6747);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(6748);
      match(MySQLParser::NOT_SYMBOL);
      setState(6749);
      match(MySQLParser::SECONDARY_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6750);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::DEFAULT_SYMBOL);
      setState(6758);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 870, _ctx)) {
      case 1: {
        setState(6751);
        signedLiteral();
        break;
      }

      case 2: {
        setState(6752);
        match(MySQLParser::NOW_SYMBOL);
        setState(6754);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 869, _ctx)) {
        case 1: {
          setState(6753);
          timeFunctionParameters();
          break;
        }

        }
        break;
      }

      case 3: {
        setState(6756);

        if (!(serverVersion >= 80013)) throw FailedPredicateException(this, "serverVersion >= 80013");
        setState(6757);
        exprWithParentheses();
        break;
      }

      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6760);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::ON_SYMBOL);
      setState(6761);
      match(MySQLParser::UPDATE_SYMBOL);
      setState(6762);
      match(MySQLParser::NOW_SYMBOL);
      setState(6764);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 871, _ctx)) {
      case 1: {
        setState(6763);
        timeFunctionParameters();
        break;
      }

      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6766);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::AUTO_INCREMENT_SYMBOL);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6767);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::SERIAL_SYMBOL);
      setState(6768);
      match(MySQLParser::DEFAULT_SYMBOL);
      setState(6769);
      match(MySQLParser::VALUE_SYMBOL);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(6770);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::UNIQUE_SYMBOL);
      setState(6772);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 872, _ctx)) {
      case 1: {
        setState(6771);
        match(MySQLParser::KEY_SYMBOL);
        break;
      }

      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(6775);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::PRIMARY_SYMBOL) {
        setState(6774);
        match(MySQLParser::PRIMARY_SYMBOL);
      }
      setState(6777);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::KEY_SYMBOL);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(6778);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::COMMENT_SYMBOL);
      setState(6779);
      textLiteral();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(6780);
      collate();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(6781);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::COLUMN_FORMAT_SYMBOL);
      setState(6782);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::DYNAMIC_SYMBOL

      || _la == MySQLParser::FIXED_SYMBOL || _la == MySQLParser::DEFAULT_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(6783);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::STORAGE_SYMBOL);
      setState(6784);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::DISK_SYMBOL || _la == MySQLParser::MEMORY_SYMBOL || _la == MySQLParser::DEFAULT_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(6785);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(6786);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::SRID_SYMBOL);
      setState(6787);
      real_ulonglong_number();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GcolAttributeContext ------------------------------------------------------------------

MySQLParser::GcolAttributeContext::GcolAttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::GcolAttributeContext::UNIQUE_SYMBOL() {
  return getToken(MySQLParser::UNIQUE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GcolAttributeContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GcolAttributeContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::GcolAttributeContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode* MySQLParser::GcolAttributeContext::NULL_SYMBOL() {
  return getToken(MySQLParser::NULL_SYMBOL, 0);
}

MySQLParser::NotRuleContext* MySQLParser::GcolAttributeContext::notRule() {
  return getRuleContext<MySQLParser::NotRuleContext>(0);
}

tree::TerminalNode* MySQLParser::GcolAttributeContext::PRIMARY_SYMBOL() {
  return getToken(MySQLParser::PRIMARY_SYMBOL, 0);
}


size_t MySQLParser::GcolAttributeContext::getRuleIndex() const {
  return MySQLParser::RuleGcolAttribute;
}

void MySQLParser::GcolAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGcolAttribute(this);
}

void MySQLParser::GcolAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGcolAttribute(this);
}


antlrcpp::Any MySQLParser::GcolAttributeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitGcolAttribute(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GcolAttributeContext* MySQLParser::gcolAttribute() {
  GcolAttributeContext *_localctx = _tracker.createInstance<GcolAttributeContext>(_ctx, getState());
  enterRule(_localctx, 844, MySQLParser::RuleGcolAttribute);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6804);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::UNIQUE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(6790);
        match(MySQLParser::UNIQUE_SYMBOL);
        setState(6792);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 875, _ctx)) {
        case 1: {
          setState(6791);
          match(MySQLParser::KEY_SYMBOL);
          break;
        }

        }
        break;
      }

      case MySQLParser::COMMENT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6794);
        match(MySQLParser::COMMENT_SYMBOL);
        setState(6795);
        textString();
        break;
      }

      case MySQLParser::NOT2_SYMBOL:
      case MySQLParser::NOT_SYMBOL:
      case MySQLParser::NULL_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(6797);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::NOT2_SYMBOL || _la == MySQLParser::NOT_SYMBOL) {
          setState(6796);
          notRule();
        }
        setState(6799);
        match(MySQLParser::NULL_SYMBOL);
        break;
      }

      case MySQLParser::KEY_SYMBOL:
      case MySQLParser::PRIMARY_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(6801);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::PRIMARY_SYMBOL) {
          setState(6800);
          match(MySQLParser::PRIMARY_SYMBOL);
        }
        setState(6803);
        match(MySQLParser::KEY_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReferencesContext ------------------------------------------------------------------

MySQLParser::ReferencesContext::ReferencesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ReferencesContext::REFERENCES_SYMBOL() {
  return getToken(MySQLParser::REFERENCES_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::ReferencesContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::IdentifierListWithParenthesesContext* MySQLParser::ReferencesContext::identifierListWithParentheses() {
  return getRuleContext<MySQLParser::IdentifierListWithParenthesesContext>(0);
}

tree::TerminalNode* MySQLParser::ReferencesContext::MATCH_SYMBOL() {
  return getToken(MySQLParser::MATCH_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::ReferencesContext::ON_SYMBOL() {
  return getTokens(MySQLParser::ON_SYMBOL);
}

tree::TerminalNode* MySQLParser::ReferencesContext::ON_SYMBOL(size_t i) {
  return getToken(MySQLParser::ON_SYMBOL, i);
}

std::vector<MySQLParser::DeleteOptionContext *> MySQLParser::ReferencesContext::deleteOption() {
  return getRuleContexts<MySQLParser::DeleteOptionContext>();
}

MySQLParser::DeleteOptionContext* MySQLParser::ReferencesContext::deleteOption(size_t i) {
  return getRuleContext<MySQLParser::DeleteOptionContext>(i);
}

tree::TerminalNode* MySQLParser::ReferencesContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReferencesContext::DELETE_SYMBOL() {
  return getToken(MySQLParser::DELETE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReferencesContext::FULL_SYMBOL() {
  return getToken(MySQLParser::FULL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReferencesContext::PARTIAL_SYMBOL() {
  return getToken(MySQLParser::PARTIAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReferencesContext::SIMPLE_SYMBOL() {
  return getToken(MySQLParser::SIMPLE_SYMBOL, 0);
}


size_t MySQLParser::ReferencesContext::getRuleIndex() const {
  return MySQLParser::RuleReferences;
}

void MySQLParser::ReferencesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReferences(this);
}

void MySQLParser::ReferencesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReferences(this);
}


antlrcpp::Any MySQLParser::ReferencesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitReferences(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ReferencesContext* MySQLParser::references() {
  ReferencesContext *_localctx = _tracker.createInstance<ReferencesContext>(_ctx, getState());
  enterRule(_localctx, 846, MySQLParser::RuleReferences);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6806);
    match(MySQLParser::REFERENCES_SYMBOL);
    setState(6807);
    tableRef();
    setState(6809);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(6808);
      identifierListWithParentheses();
    }
    setState(6813);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::MATCH_SYMBOL) {
      setState(6811);
      match(MySQLParser::MATCH_SYMBOL);
      setState(6812);
      dynamic_cast<ReferencesContext *>(_localctx)->match = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::FULL_SYMBOL || _la == MySQLParser::PARTIAL_SYMBOL

      || _la == MySQLParser::SIMPLE_SYMBOL)) {
        dynamic_cast<ReferencesContext *>(_localctx)->match = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(6831);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 883, _ctx)) {
    case 1: {
      setState(6815);
      match(MySQLParser::ON_SYMBOL);
      setState(6816);
      dynamic_cast<ReferencesContext *>(_localctx)->option = match(MySQLParser::UPDATE_SYMBOL);
      setState(6817);
      deleteOption();
      setState(6821);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::ON_SYMBOL) {
        setState(6818);
        match(MySQLParser::ON_SYMBOL);
        setState(6819);
        match(MySQLParser::DELETE_SYMBOL);
        setState(6820);
        deleteOption();
      }
      break;
    }

    case 2: {
      setState(6823);
      match(MySQLParser::ON_SYMBOL);
      setState(6824);
      dynamic_cast<ReferencesContext *>(_localctx)->option = match(MySQLParser::DELETE_SYMBOL);
      setState(6825);
      deleteOption();
      setState(6829);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::ON_SYMBOL) {
        setState(6826);
        match(MySQLParser::ON_SYMBOL);
        setState(6827);
        match(MySQLParser::UPDATE_SYMBOL);
        setState(6828);
        deleteOption();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeleteOptionContext ------------------------------------------------------------------

MySQLParser::DeleteOptionContext::DeleteOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DeleteOptionContext::RESTRICT_SYMBOL() {
  return getToken(MySQLParser::RESTRICT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DeleteOptionContext::CASCADE_SYMBOL() {
  return getToken(MySQLParser::CASCADE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DeleteOptionContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

MySQLParser::NullLiteralContext* MySQLParser::DeleteOptionContext::nullLiteral() {
  return getRuleContext<MySQLParser::NullLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::DeleteOptionContext::NO_SYMBOL() {
  return getToken(MySQLParser::NO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DeleteOptionContext::ACTION_SYMBOL() {
  return getToken(MySQLParser::ACTION_SYMBOL, 0);
}


size_t MySQLParser::DeleteOptionContext::getRuleIndex() const {
  return MySQLParser::RuleDeleteOption;
}

void MySQLParser::DeleteOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeleteOption(this);
}

void MySQLParser::DeleteOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeleteOption(this);
}


antlrcpp::Any MySQLParser::DeleteOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDeleteOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DeleteOptionContext* MySQLParser::deleteOption() {
  DeleteOptionContext *_localctx = _tracker.createInstance<DeleteOptionContext>(_ctx, getState());
  enterRule(_localctx, 848, MySQLParser::RuleDeleteOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6838);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CASCADE_SYMBOL:
      case MySQLParser::RESTRICT_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(6833);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::CASCADE_SYMBOL || _la == MySQLParser::RESTRICT_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case MySQLParser::SET_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6834);
        match(MySQLParser::SET_SYMBOL);
        setState(6835);
        nullLiteral();
        break;
      }

      case MySQLParser::NO_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(6836);
        match(MySQLParser::NO_SYMBOL);
        setState(6837);
        match(MySQLParser::ACTION_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyListContext ------------------------------------------------------------------

MySQLParser::KeyListContext::KeyListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::KeyListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::KeyPartContext *> MySQLParser::KeyListContext::keyPart() {
  return getRuleContexts<MySQLParser::KeyPartContext>();
}

MySQLParser::KeyPartContext* MySQLParser::KeyListContext::keyPart(size_t i) {
  return getRuleContext<MySQLParser::KeyPartContext>(i);
}

tree::TerminalNode* MySQLParser::KeyListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::KeyListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::KeyListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::KeyListContext::getRuleIndex() const {
  return MySQLParser::RuleKeyList;
}

void MySQLParser::KeyListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyList(this);
}

void MySQLParser::KeyListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyList(this);
}


antlrcpp::Any MySQLParser::KeyListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitKeyList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::KeyListContext* MySQLParser::keyList() {
  KeyListContext *_localctx = _tracker.createInstance<KeyListContext>(_ctx, getState());
  enterRule(_localctx, 850, MySQLParser::RuleKeyList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6840);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(6841);
    keyPart();
    setState(6846);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(6842);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6843);
      keyPart();
      setState(6848);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(6849);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyPartContext ------------------------------------------------------------------

MySQLParser::KeyPartContext::KeyPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::KeyPartContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::FieldLengthContext* MySQLParser::KeyPartContext::fieldLength() {
  return getRuleContext<MySQLParser::FieldLengthContext>(0);
}

MySQLParser::DirectionContext* MySQLParser::KeyPartContext::direction() {
  return getRuleContext<MySQLParser::DirectionContext>(0);
}


size_t MySQLParser::KeyPartContext::getRuleIndex() const {
  return MySQLParser::RuleKeyPart;
}

void MySQLParser::KeyPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyPart(this);
}

void MySQLParser::KeyPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyPart(this);
}


antlrcpp::Any MySQLParser::KeyPartContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitKeyPart(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::KeyPartContext* MySQLParser::keyPart() {
  KeyPartContext *_localctx = _tracker.createInstance<KeyPartContext>(_ctx, getState());
  enterRule(_localctx, 852, MySQLParser::RuleKeyPart);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6851);
    identifier();
    setState(6853);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(6852);
      fieldLength();
    }
    setState(6856);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ASC_SYMBOL

    || _la == MySQLParser::DESC_SYMBOL) {
      setState(6855);
      direction();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyListWithExpressionContext ------------------------------------------------------------------

MySQLParser::KeyListWithExpressionContext::KeyListWithExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::KeyListWithExpressionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::KeyPartOrExpressionContext *> MySQLParser::KeyListWithExpressionContext::keyPartOrExpression() {
  return getRuleContexts<MySQLParser::KeyPartOrExpressionContext>();
}

MySQLParser::KeyPartOrExpressionContext* MySQLParser::KeyListWithExpressionContext::keyPartOrExpression(size_t i) {
  return getRuleContext<MySQLParser::KeyPartOrExpressionContext>(i);
}

tree::TerminalNode* MySQLParser::KeyListWithExpressionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::KeyListWithExpressionContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::KeyListWithExpressionContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::KeyListWithExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleKeyListWithExpression;
}

void MySQLParser::KeyListWithExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyListWithExpression(this);
}

void MySQLParser::KeyListWithExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyListWithExpression(this);
}


antlrcpp::Any MySQLParser::KeyListWithExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitKeyListWithExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::KeyListWithExpressionContext* MySQLParser::keyListWithExpression() {
  KeyListWithExpressionContext *_localctx = _tracker.createInstance<KeyListWithExpressionContext>(_ctx, getState());
  enterRule(_localctx, 854, MySQLParser::RuleKeyListWithExpression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6858);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(6859);
    keyPartOrExpression();
    setState(6864);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(6860);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6861);
      keyPartOrExpression();
      setState(6866);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(6867);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyPartOrExpressionContext ------------------------------------------------------------------

MySQLParser::KeyPartOrExpressionContext::KeyPartOrExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::KeyPartContext* MySQLParser::KeyPartOrExpressionContext::keyPart() {
  return getRuleContext<MySQLParser::KeyPartContext>(0);
}

MySQLParser::ExprWithParenthesesContext* MySQLParser::KeyPartOrExpressionContext::exprWithParentheses() {
  return getRuleContext<MySQLParser::ExprWithParenthesesContext>(0);
}

MySQLParser::DirectionContext* MySQLParser::KeyPartOrExpressionContext::direction() {
  return getRuleContext<MySQLParser::DirectionContext>(0);
}


size_t MySQLParser::KeyPartOrExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleKeyPartOrExpression;
}

void MySQLParser::KeyPartOrExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyPartOrExpression(this);
}

void MySQLParser::KeyPartOrExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyPartOrExpression(this);
}


antlrcpp::Any MySQLParser::KeyPartOrExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitKeyPartOrExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::KeyPartOrExpressionContext* MySQLParser::keyPartOrExpression() {
  KeyPartOrExpressionContext *_localctx = _tracker.createInstance<KeyPartOrExpressionContext>(_ctx, getState());
  enterRule(_localctx, 856, MySQLParser::RuleKeyPartOrExpression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6874);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 890, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6869);
      keyPart();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6870);
      exprWithParentheses();
      setState(6872);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::ASC_SYMBOL

      || _la == MySQLParser::DESC_SYMBOL) {
        setState(6871);
        direction();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyListVariantsContext ------------------------------------------------------------------

MySQLParser::KeyListVariantsContext::KeyListVariantsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::KeyListWithExpressionContext* MySQLParser::KeyListVariantsContext::keyListWithExpression() {
  return getRuleContext<MySQLParser::KeyListWithExpressionContext>(0);
}

MySQLParser::KeyListContext* MySQLParser::KeyListVariantsContext::keyList() {
  return getRuleContext<MySQLParser::KeyListContext>(0);
}


size_t MySQLParser::KeyListVariantsContext::getRuleIndex() const {
  return MySQLParser::RuleKeyListVariants;
}

void MySQLParser::KeyListVariantsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyListVariants(this);
}

void MySQLParser::KeyListVariantsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyListVariants(this);
}


antlrcpp::Any MySQLParser::KeyListVariantsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitKeyListVariants(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::KeyListVariantsContext* MySQLParser::keyListVariants() {
  KeyListVariantsContext *_localctx = _tracker.createInstance<KeyListVariantsContext>(_ctx, getState());
  enterRule(_localctx, 858, MySQLParser::RuleKeyListVariants);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6880);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 891, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6876);

      if (!(serverVersion >= 80013)) throw FailedPredicateException(this, "serverVersion >= 80013");
      setState(6877);
      keyListWithExpression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6878);

      if (!(serverVersion < 80013)) throw FailedPredicateException(this, "serverVersion < 80013");
      setState(6879);
      keyList();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexTypeContext ------------------------------------------------------------------

MySQLParser::IndexTypeContext::IndexTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IndexTypeContext::BTREE_SYMBOL() {
  return getToken(MySQLParser::BTREE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IndexTypeContext::RTREE_SYMBOL() {
  return getToken(MySQLParser::RTREE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IndexTypeContext::HASH_SYMBOL() {
  return getToken(MySQLParser::HASH_SYMBOL, 0);
}


size_t MySQLParser::IndexTypeContext::getRuleIndex() const {
  return MySQLParser::RuleIndexType;
}

void MySQLParser::IndexTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexType(this);
}

void MySQLParser::IndexTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexType(this);
}


antlrcpp::Any MySQLParser::IndexTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIndexType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexTypeContext* MySQLParser::indexType() {
  IndexTypeContext *_localctx = _tracker.createInstance<IndexTypeContext>(_ctx, getState());
  enterRule(_localctx, 860, MySQLParser::RuleIndexType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6882);
    dynamic_cast<IndexTypeContext *>(_localctx)->algorithm = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::BTREE_SYMBOL || _la == MySQLParser::HASH_SYMBOL || _la == MySQLParser::RTREE_SYMBOL)) {
      dynamic_cast<IndexTypeContext *>(_localctx)->algorithm = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexOptionContext ------------------------------------------------------------------

MySQLParser::IndexOptionContext::IndexOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CommonIndexOptionContext* MySQLParser::IndexOptionContext::commonIndexOption() {
  return getRuleContext<MySQLParser::CommonIndexOptionContext>(0);
}

MySQLParser::IndexTypeClauseContext* MySQLParser::IndexOptionContext::indexTypeClause() {
  return getRuleContext<MySQLParser::IndexTypeClauseContext>(0);
}


size_t MySQLParser::IndexOptionContext::getRuleIndex() const {
  return MySQLParser::RuleIndexOption;
}

void MySQLParser::IndexOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexOption(this);
}

void MySQLParser::IndexOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexOption(this);
}


antlrcpp::Any MySQLParser::IndexOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIndexOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexOptionContext* MySQLParser::indexOption() {
  IndexOptionContext *_localctx = _tracker.createInstance<IndexOptionContext>(_ctx, getState());
  enterRule(_localctx, 862, MySQLParser::RuleIndexOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6886);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 892, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6884);
      commonIndexOption();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6885);
      indexTypeClause();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommonIndexOptionContext ------------------------------------------------------------------

MySQLParser::CommonIndexOptionContext::CommonIndexOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CommonIndexOptionContext::KEY_BLOCK_SIZE_SYMBOL() {
  return getToken(MySQLParser::KEY_BLOCK_SIZE_SYMBOL, 0);
}

MySQLParser::Ulong_numberContext* MySQLParser::CommonIndexOptionContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::CommonIndexOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::CommonIndexOptionContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::CommonIndexOptionContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

MySQLParser::VisibilityContext* MySQLParser::CommonIndexOptionContext::visibility() {
  return getRuleContext<MySQLParser::VisibilityContext>(0);
}


size_t MySQLParser::CommonIndexOptionContext::getRuleIndex() const {
  return MySQLParser::RuleCommonIndexOption;
}

void MySQLParser::CommonIndexOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommonIndexOption(this);
}

void MySQLParser::CommonIndexOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommonIndexOption(this);
}


antlrcpp::Any MySQLParser::CommonIndexOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCommonIndexOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CommonIndexOptionContext* MySQLParser::commonIndexOption() {
  CommonIndexOptionContext *_localctx = _tracker.createInstance<CommonIndexOptionContext>(_ctx, getState());
  enterRule(_localctx, 864, MySQLParser::RuleCommonIndexOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6898);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 894, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6888);
      match(MySQLParser::KEY_BLOCK_SIZE_SYMBOL);
      setState(6890);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(6889);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(6892);
      ulong_number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6893);

      if (!(serverVersion >= 50600)) throw FailedPredicateException(this, "serverVersion >= 50600");
      setState(6894);
      match(MySQLParser::COMMENT_SYMBOL);
      setState(6895);
      textLiteral();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6896);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(6897);
      visibility();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VisibilityContext ------------------------------------------------------------------

MySQLParser::VisibilityContext::VisibilityContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::VisibilityContext::VISIBLE_SYMBOL() {
  return getToken(MySQLParser::VISIBLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::VisibilityContext::INVISIBLE_SYMBOL() {
  return getToken(MySQLParser::INVISIBLE_SYMBOL, 0);
}


size_t MySQLParser::VisibilityContext::getRuleIndex() const {
  return MySQLParser::RuleVisibility;
}

void MySQLParser::VisibilityContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVisibility(this);
}

void MySQLParser::VisibilityContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVisibility(this);
}


antlrcpp::Any MySQLParser::VisibilityContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitVisibility(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::VisibilityContext* MySQLParser::visibility() {
  VisibilityContext *_localctx = _tracker.createInstance<VisibilityContext>(_ctx, getState());
  enterRule(_localctx, 866, MySQLParser::RuleVisibility);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6900);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::INVISIBLE_SYMBOL

    || _la == MySQLParser::VISIBLE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexTypeClauseContext ------------------------------------------------------------------

MySQLParser::IndexTypeClauseContext::IndexTypeClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IndexTypeContext* MySQLParser::IndexTypeClauseContext::indexType() {
  return getRuleContext<MySQLParser::IndexTypeContext>(0);
}

tree::TerminalNode* MySQLParser::IndexTypeClauseContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IndexTypeClauseContext::TYPE_SYMBOL() {
  return getToken(MySQLParser::TYPE_SYMBOL, 0);
}


size_t MySQLParser::IndexTypeClauseContext::getRuleIndex() const {
  return MySQLParser::RuleIndexTypeClause;
}

void MySQLParser::IndexTypeClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexTypeClause(this);
}

void MySQLParser::IndexTypeClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexTypeClause(this);
}


antlrcpp::Any MySQLParser::IndexTypeClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIndexTypeClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexTypeClauseContext* MySQLParser::indexTypeClause() {
  IndexTypeClauseContext *_localctx = _tracker.createInstance<IndexTypeClauseContext>(_ctx, getState());
  enterRule(_localctx, 868, MySQLParser::RuleIndexTypeClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6902);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::TYPE_SYMBOL || _la == MySQLParser::USING_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(6903);
    indexType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FulltextIndexOptionContext ------------------------------------------------------------------

MySQLParser::FulltextIndexOptionContext::FulltextIndexOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CommonIndexOptionContext* MySQLParser::FulltextIndexOptionContext::commonIndexOption() {
  return getRuleContext<MySQLParser::CommonIndexOptionContext>(0);
}

tree::TerminalNode* MySQLParser::FulltextIndexOptionContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FulltextIndexOptionContext::PARSER_SYMBOL() {
  return getToken(MySQLParser::PARSER_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::FulltextIndexOptionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::FulltextIndexOptionContext::getRuleIndex() const {
  return MySQLParser::RuleFulltextIndexOption;
}

void MySQLParser::FulltextIndexOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFulltextIndexOption(this);
}

void MySQLParser::FulltextIndexOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFulltextIndexOption(this);
}


antlrcpp::Any MySQLParser::FulltextIndexOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFulltextIndexOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FulltextIndexOptionContext* MySQLParser::fulltextIndexOption() {
  FulltextIndexOptionContext *_localctx = _tracker.createInstance<FulltextIndexOptionContext>(_ctx, getState());
  enterRule(_localctx, 870, MySQLParser::RuleFulltextIndexOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6909);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 895, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6905);
      commonIndexOption();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6906);
      match(MySQLParser::WITH_SYMBOL);
      setState(6907);
      match(MySQLParser::PARSER_SYMBOL);
      setState(6908);
      identifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SpatialIndexOptionContext ------------------------------------------------------------------

MySQLParser::SpatialIndexOptionContext::SpatialIndexOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CommonIndexOptionContext* MySQLParser::SpatialIndexOptionContext::commonIndexOption() {
  return getRuleContext<MySQLParser::CommonIndexOptionContext>(0);
}


size_t MySQLParser::SpatialIndexOptionContext::getRuleIndex() const {
  return MySQLParser::RuleSpatialIndexOption;
}

void MySQLParser::SpatialIndexOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpatialIndexOption(this);
}

void MySQLParser::SpatialIndexOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpatialIndexOption(this);
}


antlrcpp::Any MySQLParser::SpatialIndexOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSpatialIndexOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SpatialIndexOptionContext* MySQLParser::spatialIndexOption() {
  SpatialIndexOptionContext *_localctx = _tracker.createInstance<SpatialIndexOptionContext>(_ctx, getState());
  enterRule(_localctx, 872, MySQLParser::RuleSpatialIndexOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6911);
    commonIndexOption();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DataTypeDefinitionContext ------------------------------------------------------------------

MySQLParser::DataTypeDefinitionContext::DataTypeDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::DataTypeContext* MySQLParser::DataTypeDefinitionContext::dataType() {
  return getRuleContext<MySQLParser::DataTypeContext>(0);
}

tree::TerminalNode* MySQLParser::DataTypeDefinitionContext::EOF() {
  return getToken(MySQLParser::EOF, 0);
}


size_t MySQLParser::DataTypeDefinitionContext::getRuleIndex() const {
  return MySQLParser::RuleDataTypeDefinition;
}

void MySQLParser::DataTypeDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDataTypeDefinition(this);
}

void MySQLParser::DataTypeDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDataTypeDefinition(this);
}


antlrcpp::Any MySQLParser::DataTypeDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDataTypeDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DataTypeDefinitionContext* MySQLParser::dataTypeDefinition() {
  DataTypeDefinitionContext *_localctx = _tracker.createInstance<DataTypeDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 874, MySQLParser::RuleDataTypeDefinition);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6913);
    dataType();
    setState(6914);
    match(MySQLParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DataTypeContext ------------------------------------------------------------------

MySQLParser::DataTypeContext::DataTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DataTypeContext::INT_SYMBOL() {
  return getToken(MySQLParser::INT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::TINYINT_SYMBOL() {
  return getToken(MySQLParser::TINYINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::SMALLINT_SYMBOL() {
  return getToken(MySQLParser::SMALLINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::MEDIUMINT_SYMBOL() {
  return getToken(MySQLParser::MEDIUMINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::BIGINT_SYMBOL() {
  return getToken(MySQLParser::BIGINT_SYMBOL, 0);
}

MySQLParser::FieldLengthContext* MySQLParser::DataTypeContext::fieldLength() {
  return getRuleContext<MySQLParser::FieldLengthContext>(0);
}

MySQLParser::FieldOptionsContext* MySQLParser::DataTypeContext::fieldOptions() {
  return getRuleContext<MySQLParser::FieldOptionsContext>(0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::REAL_SYMBOL() {
  return getToken(MySQLParser::REAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::DOUBLE_SYMBOL() {
  return getToken(MySQLParser::DOUBLE_SYMBOL, 0);
}

MySQLParser::PrecisionContext* MySQLParser::DataTypeContext::precision() {
  return getRuleContext<MySQLParser::PrecisionContext>(0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::PRECISION_SYMBOL() {
  return getToken(MySQLParser::PRECISION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::FLOAT_SYMBOL() {
  return getToken(MySQLParser::FLOAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::DECIMAL_SYMBOL() {
  return getToken(MySQLParser::DECIMAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::NUMERIC_SYMBOL() {
  return getToken(MySQLParser::NUMERIC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::FIXED_SYMBOL() {
  return getToken(MySQLParser::FIXED_SYMBOL, 0);
}

MySQLParser::FloatOptionsContext* MySQLParser::DataTypeContext::floatOptions() {
  return getRuleContext<MySQLParser::FloatOptionsContext>(0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::BIT_SYMBOL() {
  return getToken(MySQLParser::BIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::BOOL_SYMBOL() {
  return getToken(MySQLParser::BOOL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::BOOLEAN_SYMBOL() {
  return getToken(MySQLParser::BOOLEAN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::CHAR_SYMBOL() {
  return getToken(MySQLParser::CHAR_SYMBOL, 0);
}

MySQLParser::CharsetWithOptBinaryContext* MySQLParser::DataTypeContext::charsetWithOptBinary() {
  return getRuleContext<MySQLParser::CharsetWithOptBinaryContext>(0);
}

MySQLParser::NcharContext* MySQLParser::DataTypeContext::nchar() {
  return getRuleContext<MySQLParser::NcharContext>(0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::VARYING_SYMBOL() {
  return getToken(MySQLParser::VARYING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::VARCHAR_SYMBOL() {
  return getToken(MySQLParser::VARCHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::NATIONAL_SYMBOL() {
  return getToken(MySQLParser::NATIONAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::NVARCHAR_SYMBOL() {
  return getToken(MySQLParser::NVARCHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::NCHAR_SYMBOL() {
  return getToken(MySQLParser::NCHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::VARBINARY_SYMBOL() {
  return getToken(MySQLParser::VARBINARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::YEAR_SYMBOL() {
  return getToken(MySQLParser::YEAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::DATE_SYMBOL() {
  return getToken(MySQLParser::DATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::TIME_SYMBOL() {
  return getToken(MySQLParser::TIME_SYMBOL, 0);
}

MySQLParser::TypeDatetimePrecisionContext* MySQLParser::DataTypeContext::typeDatetimePrecision() {
  return getRuleContext<MySQLParser::TypeDatetimePrecisionContext>(0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::TIMESTAMP_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::DATETIME_SYMBOL() {
  return getToken(MySQLParser::DATETIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::TINYBLOB_SYMBOL() {
  return getToken(MySQLParser::TINYBLOB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::BLOB_SYMBOL() {
  return getToken(MySQLParser::BLOB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::MEDIUMBLOB_SYMBOL() {
  return getToken(MySQLParser::MEDIUMBLOB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::LONGBLOB_SYMBOL() {
  return getToken(MySQLParser::LONGBLOB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::LONG_SYMBOL() {
  return getToken(MySQLParser::LONG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::TINYTEXT_SYMBOL() {
  return getToken(MySQLParser::TINYTEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::TEXT_SYMBOL() {
  return getToken(MySQLParser::TEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::MEDIUMTEXT_SYMBOL() {
  return getToken(MySQLParser::MEDIUMTEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::LONGTEXT_SYMBOL() {
  return getToken(MySQLParser::LONGTEXT_SYMBOL, 0);
}

MySQLParser::StringListContext* MySQLParser::DataTypeContext::stringList() {
  return getRuleContext<MySQLParser::StringListContext>(0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::ENUM_SYMBOL() {
  return getToken(MySQLParser::ENUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::SERIAL_SYMBOL() {
  return getToken(MySQLParser::SERIAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::JSON_SYMBOL() {
  return getToken(MySQLParser::JSON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::GEOMETRY_SYMBOL() {
  return getToken(MySQLParser::GEOMETRY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::GEOMETRYCOLLECTION_SYMBOL() {
  return getToken(MySQLParser::GEOMETRYCOLLECTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::POINT_SYMBOL() {
  return getToken(MySQLParser::POINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::MULTIPOINT_SYMBOL() {
  return getToken(MySQLParser::MULTIPOINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::LINESTRING_SYMBOL() {
  return getToken(MySQLParser::LINESTRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::MULTILINESTRING_SYMBOL() {
  return getToken(MySQLParser::MULTILINESTRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::POLYGON_SYMBOL() {
  return getToken(MySQLParser::POLYGON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::MULTIPOLYGON_SYMBOL() {
  return getToken(MySQLParser::MULTIPOLYGON_SYMBOL, 0);
}


size_t MySQLParser::DataTypeContext::getRuleIndex() const {
  return MySQLParser::RuleDataType;
}

void MySQLParser::DataTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDataType(this);
}

void MySQLParser::DataTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDataType(this);
}


antlrcpp::Any MySQLParser::DataTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDataType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DataTypeContext* MySQLParser::dataType() {
  DataTypeContext *_localctx = _tracker.createInstance<DataTypeContext>(_ctx, getState());
  enterRule(_localctx, 876, MySQLParser::RuleDataType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7063);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 929, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6916);
      dynamic_cast<DataTypeContext *>(_localctx)->type = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::BIGINT_SYMBOL || _la == MySQLParser::INT_SYMBOL

      || _la == MySQLParser::MEDIUMINT_SYMBOL || _la == MySQLParser::SMALLINT_SYMBOL

      || _la == MySQLParser::TINYINT_SYMBOL)) {
        dynamic_cast<DataTypeContext *>(_localctx)->type = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(6918);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 896, _ctx)) {
      case 1: {
        setState(6917);
        fieldLength();
        break;
      }

      }
      setState(6921);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 897, _ctx)) {
      case 1: {
        setState(6920);
        fieldOptions();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6928);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::REAL_SYMBOL: {
          setState(6923);
          dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::REAL_SYMBOL);
          break;
        }

        case MySQLParser::DOUBLE_SYMBOL: {
          setState(6924);
          dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::DOUBLE_SYMBOL);
          setState(6926);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 898, _ctx)) {
          case 1: {
            setState(6925);
            match(MySQLParser::PRECISION_SYMBOL);
            break;
          }

          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(6931);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 900, _ctx)) {
      case 1: {
        setState(6930);
        precision();
        break;
      }

      }
      setState(6934);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 901, _ctx)) {
      case 1: {
        setState(6933);
        fieldOptions();
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6936);
      dynamic_cast<DataTypeContext *>(_localctx)->type = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::FIXED_SYMBOL || _la == MySQLParser::DECIMAL_SYMBOL

      || _la == MySQLParser::FLOAT_SYMBOL || _la == MySQLParser::NUMERIC_SYMBOL)) {
        dynamic_cast<DataTypeContext *>(_localctx)->type = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(6938);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 902, _ctx)) {
      case 1: {
        setState(6937);
        floatOptions();
        break;
      }

      }
      setState(6941);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 903, _ctx)) {
      case 1: {
        setState(6940);
        fieldOptions();
        break;
      }

      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6943);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::BIT_SYMBOL);
      setState(6945);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 904, _ctx)) {
      case 1: {
        setState(6944);
        fieldLength();
        break;
      }

      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6947);
      dynamic_cast<DataTypeContext *>(_localctx)->type = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::BOOL_SYMBOL

      || _la == MySQLParser::BOOLEAN_SYMBOL)) {
        dynamic_cast<DataTypeContext *>(_localctx)->type = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6948);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::CHAR_SYMBOL);
      setState(6950);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 905, _ctx)) {
      case 1: {
        setState(6949);
        fieldLength();
        break;
      }

      }
      setState(6953);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 906, _ctx)) {
      case 1: {
        setState(6952);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(6955);
      nchar();
      setState(6957);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 907, _ctx)) {
      case 1: {
        setState(6956);
        fieldLength();
        break;
      }

      }
      setState(6960);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 908, _ctx)) {
      case 1: {
        setState(6959);
        match(MySQLParser::BINARY_SYMBOL);
        break;
      }

      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(6962);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::BINARY_SYMBOL);
      setState(6964);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 909, _ctx)) {
      case 1: {
        setState(6963);
        fieldLength();
        break;
      }

      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(6969);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::CHAR_SYMBOL: {
          setState(6966);
          dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::CHAR_SYMBOL);
          setState(6967);
          match(MySQLParser::VARYING_SYMBOL);
          break;
        }

        case MySQLParser::VARCHAR_SYMBOL: {
          setState(6968);
          dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::VARCHAR_SYMBOL);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(6971);
      fieldLength();
      setState(6973);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 911, _ctx)) {
      case 1: {
        setState(6972);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(6985);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 912, _ctx)) {
      case 1: {
        setState(6975);
        dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::NATIONAL_SYMBOL);
        setState(6976);
        match(MySQLParser::VARCHAR_SYMBOL);
        break;
      }

      case 2: {
        setState(6977);
        dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::NVARCHAR_SYMBOL);
        break;
      }

      case 3: {
        setState(6978);
        dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::NCHAR_SYMBOL);
        setState(6979);
        match(MySQLParser::VARCHAR_SYMBOL);
        break;
      }

      case 4: {
        setState(6980);
        dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::NATIONAL_SYMBOL);
        setState(6981);
        match(MySQLParser::CHAR_SYMBOL);
        setState(6982);
        match(MySQLParser::VARYING_SYMBOL);
        break;
      }

      case 5: {
        setState(6983);
        dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::NCHAR_SYMBOL);
        setState(6984);
        match(MySQLParser::VARYING_SYMBOL);
        break;
      }

      }
      setState(6987);
      fieldLength();
      setState(6989);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 913, _ctx)) {
      case 1: {
        setState(6988);
        match(MySQLParser::BINARY_SYMBOL);
        break;
      }

      }
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(6991);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::VARBINARY_SYMBOL);
      setState(6992);
      fieldLength();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(6993);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::YEAR_SYMBOL);
      setState(6995);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 914, _ctx)) {
      case 1: {
        setState(6994);
        fieldLength();
        break;
      }

      }
      setState(6998);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 915, _ctx)) {
      case 1: {
        setState(6997);
        fieldOptions();
        break;
      }

      }
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(7000);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::DATE_SYMBOL);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(7001);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::TIME_SYMBOL);
      setState(7003);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 916, _ctx)) {
      case 1: {
        setState(7002);
        typeDatetimePrecision();
        break;
      }

      }
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(7005);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::TIMESTAMP_SYMBOL);
      setState(7007);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 917, _ctx)) {
      case 1: {
        setState(7006);
        typeDatetimePrecision();
        break;
      }

      }
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(7009);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::DATETIME_SYMBOL);
      setState(7011);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 918, _ctx)) {
      case 1: {
        setState(7010);
        typeDatetimePrecision();
        break;
      }

      }
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(7013);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::TINYBLOB_SYMBOL);
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(7014);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::BLOB_SYMBOL);
      setState(7016);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 919, _ctx)) {
      case 1: {
        setState(7015);
        fieldLength();
        break;
      }

      }
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(7018);
      dynamic_cast<DataTypeContext *>(_localctx)->type = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::LONGBLOB_SYMBOL

      || _la == MySQLParser::MEDIUMBLOB_SYMBOL)) {
        dynamic_cast<DataTypeContext *>(_localctx)->type = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(7019);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::LONG_SYMBOL);
      setState(7020);
      match(MySQLParser::VARBINARY_SYMBOL);
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(7021);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::LONG_SYMBOL);
      setState(7025);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 920, _ctx)) {
      case 1: {
        setState(7022);
        match(MySQLParser::CHAR_SYMBOL);
        setState(7023);
        match(MySQLParser::VARYING_SYMBOL);
        break;
      }

      case 2: {
        setState(7024);
        match(MySQLParser::VARCHAR_SYMBOL);
        break;
      }

      }
      setState(7028);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 921, _ctx)) {
      case 1: {
        setState(7027);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(7030);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::TINYTEXT_SYMBOL);
      setState(7032);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 922, _ctx)) {
      case 1: {
        setState(7031);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(7034);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::TEXT_SYMBOL);
      setState(7036);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 923, _ctx)) {
      case 1: {
        setState(7035);
        fieldLength();
        break;
      }

      }
      setState(7039);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 924, _ctx)) {
      case 1: {
        setState(7038);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(7041);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::MEDIUMTEXT_SYMBOL);
      setState(7043);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 925, _ctx)) {
      case 1: {
        setState(7042);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(7045);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::LONGTEXT_SYMBOL);
      setState(7047);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 926, _ctx)) {
      case 1: {
        setState(7046);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(7049);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::ENUM_SYMBOL);
      setState(7050);
      stringList();
      setState(7052);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 927, _ctx)) {
      case 1: {
        setState(7051);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(7054);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::SET_SYMBOL);
      setState(7055);
      stringList();
      setState(7057);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 928, _ctx)) {
      case 1: {
        setState(7056);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(7059);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::SERIAL_SYMBOL);
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(7060);

      if (!(serverVersion >= 50708)) throw FailedPredicateException(this, "serverVersion >= 50708");
      setState(7061);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::JSON_SYMBOL);
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(7062);
      dynamic_cast<DataTypeContext *>(_localctx)->type = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 151) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 151)) & ((1ULL << (MySQLParser::GEOMETRY_SYMBOL - 151))
        | (1ULL << (MySQLParser::GEOMETRYCOLLECTION_SYMBOL - 151))
        | (1ULL << (MySQLParser::LINESTRING_SYMBOL - 151)))) != 0) || ((((_la - 224) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 224)) & ((1ULL << (MySQLParser::MULTILINESTRING_SYMBOL - 224))
        | (1ULL << (MySQLParser::MULTIPOINT_SYMBOL - 224))
        | (1ULL << (MySQLParser::MULTIPOLYGON_SYMBOL - 224))
        | (1ULL << (MySQLParser::POINT_SYMBOL - 224))
        | (1ULL << (MySQLParser::POLYGON_SYMBOL - 224)))) != 0))) {
        dynamic_cast<DataTypeContext *>(_localctx)->type = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NcharContext ------------------------------------------------------------------

MySQLParser::NcharContext::NcharContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::NcharContext::NCHAR_SYMBOL() {
  return getToken(MySQLParser::NCHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NcharContext::CHAR_SYMBOL() {
  return getToken(MySQLParser::CHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NcharContext::NATIONAL_SYMBOL() {
  return getToken(MySQLParser::NATIONAL_SYMBOL, 0);
}


size_t MySQLParser::NcharContext::getRuleIndex() const {
  return MySQLParser::RuleNchar;
}

void MySQLParser::NcharContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNchar(this);
}

void MySQLParser::NcharContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNchar(this);
}


antlrcpp::Any MySQLParser::NcharContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitNchar(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::NcharContext* MySQLParser::nchar() {
  NcharContext *_localctx = _tracker.createInstance<NcharContext>(_ctx, getState());
  enterRule(_localctx, 878, MySQLParser::RuleNchar);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7068);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::NCHAR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7065);
        dynamic_cast<NcharContext *>(_localctx)->type = match(MySQLParser::NCHAR_SYMBOL);
        break;
      }

      case MySQLParser::NATIONAL_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7066);
        dynamic_cast<NcharContext *>(_localctx)->type = match(MySQLParser::NATIONAL_SYMBOL);
        setState(7067);
        match(MySQLParser::CHAR_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarcharContext ------------------------------------------------------------------

MySQLParser::VarcharContext::VarcharContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::VarcharContext::VARYING_SYMBOL() {
  return getToken(MySQLParser::VARYING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::VarcharContext::CHAR_SYMBOL() {
  return getToken(MySQLParser::CHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::VarcharContext::VARCHAR_SYMBOL() {
  return getToken(MySQLParser::VARCHAR_SYMBOL, 0);
}


size_t MySQLParser::VarcharContext::getRuleIndex() const {
  return MySQLParser::RuleVarchar;
}

void MySQLParser::VarcharContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarchar(this);
}

void MySQLParser::VarcharContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarchar(this);
}


antlrcpp::Any MySQLParser::VarcharContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitVarchar(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::VarcharContext* MySQLParser::varchar() {
  VarcharContext *_localctx = _tracker.createInstance<VarcharContext>(_ctx, getState());
  enterRule(_localctx, 880, MySQLParser::RuleVarchar);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7073);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CHAR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7070);
        dynamic_cast<VarcharContext *>(_localctx)->type = match(MySQLParser::CHAR_SYMBOL);
        setState(7071);
        match(MySQLParser::VARYING_SYMBOL);
        break;
      }

      case MySQLParser::VARCHAR_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7072);
        dynamic_cast<VarcharContext *>(_localctx)->type = match(MySQLParser::VARCHAR_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NvarcharContext ------------------------------------------------------------------

MySQLParser::NvarcharContext::NvarcharContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::NvarcharContext::VARCHAR_SYMBOL() {
  return getToken(MySQLParser::VARCHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NvarcharContext::NATIONAL_SYMBOL() {
  return getToken(MySQLParser::NATIONAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NvarcharContext::NVARCHAR_SYMBOL() {
  return getToken(MySQLParser::NVARCHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NvarcharContext::NCHAR_SYMBOL() {
  return getToken(MySQLParser::NCHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NvarcharContext::CHAR_SYMBOL() {
  return getToken(MySQLParser::CHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NvarcharContext::VARYING_SYMBOL() {
  return getToken(MySQLParser::VARYING_SYMBOL, 0);
}


size_t MySQLParser::NvarcharContext::getRuleIndex() const {
  return MySQLParser::RuleNvarchar;
}

void MySQLParser::NvarcharContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNvarchar(this);
}

void MySQLParser::NvarcharContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNvarchar(this);
}


antlrcpp::Any MySQLParser::NvarcharContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitNvarchar(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::NvarcharContext* MySQLParser::nvarchar() {
  NvarcharContext *_localctx = _tracker.createInstance<NvarcharContext>(_ctx, getState());
  enterRule(_localctx, 882, MySQLParser::RuleNvarchar);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7085);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 932, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7075);
      dynamic_cast<NvarcharContext *>(_localctx)->type = match(MySQLParser::NATIONAL_SYMBOL);
      setState(7076);
      match(MySQLParser::VARCHAR_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7077);
      dynamic_cast<NvarcharContext *>(_localctx)->type = match(MySQLParser::NVARCHAR_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7078);
      dynamic_cast<NvarcharContext *>(_localctx)->type = match(MySQLParser::NCHAR_SYMBOL);
      setState(7079);
      match(MySQLParser::VARCHAR_SYMBOL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7080);
      dynamic_cast<NvarcharContext *>(_localctx)->type = match(MySQLParser::NATIONAL_SYMBOL);
      setState(7081);
      match(MySQLParser::CHAR_SYMBOL);
      setState(7082);
      match(MySQLParser::VARYING_SYMBOL);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(7083);
      dynamic_cast<NvarcharContext *>(_localctx)->type = match(MySQLParser::NCHAR_SYMBOL);
      setState(7084);
      match(MySQLParser::VARYING_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldLengthContext ------------------------------------------------------------------

MySQLParser::FieldLengthContext::FieldLengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::FieldLengthContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FieldLengthContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::Real_ulonglong_numberContext* MySQLParser::FieldLengthContext::real_ulonglong_number() {
  return getRuleContext<MySQLParser::Real_ulonglong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::FieldLengthContext::DECIMAL_NUMBER() {
  return getToken(MySQLParser::DECIMAL_NUMBER, 0);
}


size_t MySQLParser::FieldLengthContext::getRuleIndex() const {
  return MySQLParser::RuleFieldLength;
}

void MySQLParser::FieldLengthContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldLength(this);
}

void MySQLParser::FieldLengthContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldLength(this);
}


antlrcpp::Any MySQLParser::FieldLengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFieldLength(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FieldLengthContext* MySQLParser::fieldLength() {
  FieldLengthContext *_localctx = _tracker.createInstance<FieldLengthContext>(_ctx, getState());
  enterRule(_localctx, 884, MySQLParser::RuleFieldLength);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7087);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7090);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INT_NUMBER:
      case MySQLParser::LONG_NUMBER:
      case MySQLParser::ULONGLONG_NUMBER: {
        setState(7088);
        real_ulonglong_number();
        break;
      }

      case MySQLParser::DECIMAL_NUMBER: {
        setState(7089);
        match(MySQLParser::DECIMAL_NUMBER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(7092);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldOptionsContext ------------------------------------------------------------------

MySQLParser::FieldOptionsContext::FieldOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::FieldOptionsContext::SIGNED_SYMBOL() {
  return getTokens(MySQLParser::SIGNED_SYMBOL);
}

tree::TerminalNode* MySQLParser::FieldOptionsContext::SIGNED_SYMBOL(size_t i) {
  return getToken(MySQLParser::SIGNED_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::FieldOptionsContext::UNSIGNED_SYMBOL() {
  return getTokens(MySQLParser::UNSIGNED_SYMBOL);
}

tree::TerminalNode* MySQLParser::FieldOptionsContext::UNSIGNED_SYMBOL(size_t i) {
  return getToken(MySQLParser::UNSIGNED_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::FieldOptionsContext::ZEROFILL_SYMBOL() {
  return getTokens(MySQLParser::ZEROFILL_SYMBOL);
}

tree::TerminalNode* MySQLParser::FieldOptionsContext::ZEROFILL_SYMBOL(size_t i) {
  return getToken(MySQLParser::ZEROFILL_SYMBOL, i);
}


size_t MySQLParser::FieldOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleFieldOptions;
}

void MySQLParser::FieldOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldOptions(this);
}

void MySQLParser::FieldOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldOptions(this);
}


antlrcpp::Any MySQLParser::FieldOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFieldOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FieldOptionsContext* MySQLParser::fieldOptions() {
  FieldOptionsContext *_localctx = _tracker.createInstance<FieldOptionsContext>(_ctx, getState());
  enterRule(_localctx, 886, MySQLParser::RuleFieldOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7095); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(7094);
              _la = _input->LA(1);
              if (!(_la == MySQLParser::SIGNED_SYMBOL || _la == MySQLParser::UNSIGNED_SYMBOL

              || _la == MySQLParser::ZEROFILL_SYMBOL)) {
              _errHandler->recoverInline(this);
              }
              else {
                _errHandler->reportMatch(this);
                consume();
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(7097); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 934, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharsetWithOptBinaryContext ------------------------------------------------------------------

MySQLParser::CharsetWithOptBinaryContext::CharsetWithOptBinaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::AsciiContext* MySQLParser::CharsetWithOptBinaryContext::ascii() {
  return getRuleContext<MySQLParser::AsciiContext>(0);
}

MySQLParser::UnicodeContext* MySQLParser::CharsetWithOptBinaryContext::unicode() {
  return getRuleContext<MySQLParser::UnicodeContext>(0);
}

tree::TerminalNode* MySQLParser::CharsetWithOptBinaryContext::BYTE_SYMBOL() {
  return getToken(MySQLParser::BYTE_SYMBOL, 0);
}

MySQLParser::CharsetContext* MySQLParser::CharsetWithOptBinaryContext::charset() {
  return getRuleContext<MySQLParser::CharsetContext>(0);
}

MySQLParser::CharsetNameContext* MySQLParser::CharsetWithOptBinaryContext::charsetName() {
  return getRuleContext<MySQLParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySQLParser::CharsetWithOptBinaryContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}


size_t MySQLParser::CharsetWithOptBinaryContext::getRuleIndex() const {
  return MySQLParser::RuleCharsetWithOptBinary;
}

void MySQLParser::CharsetWithOptBinaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharsetWithOptBinary(this);
}

void MySQLParser::CharsetWithOptBinaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharsetWithOptBinary(this);
}


antlrcpp::Any MySQLParser::CharsetWithOptBinaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCharsetWithOptBinary(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CharsetWithOptBinaryContext* MySQLParser::charsetWithOptBinary() {
  CharsetWithOptBinaryContext *_localctx = _tracker.createInstance<CharsetWithOptBinaryContext>(_ctx, getState());
  enterRule(_localctx, 888, MySQLParser::RuleCharsetWithOptBinary);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7113);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 937, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7099);
      ascii();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7100);
      unicode();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7101);
      match(MySQLParser::BYTE_SYMBOL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7102);
      charset();
      setState(7103);
      charsetName();
      setState(7105);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 935, _ctx)) {
      case 1: {
        setState(7104);
        match(MySQLParser::BINARY_SYMBOL);
        break;
      }

      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(7107);
      match(MySQLParser::BINARY_SYMBOL);
      setState(7111);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 936, _ctx)) {
      case 1: {
        setState(7108);
        charset();
        setState(7109);
        charsetName();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AsciiContext ------------------------------------------------------------------

MySQLParser::AsciiContext::AsciiContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AsciiContext::ASCII_SYMBOL() {
  return getToken(MySQLParser::ASCII_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AsciiContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}


size_t MySQLParser::AsciiContext::getRuleIndex() const {
  return MySQLParser::RuleAscii;
}

void MySQLParser::AsciiContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAscii(this);
}

void MySQLParser::AsciiContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAscii(this);
}


antlrcpp::Any MySQLParser::AsciiContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAscii(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AsciiContext* MySQLParser::ascii() {
  AsciiContext *_localctx = _tracker.createInstance<AsciiContext>(_ctx, getState());
  enterRule(_localctx, 890, MySQLParser::RuleAscii);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7121);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ASCII_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7115);
        match(MySQLParser::ASCII_SYMBOL);
        setState(7117);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 938, _ctx)) {
        case 1: {
          setState(7116);
          match(MySQLParser::BINARY_SYMBOL);
          break;
        }

        }
        break;
      }

      case MySQLParser::BINARY_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7119);
        match(MySQLParser::BINARY_SYMBOL);
        setState(7120);
        match(MySQLParser::ASCII_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnicodeContext ------------------------------------------------------------------

MySQLParser::UnicodeContext::UnicodeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::UnicodeContext::UNICODE_SYMBOL() {
  return getToken(MySQLParser::UNICODE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::UnicodeContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}


size_t MySQLParser::UnicodeContext::getRuleIndex() const {
  return MySQLParser::RuleUnicode;
}

void MySQLParser::UnicodeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnicode(this);
}

void MySQLParser::UnicodeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnicode(this);
}


antlrcpp::Any MySQLParser::UnicodeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitUnicode(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UnicodeContext* MySQLParser::unicode() {
  UnicodeContext *_localctx = _tracker.createInstance<UnicodeContext>(_ctx, getState());
  enterRule(_localctx, 892, MySQLParser::RuleUnicode);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7129);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::UNICODE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7123);
        match(MySQLParser::UNICODE_SYMBOL);
        setState(7125);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 940, _ctx)) {
        case 1: {
          setState(7124);
          match(MySQLParser::BINARY_SYMBOL);
          break;
        }

        }
        break;
      }

      case MySQLParser::BINARY_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7127);
        match(MySQLParser::BINARY_SYMBOL);
        setState(7128);
        match(MySQLParser::UNICODE_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WsNumCodepointsContext ------------------------------------------------------------------

MySQLParser::WsNumCodepointsContext::WsNumCodepointsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WsNumCodepointsContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::WsNumCodepointsContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::WsNumCodepointsContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::WsNumCodepointsContext::getRuleIndex() const {
  return MySQLParser::RuleWsNumCodepoints;
}

void MySQLParser::WsNumCodepointsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWsNumCodepoints(this);
}

void MySQLParser::WsNumCodepointsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWsNumCodepoints(this);
}


antlrcpp::Any MySQLParser::WsNumCodepointsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitWsNumCodepoints(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WsNumCodepointsContext* MySQLParser::wsNumCodepoints() {
  WsNumCodepointsContext *_localctx = _tracker.createInstance<WsNumCodepointsContext>(_ctx, getState());
  enterRule(_localctx, 894, MySQLParser::RuleWsNumCodepoints);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7131);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7132);
    real_ulong_number();
    setState(7133);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeDatetimePrecisionContext ------------------------------------------------------------------

MySQLParser::TypeDatetimePrecisionContext::TypeDatetimePrecisionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TypeDatetimePrecisionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TypeDatetimePrecisionContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::TypeDatetimePrecisionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::TypeDatetimePrecisionContext::getRuleIndex() const {
  return MySQLParser::RuleTypeDatetimePrecision;
}

void MySQLParser::TypeDatetimePrecisionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeDatetimePrecision(this);
}

void MySQLParser::TypeDatetimePrecisionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeDatetimePrecision(this);
}


antlrcpp::Any MySQLParser::TypeDatetimePrecisionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTypeDatetimePrecision(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TypeDatetimePrecisionContext* MySQLParser::typeDatetimePrecision() {
  TypeDatetimePrecisionContext *_localctx = _tracker.createInstance<TypeDatetimePrecisionContext>(_ctx, getState());
  enterRule(_localctx, 896, MySQLParser::RuleTypeDatetimePrecision);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7135);

    if (!(serverVersion >= 50600)) throw FailedPredicateException(this, "serverVersion >= 50600");
    setState(7136);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7137);
    match(MySQLParser::INT_NUMBER);
    setState(7138);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharsetNameContext ------------------------------------------------------------------

MySQLParser::CharsetNameContext::CharsetNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextOrIdentifierContext* MySQLParser::CharsetNameContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::CharsetNameContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CharsetNameContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}


size_t MySQLParser::CharsetNameContext::getRuleIndex() const {
  return MySQLParser::RuleCharsetName;
}

void MySQLParser::CharsetNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharsetName(this);
}

void MySQLParser::CharsetNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharsetName(this);
}


antlrcpp::Any MySQLParser::CharsetNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCharsetName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CharsetNameContext* MySQLParser::charsetName() {
  CharsetNameContext *_localctx = _tracker.createInstance<CharsetNameContext>(_ctx, getState());
  enterRule(_localctx, 898, MySQLParser::RuleCharsetName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7144);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 942, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7140);
      textOrIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7141);
      match(MySQLParser::BINARY_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7142);

      if (!(serverVersion < 80011)) throw FailedPredicateException(this, "serverVersion < 80011");
      setState(7143);
      match(MySQLParser::DEFAULT_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CollationNameContext ------------------------------------------------------------------

MySQLParser::CollationNameContext::CollationNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextOrIdentifierContext* MySQLParser::CollationNameContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::CollationNameContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}


size_t MySQLParser::CollationNameContext::getRuleIndex() const {
  return MySQLParser::RuleCollationName;
}

void MySQLParser::CollationNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCollationName(this);
}

void MySQLParser::CollationNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCollationName(this);
}


antlrcpp::Any MySQLParser::CollationNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCollationName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CollationNameContext* MySQLParser::collationName() {
  CollationNameContext *_localctx = _tracker.createInstance<CollationNameContext>(_ctx, getState());
  enterRule(_localctx, 900, MySQLParser::RuleCollationName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7149);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 943, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7146);
      textOrIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7147);

      if (!(serverVersion < 80011)) throw FailedPredicateException(this, "serverVersion < 80011");
      setState(7148);
      match(MySQLParser::DEFAULT_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTableOptionsContext ------------------------------------------------------------------

MySQLParser::CreateTableOptionsContext::CreateTableOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::CreateTableOptionContext *> MySQLParser::CreateTableOptionsContext::createTableOption() {
  return getRuleContexts<MySQLParser::CreateTableOptionContext>();
}

MySQLParser::CreateTableOptionContext* MySQLParser::CreateTableOptionsContext::createTableOption(size_t i) {
  return getRuleContext<MySQLParser::CreateTableOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::CreateTableOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::CreateTableOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::CreateTableOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleCreateTableOptions;
}

void MySQLParser::CreateTableOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTableOptions(this);
}

void MySQLParser::CreateTableOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTableOptions(this);
}


antlrcpp::Any MySQLParser::CreateTableOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateTableOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateTableOptionsContext* MySQLParser::createTableOptions() {
  CreateTableOptionsContext *_localctx = _tracker.createInstance<CreateTableOptionsContext>(_ctx, getState());
  enterRule(_localctx, 902, MySQLParser::RuleCreateTableOptions);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7151);
    createTableOption();
    setState(7158);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 945, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(7153);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 944, _ctx)) {
        case 1: {
          setState(7152);
          match(MySQLParser::COMMA_SYMBOL);
          break;
        }

        }
        setState(7155);
        createTableOption(); 
      }
      setState(7160);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 945, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTableOptionsSpaceSeparatedContext ------------------------------------------------------------------

MySQLParser::CreateTableOptionsSpaceSeparatedContext::CreateTableOptionsSpaceSeparatedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::CreateTableOptionContext *> MySQLParser::CreateTableOptionsSpaceSeparatedContext::createTableOption() {
  return getRuleContexts<MySQLParser::CreateTableOptionContext>();
}

MySQLParser::CreateTableOptionContext* MySQLParser::CreateTableOptionsSpaceSeparatedContext::createTableOption(size_t i) {
  return getRuleContext<MySQLParser::CreateTableOptionContext>(i);
}


size_t MySQLParser::CreateTableOptionsSpaceSeparatedContext::getRuleIndex() const {
  return MySQLParser::RuleCreateTableOptionsSpaceSeparated;
}

void MySQLParser::CreateTableOptionsSpaceSeparatedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTableOptionsSpaceSeparated(this);
}

void MySQLParser::CreateTableOptionsSpaceSeparatedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTableOptionsSpaceSeparated(this);
}


antlrcpp::Any MySQLParser::CreateTableOptionsSpaceSeparatedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateTableOptionsSpaceSeparated(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateTableOptionsSpaceSeparatedContext* MySQLParser::createTableOptionsSpaceSeparated() {
  CreateTableOptionsSpaceSeparatedContext *_localctx = _tracker.createInstance<CreateTableOptionsSpaceSeparatedContext>(_ctx, getState());
  enterRule(_localctx, 904, MySQLParser::RuleCreateTableOptionsSpaceSeparated);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7162); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(7161);
              createTableOption();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(7164); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 946, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTableOptionContext ------------------------------------------------------------------

MySQLParser::CreateTableOptionContext::CreateTableOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::EngineRefContext* MySQLParser::CreateTableOptionContext::engineRef() {
  return getRuleContext<MySQLParser::EngineRefContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::SECONDARY_ENGINE_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_ENGINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::NULL_SYMBOL() {
  return getToken(MySQLParser::NULL_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::CreateTableOptionContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

MySQLParser::EqualContext* MySQLParser::CreateTableOptionContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

MySQLParser::Ulonglong_numberContext* MySQLParser::CreateTableOptionContext::ulonglong_number() {
  return getRuleContext<MySQLParser::Ulonglong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::MAX_ROWS_SYMBOL() {
  return getToken(MySQLParser::MAX_ROWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::MIN_ROWS_SYMBOL() {
  return getToken(MySQLParser::MIN_ROWS_SYMBOL, 0);
}

MySQLParser::Ulong_numberContext* MySQLParser::CreateTableOptionContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::AVG_ROW_LENGTH_SYMBOL() {
  return getToken(MySQLParser::AVG_ROW_LENGTH_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::CreateTableOptionContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::CreateTableOptionContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::COMPRESSION_SYMBOL() {
  return getToken(MySQLParser::COMPRESSION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::ENCRYPTION_SYMBOL() {
  return getToken(MySQLParser::ENCRYPTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::AUTO_INCREMENT_SYMBOL() {
  return getToken(MySQLParser::AUTO_INCREMENT_SYMBOL, 0);
}

MySQLParser::TernaryOptionContext* MySQLParser::CreateTableOptionContext::ternaryOption() {
  return getRuleContext<MySQLParser::TernaryOptionContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::PACK_KEYS_SYMBOL() {
  return getToken(MySQLParser::PACK_KEYS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::STATS_AUTO_RECALC_SYMBOL() {
  return getToken(MySQLParser::STATS_AUTO_RECALC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::STATS_PERSISTENT_SYMBOL() {
  return getToken(MySQLParser::STATS_PERSISTENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::STATS_SAMPLE_PAGES_SYMBOL() {
  return getToken(MySQLParser::STATS_SAMPLE_PAGES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::CHECKSUM_SYMBOL() {
  return getToken(MySQLParser::CHECKSUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::TABLE_CHECKSUM_SYMBOL() {
  return getToken(MySQLParser::TABLE_CHECKSUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::DELAY_KEY_WRITE_SYMBOL() {
  return getToken(MySQLParser::DELAY_KEY_WRITE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::ROW_FORMAT_SYMBOL() {
  return getToken(MySQLParser::ROW_FORMAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::DYNAMIC_SYMBOL() {
  return getToken(MySQLParser::DYNAMIC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::FIXED_SYMBOL() {
  return getToken(MySQLParser::FIXED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::COMPRESSED_SYMBOL() {
  return getToken(MySQLParser::COMPRESSED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::REDUNDANT_SYMBOL() {
  return getToken(MySQLParser::REDUNDANT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::COMPACT_SYMBOL() {
  return getToken(MySQLParser::COMPACT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::TableRefListContext* MySQLParser::CreateTableOptionContext::tableRefList() {
  return getRuleContext<MySQLParser::TableRefListContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::UNION_SYMBOL() {
  return getToken(MySQLParser::UNION_SYMBOL, 0);
}

MySQLParser::DefaultCharsetContext* MySQLParser::CreateTableOptionContext::defaultCharset() {
  return getRuleContext<MySQLParser::DefaultCharsetContext>(0);
}

MySQLParser::DefaultCollationContext* MySQLParser::CreateTableOptionContext::defaultCollation() {
  return getRuleContext<MySQLParser::DefaultCollationContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::INSERT_METHOD_SYMBOL() {
  return getToken(MySQLParser::INSERT_METHOD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::NO_SYMBOL() {
  return getToken(MySQLParser::NO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::FIRST_SYMBOL() {
  return getToken(MySQLParser::FIRST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::LAST_SYMBOL() {
  return getToken(MySQLParser::LAST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::DIRECTORY_SYMBOL() {
  return getToken(MySQLParser::DIRECTORY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::CreateTableOptionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::STORAGE_SYMBOL() {
  return getToken(MySQLParser::STORAGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::DISK_SYMBOL() {
  return getToken(MySQLParser::DISK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::MEMORY_SYMBOL() {
  return getToken(MySQLParser::MEMORY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::CONNECTION_SYMBOL() {
  return getToken(MySQLParser::CONNECTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::KEY_BLOCK_SIZE_SYMBOL() {
  return getToken(MySQLParser::KEY_BLOCK_SIZE_SYMBOL, 0);
}


size_t MySQLParser::CreateTableOptionContext::getRuleIndex() const {
  return MySQLParser::RuleCreateTableOption;
}

void MySQLParser::CreateTableOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTableOption(this);
}

void MySQLParser::CreateTableOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTableOption(this);
}


antlrcpp::Any MySQLParser::CreateTableOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateTableOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateTableOptionContext* MySQLParser::createTableOption() {
  CreateTableOptionContext *_localctx = _tracker.createInstance<CreateTableOptionContext>(_ctx, getState());
  enterRule(_localctx, 906, MySQLParser::RuleCreateTableOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7296);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 971, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7166);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::ENGINE_SYMBOL);
      setState(7168);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 947, _ctx)) {
      case 1: {
        setState(7167);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      }
      setState(7170);
      engineRef();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7171);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(7172);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::SECONDARY_ENGINE_SYMBOL);
      setState(7174);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 948, _ctx)) {
      case 1: {
        setState(7173);
        equal();
        break;
      }

      }
      setState(7178);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 949, _ctx)) {
      case 1: {
        setState(7176);
        match(MySQLParser::NULL_SYMBOL);
        break;
      }

      case 2: {
        setState(7177);
        textOrIdentifier();
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7180);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::MAX_ROWS_SYMBOL);
      setState(7182);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7181);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7184);
      ulonglong_number();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7185);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::MIN_ROWS_SYMBOL);
      setState(7187);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7186);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7189);
      ulonglong_number();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(7190);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::AVG_ROW_LENGTH_SYMBOL);
      setState(7192);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7191);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7194);
      ulong_number();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(7195);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::PASSWORD_SYMBOL);
      setState(7197);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 953, _ctx)) {
      case 1: {
        setState(7196);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      }
      setState(7199);
      textStringLiteral();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(7200);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::COMMENT_SYMBOL);
      setState(7202);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 954, _ctx)) {
      case 1: {
        setState(7201);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      }
      setState(7204);
      textStringLiteral();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(7205);

      if (!(serverVersion >= 50708)) throw FailedPredicateException(this, "serverVersion >= 50708");
      setState(7206);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::COMPRESSION_SYMBOL);
      setState(7208);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 955, _ctx)) {
      case 1: {
        setState(7207);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      }
      setState(7210);
      textString();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(7211);

      if (!(serverVersion >= 50711)) throw FailedPredicateException(this, "serverVersion >= 50711");
      setState(7212);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::ENCRYPTION_SYMBOL);
      setState(7214);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 956, _ctx)) {
      case 1: {
        setState(7213);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      }
      setState(7216);
      textString();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(7217);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::AUTO_INCREMENT_SYMBOL);
      setState(7219);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7218);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7221);
      ulonglong_number();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(7222);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::PACK_KEYS_SYMBOL);
      setState(7224);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7223);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7226);
      ternaryOption();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(7227);

      if (!(serverVersion >= 50600)) throw FailedPredicateException(this, "serverVersion >= 50600");
      setState(7228);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 324) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 324)) & ((1ULL << (MySQLParser::STATS_AUTO_RECALC_SYMBOL - 324))
        | (1ULL << (MySQLParser::STATS_PERSISTENT_SYMBOL - 324))
        | (1ULL << (MySQLParser::STATS_SAMPLE_PAGES_SYMBOL - 324)))) != 0))) {
        dynamic_cast<CreateTableOptionContext *>(_localctx)->option = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(7230);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7229);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7232);
      ternaryOption();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(7233);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::CHECKSUM_SYMBOL || _la == MySQLParser::TABLE_CHECKSUM_SYMBOL)) {
        dynamic_cast<CreateTableOptionContext *>(_localctx)->option = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(7235);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7234);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7237);
      ulong_number();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(7238);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::DELAY_KEY_WRITE_SYMBOL);
      setState(7240);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7239);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7242);
      ulong_number();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(7243);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::ROW_FORMAT_SYMBOL);
      setState(7245);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7244);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7247);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->format = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 92) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 92)) & ((1ULL << (MySQLParser::COMPACT_SYMBOL - 92))
        | (1ULL << (MySQLParser::COMPRESSED_SYMBOL - 92))
        | (1ULL << (MySQLParser::DYNAMIC_SYMBOL - 92))
        | (1ULL << (MySQLParser::FIXED_SYMBOL - 92)))) != 0) || _la == MySQLParser::REDUNDANT_SYMBOL || _la == MySQLParser::DEFAULT_SYMBOL)) {
        dynamic_cast<CreateTableOptionContext *>(_localctx)->format = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(7248);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::UNION_SYMBOL);
      setState(7250);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7249);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7252);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(7253);
      tableRefList();
      setState(7254);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(7256);
      defaultCharset();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(7257);
      defaultCollation();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(7258);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::INSERT_METHOD_SYMBOL);
      setState(7260);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7259);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7262);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->method = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::NO_SYMBOL || _la == MySQLParser::FIRST_SYMBOL

      || _la == MySQLParser::LAST_SYMBOL)) {
        dynamic_cast<CreateTableOptionContext *>(_localctx)->method = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(7263);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::DATA_SYMBOL);
      setState(7264);
      match(MySQLParser::DIRECTORY_SYMBOL);
      setState(7266);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 965, _ctx)) {
      case 1: {
        setState(7265);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      }
      setState(7268);
      textString();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(7269);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::INDEX_SYMBOL);
      setState(7270);
      match(MySQLParser::DIRECTORY_SYMBOL);
      setState(7272);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 966, _ctx)) {
      case 1: {
        setState(7271);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      }
      setState(7274);
      textString();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(7275);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::TABLESPACE_SYMBOL);
      setState(7281);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 968, _ctx)) {
      case 1: {
        setState(7276);

        if (!(serverVersion >= 50707)) throw FailedPredicateException(this, "serverVersion >= 50707");
        setState(7278);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 967, _ctx)) {
        case 1: {
          setState(7277);
          match(MySQLParser::EQUAL_OPERATOR);
          break;
        }

        }
        break;
      }

      case 2: {
        break;
      }

      }
      setState(7283);
      identifier();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(7284);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::STORAGE_SYMBOL);
      setState(7285);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::DISK_SYMBOL || _la == MySQLParser::MEMORY_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(7286);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::CONNECTION_SYMBOL);
      setState(7288);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 969, _ctx)) {
      case 1: {
        setState(7287);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      }
      setState(7290);
      textString();
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(7291);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::KEY_BLOCK_SIZE_SYMBOL);
      setState(7293);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7292);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7295);
      ulong_number();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TernaryOptionContext ------------------------------------------------------------------

MySQLParser::TernaryOptionContext::TernaryOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::Ulong_numberContext* MySQLParser::TernaryOptionContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::TernaryOptionContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}


size_t MySQLParser::TernaryOptionContext::getRuleIndex() const {
  return MySQLParser::RuleTernaryOption;
}

void MySQLParser::TernaryOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTernaryOption(this);
}

void MySQLParser::TernaryOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTernaryOption(this);
}


antlrcpp::Any MySQLParser::TernaryOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTernaryOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TernaryOptionContext* MySQLParser::ternaryOption() {
  TernaryOptionContext *_localctx = _tracker.createInstance<TernaryOptionContext>(_ctx, getState());
  enterRule(_localctx, 908, MySQLParser::RuleTernaryOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7300);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INT_NUMBER:
      case MySQLParser::LONG_NUMBER:
      case MySQLParser::ULONGLONG_NUMBER:
      case MySQLParser::HEX_NUMBER:
      case MySQLParser::DECIMAL_NUMBER:
      case MySQLParser::FLOAT_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(7298);
        ulong_number();
        break;
      }

      case MySQLParser::DEFAULT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7299);
        match(MySQLParser::DEFAULT_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultCollationContext ------------------------------------------------------------------

MySQLParser::DefaultCollationContext::DefaultCollationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DefaultCollationContext::COLLATE_SYMBOL() {
  return getToken(MySQLParser::COLLATE_SYMBOL, 0);
}

MySQLParser::CollationNameContext* MySQLParser::DefaultCollationContext::collationName() {
  return getRuleContext<MySQLParser::CollationNameContext>(0);
}

tree::TerminalNode* MySQLParser::DefaultCollationContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DefaultCollationContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::DefaultCollationContext::getRuleIndex() const {
  return MySQLParser::RuleDefaultCollation;
}

void MySQLParser::DefaultCollationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultCollation(this);
}

void MySQLParser::DefaultCollationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultCollation(this);
}


antlrcpp::Any MySQLParser::DefaultCollationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDefaultCollation(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DefaultCollationContext* MySQLParser::defaultCollation() {
  DefaultCollationContext *_localctx = _tracker.createInstance<DefaultCollationContext>(_ctx, getState());
  enterRule(_localctx, 910, MySQLParser::RuleDefaultCollation);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7303);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFAULT_SYMBOL) {
      setState(7302);
      match(MySQLParser::DEFAULT_SYMBOL);
    }
    setState(7305);
    match(MySQLParser::COLLATE_SYMBOL);
    setState(7307);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 974, _ctx)) {
    case 1: {
      setState(7306);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(7309);
    collationName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultEncryptionContext ------------------------------------------------------------------

MySQLParser::DefaultEncryptionContext::DefaultEncryptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DefaultEncryptionContext::ENCRYPTION_SYMBOL() {
  return getToken(MySQLParser::ENCRYPTION_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::DefaultEncryptionContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::DefaultEncryptionContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DefaultEncryptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::DefaultEncryptionContext::getRuleIndex() const {
  return MySQLParser::RuleDefaultEncryption;
}

void MySQLParser::DefaultEncryptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultEncryption(this);
}

void MySQLParser::DefaultEncryptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultEncryption(this);
}


antlrcpp::Any MySQLParser::DefaultEncryptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDefaultEncryption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DefaultEncryptionContext* MySQLParser::defaultEncryption() {
  DefaultEncryptionContext *_localctx = _tracker.createInstance<DefaultEncryptionContext>(_ctx, getState());
  enterRule(_localctx, 912, MySQLParser::RuleDefaultEncryption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7312);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFAULT_SYMBOL) {
      setState(7311);
      match(MySQLParser::DEFAULT_SYMBOL);
    }
    setState(7314);
    match(MySQLParser::ENCRYPTION_SYMBOL);
    setState(7316);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 976, _ctx)) {
    case 1: {
      setState(7315);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(7318);
    textStringLiteral();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultCharsetContext ------------------------------------------------------------------

MySQLParser::DefaultCharsetContext::DefaultCharsetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CharsetContext* MySQLParser::DefaultCharsetContext::charset() {
  return getRuleContext<MySQLParser::CharsetContext>(0);
}

MySQLParser::CharsetNameContext* MySQLParser::DefaultCharsetContext::charsetName() {
  return getRuleContext<MySQLParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySQLParser::DefaultCharsetContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DefaultCharsetContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::DefaultCharsetContext::getRuleIndex() const {
  return MySQLParser::RuleDefaultCharset;
}

void MySQLParser::DefaultCharsetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultCharset(this);
}

void MySQLParser::DefaultCharsetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultCharset(this);
}


antlrcpp::Any MySQLParser::DefaultCharsetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDefaultCharset(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DefaultCharsetContext* MySQLParser::defaultCharset() {
  DefaultCharsetContext *_localctx = _tracker.createInstance<DefaultCharsetContext>(_ctx, getState());
  enterRule(_localctx, 914, MySQLParser::RuleDefaultCharset);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7321);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFAULT_SYMBOL) {
      setState(7320);
      match(MySQLParser::DEFAULT_SYMBOL);
    }
    setState(7323);
    charset();
    setState(7325);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 978, _ctx)) {
    case 1: {
      setState(7324);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(7327);
    charsetName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionClauseContext ------------------------------------------------------------------

MySQLParser::PartitionClauseContext::PartitionClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::PartitionClauseContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionClauseContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::PartitionTypeDefContext* MySQLParser::PartitionClauseContext::partitionTypeDef() {
  return getRuleContext<MySQLParser::PartitionTypeDefContext>(0);
}

tree::TerminalNode* MySQLParser::PartitionClauseContext::PARTITIONS_SYMBOL() {
  return getToken(MySQLParser::PARTITIONS_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::PartitionClauseContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

MySQLParser::SubPartitionsContext* MySQLParser::PartitionClauseContext::subPartitions() {
  return getRuleContext<MySQLParser::SubPartitionsContext>(0);
}

MySQLParser::PartitionDefinitionsContext* MySQLParser::PartitionClauseContext::partitionDefinitions() {
  return getRuleContext<MySQLParser::PartitionDefinitionsContext>(0);
}


size_t MySQLParser::PartitionClauseContext::getRuleIndex() const {
  return MySQLParser::RulePartitionClause;
}

void MySQLParser::PartitionClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionClause(this);
}

void MySQLParser::PartitionClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionClause(this);
}


antlrcpp::Any MySQLParser::PartitionClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPartitionClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PartitionClauseContext* MySQLParser::partitionClause() {
  PartitionClauseContext *_localctx = _tracker.createInstance<PartitionClauseContext>(_ctx, getState());
  enterRule(_localctx, 916, MySQLParser::RulePartitionClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7329);
    match(MySQLParser::PARTITION_SYMBOL);
    setState(7330);
    match(MySQLParser::BY_SYMBOL);
    setState(7331);
    partitionTypeDef();
    setState(7334);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 979, _ctx)) {
    case 1: {
      setState(7332);
      match(MySQLParser::PARTITIONS_SYMBOL);
      setState(7333);
      real_ulong_number();
      break;
    }

    }
    setState(7337);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 980, _ctx)) {
    case 1: {
      setState(7336);
      subPartitions();
      break;
    }

    }
    setState(7340);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 981, _ctx)) {
    case 1: {
      setState(7339);
      partitionDefinitions();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionTypeDefContext ------------------------------------------------------------------

MySQLParser::PartitionTypeDefContext::PartitionTypeDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySQLParser::PartitionTypeDefContext::getRuleIndex() const {
  return MySQLParser::RulePartitionTypeDef;
}

void MySQLParser::PartitionTypeDefContext::copyFrom(PartitionTypeDefContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PartitionDefRangeListContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::PartitionDefRangeListContext::RANGE_SYMBOL() {
  return getToken(MySQLParser::RANGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDefRangeListContext::LIST_SYMBOL() {
  return getToken(MySQLParser::LIST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDefRangeListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::BitExprContext* MySQLParser::PartitionDefRangeListContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

tree::TerminalNode* MySQLParser::PartitionDefRangeListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDefRangeListContext::COLUMNS_SYMBOL() {
  return getToken(MySQLParser::COLUMNS_SYMBOL, 0);
}

MySQLParser::IdentifierListContext* MySQLParser::PartitionDefRangeListContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

MySQLParser::PartitionDefRangeListContext::PartitionDefRangeListContext(PartitionTypeDefContext *ctx) { copyFrom(ctx); }

void MySQLParser::PartitionDefRangeListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDefRangeList(this);
}
void MySQLParser::PartitionDefRangeListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDefRangeList(this);
}

antlrcpp::Any MySQLParser::PartitionDefRangeListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPartitionDefRangeList(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PartitionDefKeyContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::PartitionDefKeyContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDefKeyContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDefKeyContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDefKeyContext::LINEAR_SYMBOL() {
  return getToken(MySQLParser::LINEAR_SYMBOL, 0);
}

MySQLParser::PartitionKeyAlgorithmContext* MySQLParser::PartitionDefKeyContext::partitionKeyAlgorithm() {
  return getRuleContext<MySQLParser::PartitionKeyAlgorithmContext>(0);
}

MySQLParser::IdentifierListContext* MySQLParser::PartitionDefKeyContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

MySQLParser::PartitionDefKeyContext::PartitionDefKeyContext(PartitionTypeDefContext *ctx) { copyFrom(ctx); }

void MySQLParser::PartitionDefKeyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDefKey(this);
}
void MySQLParser::PartitionDefKeyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDefKey(this);
}

antlrcpp::Any MySQLParser::PartitionDefKeyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPartitionDefKey(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PartitionDefHashContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::PartitionDefHashContext::HASH_SYMBOL() {
  return getToken(MySQLParser::HASH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDefHashContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::BitExprContext* MySQLParser::PartitionDefHashContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

tree::TerminalNode* MySQLParser::PartitionDefHashContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDefHashContext::LINEAR_SYMBOL() {
  return getToken(MySQLParser::LINEAR_SYMBOL, 0);
}

MySQLParser::PartitionDefHashContext::PartitionDefHashContext(PartitionTypeDefContext *ctx) { copyFrom(ctx); }

void MySQLParser::PartitionDefHashContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDefHash(this);
}
void MySQLParser::PartitionDefHashContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDefHash(this);
}

antlrcpp::Any MySQLParser::PartitionDefHashContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPartitionDefHash(this);
  else
    return visitor->visitChildren(this);
}
MySQLParser::PartitionTypeDefContext* MySQLParser::partitionTypeDef() {
  PartitionTypeDefContext *_localctx = _tracker.createInstance<PartitionTypeDefContext>(_ctx, getState());
  enterRule(_localctx, 918, MySQLParser::RulePartitionTypeDef);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7375);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 988, _ctx)) {
    case 1: {
      _localctx = dynamic_cast<PartitionTypeDefContext *>(_tracker.createInstance<MySQLParser::PartitionDefKeyContext>(_localctx));
      enterOuterAlt(_localctx, 1);
      setState(7343);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LINEAR_SYMBOL) {
        setState(7342);
        match(MySQLParser::LINEAR_SYMBOL);
      }
      setState(7345);
      match(MySQLParser::KEY_SYMBOL);
      setState(7347);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 983, _ctx)) {
      case 1: {
        setState(7346);
        partitionKeyAlgorithm();
        break;
      }

      }
      setState(7349);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(7351);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 984, _ctx)) {
      case 1: {
        setState(7350);
        identifierList();
        break;
      }

      }
      setState(7353);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 2: {
      _localctx = dynamic_cast<PartitionTypeDefContext *>(_tracker.createInstance<MySQLParser::PartitionDefHashContext>(_localctx));
      enterOuterAlt(_localctx, 2);
      setState(7355);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LINEAR_SYMBOL) {
        setState(7354);
        match(MySQLParser::LINEAR_SYMBOL);
      }
      setState(7357);
      match(MySQLParser::HASH_SYMBOL);
      setState(7358);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(7359);
      bitExpr(0);
      setState(7360);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 3: {
      _localctx = dynamic_cast<PartitionTypeDefContext *>(_tracker.createInstance<MySQLParser::PartitionDefRangeListContext>(_localctx));
      enterOuterAlt(_localctx, 3);
      setState(7362);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::LIST_SYMBOL || _la == MySQLParser::RANGE_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(7373);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::OPEN_PAR_SYMBOL: {
          setState(7363);
          match(MySQLParser::OPEN_PAR_SYMBOL);
          setState(7364);
          bitExpr(0);
          setState(7365);
          match(MySQLParser::CLOSE_PAR_SYMBOL);
          break;
        }

        case MySQLParser::COLUMNS_SYMBOL: {
          setState(7367);
          match(MySQLParser::COLUMNS_SYMBOL);
          setState(7368);
          match(MySQLParser::OPEN_PAR_SYMBOL);
          setState(7370);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 986, _ctx)) {
          case 1: {
            setState(7369);
            identifierList();
            break;
          }

          }
          setState(7372);
          match(MySQLParser::CLOSE_PAR_SYMBOL);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubPartitionsContext ------------------------------------------------------------------

MySQLParser::SubPartitionsContext::SubPartitionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SubPartitionsContext::SUBPARTITION_SYMBOL() {
  return getToken(MySQLParser::SUBPARTITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SubPartitionsContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SubPartitionsContext::HASH_SYMBOL() {
  return getToken(MySQLParser::HASH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SubPartitionsContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::BitExprContext* MySQLParser::SubPartitionsContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

tree::TerminalNode* MySQLParser::SubPartitionsContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SubPartitionsContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

MySQLParser::IdentifierListWithParenthesesContext* MySQLParser::SubPartitionsContext::identifierListWithParentheses() {
  return getRuleContext<MySQLParser::IdentifierListWithParenthesesContext>(0);
}

tree::TerminalNode* MySQLParser::SubPartitionsContext::LINEAR_SYMBOL() {
  return getToken(MySQLParser::LINEAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SubPartitionsContext::SUBPARTITIONS_SYMBOL() {
  return getToken(MySQLParser::SUBPARTITIONS_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::SubPartitionsContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

MySQLParser::PartitionKeyAlgorithmContext* MySQLParser::SubPartitionsContext::partitionKeyAlgorithm() {
  return getRuleContext<MySQLParser::PartitionKeyAlgorithmContext>(0);
}


size_t MySQLParser::SubPartitionsContext::getRuleIndex() const {
  return MySQLParser::RuleSubPartitions;
}

void MySQLParser::SubPartitionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubPartitions(this);
}

void MySQLParser::SubPartitionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubPartitions(this);
}


antlrcpp::Any MySQLParser::SubPartitionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSubPartitions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SubPartitionsContext* MySQLParser::subPartitions() {
  SubPartitionsContext *_localctx = _tracker.createInstance<SubPartitionsContext>(_ctx, getState());
  enterRule(_localctx, 920, MySQLParser::RuleSubPartitions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7377);
    match(MySQLParser::SUBPARTITION_SYMBOL);
    setState(7378);
    match(MySQLParser::BY_SYMBOL);
    setState(7380);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LINEAR_SYMBOL) {
      setState(7379);
      match(MySQLParser::LINEAR_SYMBOL);
    }
    setState(7392);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::HASH_SYMBOL: {
        setState(7382);
        match(MySQLParser::HASH_SYMBOL);
        setState(7383);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(7384);
        bitExpr(0);
        setState(7385);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::KEY_SYMBOL: {
        setState(7387);
        match(MySQLParser::KEY_SYMBOL);
        setState(7389);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 990, _ctx)) {
        case 1: {
          setState(7388);
          partitionKeyAlgorithm();
          break;
        }

        }
        setState(7391);
        identifierListWithParentheses();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(7396);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 992, _ctx)) {
    case 1: {
      setState(7394);
      match(MySQLParser::SUBPARTITIONS_SYMBOL);
      setState(7395);
      real_ulong_number();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionKeyAlgorithmContext ------------------------------------------------------------------

MySQLParser::PartitionKeyAlgorithmContext::PartitionKeyAlgorithmContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::PartitionKeyAlgorithmContext::ALGORITHM_SYMBOL() {
  return getToken(MySQLParser::ALGORITHM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionKeyAlgorithmContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::PartitionKeyAlgorithmContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}


size_t MySQLParser::PartitionKeyAlgorithmContext::getRuleIndex() const {
  return MySQLParser::RulePartitionKeyAlgorithm;
}

void MySQLParser::PartitionKeyAlgorithmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionKeyAlgorithm(this);
}

void MySQLParser::PartitionKeyAlgorithmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionKeyAlgorithm(this);
}


antlrcpp::Any MySQLParser::PartitionKeyAlgorithmContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPartitionKeyAlgorithm(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PartitionKeyAlgorithmContext* MySQLParser::partitionKeyAlgorithm() {
  PartitionKeyAlgorithmContext *_localctx = _tracker.createInstance<PartitionKeyAlgorithmContext>(_ctx, getState());
  enterRule(_localctx, 922, MySQLParser::RulePartitionKeyAlgorithm);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7398);

    if (!(serverVersion >= 50700)) throw FailedPredicateException(this, "serverVersion >= 50700");
    setState(7399);
    match(MySQLParser::ALGORITHM_SYMBOL);
    setState(7400);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(7401);
    real_ulong_number();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionDefinitionsContext ------------------------------------------------------------------

MySQLParser::PartitionDefinitionsContext::PartitionDefinitionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::PartitionDefinitionsContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::PartitionDefinitionContext *> MySQLParser::PartitionDefinitionsContext::partitionDefinition() {
  return getRuleContexts<MySQLParser::PartitionDefinitionContext>();
}

MySQLParser::PartitionDefinitionContext* MySQLParser::PartitionDefinitionsContext::partitionDefinition(size_t i) {
  return getRuleContext<MySQLParser::PartitionDefinitionContext>(i);
}

tree::TerminalNode* MySQLParser::PartitionDefinitionsContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::PartitionDefinitionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::PartitionDefinitionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::PartitionDefinitionsContext::getRuleIndex() const {
  return MySQLParser::RulePartitionDefinitions;
}

void MySQLParser::PartitionDefinitionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDefinitions(this);
}

void MySQLParser::PartitionDefinitionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDefinitions(this);
}


antlrcpp::Any MySQLParser::PartitionDefinitionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPartitionDefinitions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PartitionDefinitionsContext* MySQLParser::partitionDefinitions() {
  PartitionDefinitionsContext *_localctx = _tracker.createInstance<PartitionDefinitionsContext>(_ctx, getState());
  enterRule(_localctx, 924, MySQLParser::RulePartitionDefinitions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7403);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7404);
    partitionDefinition();
    setState(7409);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(7405);
      match(MySQLParser::COMMA_SYMBOL);
      setState(7406);
      partitionDefinition();
      setState(7411);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(7412);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionDefinitionContext ------------------------------------------------------------------

MySQLParser::PartitionDefinitionContext::PartitionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::PartitionDefinitionContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::PartitionDefinitionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::PartitionDefinitionContext::VALUES_SYMBOL() {
  return getToken(MySQLParser::VALUES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDefinitionContext::LESS_SYMBOL() {
  return getToken(MySQLParser::LESS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDefinitionContext::THAN_SYMBOL() {
  return getToken(MySQLParser::THAN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDefinitionContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

MySQLParser::PartitionValuesInContext* MySQLParser::PartitionDefinitionContext::partitionValuesIn() {
  return getRuleContext<MySQLParser::PartitionValuesInContext>(0);
}

std::vector<MySQLParser::PartitionOptionContext *> MySQLParser::PartitionDefinitionContext::partitionOption() {
  return getRuleContexts<MySQLParser::PartitionOptionContext>();
}

MySQLParser::PartitionOptionContext* MySQLParser::PartitionDefinitionContext::partitionOption(size_t i) {
  return getRuleContext<MySQLParser::PartitionOptionContext>(i);
}

tree::TerminalNode* MySQLParser::PartitionDefinitionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::SubpartitionDefinitionContext *> MySQLParser::PartitionDefinitionContext::subpartitionDefinition() {
  return getRuleContexts<MySQLParser::SubpartitionDefinitionContext>();
}

MySQLParser::SubpartitionDefinitionContext* MySQLParser::PartitionDefinitionContext::subpartitionDefinition(size_t i) {
  return getRuleContext<MySQLParser::SubpartitionDefinitionContext>(i);
}

tree::TerminalNode* MySQLParser::PartitionDefinitionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::PartitionValueItemListParenContext* MySQLParser::PartitionDefinitionContext::partitionValueItemListParen() {
  return getRuleContext<MySQLParser::PartitionValueItemListParenContext>(0);
}

tree::TerminalNode* MySQLParser::PartitionDefinitionContext::MAXVALUE_SYMBOL() {
  return getToken(MySQLParser::MAXVALUE_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::PartitionDefinitionContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::PartitionDefinitionContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::PartitionDefinitionContext::getRuleIndex() const {
  return MySQLParser::RulePartitionDefinition;
}

void MySQLParser::PartitionDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDefinition(this);
}

void MySQLParser::PartitionDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDefinition(this);
}


antlrcpp::Any MySQLParser::PartitionDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPartitionDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PartitionDefinitionContext* MySQLParser::partitionDefinition() {
  PartitionDefinitionContext *_localctx = _tracker.createInstance<PartitionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 926, MySQLParser::RulePartitionDefinition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7414);
    match(MySQLParser::PARTITION_SYMBOL);
    setState(7415);
    identifier();
    setState(7426);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 995, _ctx)) {
    case 1: {
      setState(7416);
      match(MySQLParser::VALUES_SYMBOL);
      setState(7417);
      match(MySQLParser::LESS_SYMBOL);
      setState(7418);
      match(MySQLParser::THAN_SYMBOL);
      setState(7421);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::OPEN_PAR_SYMBOL: {
          setState(7419);
          partitionValueItemListParen();
          break;
        }

        case MySQLParser::MAXVALUE_SYMBOL: {
          setState(7420);
          match(MySQLParser::MAXVALUE_SYMBOL);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      setState(7423);
      match(MySQLParser::VALUES_SYMBOL);
      setState(7424);
      match(MySQLParser::IN_SYMBOL);
      setState(7425);
      partitionValuesIn();
      break;
    }

    }
    setState(7431);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMENT_SYMBOL || _la == MySQLParser::DATA_SYMBOL

    || _la == MySQLParser::ENGINE_SYMBOL || ((((_la - 184) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 184)) & ((1ULL << (MySQLParser::MAX_ROWS_SYMBOL - 184))
      | (1ULL << (MySQLParser::MIN_ROWS_SYMBOL - 184))
      | (1ULL << (MySQLParser::NODEGROUP_SYMBOL - 184)))) != 0) || _la == MySQLParser::STORAGE_SYMBOL

    || _la == MySQLParser::TABLESPACE_SYMBOL || _la == MySQLParser::INDEX_SYMBOL) {
      setState(7428);
      partitionOption();
      setState(7433);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(7445);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(7434);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(7435);
      subpartitionDefinition();
      setState(7440);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(7436);
        match(MySQLParser::COMMA_SYMBOL);
        setState(7437);
        subpartitionDefinition();
        setState(7442);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(7443);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionValuesInContext ------------------------------------------------------------------

MySQLParser::PartitionValuesInContext::PartitionValuesInContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::PartitionValueItemListParenContext *> MySQLParser::PartitionValuesInContext::partitionValueItemListParen() {
  return getRuleContexts<MySQLParser::PartitionValueItemListParenContext>();
}

MySQLParser::PartitionValueItemListParenContext* MySQLParser::PartitionValuesInContext::partitionValueItemListParen(size_t i) {
  return getRuleContext<MySQLParser::PartitionValueItemListParenContext>(i);
}

tree::TerminalNode* MySQLParser::PartitionValuesInContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionValuesInContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::PartitionValuesInContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::PartitionValuesInContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::PartitionValuesInContext::getRuleIndex() const {
  return MySQLParser::RulePartitionValuesIn;
}

void MySQLParser::PartitionValuesInContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionValuesIn(this);
}

void MySQLParser::PartitionValuesInContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionValuesIn(this);
}


antlrcpp::Any MySQLParser::PartitionValuesInContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPartitionValuesIn(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PartitionValuesInContext* MySQLParser::partitionValuesIn() {
  PartitionValuesInContext *_localctx = _tracker.createInstance<PartitionValuesInContext>(_ctx, getState());
  enterRule(_localctx, 928, MySQLParser::RulePartitionValuesIn);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7459);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1000, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7447);
      partitionValueItemListParen();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7448);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(7449);
      partitionValueItemListParen();
      setState(7454);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(7450);
        match(MySQLParser::COMMA_SYMBOL);
        setState(7451);
        partitionValueItemListParen();
        setState(7456);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(7457);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionOptionContext ------------------------------------------------------------------

MySQLParser::PartitionOptionContext::PartitionOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::PartitionOptionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::PartitionOptionContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::EngineRefContext* MySQLParser::PartitionOptionContext::engineRef() {
  return getRuleContext<MySQLParser::EngineRefContext>(0);
}

tree::TerminalNode* MySQLParser::PartitionOptionContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionOptionContext::STORAGE_SYMBOL() {
  return getToken(MySQLParser::STORAGE_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::PartitionOptionContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::PartitionOptionContext::NODEGROUP_SYMBOL() {
  return getToken(MySQLParser::NODEGROUP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionOptionContext::MAX_ROWS_SYMBOL() {
  return getToken(MySQLParser::MAX_ROWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionOptionContext::MIN_ROWS_SYMBOL() {
  return getToken(MySQLParser::MIN_ROWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionOptionContext::DIRECTORY_SYMBOL() {
  return getToken(MySQLParser::DIRECTORY_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::PartitionOptionContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::PartitionOptionContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionOptionContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionOptionContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}


size_t MySQLParser::PartitionOptionContext::getRuleIndex() const {
  return MySQLParser::RulePartitionOption;
}

void MySQLParser::PartitionOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionOption(this);
}

void MySQLParser::PartitionOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionOption(this);
}


antlrcpp::Any MySQLParser::PartitionOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPartitionOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PartitionOptionContext* MySQLParser::partitionOption() {
  PartitionOptionContext *_localctx = _tracker.createInstance<PartitionOptionContext>(_ctx, getState());
  enterRule(_localctx, 930, MySQLParser::RulePartitionOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7495);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::TABLESPACE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7461);
        dynamic_cast<PartitionOptionContext *>(_localctx)->option = match(MySQLParser::TABLESPACE_SYMBOL);
        setState(7463);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1001, _ctx)) {
        case 1: {
          setState(7462);
          match(MySQLParser::EQUAL_OPERATOR);
          break;
        }

        }
        setState(7465);
        identifier();
        break;
      }

      case MySQLParser::ENGINE_SYMBOL:
      case MySQLParser::STORAGE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7467);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::STORAGE_SYMBOL) {
          setState(7466);
          match(MySQLParser::STORAGE_SYMBOL);
        }
        setState(7469);
        dynamic_cast<PartitionOptionContext *>(_localctx)->option = match(MySQLParser::ENGINE_SYMBOL);
        setState(7471);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1003, _ctx)) {
        case 1: {
          setState(7470);
          match(MySQLParser::EQUAL_OPERATOR);
          break;
        }

        }
        setState(7473);
        engineRef();
        break;
      }

      case MySQLParser::NODEGROUP_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(7474);
        dynamic_cast<PartitionOptionContext *>(_localctx)->option = match(MySQLParser::NODEGROUP_SYMBOL);
        setState(7476);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EQUAL_OPERATOR) {
          setState(7475);
          match(MySQLParser::EQUAL_OPERATOR);
        }
        setState(7478);
        real_ulong_number();
        break;
      }

      case MySQLParser::MAX_ROWS_SYMBOL:
      case MySQLParser::MIN_ROWS_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(7479);
        dynamic_cast<PartitionOptionContext *>(_localctx)->option = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::MAX_ROWS_SYMBOL

        || _la == MySQLParser::MIN_ROWS_SYMBOL)) {
          dynamic_cast<PartitionOptionContext *>(_localctx)->option = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(7481);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EQUAL_OPERATOR) {
          setState(7480);
          match(MySQLParser::EQUAL_OPERATOR);
        }
        setState(7483);
        real_ulong_number();
        break;
      }

      case MySQLParser::DATA_SYMBOL:
      case MySQLParser::INDEX_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(7484);
        dynamic_cast<PartitionOptionContext *>(_localctx)->option = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::DATA_SYMBOL || _la == MySQLParser::INDEX_SYMBOL)) {
          dynamic_cast<PartitionOptionContext *>(_localctx)->option = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(7485);
        match(MySQLParser::DIRECTORY_SYMBOL);
        setState(7487);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1006, _ctx)) {
        case 1: {
          setState(7486);
          match(MySQLParser::EQUAL_OPERATOR);
          break;
        }

        }
        setState(7489);
        textLiteral();
        break;
      }

      case MySQLParser::COMMENT_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(7490);
        dynamic_cast<PartitionOptionContext *>(_localctx)->option = match(MySQLParser::COMMENT_SYMBOL);
        setState(7492);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1007, _ctx)) {
        case 1: {
          setState(7491);
          match(MySQLParser::EQUAL_OPERATOR);
          break;
        }

        }
        setState(7494);
        textLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubpartitionDefinitionContext ------------------------------------------------------------------

MySQLParser::SubpartitionDefinitionContext::SubpartitionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SubpartitionDefinitionContext::SUBPARTITION_SYMBOL() {
  return getToken(MySQLParser::SUBPARTITION_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::SubpartitionDefinitionContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

std::vector<MySQLParser::PartitionOptionContext *> MySQLParser::SubpartitionDefinitionContext::partitionOption() {
  return getRuleContexts<MySQLParser::PartitionOptionContext>();
}

MySQLParser::PartitionOptionContext* MySQLParser::SubpartitionDefinitionContext::partitionOption(size_t i) {
  return getRuleContext<MySQLParser::PartitionOptionContext>(i);
}


size_t MySQLParser::SubpartitionDefinitionContext::getRuleIndex() const {
  return MySQLParser::RuleSubpartitionDefinition;
}

void MySQLParser::SubpartitionDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubpartitionDefinition(this);
}

void MySQLParser::SubpartitionDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubpartitionDefinition(this);
}


antlrcpp::Any MySQLParser::SubpartitionDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSubpartitionDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SubpartitionDefinitionContext* MySQLParser::subpartitionDefinition() {
  SubpartitionDefinitionContext *_localctx = _tracker.createInstance<SubpartitionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 932, MySQLParser::RuleSubpartitionDefinition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7497);
    match(MySQLParser::SUBPARTITION_SYMBOL);
    setState(7498);
    textOrIdentifier();
    setState(7502);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMENT_SYMBOL || _la == MySQLParser::DATA_SYMBOL

    || _la == MySQLParser::ENGINE_SYMBOL || ((((_la - 184) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 184)) & ((1ULL << (MySQLParser::MAX_ROWS_SYMBOL - 184))
      | (1ULL << (MySQLParser::MIN_ROWS_SYMBOL - 184))
      | (1ULL << (MySQLParser::NODEGROUP_SYMBOL - 184)))) != 0) || _la == MySQLParser::STORAGE_SYMBOL

    || _la == MySQLParser::TABLESPACE_SYMBOL || _la == MySQLParser::INDEX_SYMBOL) {
      setState(7499);
      partitionOption();
      setState(7504);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionValueItemListParenContext ------------------------------------------------------------------

MySQLParser::PartitionValueItemListParenContext::PartitionValueItemListParenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::PartitionValueItemListParenContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::PartitionValueItemContext *> MySQLParser::PartitionValueItemListParenContext::partitionValueItem() {
  return getRuleContexts<MySQLParser::PartitionValueItemContext>();
}

MySQLParser::PartitionValueItemContext* MySQLParser::PartitionValueItemListParenContext::partitionValueItem(size_t i) {
  return getRuleContext<MySQLParser::PartitionValueItemContext>(i);
}

tree::TerminalNode* MySQLParser::PartitionValueItemListParenContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::PartitionValueItemListParenContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::PartitionValueItemListParenContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::PartitionValueItemListParenContext::getRuleIndex() const {
  return MySQLParser::RulePartitionValueItemListParen;
}

void MySQLParser::PartitionValueItemListParenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionValueItemListParen(this);
}

void MySQLParser::PartitionValueItemListParenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionValueItemListParen(this);
}


antlrcpp::Any MySQLParser::PartitionValueItemListParenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPartitionValueItemListParen(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PartitionValueItemListParenContext* MySQLParser::partitionValueItemListParen() {
  PartitionValueItemListParenContext *_localctx = _tracker.createInstance<PartitionValueItemListParenContext>(_ctx, getState());
  enterRule(_localctx, 934, MySQLParser::RulePartitionValueItemListParen);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7505);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7506);
    partitionValueItem();
    setState(7511);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(7507);
      match(MySQLParser::COMMA_SYMBOL);
      setState(7508);
      partitionValueItem();
      setState(7513);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(7514);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionValueItemContext ------------------------------------------------------------------

MySQLParser::PartitionValueItemContext::PartitionValueItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::BitExprContext* MySQLParser::PartitionValueItemContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

tree::TerminalNode* MySQLParser::PartitionValueItemContext::MAXVALUE_SYMBOL() {
  return getToken(MySQLParser::MAXVALUE_SYMBOL, 0);
}


size_t MySQLParser::PartitionValueItemContext::getRuleIndex() const {
  return MySQLParser::RulePartitionValueItem;
}

void MySQLParser::PartitionValueItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionValueItem(this);
}

void MySQLParser::PartitionValueItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionValueItem(this);
}


antlrcpp::Any MySQLParser::PartitionValueItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPartitionValueItem(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PartitionValueItemContext* MySQLParser::partitionValueItem() {
  PartitionValueItemContext *_localctx = _tracker.createInstance<PartitionValueItemContext>(_ctx, getState());
  enterRule(_localctx, 936, MySQLParser::RulePartitionValueItem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7518);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1011, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7516);
      bitExpr(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7517);
      match(MySQLParser::MAXVALUE_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefinerClauseContext ------------------------------------------------------------------

MySQLParser::DefinerClauseContext::DefinerClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DefinerClauseContext::DEFINER_SYMBOL() {
  return getToken(MySQLParser::DEFINER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DefinerClauseContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::UserContext* MySQLParser::DefinerClauseContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}


size_t MySQLParser::DefinerClauseContext::getRuleIndex() const {
  return MySQLParser::RuleDefinerClause;
}

void MySQLParser::DefinerClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefinerClause(this);
}

void MySQLParser::DefinerClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefinerClause(this);
}


antlrcpp::Any MySQLParser::DefinerClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDefinerClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DefinerClauseContext* MySQLParser::definerClause() {
  DefinerClauseContext *_localctx = _tracker.createInstance<DefinerClauseContext>(_ctx, getState());
  enterRule(_localctx, 938, MySQLParser::RuleDefinerClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7520);
    match(MySQLParser::DEFINER_SYMBOL);
    setState(7521);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(7522);
    user();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfExistsContext ------------------------------------------------------------------

MySQLParser::IfExistsContext::IfExistsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IfExistsContext::IF_SYMBOL() {
  return getToken(MySQLParser::IF_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IfExistsContext::EXISTS_SYMBOL() {
  return getToken(MySQLParser::EXISTS_SYMBOL, 0);
}


size_t MySQLParser::IfExistsContext::getRuleIndex() const {
  return MySQLParser::RuleIfExists;
}

void MySQLParser::IfExistsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfExists(this);
}

void MySQLParser::IfExistsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfExists(this);
}


antlrcpp::Any MySQLParser::IfExistsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIfExists(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IfExistsContext* MySQLParser::ifExists() {
  IfExistsContext *_localctx = _tracker.createInstance<IfExistsContext>(_ctx, getState());
  enterRule(_localctx, 940, MySQLParser::RuleIfExists);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7524);
    match(MySQLParser::IF_SYMBOL);
    setState(7525);
    match(MySQLParser::EXISTS_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfNotExistsContext ------------------------------------------------------------------

MySQLParser::IfNotExistsContext::IfNotExistsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IfNotExistsContext::IF_SYMBOL() {
  return getToken(MySQLParser::IF_SYMBOL, 0);
}

MySQLParser::NotRuleContext* MySQLParser::IfNotExistsContext::notRule() {
  return getRuleContext<MySQLParser::NotRuleContext>(0);
}

tree::TerminalNode* MySQLParser::IfNotExistsContext::EXISTS_SYMBOL() {
  return getToken(MySQLParser::EXISTS_SYMBOL, 0);
}


size_t MySQLParser::IfNotExistsContext::getRuleIndex() const {
  return MySQLParser::RuleIfNotExists;
}

void MySQLParser::IfNotExistsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfNotExists(this);
}

void MySQLParser::IfNotExistsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfNotExists(this);
}


antlrcpp::Any MySQLParser::IfNotExistsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIfNotExists(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IfNotExistsContext* MySQLParser::ifNotExists() {
  IfNotExistsContext *_localctx = _tracker.createInstance<IfNotExistsContext>(_ctx, getState());
  enterRule(_localctx, 942, MySQLParser::RuleIfNotExists);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7527);
    match(MySQLParser::IF_SYMBOL);
    setState(7528);
    notRule();
    setState(7529);
    match(MySQLParser::EXISTS_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureParameterContext ------------------------------------------------------------------

MySQLParser::ProcedureParameterContext::ProcedureParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::FunctionParameterContext* MySQLParser::ProcedureParameterContext::functionParameter() {
  return getRuleContext<MySQLParser::FunctionParameterContext>(0);
}

tree::TerminalNode* MySQLParser::ProcedureParameterContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProcedureParameterContext::OUT_SYMBOL() {
  return getToken(MySQLParser::OUT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProcedureParameterContext::INOUT_SYMBOL() {
  return getToken(MySQLParser::INOUT_SYMBOL, 0);
}


size_t MySQLParser::ProcedureParameterContext::getRuleIndex() const {
  return MySQLParser::RuleProcedureParameter;
}

void MySQLParser::ProcedureParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureParameter(this);
}

void MySQLParser::ProcedureParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureParameter(this);
}


antlrcpp::Any MySQLParser::ProcedureParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitProcedureParameter(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ProcedureParameterContext* MySQLParser::procedureParameter() {
  ProcedureParameterContext *_localctx = _tracker.createInstance<ProcedureParameterContext>(_ctx, getState());
  enterRule(_localctx, 944, MySQLParser::RuleProcedureParameter);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7532);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1012, _ctx)) {
    case 1: {
      setState(7531);
      dynamic_cast<ProcedureParameterContext *>(_localctx)->type = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::INOUT_SYMBOL

      || _la == MySQLParser::IN_SYMBOL || _la == MySQLParser::OUT_SYMBOL)) {
        dynamic_cast<ProcedureParameterContext *>(_localctx)->type = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
    setState(7534);
    functionParameter();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionParameterContext ------------------------------------------------------------------

MySQLParser::FunctionParameterContext::FunctionParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ParameterNameContext* MySQLParser::FunctionParameterContext::parameterName() {
  return getRuleContext<MySQLParser::ParameterNameContext>(0);
}

MySQLParser::TypeWithOptCollateContext* MySQLParser::FunctionParameterContext::typeWithOptCollate() {
  return getRuleContext<MySQLParser::TypeWithOptCollateContext>(0);
}


size_t MySQLParser::FunctionParameterContext::getRuleIndex() const {
  return MySQLParser::RuleFunctionParameter;
}

void MySQLParser::FunctionParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionParameter(this);
}

void MySQLParser::FunctionParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionParameter(this);
}


antlrcpp::Any MySQLParser::FunctionParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFunctionParameter(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FunctionParameterContext* MySQLParser::functionParameter() {
  FunctionParameterContext *_localctx = _tracker.createInstance<FunctionParameterContext>(_ctx, getState());
  enterRule(_localctx, 946, MySQLParser::RuleFunctionParameter);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7536);
    parameterName();
    setState(7537);
    typeWithOptCollate();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CollateContext ------------------------------------------------------------------

MySQLParser::CollateContext::CollateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CollateContext::COLLATE_SYMBOL() {
  return getToken(MySQLParser::COLLATE_SYMBOL, 0);
}

MySQLParser::CollationNameContext* MySQLParser::CollateContext::collationName() {
  return getRuleContext<MySQLParser::CollationNameContext>(0);
}


size_t MySQLParser::CollateContext::getRuleIndex() const {
  return MySQLParser::RuleCollate;
}

void MySQLParser::CollateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCollate(this);
}

void MySQLParser::CollateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCollate(this);
}


antlrcpp::Any MySQLParser::CollateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCollate(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CollateContext* MySQLParser::collate() {
  CollateContext *_localctx = _tracker.createInstance<CollateContext>(_ctx, getState());
  enterRule(_localctx, 948, MySQLParser::RuleCollate);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7539);
    match(MySQLParser::COLLATE_SYMBOL);
    setState(7540);
    collationName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeWithOptCollateContext ------------------------------------------------------------------

MySQLParser::TypeWithOptCollateContext::TypeWithOptCollateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::DataTypeContext* MySQLParser::TypeWithOptCollateContext::dataType() {
  return getRuleContext<MySQLParser::DataTypeContext>(0);
}

MySQLParser::CollateContext* MySQLParser::TypeWithOptCollateContext::collate() {
  return getRuleContext<MySQLParser::CollateContext>(0);
}


size_t MySQLParser::TypeWithOptCollateContext::getRuleIndex() const {
  return MySQLParser::RuleTypeWithOptCollate;
}

void MySQLParser::TypeWithOptCollateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeWithOptCollate(this);
}

void MySQLParser::TypeWithOptCollateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeWithOptCollate(this);
}


antlrcpp::Any MySQLParser::TypeWithOptCollateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTypeWithOptCollate(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TypeWithOptCollateContext* MySQLParser::typeWithOptCollate() {
  TypeWithOptCollateContext *_localctx = _tracker.createInstance<TypeWithOptCollateContext>(_ctx, getState());
  enterRule(_localctx, 950, MySQLParser::RuleTypeWithOptCollate);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7542);
    dataType();
    setState(7544);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1013, _ctx)) {
    case 1: {
      setState(7543);
      collate();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SchemaIdentifierPairContext ------------------------------------------------------------------

MySQLParser::SchemaIdentifierPairContext::SchemaIdentifierPairContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SchemaIdentifierPairContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::SchemaRefContext *> MySQLParser::SchemaIdentifierPairContext::schemaRef() {
  return getRuleContexts<MySQLParser::SchemaRefContext>();
}

MySQLParser::SchemaRefContext* MySQLParser::SchemaIdentifierPairContext::schemaRef(size_t i) {
  return getRuleContext<MySQLParser::SchemaRefContext>(i);
}

tree::TerminalNode* MySQLParser::SchemaIdentifierPairContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SchemaIdentifierPairContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::SchemaIdentifierPairContext::getRuleIndex() const {
  return MySQLParser::RuleSchemaIdentifierPair;
}

void MySQLParser::SchemaIdentifierPairContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchemaIdentifierPair(this);
}

void MySQLParser::SchemaIdentifierPairContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchemaIdentifierPair(this);
}


antlrcpp::Any MySQLParser::SchemaIdentifierPairContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSchemaIdentifierPair(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SchemaIdentifierPairContext* MySQLParser::schemaIdentifierPair() {
  SchemaIdentifierPairContext *_localctx = _tracker.createInstance<SchemaIdentifierPairContext>(_ctx, getState());
  enterRule(_localctx, 952, MySQLParser::RuleSchemaIdentifierPair);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7546);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7547);
    schemaRef();
    setState(7548);
    match(MySQLParser::COMMA_SYMBOL);
    setState(7549);
    schemaRef();
    setState(7550);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewRefListContext ------------------------------------------------------------------

MySQLParser::ViewRefListContext::ViewRefListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::ViewRefContext *> MySQLParser::ViewRefListContext::viewRef() {
  return getRuleContexts<MySQLParser::ViewRefContext>();
}

MySQLParser::ViewRefContext* MySQLParser::ViewRefListContext::viewRef(size_t i) {
  return getRuleContext<MySQLParser::ViewRefContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ViewRefListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ViewRefListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ViewRefListContext::getRuleIndex() const {
  return MySQLParser::RuleViewRefList;
}

void MySQLParser::ViewRefListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewRefList(this);
}

void MySQLParser::ViewRefListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewRefList(this);
}


antlrcpp::Any MySQLParser::ViewRefListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitViewRefList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ViewRefListContext* MySQLParser::viewRefList() {
  ViewRefListContext *_localctx = _tracker.createInstance<ViewRefListContext>(_ctx, getState());
  enterRule(_localctx, 954, MySQLParser::RuleViewRefList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7552);
    viewRef();
    setState(7557);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(7553);
      match(MySQLParser::COMMA_SYMBOL);
      setState(7554);
      viewRef();
      setState(7559);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UpdateListContext ------------------------------------------------------------------

MySQLParser::UpdateListContext::UpdateListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::UpdateElementContext *> MySQLParser::UpdateListContext::updateElement() {
  return getRuleContexts<MySQLParser::UpdateElementContext>();
}

MySQLParser::UpdateElementContext* MySQLParser::UpdateListContext::updateElement(size_t i) {
  return getRuleContext<MySQLParser::UpdateElementContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::UpdateListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::UpdateListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::UpdateListContext::getRuleIndex() const {
  return MySQLParser::RuleUpdateList;
}

void MySQLParser::UpdateListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdateList(this);
}

void MySQLParser::UpdateListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdateList(this);
}


antlrcpp::Any MySQLParser::UpdateListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitUpdateList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UpdateListContext* MySQLParser::updateList() {
  UpdateListContext *_localctx = _tracker.createInstance<UpdateListContext>(_ctx, getState());
  enterRule(_localctx, 956, MySQLParser::RuleUpdateList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7560);
    updateElement();
    setState(7565);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(7561);
      match(MySQLParser::COMMA_SYMBOL);
      setState(7562);
      updateElement();
      setState(7567);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UpdateElementContext ------------------------------------------------------------------

MySQLParser::UpdateElementContext::UpdateElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ColumnRefContext* MySQLParser::UpdateElementContext::columnRef() {
  return getRuleContext<MySQLParser::ColumnRefContext>(0);
}

tree::TerminalNode* MySQLParser::UpdateElementContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::ExprContext* MySQLParser::UpdateElementContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::UpdateElementContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}


size_t MySQLParser::UpdateElementContext::getRuleIndex() const {
  return MySQLParser::RuleUpdateElement;
}

void MySQLParser::UpdateElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdateElement(this);
}

void MySQLParser::UpdateElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdateElement(this);
}


antlrcpp::Any MySQLParser::UpdateElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitUpdateElement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UpdateElementContext* MySQLParser::updateElement() {
  UpdateElementContext *_localctx = _tracker.createInstance<UpdateElementContext>(_ctx, getState());
  enterRule(_localctx, 958, MySQLParser::RuleUpdateElement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7568);
    columnRef();
    setState(7569);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(7572);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1016, _ctx)) {
    case 1: {
      setState(7570);
      expr(0);
      break;
    }

    case 2: {
      setState(7571);
      match(MySQLParser::DEFAULT_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharsetClauseContext ------------------------------------------------------------------

MySQLParser::CharsetClauseContext::CharsetClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CharsetContext* MySQLParser::CharsetClauseContext::charset() {
  return getRuleContext<MySQLParser::CharsetContext>(0);
}

MySQLParser::CharsetNameContext* MySQLParser::CharsetClauseContext::charsetName() {
  return getRuleContext<MySQLParser::CharsetNameContext>(0);
}


size_t MySQLParser::CharsetClauseContext::getRuleIndex() const {
  return MySQLParser::RuleCharsetClause;
}

void MySQLParser::CharsetClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharsetClause(this);
}

void MySQLParser::CharsetClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharsetClause(this);
}


antlrcpp::Any MySQLParser::CharsetClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCharsetClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CharsetClauseContext* MySQLParser::charsetClause() {
  CharsetClauseContext *_localctx = _tracker.createInstance<CharsetClauseContext>(_ctx, getState());
  enterRule(_localctx, 960, MySQLParser::RuleCharsetClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7574);
    charset();
    setState(7575);
    charsetName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldsClauseContext ------------------------------------------------------------------

MySQLParser::FieldsClauseContext::FieldsClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::FieldsClauseContext::COLUMNS_SYMBOL() {
  return getToken(MySQLParser::COLUMNS_SYMBOL, 0);
}

std::vector<MySQLParser::FieldTermContext *> MySQLParser::FieldsClauseContext::fieldTerm() {
  return getRuleContexts<MySQLParser::FieldTermContext>();
}

MySQLParser::FieldTermContext* MySQLParser::FieldsClauseContext::fieldTerm(size_t i) {
  return getRuleContext<MySQLParser::FieldTermContext>(i);
}


size_t MySQLParser::FieldsClauseContext::getRuleIndex() const {
  return MySQLParser::RuleFieldsClause;
}

void MySQLParser::FieldsClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldsClause(this);
}

void MySQLParser::FieldsClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldsClause(this);
}


antlrcpp::Any MySQLParser::FieldsClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFieldsClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FieldsClauseContext* MySQLParser::fieldsClause() {
  FieldsClauseContext *_localctx = _tracker.createInstance<FieldsClauseContext>(_ctx, getState());
  enterRule(_localctx, 962, MySQLParser::RuleFieldsClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7577);
    match(MySQLParser::COLUMNS_SYMBOL);
    setState(7579); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(7578);
              fieldTerm();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(7581); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1017, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldTermContext ------------------------------------------------------------------

MySQLParser::FieldTermContext::FieldTermContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::FieldTermContext::TERMINATED_SYMBOL() {
  return getToken(MySQLParser::TERMINATED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FieldTermContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::FieldTermContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode* MySQLParser::FieldTermContext::ENCLOSED_SYMBOL() {
  return getToken(MySQLParser::ENCLOSED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FieldTermContext::OPTIONALLY_SYMBOL() {
  return getToken(MySQLParser::OPTIONALLY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FieldTermContext::ESCAPED_SYMBOL() {
  return getToken(MySQLParser::ESCAPED_SYMBOL, 0);
}


size_t MySQLParser::FieldTermContext::getRuleIndex() const {
  return MySQLParser::RuleFieldTerm;
}

void MySQLParser::FieldTermContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldTerm(this);
}

void MySQLParser::FieldTermContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldTerm(this);
}


antlrcpp::Any MySQLParser::FieldTermContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFieldTerm(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FieldTermContext* MySQLParser::fieldTerm() {
  FieldTermContext *_localctx = _tracker.createInstance<FieldTermContext>(_ctx, getState());
  enterRule(_localctx, 964, MySQLParser::RuleFieldTerm);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7595);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::TERMINATED_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7583);
        match(MySQLParser::TERMINATED_SYMBOL);
        setState(7584);
        match(MySQLParser::BY_SYMBOL);
        setState(7585);
        textString();
        break;
      }

      case MySQLParser::ENCLOSED_SYMBOL:
      case MySQLParser::OPTIONALLY_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7587);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::OPTIONALLY_SYMBOL) {
          setState(7586);
          match(MySQLParser::OPTIONALLY_SYMBOL);
        }
        setState(7589);
        match(MySQLParser::ENCLOSED_SYMBOL);
        setState(7590);
        match(MySQLParser::BY_SYMBOL);
        setState(7591);
        textString();
        break;
      }

      case MySQLParser::ESCAPED_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(7592);
        match(MySQLParser::ESCAPED_SYMBOL);
        setState(7593);
        match(MySQLParser::BY_SYMBOL);
        setState(7594);
        textString();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LinesClauseContext ------------------------------------------------------------------

MySQLParser::LinesClauseContext::LinesClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LinesClauseContext::LINES_SYMBOL() {
  return getToken(MySQLParser::LINES_SYMBOL, 0);
}

std::vector<MySQLParser::LineTermContext *> MySQLParser::LinesClauseContext::lineTerm() {
  return getRuleContexts<MySQLParser::LineTermContext>();
}

MySQLParser::LineTermContext* MySQLParser::LinesClauseContext::lineTerm(size_t i) {
  return getRuleContext<MySQLParser::LineTermContext>(i);
}


size_t MySQLParser::LinesClauseContext::getRuleIndex() const {
  return MySQLParser::RuleLinesClause;
}

void MySQLParser::LinesClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLinesClause(this);
}

void MySQLParser::LinesClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLinesClause(this);
}


antlrcpp::Any MySQLParser::LinesClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLinesClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LinesClauseContext* MySQLParser::linesClause() {
  LinesClauseContext *_localctx = _tracker.createInstance<LinesClauseContext>(_ctx, getState());
  enterRule(_localctx, 966, MySQLParser::RuleLinesClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7597);
    match(MySQLParser::LINES_SYMBOL);
    setState(7599); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(7598);
              lineTerm();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(7601); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1020, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LineTermContext ------------------------------------------------------------------

MySQLParser::LineTermContext::LineTermContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LineTermContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::LineTermContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode* MySQLParser::LineTermContext::TERMINATED_SYMBOL() {
  return getToken(MySQLParser::TERMINATED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LineTermContext::STARTING_SYMBOL() {
  return getToken(MySQLParser::STARTING_SYMBOL, 0);
}


size_t MySQLParser::LineTermContext::getRuleIndex() const {
  return MySQLParser::RuleLineTerm;
}

void MySQLParser::LineTermContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLineTerm(this);
}

void MySQLParser::LineTermContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLineTerm(this);
}


antlrcpp::Any MySQLParser::LineTermContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLineTerm(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LineTermContext* MySQLParser::lineTerm() {
  LineTermContext *_localctx = _tracker.createInstance<LineTermContext>(_ctx, getState());
  enterRule(_localctx, 968, MySQLParser::RuleLineTerm);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7603);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::STARTING_SYMBOL

    || _la == MySQLParser::TERMINATED_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(7604);
    match(MySQLParser::BY_SYMBOL);
    setState(7605);
    textString();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserListContext ------------------------------------------------------------------

MySQLParser::UserListContext::UserListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::UserContext *> MySQLParser::UserListContext::user() {
  return getRuleContexts<MySQLParser::UserContext>();
}

MySQLParser::UserContext* MySQLParser::UserListContext::user(size_t i) {
  return getRuleContext<MySQLParser::UserContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::UserListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::UserListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::UserListContext::getRuleIndex() const {
  return MySQLParser::RuleUserList;
}

void MySQLParser::UserListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserList(this);
}

void MySQLParser::UserListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserList(this);
}


antlrcpp::Any MySQLParser::UserListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitUserList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UserListContext* MySQLParser::userList() {
  UserListContext *_localctx = _tracker.createInstance<UserListContext>(_ctx, getState());
  enterRule(_localctx, 970, MySQLParser::RuleUserList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7607);
    user();
    setState(7612);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1021, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(7608);
        match(MySQLParser::COMMA_SYMBOL);
        setState(7609);
        user(); 
      }
      setState(7614);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1021, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUserListContext ------------------------------------------------------------------

MySQLParser::CreateUserListContext::CreateUserListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::CreateUserEntryContext *> MySQLParser::CreateUserListContext::createUserEntry() {
  return getRuleContexts<MySQLParser::CreateUserEntryContext>();
}

MySQLParser::CreateUserEntryContext* MySQLParser::CreateUserListContext::createUserEntry(size_t i) {
  return getRuleContext<MySQLParser::CreateUserEntryContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::CreateUserListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::CreateUserListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::CreateUserListContext::getRuleIndex() const {
  return MySQLParser::RuleCreateUserList;
}

void MySQLParser::CreateUserListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUserList(this);
}

void MySQLParser::CreateUserListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUserList(this);
}


antlrcpp::Any MySQLParser::CreateUserListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateUserList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateUserListContext* MySQLParser::createUserList() {
  CreateUserListContext *_localctx = _tracker.createInstance<CreateUserListContext>(_ctx, getState());
  enterRule(_localctx, 972, MySQLParser::RuleCreateUserList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7615);
    createUserEntry();
    setState(7620);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1022, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(7616);
        match(MySQLParser::COMMA_SYMBOL);
        setState(7617);
        createUserEntry(); 
      }
      setState(7622);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1022, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterUserListContext ------------------------------------------------------------------

MySQLParser::AlterUserListContext::AlterUserListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::AlterUserEntryContext *> MySQLParser::AlterUserListContext::alterUserEntry() {
  return getRuleContexts<MySQLParser::AlterUserEntryContext>();
}

MySQLParser::AlterUserEntryContext* MySQLParser::AlterUserListContext::alterUserEntry(size_t i) {
  return getRuleContext<MySQLParser::AlterUserEntryContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterUserListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::AlterUserListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::AlterUserListContext::getRuleIndex() const {
  return MySQLParser::RuleAlterUserList;
}

void MySQLParser::AlterUserListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterUserList(this);
}

void MySQLParser::AlterUserListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterUserList(this);
}


antlrcpp::Any MySQLParser::AlterUserListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterUserList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterUserListContext* MySQLParser::alterUserList() {
  AlterUserListContext *_localctx = _tracker.createInstance<AlterUserListContext>(_ctx, getState());
  enterRule(_localctx, 974, MySQLParser::RuleAlterUserList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7623);
    alterUserEntry();
    setState(7628);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1023, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(7624);
        match(MySQLParser::COMMA_SYMBOL);
        setState(7625);
        alterUserEntry(); 
      }
      setState(7630);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1023, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUserEntryContext ------------------------------------------------------------------

MySQLParser::CreateUserEntryContext::CreateUserEntryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::UserContext* MySQLParser::CreateUserEntryContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

tree::TerminalNode* MySQLParser::CreateUserEntryContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateUserEntryContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::CreateUserEntryContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode* MySQLParser::CreateUserEntryContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::CreateUserEntryContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::CreateUserEntryContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateUserEntryContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::CreateUserEntryContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}


size_t MySQLParser::CreateUserEntryContext::getRuleIndex() const {
  return MySQLParser::RuleCreateUserEntry;
}

void MySQLParser::CreateUserEntryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUserEntry(this);
}

void MySQLParser::CreateUserEntryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUserEntry(this);
}


antlrcpp::Any MySQLParser::CreateUserEntryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateUserEntry(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateUserEntryContext* MySQLParser::createUserEntry() {
  CreateUserEntryContext *_localctx = _tracker.createInstance<CreateUserEntryContext>(_ctx, getState());
  enterRule(_localctx, 976, MySQLParser::RuleCreateUserEntry);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7631);
    user();
    setState(7653);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1028, _ctx)) {
    case 1: {
      setState(7632);
      match(MySQLParser::IDENTIFIED_SYMBOL);
      setState(7651);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1027, _ctx)) {
      case 1: {
        setState(7633);
        match(MySQLParser::BY_SYMBOL);
        setState(7636);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1024, _ctx)) {
        case 1: {
          setState(7634);

          if (!(serverVersion < 80011)) throw FailedPredicateException(this, "serverVersion < 80011");
          setState(7635);
          match(MySQLParser::PASSWORD_SYMBOL);
          break;
        }

        }
        setState(7638);
        textString();
        break;
      }

      case 2: {
        setState(7639);

        if (!(serverVersion >= 50600)) throw FailedPredicateException(this, "serverVersion >= 50600");
        setState(7640);
        match(MySQLParser::WITH_SYMBOL);
        setState(7641);
        textOrIdentifier();
        setState(7649);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1026, _ctx)) {
        case 1: {
          setState(7647);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1025, _ctx)) {
          case 1: {
            setState(7642);
            match(MySQLParser::AS_SYMBOL);
            setState(7643);
            textStringLiteral();
            break;
          }

          case 2: {
            setState(7644);

            if (!(serverVersion >= 50706)) throw FailedPredicateException(this, "serverVersion >= 50706");
            setState(7645);
            match(MySQLParser::BY_SYMBOL);
            setState(7646);
            textString();
            break;
          }

          }
          break;
        }

        }
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterUserEntryContext ------------------------------------------------------------------

MySQLParser::AlterUserEntryContext::AlterUserEntryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::UserContext* MySQLParser::AlterUserEntryContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

tree::TerminalNode* MySQLParser::AlterUserEntryContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

MySQLParser::DiscardOldPasswordContext* MySQLParser::AlterUserEntryContext::discardOldPassword() {
  return getRuleContext<MySQLParser::DiscardOldPasswordContext>(0);
}

tree::TerminalNode* MySQLParser::AlterUserEntryContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

std::vector<MySQLParser::TextStringContext *> MySQLParser::AlterUserEntryContext::textString() {
  return getRuleContexts<MySQLParser::TextStringContext>();
}

MySQLParser::TextStringContext* MySQLParser::AlterUserEntryContext::textString(size_t i) {
  return getRuleContext<MySQLParser::TextStringContext>(i);
}

tree::TerminalNode* MySQLParser::AlterUserEntryContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::AlterUserEntryContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::AlterUserEntryContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

MySQLParser::RetainCurrentPasswordContext* MySQLParser::AlterUserEntryContext::retainCurrentPassword() {
  return getRuleContext<MySQLParser::RetainCurrentPasswordContext>(0);
}

tree::TerminalNode* MySQLParser::AlterUserEntryContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::AlterUserEntryContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}


size_t MySQLParser::AlterUserEntryContext::getRuleIndex() const {
  return MySQLParser::RuleAlterUserEntry;
}

void MySQLParser::AlterUserEntryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterUserEntry(this);
}

void MySQLParser::AlterUserEntryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterUserEntry(this);
}


antlrcpp::Any MySQLParser::AlterUserEntryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterUserEntry(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterUserEntryContext* MySQLParser::alterUserEntry() {
  AlterUserEntryContext *_localctx = _tracker.createInstance<AlterUserEntryContext>(_ctx, getState());
  enterRule(_localctx, 978, MySQLParser::RuleAlterUserEntry);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7655);
    user();
    setState(7682);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::IDENTIFIED_SYMBOL: {
        setState(7656);
        match(MySQLParser::IDENTIFIED_SYMBOL);
        setState(7679);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1034, _ctx)) {
        case 1: {
          setState(7659);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLParser::WITH_SYMBOL) {
            setState(7657);
            match(MySQLParser::WITH_SYMBOL);
            setState(7658);
            textOrIdentifier();
          }
          setState(7661);
          match(MySQLParser::BY_SYMBOL);
          setState(7662);
          textString();
          setState(7665);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1030, _ctx)) {
          case 1: {
            setState(7663);
            match(MySQLParser::REPLACE_SYMBOL);
            setState(7664);
            textString();
            break;
          }

          }
          setState(7668);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1031, _ctx)) {
          case 1: {
            setState(7667);
            retainCurrentPassword();
            break;
          }

          }
          break;
        }

        case 2: {
          setState(7670);
          match(MySQLParser::WITH_SYMBOL);
          setState(7671);
          textOrIdentifier();
          setState(7677);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1033, _ctx)) {
          case 1: {
            setState(7672);
            match(MySQLParser::AS_SYMBOL);
            setState(7673);
            textStringLiteral();
            setState(7675);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1032, _ctx)) {
            case 1: {
              setState(7674);
              retainCurrentPassword();
              break;
            }

            }
            break;
          }

          }
          break;
        }

        }
        break;
      }

      case MySQLParser::DISCARD_SYMBOL: {
        setState(7681);
        discardOldPassword();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RetainCurrentPasswordContext ------------------------------------------------------------------

MySQLParser::RetainCurrentPasswordContext::RetainCurrentPasswordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RetainCurrentPasswordContext::RETAIN_SYMBOL() {
  return getToken(MySQLParser::RETAIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RetainCurrentPasswordContext::CURRENT_SYMBOL() {
  return getToken(MySQLParser::CURRENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RetainCurrentPasswordContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}


size_t MySQLParser::RetainCurrentPasswordContext::getRuleIndex() const {
  return MySQLParser::RuleRetainCurrentPassword;
}

void MySQLParser::RetainCurrentPasswordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRetainCurrentPassword(this);
}

void MySQLParser::RetainCurrentPasswordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRetainCurrentPassword(this);
}


antlrcpp::Any MySQLParser::RetainCurrentPasswordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRetainCurrentPassword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RetainCurrentPasswordContext* MySQLParser::retainCurrentPassword() {
  RetainCurrentPasswordContext *_localctx = _tracker.createInstance<RetainCurrentPasswordContext>(_ctx, getState());
  enterRule(_localctx, 980, MySQLParser::RuleRetainCurrentPassword);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7684);
    match(MySQLParser::RETAIN_SYMBOL);
    setState(7685);
    match(MySQLParser::CURRENT_SYMBOL);
    setState(7686);
    match(MySQLParser::PASSWORD_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DiscardOldPasswordContext ------------------------------------------------------------------

MySQLParser::DiscardOldPasswordContext::DiscardOldPasswordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DiscardOldPasswordContext::DISCARD_SYMBOL() {
  return getToken(MySQLParser::DISCARD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DiscardOldPasswordContext::OLD_SYMBOL() {
  return getToken(MySQLParser::OLD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DiscardOldPasswordContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}


size_t MySQLParser::DiscardOldPasswordContext::getRuleIndex() const {
  return MySQLParser::RuleDiscardOldPassword;
}

void MySQLParser::DiscardOldPasswordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDiscardOldPassword(this);
}

void MySQLParser::DiscardOldPasswordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDiscardOldPassword(this);
}


antlrcpp::Any MySQLParser::DiscardOldPasswordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDiscardOldPassword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DiscardOldPasswordContext* MySQLParser::discardOldPassword() {
  DiscardOldPasswordContext *_localctx = _tracker.createInstance<DiscardOldPasswordContext>(_ctx, getState());
  enterRule(_localctx, 982, MySQLParser::RuleDiscardOldPassword);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7688);
    match(MySQLParser::DISCARD_SYMBOL);
    setState(7689);
    match(MySQLParser::OLD_SYMBOL);
    setState(7690);
    match(MySQLParser::PASSWORD_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplacePasswordContext ------------------------------------------------------------------

MySQLParser::ReplacePasswordContext::ReplacePasswordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ReplacePasswordContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::ReplacePasswordContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}


size_t MySQLParser::ReplacePasswordContext::getRuleIndex() const {
  return MySQLParser::RuleReplacePassword;
}

void MySQLParser::ReplacePasswordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplacePassword(this);
}

void MySQLParser::ReplacePasswordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplacePassword(this);
}


antlrcpp::Any MySQLParser::ReplacePasswordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitReplacePassword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ReplacePasswordContext* MySQLParser::replacePassword() {
  ReplacePasswordContext *_localctx = _tracker.createInstance<ReplacePasswordContext>(_ctx, getState());
  enterRule(_localctx, 984, MySQLParser::RuleReplacePassword);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7692);
    match(MySQLParser::REPLACE_SYMBOL);
    setState(7693);
    textString();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserContext ------------------------------------------------------------------

MySQLParser::UserContext::UserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TextOrIdentifierContext *> MySQLParser::UserContext::textOrIdentifier() {
  return getRuleContexts<MySQLParser::TextOrIdentifierContext>();
}

MySQLParser::TextOrIdentifierContext* MySQLParser::UserContext::textOrIdentifier(size_t i) {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(i);
}

tree::TerminalNode* MySQLParser::UserContext::AT_SIGN_SYMBOL() {
  return getToken(MySQLParser::AT_SIGN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::UserContext::AT_TEXT_SUFFIX() {
  return getToken(MySQLParser::AT_TEXT_SUFFIX, 0);
}

tree::TerminalNode* MySQLParser::UserContext::CURRENT_USER_SYMBOL() {
  return getToken(MySQLParser::CURRENT_USER_SYMBOL, 0);
}

MySQLParser::ParenthesesContext* MySQLParser::UserContext::parentheses() {
  return getRuleContext<MySQLParser::ParenthesesContext>(0);
}


size_t MySQLParser::UserContext::getRuleIndex() const {
  return MySQLParser::RuleUser;
}

void MySQLParser::UserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUser(this);
}

void MySQLParser::UserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUser(this);
}


antlrcpp::Any MySQLParser::UserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitUser(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UserContext* MySQLParser::user() {
  UserContext *_localctx = _tracker.createInstance<UserContext>(_ctx, getState());
  enterRule(_localctx, 986, MySQLParser::RuleUser);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7705);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1038, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7695);
      textOrIdentifier();
      setState(7699);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1036, _ctx)) {
      case 1: {
        setState(7696);
        match(MySQLParser::AT_SIGN_SYMBOL);
        setState(7697);
        textOrIdentifier();
        break;
      }

      case 2: {
        setState(7698);
        match(MySQLParser::AT_TEXT_SUFFIX);
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7701);
      match(MySQLParser::CURRENT_USER_SYMBOL);
      setState(7703);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1037, _ctx)) {
      case 1: {
        setState(7702);
        parentheses();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LikeClauseContext ------------------------------------------------------------------

MySQLParser::LikeClauseContext::LikeClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LikeClauseContext::LIKE_SYMBOL() {
  return getToken(MySQLParser::LIKE_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::LikeClauseContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}


size_t MySQLParser::LikeClauseContext::getRuleIndex() const {
  return MySQLParser::RuleLikeClause;
}

void MySQLParser::LikeClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLikeClause(this);
}

void MySQLParser::LikeClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLikeClause(this);
}


antlrcpp::Any MySQLParser::LikeClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLikeClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LikeClauseContext* MySQLParser::likeClause() {
  LikeClauseContext *_localctx = _tracker.createInstance<LikeClauseContext>(_ctx, getState());
  enterRule(_localctx, 988, MySQLParser::RuleLikeClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7707);
    match(MySQLParser::LIKE_SYMBOL);
    setState(7708);
    textStringLiteral();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LikeOrWhereContext ------------------------------------------------------------------

MySQLParser::LikeOrWhereContext::LikeOrWhereContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LikeClauseContext* MySQLParser::LikeOrWhereContext::likeClause() {
  return getRuleContext<MySQLParser::LikeClauseContext>(0);
}

MySQLParser::WhereClauseContext* MySQLParser::LikeOrWhereContext::whereClause() {
  return getRuleContext<MySQLParser::WhereClauseContext>(0);
}


size_t MySQLParser::LikeOrWhereContext::getRuleIndex() const {
  return MySQLParser::RuleLikeOrWhere;
}

void MySQLParser::LikeOrWhereContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLikeOrWhere(this);
}

void MySQLParser::LikeOrWhereContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLikeOrWhere(this);
}


antlrcpp::Any MySQLParser::LikeOrWhereContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLikeOrWhere(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LikeOrWhereContext* MySQLParser::likeOrWhere() {
  LikeOrWhereContext *_localctx = _tracker.createInstance<LikeOrWhereContext>(_ctx, getState());
  enterRule(_localctx, 990, MySQLParser::RuleLikeOrWhere);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7712);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::LIKE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7710);
        likeClause();
        break;
      }

      case MySQLParser::WHERE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7711);
        whereClause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnlineOptionContext ------------------------------------------------------------------

MySQLParser::OnlineOptionContext::OnlineOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::OnlineOptionContext::ONLINE_SYMBOL() {
  return getToken(MySQLParser::ONLINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OnlineOptionContext::OFFLINE_SYMBOL() {
  return getToken(MySQLParser::OFFLINE_SYMBOL, 0);
}


size_t MySQLParser::OnlineOptionContext::getRuleIndex() const {
  return MySQLParser::RuleOnlineOption;
}

void MySQLParser::OnlineOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnlineOption(this);
}

void MySQLParser::OnlineOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnlineOption(this);
}


antlrcpp::Any MySQLParser::OnlineOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitOnlineOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OnlineOptionContext* MySQLParser::onlineOption() {
  OnlineOptionContext *_localctx = _tracker.createInstance<OnlineOptionContext>(_ctx, getState());
  enterRule(_localctx, 992, MySQLParser::RuleOnlineOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7714);

    if (!(serverVersion < 50600)) throw FailedPredicateException(this, "serverVersion < 50600");
    setState(7715);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::OFFLINE_SYMBOL

    || _la == MySQLParser::ONLINE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NoWriteToBinLogContext ------------------------------------------------------------------

MySQLParser::NoWriteToBinLogContext::NoWriteToBinLogContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::NoWriteToBinLogContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NoWriteToBinLogContext::NO_WRITE_TO_BINLOG_SYMBOL() {
  return getToken(MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL, 0);
}


size_t MySQLParser::NoWriteToBinLogContext::getRuleIndex() const {
  return MySQLParser::RuleNoWriteToBinLog;
}

void MySQLParser::NoWriteToBinLogContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNoWriteToBinLog(this);
}

void MySQLParser::NoWriteToBinLogContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNoWriteToBinLog(this);
}


antlrcpp::Any MySQLParser::NoWriteToBinLogContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitNoWriteToBinLog(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::NoWriteToBinLogContext* MySQLParser::noWriteToBinLog() {
  NoWriteToBinLogContext *_localctx = _tracker.createInstance<NoWriteToBinLogContext>(_ctx, getState());
  enterRule(_localctx, 994, MySQLParser::RuleNoWriteToBinLog);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7717);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UsePartitionContext ------------------------------------------------------------------

MySQLParser::UsePartitionContext::UsePartitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::UsePartitionContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

MySQLParser::IdentifierListWithParenthesesContext* MySQLParser::UsePartitionContext::identifierListWithParentheses() {
  return getRuleContext<MySQLParser::IdentifierListWithParenthesesContext>(0);
}


size_t MySQLParser::UsePartitionContext::getRuleIndex() const {
  return MySQLParser::RuleUsePartition;
}

void MySQLParser::UsePartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUsePartition(this);
}

void MySQLParser::UsePartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUsePartition(this);
}


antlrcpp::Any MySQLParser::UsePartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitUsePartition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UsePartitionContext* MySQLParser::usePartition() {
  UsePartitionContext *_localctx = _tracker.createInstance<UsePartitionContext>(_ctx, getState());
  enterRule(_localctx, 996, MySQLParser::RuleUsePartition);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7719);

    if (!(serverVersion >= 50602)) throw FailedPredicateException(this, "serverVersion >= 50602");
    setState(7720);
    match(MySQLParser::PARTITION_SYMBOL);
    setState(7721);
    identifierListWithParentheses();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldIdentifierContext ------------------------------------------------------------------

MySQLParser::FieldIdentifierContext::FieldIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::DotIdentifierContext* MySQLParser::FieldIdentifierContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::FieldIdentifierContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}


size_t MySQLParser::FieldIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleFieldIdentifier;
}

void MySQLParser::FieldIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldIdentifier(this);
}

void MySQLParser::FieldIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldIdentifier(this);
}


antlrcpp::Any MySQLParser::FieldIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFieldIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FieldIdentifierContext* MySQLParser::fieldIdentifier() {
  FieldIdentifierContext *_localctx = _tracker.createInstance<FieldIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 998, MySQLParser::RuleFieldIdentifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7728);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1041, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7723);
      dotIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7724);
      qualifiedIdentifier();
      setState(7726);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1040, _ctx)) {
      case 1: {
        setState(7725);
        dotIdentifier();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnNameContext ------------------------------------------------------------------

MySQLParser::ColumnNameContext::ColumnNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::ColumnNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::FieldIdentifierContext* MySQLParser::ColumnNameContext::fieldIdentifier() {
  return getRuleContext<MySQLParser::FieldIdentifierContext>(0);
}


size_t MySQLParser::ColumnNameContext::getRuleIndex() const {
  return MySQLParser::RuleColumnName;
}

void MySQLParser::ColumnNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnName(this);
}

void MySQLParser::ColumnNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnName(this);
}


antlrcpp::Any MySQLParser::ColumnNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitColumnName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ColumnNameContext* MySQLParser::columnName() {
  ColumnNameContext *_localctx = _tracker.createInstance<ColumnNameContext>(_ctx, getState());
  enterRule(_localctx, 1000, MySQLParser::RuleColumnName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7734);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1042, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7730);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(7731);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7732);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(7733);
      fieldIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnInternalRefContext ------------------------------------------------------------------

MySQLParser::ColumnInternalRefContext::ColumnInternalRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::ColumnInternalRefContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::ColumnInternalRefContext::getRuleIndex() const {
  return MySQLParser::RuleColumnInternalRef;
}

void MySQLParser::ColumnInternalRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnInternalRef(this);
}

void MySQLParser::ColumnInternalRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnInternalRef(this);
}


antlrcpp::Any MySQLParser::ColumnInternalRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitColumnInternalRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ColumnInternalRefContext* MySQLParser::columnInternalRef() {
  ColumnInternalRefContext *_localctx = _tracker.createInstance<ColumnInternalRefContext>(_ctx, getState());
  enterRule(_localctx, 1002, MySQLParser::RuleColumnInternalRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7736);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnInternalRefListContext ------------------------------------------------------------------

MySQLParser::ColumnInternalRefListContext::ColumnInternalRefListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ColumnInternalRefListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::ColumnInternalRefContext *> MySQLParser::ColumnInternalRefListContext::columnInternalRef() {
  return getRuleContexts<MySQLParser::ColumnInternalRefContext>();
}

MySQLParser::ColumnInternalRefContext* MySQLParser::ColumnInternalRefListContext::columnInternalRef(size_t i) {
  return getRuleContext<MySQLParser::ColumnInternalRefContext>(i);
}

tree::TerminalNode* MySQLParser::ColumnInternalRefListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::ColumnInternalRefListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ColumnInternalRefListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ColumnInternalRefListContext::getRuleIndex() const {
  return MySQLParser::RuleColumnInternalRefList;
}

void MySQLParser::ColumnInternalRefListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnInternalRefList(this);
}

void MySQLParser::ColumnInternalRefListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnInternalRefList(this);
}


antlrcpp::Any MySQLParser::ColumnInternalRefListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitColumnInternalRefList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ColumnInternalRefListContext* MySQLParser::columnInternalRefList() {
  ColumnInternalRefListContext *_localctx = _tracker.createInstance<ColumnInternalRefListContext>(_ctx, getState());
  enterRule(_localctx, 1004, MySQLParser::RuleColumnInternalRefList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7738);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7739);
    columnInternalRef();
    setState(7744);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(7740);
      match(MySQLParser::COMMA_SYMBOL);
      setState(7741);
      columnInternalRef();
      setState(7746);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(7747);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnRefContext ------------------------------------------------------------------

MySQLParser::ColumnRefContext::ColumnRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::FieldIdentifierContext* MySQLParser::ColumnRefContext::fieldIdentifier() {
  return getRuleContext<MySQLParser::FieldIdentifierContext>(0);
}


size_t MySQLParser::ColumnRefContext::getRuleIndex() const {
  return MySQLParser::RuleColumnRef;
}

void MySQLParser::ColumnRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnRef(this);
}

void MySQLParser::ColumnRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnRef(this);
}


antlrcpp::Any MySQLParser::ColumnRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitColumnRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ColumnRefContext* MySQLParser::columnRef() {
  ColumnRefContext *_localctx = _tracker.createInstance<ColumnRefContext>(_ctx, getState());
  enterRule(_localctx, 1006, MySQLParser::RuleColumnRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7749);
    fieldIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertIdentifierContext ------------------------------------------------------------------

MySQLParser::InsertIdentifierContext::InsertIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ColumnRefContext* MySQLParser::InsertIdentifierContext::columnRef() {
  return getRuleContext<MySQLParser::ColumnRefContext>(0);
}

MySQLParser::TableWildContext* MySQLParser::InsertIdentifierContext::tableWild() {
  return getRuleContext<MySQLParser::TableWildContext>(0);
}


size_t MySQLParser::InsertIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleInsertIdentifier;
}

void MySQLParser::InsertIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertIdentifier(this);
}

void MySQLParser::InsertIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertIdentifier(this);
}


antlrcpp::Any MySQLParser::InsertIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitInsertIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InsertIdentifierContext* MySQLParser::insertIdentifier() {
  InsertIdentifierContext *_localctx = _tracker.createInstance<InsertIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1008, MySQLParser::RuleInsertIdentifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7753);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1044, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7751);
      columnRef();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7752);
      tableWild();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexNameContext ------------------------------------------------------------------

MySQLParser::IndexNameContext::IndexNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::IndexNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::IndexNameContext::getRuleIndex() const {
  return MySQLParser::RuleIndexName;
}

void MySQLParser::IndexNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexName(this);
}

void MySQLParser::IndexNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexName(this);
}


antlrcpp::Any MySQLParser::IndexNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIndexName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexNameContext* MySQLParser::indexName() {
  IndexNameContext *_localctx = _tracker.createInstance<IndexNameContext>(_ctx, getState());
  enterRule(_localctx, 1010, MySQLParser::RuleIndexName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7755);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexRefContext ------------------------------------------------------------------

MySQLParser::IndexRefContext::IndexRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::FieldIdentifierContext* MySQLParser::IndexRefContext::fieldIdentifier() {
  return getRuleContext<MySQLParser::FieldIdentifierContext>(0);
}


size_t MySQLParser::IndexRefContext::getRuleIndex() const {
  return MySQLParser::RuleIndexRef;
}

void MySQLParser::IndexRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexRef(this);
}

void MySQLParser::IndexRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexRef(this);
}


antlrcpp::Any MySQLParser::IndexRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIndexRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexRefContext* MySQLParser::indexRef() {
  IndexRefContext *_localctx = _tracker.createInstance<IndexRefContext>(_ctx, getState());
  enterRule(_localctx, 1012, MySQLParser::RuleIndexRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7757);
    fieldIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableWildContext ------------------------------------------------------------------

MySQLParser::TableWildContext::TableWildContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::IdentifierContext *> MySQLParser::TableWildContext::identifier() {
  return getRuleContexts<MySQLParser::IdentifierContext>();
}

MySQLParser::IdentifierContext* MySQLParser::TableWildContext::identifier(size_t i) {
  return getRuleContext<MySQLParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::TableWildContext::DOT_SYMBOL() {
  return getTokens(MySQLParser::DOT_SYMBOL);
}

tree::TerminalNode* MySQLParser::TableWildContext::DOT_SYMBOL(size_t i) {
  return getToken(MySQLParser::DOT_SYMBOL, i);
}

tree::TerminalNode* MySQLParser::TableWildContext::MULT_OPERATOR() {
  return getToken(MySQLParser::MULT_OPERATOR, 0);
}


size_t MySQLParser::TableWildContext::getRuleIndex() const {
  return MySQLParser::RuleTableWild;
}

void MySQLParser::TableWildContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableWild(this);
}

void MySQLParser::TableWildContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableWild(this);
}


antlrcpp::Any MySQLParser::TableWildContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTableWild(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableWildContext* MySQLParser::tableWild() {
  TableWildContext *_localctx = _tracker.createInstance<TableWildContext>(_ctx, getState());
  enterRule(_localctx, 1014, MySQLParser::RuleTableWild);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7759);
    identifier();
    setState(7760);
    match(MySQLParser::DOT_SYMBOL);
    setState(7764);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1045, _ctx)) {
    case 1: {
      setState(7761);
      identifier();
      setState(7762);
      match(MySQLParser::DOT_SYMBOL);
      break;
    }

    }
    setState(7766);
    match(MySQLParser::MULT_OPERATOR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SchemaNameContext ------------------------------------------------------------------

MySQLParser::SchemaNameContext::SchemaNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::SchemaNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::SchemaNameContext::getRuleIndex() const {
  return MySQLParser::RuleSchemaName;
}

void MySQLParser::SchemaNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchemaName(this);
}

void MySQLParser::SchemaNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchemaName(this);
}


antlrcpp::Any MySQLParser::SchemaNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSchemaName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SchemaNameContext* MySQLParser::schemaName() {
  SchemaNameContext *_localctx = _tracker.createInstance<SchemaNameContext>(_ctx, getState());
  enterRule(_localctx, 1016, MySQLParser::RuleSchemaName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7768);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SchemaRefContext ------------------------------------------------------------------

MySQLParser::SchemaRefContext::SchemaRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::SchemaRefContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::SchemaRefContext::getRuleIndex() const {
  return MySQLParser::RuleSchemaRef;
}

void MySQLParser::SchemaRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchemaRef(this);
}

void MySQLParser::SchemaRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchemaRef(this);
}


antlrcpp::Any MySQLParser::SchemaRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSchemaRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SchemaRefContext* MySQLParser::schemaRef() {
  SchemaRefContext *_localctx = _tracker.createInstance<SchemaRefContext>(_ctx, getState());
  enterRule(_localctx, 1018, MySQLParser::RuleSchemaRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7770);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureNameContext ------------------------------------------------------------------

MySQLParser::ProcedureNameContext::ProcedureNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::ProcedureNameContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}


size_t MySQLParser::ProcedureNameContext::getRuleIndex() const {
  return MySQLParser::RuleProcedureName;
}

void MySQLParser::ProcedureNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureName(this);
}

void MySQLParser::ProcedureNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureName(this);
}


antlrcpp::Any MySQLParser::ProcedureNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitProcedureName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ProcedureNameContext* MySQLParser::procedureName() {
  ProcedureNameContext *_localctx = _tracker.createInstance<ProcedureNameContext>(_ctx, getState());
  enterRule(_localctx, 1020, MySQLParser::RuleProcedureName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7772);
    qualifiedIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureRefContext ------------------------------------------------------------------

MySQLParser::ProcedureRefContext::ProcedureRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::ProcedureRefContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}


size_t MySQLParser::ProcedureRefContext::getRuleIndex() const {
  return MySQLParser::RuleProcedureRef;
}

void MySQLParser::ProcedureRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureRef(this);
}

void MySQLParser::ProcedureRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureRef(this);
}


antlrcpp::Any MySQLParser::ProcedureRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitProcedureRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ProcedureRefContext* MySQLParser::procedureRef() {
  ProcedureRefContext *_localctx = _tracker.createInstance<ProcedureRefContext>(_ctx, getState());
  enterRule(_localctx, 1022, MySQLParser::RuleProcedureRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7774);
    qualifiedIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionNameContext ------------------------------------------------------------------

MySQLParser::FunctionNameContext::FunctionNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::FunctionNameContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}


size_t MySQLParser::FunctionNameContext::getRuleIndex() const {
  return MySQLParser::RuleFunctionName;
}

void MySQLParser::FunctionNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionName(this);
}

void MySQLParser::FunctionNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionName(this);
}


antlrcpp::Any MySQLParser::FunctionNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFunctionName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FunctionNameContext* MySQLParser::functionName() {
  FunctionNameContext *_localctx = _tracker.createInstance<FunctionNameContext>(_ctx, getState());
  enterRule(_localctx, 1024, MySQLParser::RuleFunctionName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7776);
    qualifiedIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionRefContext ------------------------------------------------------------------

MySQLParser::FunctionRefContext::FunctionRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::FunctionRefContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}


size_t MySQLParser::FunctionRefContext::getRuleIndex() const {
  return MySQLParser::RuleFunctionRef;
}

void MySQLParser::FunctionRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionRef(this);
}

void MySQLParser::FunctionRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionRef(this);
}


antlrcpp::Any MySQLParser::FunctionRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFunctionRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FunctionRefContext* MySQLParser::functionRef() {
  FunctionRefContext *_localctx = _tracker.createInstance<FunctionRefContext>(_ctx, getState());
  enterRule(_localctx, 1026, MySQLParser::RuleFunctionRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7778);
    qualifiedIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerNameContext ------------------------------------------------------------------

MySQLParser::TriggerNameContext::TriggerNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::TriggerNameContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}


size_t MySQLParser::TriggerNameContext::getRuleIndex() const {
  return MySQLParser::RuleTriggerName;
}

void MySQLParser::TriggerNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTriggerName(this);
}

void MySQLParser::TriggerNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTriggerName(this);
}


antlrcpp::Any MySQLParser::TriggerNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTriggerName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TriggerNameContext* MySQLParser::triggerName() {
  TriggerNameContext *_localctx = _tracker.createInstance<TriggerNameContext>(_ctx, getState());
  enterRule(_localctx, 1028, MySQLParser::RuleTriggerName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7780);
    qualifiedIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerRefContext ------------------------------------------------------------------

MySQLParser::TriggerRefContext::TriggerRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::TriggerRefContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}


size_t MySQLParser::TriggerRefContext::getRuleIndex() const {
  return MySQLParser::RuleTriggerRef;
}

void MySQLParser::TriggerRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTriggerRef(this);
}

void MySQLParser::TriggerRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTriggerRef(this);
}


antlrcpp::Any MySQLParser::TriggerRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTriggerRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TriggerRefContext* MySQLParser::triggerRef() {
  TriggerRefContext *_localctx = _tracker.createInstance<TriggerRefContext>(_ctx, getState());
  enterRule(_localctx, 1030, MySQLParser::RuleTriggerRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7782);
    qualifiedIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewNameContext ------------------------------------------------------------------

MySQLParser::ViewNameContext::ViewNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::ViewNameContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

MySQLParser::DotIdentifierContext* MySQLParser::ViewNameContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}


size_t MySQLParser::ViewNameContext::getRuleIndex() const {
  return MySQLParser::RuleViewName;
}

void MySQLParser::ViewNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewName(this);
}

void MySQLParser::ViewNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewName(this);
}


antlrcpp::Any MySQLParser::ViewNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitViewName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ViewNameContext* MySQLParser::viewName() {
  ViewNameContext *_localctx = _tracker.createInstance<ViewNameContext>(_ctx, getState());
  enterRule(_localctx, 1032, MySQLParser::RuleViewName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7786);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1046, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7784);
      qualifiedIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7785);
      dotIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewRefContext ------------------------------------------------------------------

MySQLParser::ViewRefContext::ViewRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::ViewRefContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

MySQLParser::DotIdentifierContext* MySQLParser::ViewRefContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}


size_t MySQLParser::ViewRefContext::getRuleIndex() const {
  return MySQLParser::RuleViewRef;
}

void MySQLParser::ViewRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewRef(this);
}

void MySQLParser::ViewRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewRef(this);
}


antlrcpp::Any MySQLParser::ViewRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitViewRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ViewRefContext* MySQLParser::viewRef() {
  ViewRefContext *_localctx = _tracker.createInstance<ViewRefContext>(_ctx, getState());
  enterRule(_localctx, 1034, MySQLParser::RuleViewRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7790);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1047, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7788);
      qualifiedIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7789);
      dotIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TablespaceNameContext ------------------------------------------------------------------

MySQLParser::TablespaceNameContext::TablespaceNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::TablespaceNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::TablespaceNameContext::getRuleIndex() const {
  return MySQLParser::RuleTablespaceName;
}

void MySQLParser::TablespaceNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTablespaceName(this);
}

void MySQLParser::TablespaceNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTablespaceName(this);
}


antlrcpp::Any MySQLParser::TablespaceNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTablespaceName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TablespaceNameContext* MySQLParser::tablespaceName() {
  TablespaceNameContext *_localctx = _tracker.createInstance<TablespaceNameContext>(_ctx, getState());
  enterRule(_localctx, 1036, MySQLParser::RuleTablespaceName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7792);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TablespaceRefContext ------------------------------------------------------------------

MySQLParser::TablespaceRefContext::TablespaceRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::TablespaceRefContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::TablespaceRefContext::getRuleIndex() const {
  return MySQLParser::RuleTablespaceRef;
}

void MySQLParser::TablespaceRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTablespaceRef(this);
}

void MySQLParser::TablespaceRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTablespaceRef(this);
}


antlrcpp::Any MySQLParser::TablespaceRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTablespaceRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TablespaceRefContext* MySQLParser::tablespaceRef() {
  TablespaceRefContext *_localctx = _tracker.createInstance<TablespaceRefContext>(_ctx, getState());
  enterRule(_localctx, 1038, MySQLParser::RuleTablespaceRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7794);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogfileGroupNameContext ------------------------------------------------------------------

MySQLParser::LogfileGroupNameContext::LogfileGroupNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::LogfileGroupNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::LogfileGroupNameContext::getRuleIndex() const {
  return MySQLParser::RuleLogfileGroupName;
}

void MySQLParser::LogfileGroupNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogfileGroupName(this);
}

void MySQLParser::LogfileGroupNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogfileGroupName(this);
}


antlrcpp::Any MySQLParser::LogfileGroupNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLogfileGroupName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LogfileGroupNameContext* MySQLParser::logfileGroupName() {
  LogfileGroupNameContext *_localctx = _tracker.createInstance<LogfileGroupNameContext>(_ctx, getState());
  enterRule(_localctx, 1040, MySQLParser::RuleLogfileGroupName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7796);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogfileGroupRefContext ------------------------------------------------------------------

MySQLParser::LogfileGroupRefContext::LogfileGroupRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::LogfileGroupRefContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::LogfileGroupRefContext::getRuleIndex() const {
  return MySQLParser::RuleLogfileGroupRef;
}

void MySQLParser::LogfileGroupRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogfileGroupRef(this);
}

void MySQLParser::LogfileGroupRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogfileGroupRef(this);
}


antlrcpp::Any MySQLParser::LogfileGroupRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLogfileGroupRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LogfileGroupRefContext* MySQLParser::logfileGroupRef() {
  LogfileGroupRefContext *_localctx = _tracker.createInstance<LogfileGroupRefContext>(_ctx, getState());
  enterRule(_localctx, 1042, MySQLParser::RuleLogfileGroupRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7798);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EventNameContext ------------------------------------------------------------------

MySQLParser::EventNameContext::EventNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::EventNameContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}


size_t MySQLParser::EventNameContext::getRuleIndex() const {
  return MySQLParser::RuleEventName;
}

void MySQLParser::EventNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEventName(this);
}

void MySQLParser::EventNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEventName(this);
}


antlrcpp::Any MySQLParser::EventNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitEventName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::EventNameContext* MySQLParser::eventName() {
  EventNameContext *_localctx = _tracker.createInstance<EventNameContext>(_ctx, getState());
  enterRule(_localctx, 1044, MySQLParser::RuleEventName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7800);
    qualifiedIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EventRefContext ------------------------------------------------------------------

MySQLParser::EventRefContext::EventRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::EventRefContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}


size_t MySQLParser::EventRefContext::getRuleIndex() const {
  return MySQLParser::RuleEventRef;
}

void MySQLParser::EventRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEventRef(this);
}

void MySQLParser::EventRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEventRef(this);
}


antlrcpp::Any MySQLParser::EventRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitEventRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::EventRefContext* MySQLParser::eventRef() {
  EventRefContext *_localctx = _tracker.createInstance<EventRefContext>(_ctx, getState());
  enterRule(_localctx, 1046, MySQLParser::RuleEventRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7802);
    qualifiedIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UdfNameContext ------------------------------------------------------------------

MySQLParser::UdfNameContext::UdfNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::UdfNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::UdfNameContext::getRuleIndex() const {
  return MySQLParser::RuleUdfName;
}

void MySQLParser::UdfNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdfName(this);
}

void MySQLParser::UdfNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdfName(this);
}


antlrcpp::Any MySQLParser::UdfNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitUdfName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UdfNameContext* MySQLParser::udfName() {
  UdfNameContext *_localctx = _tracker.createInstance<UdfNameContext>(_ctx, getState());
  enterRule(_localctx, 1048, MySQLParser::RuleUdfName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7804);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ServerNameContext ------------------------------------------------------------------

MySQLParser::ServerNameContext::ServerNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextOrIdentifierContext* MySQLParser::ServerNameContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}


size_t MySQLParser::ServerNameContext::getRuleIndex() const {
  return MySQLParser::RuleServerName;
}

void MySQLParser::ServerNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterServerName(this);
}

void MySQLParser::ServerNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitServerName(this);
}


antlrcpp::Any MySQLParser::ServerNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitServerName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ServerNameContext* MySQLParser::serverName() {
  ServerNameContext *_localctx = _tracker.createInstance<ServerNameContext>(_ctx, getState());
  enterRule(_localctx, 1050, MySQLParser::RuleServerName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7806);
    textOrIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ServerRefContext ------------------------------------------------------------------

MySQLParser::ServerRefContext::ServerRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextOrIdentifierContext* MySQLParser::ServerRefContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}


size_t MySQLParser::ServerRefContext::getRuleIndex() const {
  return MySQLParser::RuleServerRef;
}

void MySQLParser::ServerRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterServerRef(this);
}

void MySQLParser::ServerRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitServerRef(this);
}


antlrcpp::Any MySQLParser::ServerRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitServerRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ServerRefContext* MySQLParser::serverRef() {
  ServerRefContext *_localctx = _tracker.createInstance<ServerRefContext>(_ctx, getState());
  enterRule(_localctx, 1052, MySQLParser::RuleServerRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7808);
    textOrIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EngineRefContext ------------------------------------------------------------------

MySQLParser::EngineRefContext::EngineRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextOrIdentifierContext* MySQLParser::EngineRefContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}


size_t MySQLParser::EngineRefContext::getRuleIndex() const {
  return MySQLParser::RuleEngineRef;
}

void MySQLParser::EngineRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEngineRef(this);
}

void MySQLParser::EngineRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEngineRef(this);
}


antlrcpp::Any MySQLParser::EngineRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitEngineRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::EngineRefContext* MySQLParser::engineRef() {
  EngineRefContext *_localctx = _tracker.createInstance<EngineRefContext>(_ctx, getState());
  enterRule(_localctx, 1054, MySQLParser::RuleEngineRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7810);
    textOrIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableNameContext ------------------------------------------------------------------

MySQLParser::TableNameContext::TableNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::TableNameContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

MySQLParser::DotIdentifierContext* MySQLParser::TableNameContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}


size_t MySQLParser::TableNameContext::getRuleIndex() const {
  return MySQLParser::RuleTableName;
}

void MySQLParser::TableNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableName(this);
}

void MySQLParser::TableNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableName(this);
}


antlrcpp::Any MySQLParser::TableNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTableName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableNameContext* MySQLParser::tableName() {
  TableNameContext *_localctx = _tracker.createInstance<TableNameContext>(_ctx, getState());
  enterRule(_localctx, 1056, MySQLParser::RuleTableName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7814);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1048, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7812);
      qualifiedIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7813);
      dotIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterTableRefContext ------------------------------------------------------------------

MySQLParser::FilterTableRefContext::FilterTableRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::FilterTableRefContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::DotIdentifierContext* MySQLParser::FilterTableRefContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}


size_t MySQLParser::FilterTableRefContext::getRuleIndex() const {
  return MySQLParser::RuleFilterTableRef;
}

void MySQLParser::FilterTableRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterTableRef(this);
}

void MySQLParser::FilterTableRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterTableRef(this);
}


antlrcpp::Any MySQLParser::FilterTableRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFilterTableRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FilterTableRefContext* MySQLParser::filterTableRef() {
  FilterTableRefContext *_localctx = _tracker.createInstance<FilterTableRefContext>(_ctx, getState());
  enterRule(_localctx, 1058, MySQLParser::RuleFilterTableRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7816);
    identifier();
    setState(7817);
    dotIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableRefWithWildcardContext ------------------------------------------------------------------

MySQLParser::TableRefWithWildcardContext::TableRefWithWildcardContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::TableRefWithWildcardContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::TableRefWithWildcardContext::DOT_SYMBOL() {
  return getToken(MySQLParser::DOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TableRefWithWildcardContext::MULT_OPERATOR() {
  return getToken(MySQLParser::MULT_OPERATOR, 0);
}

MySQLParser::DotIdentifierContext* MySQLParser::TableRefWithWildcardContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}


size_t MySQLParser::TableRefWithWildcardContext::getRuleIndex() const {
  return MySQLParser::RuleTableRefWithWildcard;
}

void MySQLParser::TableRefWithWildcardContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableRefWithWildcard(this);
}

void MySQLParser::TableRefWithWildcardContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableRefWithWildcard(this);
}


antlrcpp::Any MySQLParser::TableRefWithWildcardContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTableRefWithWildcard(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableRefWithWildcardContext* MySQLParser::tableRefWithWildcard() {
  TableRefWithWildcardContext *_localctx = _tracker.createInstance<TableRefWithWildcardContext>(_ctx, getState());
  enterRule(_localctx, 1060, MySQLParser::RuleTableRefWithWildcard);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7819);
    identifier();
    setState(7827);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1050, _ctx)) {
    case 1: {
      setState(7820);
      match(MySQLParser::DOT_SYMBOL);
      setState(7821);
      match(MySQLParser::MULT_OPERATOR);
      break;
    }

    case 2: {
      setState(7822);
      dotIdentifier();
      setState(7825);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1049, _ctx)) {
      case 1: {
        setState(7823);
        match(MySQLParser::DOT_SYMBOL);
        setState(7824);
        match(MySQLParser::MULT_OPERATOR);
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableRefContext ------------------------------------------------------------------

MySQLParser::TableRefContext::TableRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::TableRefContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

MySQLParser::DotIdentifierContext* MySQLParser::TableRefContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}


size_t MySQLParser::TableRefContext::getRuleIndex() const {
  return MySQLParser::RuleTableRef;
}

void MySQLParser::TableRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableRef(this);
}

void MySQLParser::TableRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableRef(this);
}


antlrcpp::Any MySQLParser::TableRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTableRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableRefContext* MySQLParser::tableRef() {
  TableRefContext *_localctx = _tracker.createInstance<TableRefContext>(_ctx, getState());
  enterRule(_localctx, 1062, MySQLParser::RuleTableRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7831);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1051, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7829);
      qualifiedIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7830);
      dotIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableRefListContext ------------------------------------------------------------------

MySQLParser::TableRefListContext::TableRefListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TableRefContext *> MySQLParser::TableRefListContext::tableRef() {
  return getRuleContexts<MySQLParser::TableRefContext>();
}

MySQLParser::TableRefContext* MySQLParser::TableRefListContext::tableRef(size_t i) {
  return getRuleContext<MySQLParser::TableRefContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::TableRefListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::TableRefListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::TableRefListContext::getRuleIndex() const {
  return MySQLParser::RuleTableRefList;
}

void MySQLParser::TableRefListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableRefList(this);
}

void MySQLParser::TableRefListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableRefList(this);
}


antlrcpp::Any MySQLParser::TableRefListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTableRefList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableRefListContext* MySQLParser::tableRefList() {
  TableRefListContext *_localctx = _tracker.createInstance<TableRefListContext>(_ctx, getState());
  enterRule(_localctx, 1064, MySQLParser::RuleTableRefList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7833);
    tableRef();
    setState(7838);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1052, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(7834);
        match(MySQLParser::COMMA_SYMBOL);
        setState(7835);
        tableRef(); 
      }
      setState(7840);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1052, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableAliasRefListContext ------------------------------------------------------------------

MySQLParser::TableAliasRefListContext::TableAliasRefListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TableRefWithWildcardContext *> MySQLParser::TableAliasRefListContext::tableRefWithWildcard() {
  return getRuleContexts<MySQLParser::TableRefWithWildcardContext>();
}

MySQLParser::TableRefWithWildcardContext* MySQLParser::TableAliasRefListContext::tableRefWithWildcard(size_t i) {
  return getRuleContext<MySQLParser::TableRefWithWildcardContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::TableAliasRefListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::TableAliasRefListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::TableAliasRefListContext::getRuleIndex() const {
  return MySQLParser::RuleTableAliasRefList;
}

void MySQLParser::TableAliasRefListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableAliasRefList(this);
}

void MySQLParser::TableAliasRefListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableAliasRefList(this);
}


antlrcpp::Any MySQLParser::TableAliasRefListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTableAliasRefList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableAliasRefListContext* MySQLParser::tableAliasRefList() {
  TableAliasRefListContext *_localctx = _tracker.createInstance<TableAliasRefListContext>(_ctx, getState());
  enterRule(_localctx, 1066, MySQLParser::RuleTableAliasRefList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7841);
    tableRefWithWildcard();
    setState(7846);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1053, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(7842);
        match(MySQLParser::COMMA_SYMBOL);
        setState(7843);
        tableRefWithWildcard(); 
      }
      setState(7848);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1053, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterNameContext ------------------------------------------------------------------

MySQLParser::ParameterNameContext::ParameterNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::ParameterNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::ParameterNameContext::getRuleIndex() const {
  return MySQLParser::RuleParameterName;
}

void MySQLParser::ParameterNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameterName(this);
}

void MySQLParser::ParameterNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameterName(this);
}


antlrcpp::Any MySQLParser::ParameterNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitParameterName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ParameterNameContext* MySQLParser::parameterName() {
  ParameterNameContext *_localctx = _tracker.createInstance<ParameterNameContext>(_ctx, getState());
  enterRule(_localctx, 1068, MySQLParser::RuleParameterName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7849);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelIdentifierContext ------------------------------------------------------------------

MySQLParser::LabelIdentifierContext::LabelIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::PureIdentifierContext* MySQLParser::LabelIdentifierContext::pureIdentifier() {
  return getRuleContext<MySQLParser::PureIdentifierContext>(0);
}

MySQLParser::LabelKeywordContext* MySQLParser::LabelIdentifierContext::labelKeyword() {
  return getRuleContext<MySQLParser::LabelKeywordContext>(0);
}


size_t MySQLParser::LabelIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleLabelIdentifier;
}

void MySQLParser::LabelIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabelIdentifier(this);
}

void MySQLParser::LabelIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabelIdentifier(this);
}


antlrcpp::Any MySQLParser::LabelIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLabelIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LabelIdentifierContext* MySQLParser::labelIdentifier() {
  LabelIdentifierContext *_localctx = _tracker.createInstance<LabelIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1070, MySQLParser::RuleLabelIdentifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7853);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1054, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7851);
      pureIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7852);
      labelKeyword();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelRefContext ------------------------------------------------------------------

MySQLParser::LabelRefContext::LabelRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LabelIdentifierContext* MySQLParser::LabelRefContext::labelIdentifier() {
  return getRuleContext<MySQLParser::LabelIdentifierContext>(0);
}


size_t MySQLParser::LabelRefContext::getRuleIndex() const {
  return MySQLParser::RuleLabelRef;
}

void MySQLParser::LabelRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabelRef(this);
}

void MySQLParser::LabelRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabelRef(this);
}


antlrcpp::Any MySQLParser::LabelRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLabelRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LabelRefContext* MySQLParser::labelRef() {
  LabelRefContext *_localctx = _tracker.createInstance<LabelRefContext>(_ctx, getState());
  enterRule(_localctx, 1072, MySQLParser::RuleLabelRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7855);
    labelIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleIdentifierContext ------------------------------------------------------------------

MySQLParser::RoleIdentifierContext::RoleIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::PureIdentifierContext* MySQLParser::RoleIdentifierContext::pureIdentifier() {
  return getRuleContext<MySQLParser::PureIdentifierContext>(0);
}

MySQLParser::RoleKeywordContext* MySQLParser::RoleIdentifierContext::roleKeyword() {
  return getRuleContext<MySQLParser::RoleKeywordContext>(0);
}


size_t MySQLParser::RoleIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleRoleIdentifier;
}

void MySQLParser::RoleIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleIdentifier(this);
}

void MySQLParser::RoleIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleIdentifier(this);
}


antlrcpp::Any MySQLParser::RoleIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRoleIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoleIdentifierContext* MySQLParser::roleIdentifier() {
  RoleIdentifierContext *_localctx = _tracker.createInstance<RoleIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1074, MySQLParser::RuleRoleIdentifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7859);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1055, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7857);
      pureIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7858);
      roleKeyword();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleRefContext ------------------------------------------------------------------

MySQLParser::RoleRefContext::RoleRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RoleIdentifierContext* MySQLParser::RoleRefContext::roleIdentifier() {
  return getRuleContext<MySQLParser::RoleIdentifierContext>(0);
}


size_t MySQLParser::RoleRefContext::getRuleIndex() const {
  return MySQLParser::RuleRoleRef;
}

void MySQLParser::RoleRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleRef(this);
}

void MySQLParser::RoleRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleRef(this);
}


antlrcpp::Any MySQLParser::RoleRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRoleRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoleRefContext* MySQLParser::roleRef() {
  RoleRefContext *_localctx = _tracker.createInstance<RoleRefContext>(_ctx, getState());
  enterRule(_localctx, 1076, MySQLParser::RuleRoleRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7861);
    roleIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PluginRefContext ------------------------------------------------------------------

MySQLParser::PluginRefContext::PluginRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::PluginRefContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::PluginRefContext::getRuleIndex() const {
  return MySQLParser::RulePluginRef;
}

void MySQLParser::PluginRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPluginRef(this);
}

void MySQLParser::PluginRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPluginRef(this);
}


antlrcpp::Any MySQLParser::PluginRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPluginRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PluginRefContext* MySQLParser::pluginRef() {
  PluginRefContext *_localctx = _tracker.createInstance<PluginRefContext>(_ctx, getState());
  enterRule(_localctx, 1078, MySQLParser::RulePluginRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7863);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComponentRefContext ------------------------------------------------------------------

MySQLParser::ComponentRefContext::ComponentRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextStringLiteralContext* MySQLParser::ComponentRefContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}


size_t MySQLParser::ComponentRefContext::getRuleIndex() const {
  return MySQLParser::RuleComponentRef;
}

void MySQLParser::ComponentRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponentRef(this);
}

void MySQLParser::ComponentRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponentRef(this);
}


antlrcpp::Any MySQLParser::ComponentRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitComponentRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ComponentRefContext* MySQLParser::componentRef() {
  ComponentRefContext *_localctx = _tracker.createInstance<ComponentRefContext>(_ctx, getState());
  enterRule(_localctx, 1080, MySQLParser::RuleComponentRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7865);
    textStringLiteral();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResourceGroupRefContext ------------------------------------------------------------------

MySQLParser::ResourceGroupRefContext::ResourceGroupRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::ResourceGroupRefContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::ResourceGroupRefContext::getRuleIndex() const {
  return MySQLParser::RuleResourceGroupRef;
}

void MySQLParser::ResourceGroupRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResourceGroupRef(this);
}

void MySQLParser::ResourceGroupRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResourceGroupRef(this);
}


antlrcpp::Any MySQLParser::ResourceGroupRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitResourceGroupRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ResourceGroupRefContext* MySQLParser::resourceGroupRef() {
  ResourceGroupRefContext *_localctx = _tracker.createInstance<ResourceGroupRefContext>(_ctx, getState());
  enterRule(_localctx, 1082, MySQLParser::RuleResourceGroupRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7867);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowNameContext ------------------------------------------------------------------

MySQLParser::WindowNameContext::WindowNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::WindowNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::WindowNameContext::getRuleIndex() const {
  return MySQLParser::RuleWindowName;
}

void MySQLParser::WindowNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowName(this);
}

void MySQLParser::WindowNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowName(this);
}


antlrcpp::Any MySQLParser::WindowNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitWindowName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowNameContext* MySQLParser::windowName() {
  WindowNameContext *_localctx = _tracker.createInstance<WindowNameContext>(_ctx, getState());
  enterRule(_localctx, 1084, MySQLParser::RuleWindowName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7869);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PureIdentifierContext ------------------------------------------------------------------

MySQLParser::PureIdentifierContext::PureIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::PureIdentifierContext::IDENTIFIER() {
  return getToken(MySQLParser::IDENTIFIER, 0);
}

tree::TerminalNode* MySQLParser::PureIdentifierContext::BACK_TICK_QUOTED_ID() {
  return getToken(MySQLParser::BACK_TICK_QUOTED_ID, 0);
}

tree::TerminalNode* MySQLParser::PureIdentifierContext::DOUBLE_QUOTED_TEXT() {
  return getToken(MySQLParser::DOUBLE_QUOTED_TEXT, 0);
}


size_t MySQLParser::PureIdentifierContext::getRuleIndex() const {
  return MySQLParser::RulePureIdentifier;
}

void MySQLParser::PureIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPureIdentifier(this);
}

void MySQLParser::PureIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPureIdentifier(this);
}


antlrcpp::Any MySQLParser::PureIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPureIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PureIdentifierContext* MySQLParser::pureIdentifier() {
  PureIdentifierContext *_localctx = _tracker.createInstance<PureIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1086, MySQLParser::RulePureIdentifier);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7874);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1056, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7871);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::IDENTIFIER

      || _la == MySQLParser::BACK_TICK_QUOTED_ID)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7872);

      if (!(isSqlModeActive(AnsiQuotes))) throw FailedPredicateException(this, "isSqlModeActive(AnsiQuotes)");
      setState(7873);
      match(MySQLParser::DOUBLE_QUOTED_TEXT);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

MySQLParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::PureIdentifierContext* MySQLParser::IdentifierContext::pureIdentifier() {
  return getRuleContext<MySQLParser::PureIdentifierContext>(0);
}

MySQLParser::IdentifierKeywordContext* MySQLParser::IdentifierContext::identifierKeyword() {
  return getRuleContext<MySQLParser::IdentifierKeywordContext>(0);
}


size_t MySQLParser::IdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifier;
}

void MySQLParser::IdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifier(this);
}

void MySQLParser::IdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifier(this);
}


antlrcpp::Any MySQLParser::IdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentifierContext* MySQLParser::identifier() {
  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1088, MySQLParser::RuleIdentifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7878);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1057, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7876);
      pureIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7877);
      identifierKeyword();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierListContext ------------------------------------------------------------------

MySQLParser::IdentifierListContext::IdentifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::IdentifierContext *> MySQLParser::IdentifierListContext::identifier() {
  return getRuleContexts<MySQLParser::IdentifierContext>();
}

MySQLParser::IdentifierContext* MySQLParser::IdentifierListContext::identifier(size_t i) {
  return getRuleContext<MySQLParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::IdentifierListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::IdentifierListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::IdentifierListContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifierList;
}

void MySQLParser::IdentifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierList(this);
}

void MySQLParser::IdentifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierList(this);
}


antlrcpp::Any MySQLParser::IdentifierListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIdentifierList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentifierListContext* MySQLParser::identifierList() {
  IdentifierListContext *_localctx = _tracker.createInstance<IdentifierListContext>(_ctx, getState());
  enterRule(_localctx, 1090, MySQLParser::RuleIdentifierList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7880);
    identifier();
    setState(7885);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1058, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(7881);
        match(MySQLParser::COMMA_SYMBOL);
        setState(7882);
        identifier(); 
      }
      setState(7887);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1058, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierListWithParenthesesContext ------------------------------------------------------------------

MySQLParser::IdentifierListWithParenthesesContext::IdentifierListWithParenthesesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IdentifierListWithParenthesesContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::IdentifierListContext* MySQLParser::IdentifierListWithParenthesesContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

tree::TerminalNode* MySQLParser::IdentifierListWithParenthesesContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::IdentifierListWithParenthesesContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifierListWithParentheses;
}

void MySQLParser::IdentifierListWithParenthesesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierListWithParentheses(this);
}

void MySQLParser::IdentifierListWithParenthesesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierListWithParentheses(this);
}


antlrcpp::Any MySQLParser::IdentifierListWithParenthesesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIdentifierListWithParentheses(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentifierListWithParenthesesContext* MySQLParser::identifierListWithParentheses() {
  IdentifierListWithParenthesesContext *_localctx = _tracker.createInstance<IdentifierListWithParenthesesContext>(_ctx, getState());
  enterRule(_localctx, 1092, MySQLParser::RuleIdentifierListWithParentheses);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7888);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7889);
    identifierList();
    setState(7890);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedIdentifierContext ------------------------------------------------------------------

MySQLParser::QualifiedIdentifierContext::QualifiedIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::QualifiedIdentifierContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::DotIdentifierContext* MySQLParser::QualifiedIdentifierContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}


size_t MySQLParser::QualifiedIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleQualifiedIdentifier;
}

void MySQLParser::QualifiedIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiedIdentifier(this);
}

void MySQLParser::QualifiedIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiedIdentifier(this);
}


antlrcpp::Any MySQLParser::QualifiedIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitQualifiedIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::qualifiedIdentifier() {
  QualifiedIdentifierContext *_localctx = _tracker.createInstance<QualifiedIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1094, MySQLParser::RuleQualifiedIdentifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7892);
    identifier();
    setState(7894);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1059, _ctx)) {
    case 1: {
      setState(7893);
      dotIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleIdentifierContext ------------------------------------------------------------------

MySQLParser::SimpleIdentifierContext::SimpleIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::SimpleIdentifierContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

std::vector<MySQLParser::DotIdentifierContext *> MySQLParser::SimpleIdentifierContext::dotIdentifier() {
  return getRuleContexts<MySQLParser::DotIdentifierContext>();
}

MySQLParser::DotIdentifierContext* MySQLParser::SimpleIdentifierContext::dotIdentifier(size_t i) {
  return getRuleContext<MySQLParser::DotIdentifierContext>(i);
}


size_t MySQLParser::SimpleIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleSimpleIdentifier;
}

void MySQLParser::SimpleIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleIdentifier(this);
}

void MySQLParser::SimpleIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleIdentifier(this);
}


antlrcpp::Any MySQLParser::SimpleIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpleIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SimpleIdentifierContext* MySQLParser::simpleIdentifier() {
  SimpleIdentifierContext *_localctx = _tracker.createInstance<SimpleIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1096, MySQLParser::RuleSimpleIdentifier);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7907);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1062, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7896);
      identifier();
      setState(7901);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::DOT_SYMBOL) {
        setState(7897);
        dotIdentifier();
        setState(7899);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::DOT_SYMBOL) {
          setState(7898);
          dotIdentifier();
        }
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7903);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(7904);
      dotIdentifier();
      setState(7905);
      dotIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DotIdentifierContext ------------------------------------------------------------------

MySQLParser::DotIdentifierContext::DotIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DotIdentifierContext::DOT_SYMBOL() {
  return getToken(MySQLParser::DOT_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::DotIdentifierContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::DotIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleDotIdentifier;
}

void MySQLParser::DotIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDotIdentifier(this);
}

void MySQLParser::DotIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDotIdentifier(this);
}


antlrcpp::Any MySQLParser::DotIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitDotIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DotIdentifierContext* MySQLParser::dotIdentifier() {
  DotIdentifierContext *_localctx = _tracker.createInstance<DotIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1098, MySQLParser::RuleDotIdentifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7909);
    match(MySQLParser::DOT_SYMBOL);
    setState(7910);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ulong_numberContext ------------------------------------------------------------------

MySQLParser::Ulong_numberContext::Ulong_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::Ulong_numberContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Ulong_numberContext::HEX_NUMBER() {
  return getToken(MySQLParser::HEX_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Ulong_numberContext::LONG_NUMBER() {
  return getToken(MySQLParser::LONG_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Ulong_numberContext::ULONGLONG_NUMBER() {
  return getToken(MySQLParser::ULONGLONG_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Ulong_numberContext::DECIMAL_NUMBER() {
  return getToken(MySQLParser::DECIMAL_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Ulong_numberContext::FLOAT_NUMBER() {
  return getToken(MySQLParser::FLOAT_NUMBER, 0);
}


size_t MySQLParser::Ulong_numberContext::getRuleIndex() const {
  return MySQLParser::RuleUlong_number;
}

void MySQLParser::Ulong_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUlong_number(this);
}

void MySQLParser::Ulong_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUlong_number(this);
}


antlrcpp::Any MySQLParser::Ulong_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitUlong_number(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::Ulong_numberContext* MySQLParser::ulong_number() {
  Ulong_numberContext *_localctx = _tracker.createInstance<Ulong_numberContext>(_ctx, getState());
  enterRule(_localctx, 1100, MySQLParser::RuleUlong_number);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7912);
    _la = _input->LA(1);
    if (!(((((_la - 380) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 380)) & ((1ULL << (MySQLParser::INT_NUMBER - 380))
      | (1ULL << (MySQLParser::LONG_NUMBER - 380))
      | (1ULL << (MySQLParser::ULONGLONG_NUMBER - 380))
      | (1ULL << (MySQLParser::HEX_NUMBER - 380))
      | (1ULL << (MySQLParser::DECIMAL_NUMBER - 380))
      | (1ULL << (MySQLParser::FLOAT_NUMBER - 380)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Real_ulong_numberContext ------------------------------------------------------------------

MySQLParser::Real_ulong_numberContext::Real_ulong_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::Real_ulong_numberContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Real_ulong_numberContext::HEX_NUMBER() {
  return getToken(MySQLParser::HEX_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Real_ulong_numberContext::LONG_NUMBER() {
  return getToken(MySQLParser::LONG_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Real_ulong_numberContext::ULONGLONG_NUMBER() {
  return getToken(MySQLParser::ULONGLONG_NUMBER, 0);
}


size_t MySQLParser::Real_ulong_numberContext::getRuleIndex() const {
  return MySQLParser::RuleReal_ulong_number;
}

void MySQLParser::Real_ulong_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReal_ulong_number(this);
}

void MySQLParser::Real_ulong_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReal_ulong_number(this);
}


antlrcpp::Any MySQLParser::Real_ulong_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitReal_ulong_number(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::real_ulong_number() {
  Real_ulong_numberContext *_localctx = _tracker.createInstance<Real_ulong_numberContext>(_ctx, getState());
  enterRule(_localctx, 1102, MySQLParser::RuleReal_ulong_number);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7914);
    _la = _input->LA(1);
    if (!(((((_la - 380) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 380)) & ((1ULL << (MySQLParser::INT_NUMBER - 380))
      | (1ULL << (MySQLParser::LONG_NUMBER - 380))
      | (1ULL << (MySQLParser::ULONGLONG_NUMBER - 380))
      | (1ULL << (MySQLParser::HEX_NUMBER - 380)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ulonglong_numberContext ------------------------------------------------------------------

MySQLParser::Ulonglong_numberContext::Ulonglong_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::Ulonglong_numberContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Ulonglong_numberContext::LONG_NUMBER() {
  return getToken(MySQLParser::LONG_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Ulonglong_numberContext::ULONGLONG_NUMBER() {
  return getToken(MySQLParser::ULONGLONG_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Ulonglong_numberContext::DECIMAL_NUMBER() {
  return getToken(MySQLParser::DECIMAL_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Ulonglong_numberContext::FLOAT_NUMBER() {
  return getToken(MySQLParser::FLOAT_NUMBER, 0);
}


size_t MySQLParser::Ulonglong_numberContext::getRuleIndex() const {
  return MySQLParser::RuleUlonglong_number;
}

void MySQLParser::Ulonglong_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUlonglong_number(this);
}

void MySQLParser::Ulonglong_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUlonglong_number(this);
}


antlrcpp::Any MySQLParser::Ulonglong_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitUlonglong_number(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::Ulonglong_numberContext* MySQLParser::ulonglong_number() {
  Ulonglong_numberContext *_localctx = _tracker.createInstance<Ulonglong_numberContext>(_ctx, getState());
  enterRule(_localctx, 1104, MySQLParser::RuleUlonglong_number);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7916);
    _la = _input->LA(1);
    if (!(((((_la - 380) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 380)) & ((1ULL << (MySQLParser::INT_NUMBER - 380))
      | (1ULL << (MySQLParser::LONG_NUMBER - 380))
      | (1ULL << (MySQLParser::ULONGLONG_NUMBER - 380))
      | (1ULL << (MySQLParser::DECIMAL_NUMBER - 380))
      | (1ULL << (MySQLParser::FLOAT_NUMBER - 380)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Real_ulonglong_numberContext ------------------------------------------------------------------

MySQLParser::Real_ulonglong_numberContext::Real_ulonglong_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::Real_ulonglong_numberContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Real_ulonglong_numberContext::ULONGLONG_NUMBER() {
  return getToken(MySQLParser::ULONGLONG_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Real_ulonglong_numberContext::LONG_NUMBER() {
  return getToken(MySQLParser::LONG_NUMBER, 0);
}


size_t MySQLParser::Real_ulonglong_numberContext::getRuleIndex() const {
  return MySQLParser::RuleReal_ulonglong_number;
}

void MySQLParser::Real_ulonglong_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReal_ulonglong_number(this);
}

void MySQLParser::Real_ulonglong_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReal_ulonglong_number(this);
}


antlrcpp::Any MySQLParser::Real_ulonglong_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitReal_ulonglong_number(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::Real_ulonglong_numberContext* MySQLParser::real_ulonglong_number() {
  Real_ulonglong_numberContext *_localctx = _tracker.createInstance<Real_ulonglong_numberContext>(_ctx, getState());
  enterRule(_localctx, 1106, MySQLParser::RuleReal_ulonglong_number);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7918);
    _la = _input->LA(1);
    if (!(((((_la - 380) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 380)) & ((1ULL << (MySQLParser::INT_NUMBER - 380))
      | (1ULL << (MySQLParser::LONG_NUMBER - 380))
      | (1ULL << (MySQLParser::ULONGLONG_NUMBER - 380)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

MySQLParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextLiteralContext* MySQLParser::LiteralContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

MySQLParser::NumLiteralContext* MySQLParser::LiteralContext::numLiteral() {
  return getRuleContext<MySQLParser::NumLiteralContext>(0);
}

MySQLParser::TemporalLiteralContext* MySQLParser::LiteralContext::temporalLiteral() {
  return getRuleContext<MySQLParser::TemporalLiteralContext>(0);
}

MySQLParser::NullLiteralContext* MySQLParser::LiteralContext::nullLiteral() {
  return getRuleContext<MySQLParser::NullLiteralContext>(0);
}

MySQLParser::BoolLiteralContext* MySQLParser::LiteralContext::boolLiteral() {
  return getRuleContext<MySQLParser::BoolLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::LiteralContext::HEX_NUMBER() {
  return getToken(MySQLParser::HEX_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::LiteralContext::BIN_NUMBER() {
  return getToken(MySQLParser::BIN_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::LiteralContext::UNDERSCORE_CHARSET() {
  return getToken(MySQLParser::UNDERSCORE_CHARSET, 0);
}


size_t MySQLParser::LiteralContext::getRuleIndex() const {
  return MySQLParser::RuleLiteral;
}

void MySQLParser::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}

void MySQLParser::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}


antlrcpp::Any MySQLParser::LiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LiteralContext* MySQLParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 1108, MySQLParser::RuleLiteral);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7929);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1064, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7920);
      textLiteral();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7921);
      numLiteral();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7922);
      temporalLiteral();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7923);
      nullLiteral();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(7924);
      boolLiteral();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(7926);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::UNDERSCORE_CHARSET) {
        setState(7925);
        match(MySQLParser::UNDERSCORE_CHARSET);
      }
      setState(7928);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::HEX_NUMBER

      || _la == MySQLParser::BIN_NUMBER)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignedLiteralContext ------------------------------------------------------------------

MySQLParser::SignedLiteralContext::SignedLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LiteralContext* MySQLParser::SignedLiteralContext::literal() {
  return getRuleContext<MySQLParser::LiteralContext>(0);
}

tree::TerminalNode* MySQLParser::SignedLiteralContext::PLUS_OPERATOR() {
  return getToken(MySQLParser::PLUS_OPERATOR, 0);
}

MySQLParser::Ulong_numberContext* MySQLParser::SignedLiteralContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::SignedLiteralContext::MINUS_OPERATOR() {
  return getToken(MySQLParser::MINUS_OPERATOR, 0);
}


size_t MySQLParser::SignedLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleSignedLiteral;
}

void MySQLParser::SignedLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignedLiteral(this);
}

void MySQLParser::SignedLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignedLiteral(this);
}


antlrcpp::Any MySQLParser::SignedLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSignedLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SignedLiteralContext* MySQLParser::signedLiteral() {
  SignedLiteralContext *_localctx = _tracker.createInstance<SignedLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1110, MySQLParser::RuleSignedLiteral);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7936);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1065, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7931);
      literal();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7932);
      match(MySQLParser::PLUS_OPERATOR);
      setState(7933);
      ulong_number();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7934);
      match(MySQLParser::MINUS_OPERATOR);
      setState(7935);
      ulong_number();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringListContext ------------------------------------------------------------------

MySQLParser::StringListContext::StringListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::StringListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::TextStringContext *> MySQLParser::StringListContext::textString() {
  return getRuleContexts<MySQLParser::TextStringContext>();
}

MySQLParser::TextStringContext* MySQLParser::StringListContext::textString(size_t i) {
  return getRuleContext<MySQLParser::TextStringContext>(i);
}

tree::TerminalNode* MySQLParser::StringListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::StringListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::StringListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::StringListContext::getRuleIndex() const {
  return MySQLParser::RuleStringList;
}

void MySQLParser::StringListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringList(this);
}

void MySQLParser::StringListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringList(this);
}


antlrcpp::Any MySQLParser::StringListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitStringList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::StringListContext* MySQLParser::stringList() {
  StringListContext *_localctx = _tracker.createInstance<StringListContext>(_ctx, getState());
  enterRule(_localctx, 1112, MySQLParser::RuleStringList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7938);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7939);
    textString();
    setState(7944);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(7940);
      match(MySQLParser::COMMA_SYMBOL);
      setState(7941);
      textString();
      setState(7946);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(7947);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextStringLiteralContext ------------------------------------------------------------------

MySQLParser::TextStringLiteralContext::TextStringLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TextStringLiteralContext::SINGLE_QUOTED_TEXT() {
  return getToken(MySQLParser::SINGLE_QUOTED_TEXT, 0);
}

tree::TerminalNode* MySQLParser::TextStringLiteralContext::DOUBLE_QUOTED_TEXT() {
  return getToken(MySQLParser::DOUBLE_QUOTED_TEXT, 0);
}


size_t MySQLParser::TextStringLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleTextStringLiteral;
}

void MySQLParser::TextStringLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextStringLiteral(this);
}

void MySQLParser::TextStringLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextStringLiteral(this);
}


antlrcpp::Any MySQLParser::TextStringLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTextStringLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TextStringLiteralContext* MySQLParser::textStringLiteral() {
  TextStringLiteralContext *_localctx = _tracker.createInstance<TextStringLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1114, MySQLParser::RuleTextStringLiteral);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7952);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1067, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7949);
      dynamic_cast<TextStringLiteralContext *>(_localctx)->value = match(MySQLParser::SINGLE_QUOTED_TEXT);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7950);

      if (!(!isSqlModeActive(AnsiQuotes))) throw FailedPredicateException(this, "!isSqlModeActive(AnsiQuotes)");
      setState(7951);
      dynamic_cast<TextStringLiteralContext *>(_localctx)->value = match(MySQLParser::DOUBLE_QUOTED_TEXT);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextStringContext ------------------------------------------------------------------

MySQLParser::TextStringContext::TextStringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextStringLiteralContext* MySQLParser::TextStringContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::TextStringContext::HEX_NUMBER() {
  return getToken(MySQLParser::HEX_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::TextStringContext::BIN_NUMBER() {
  return getToken(MySQLParser::BIN_NUMBER, 0);
}


size_t MySQLParser::TextStringContext::getRuleIndex() const {
  return MySQLParser::RuleTextString;
}

void MySQLParser::TextStringContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextString(this);
}

void MySQLParser::TextStringContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextString(this);
}


antlrcpp::Any MySQLParser::TextStringContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTextString(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TextStringContext* MySQLParser::textString() {
  TextStringContext *_localctx = _tracker.createInstance<TextStringContext>(_ctx, getState());
  enterRule(_localctx, 1116, MySQLParser::RuleTextString);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7957);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1068, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7954);
      textStringLiteral();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7955);
      match(MySQLParser::HEX_NUMBER);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7956);
      match(MySQLParser::BIN_NUMBER);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextLiteralContext ------------------------------------------------------------------

MySQLParser::TextLiteralContext::TextLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TextStringLiteralContext *> MySQLParser::TextLiteralContext::textStringLiteral() {
  return getRuleContexts<MySQLParser::TextStringLiteralContext>();
}

MySQLParser::TextStringLiteralContext* MySQLParser::TextLiteralContext::textStringLiteral(size_t i) {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(i);
}

tree::TerminalNode* MySQLParser::TextLiteralContext::NCHAR_TEXT() {
  return getToken(MySQLParser::NCHAR_TEXT, 0);
}

tree::TerminalNode* MySQLParser::TextLiteralContext::UNDERSCORE_CHARSET() {
  return getToken(MySQLParser::UNDERSCORE_CHARSET, 0);
}


size_t MySQLParser::TextLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleTextLiteral;
}

void MySQLParser::TextLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextLiteral(this);
}

void MySQLParser::TextLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextLiteral(this);
}


antlrcpp::Any MySQLParser::TextLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTextLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TextLiteralContext* MySQLParser::textLiteral() {
  TextLiteralContext *_localctx = _tracker.createInstance<TextLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1118, MySQLParser::RuleTextLiteral);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7964);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1070, _ctx)) {
    case 1: {
      setState(7960);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1069, _ctx)) {
      case 1: {
        setState(7959);
        match(MySQLParser::UNDERSCORE_CHARSET);
        break;
      }

      }
      setState(7962);
      textStringLiteral();
      break;
    }

    case 2: {
      setState(7963);
      match(MySQLParser::NCHAR_TEXT);
      break;
    }

    }
    setState(7969);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1071, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(7966);
        textStringLiteral(); 
      }
      setState(7971);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1071, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextStringNoLinebreakContext ------------------------------------------------------------------

MySQLParser::TextStringNoLinebreakContext::TextStringNoLinebreakContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextStringLiteralContext* MySQLParser::TextStringNoLinebreakContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}


size_t MySQLParser::TextStringNoLinebreakContext::getRuleIndex() const {
  return MySQLParser::RuleTextStringNoLinebreak;
}

void MySQLParser::TextStringNoLinebreakContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextStringNoLinebreak(this);
}

void MySQLParser::TextStringNoLinebreakContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextStringNoLinebreak(this);
}


antlrcpp::Any MySQLParser::TextStringNoLinebreakContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTextStringNoLinebreak(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TextStringNoLinebreakContext* MySQLParser::textStringNoLinebreak() {
  TextStringNoLinebreakContext *_localctx = _tracker.createInstance<TextStringNoLinebreakContext>(_ctx, getState());
  enterRule(_localctx, 1120, MySQLParser::RuleTextStringNoLinebreak);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7972);
    textStringLiteral();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextStringLiteralListContext ------------------------------------------------------------------

MySQLParser::TextStringLiteralListContext::TextStringLiteralListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TextStringLiteralContext *> MySQLParser::TextStringLiteralListContext::textStringLiteral() {
  return getRuleContexts<MySQLParser::TextStringLiteralContext>();
}

MySQLParser::TextStringLiteralContext* MySQLParser::TextStringLiteralListContext::textStringLiteral(size_t i) {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::TextStringLiteralListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::TextStringLiteralListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::TextStringLiteralListContext::getRuleIndex() const {
  return MySQLParser::RuleTextStringLiteralList;
}

void MySQLParser::TextStringLiteralListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextStringLiteralList(this);
}

void MySQLParser::TextStringLiteralListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextStringLiteralList(this);
}


antlrcpp::Any MySQLParser::TextStringLiteralListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTextStringLiteralList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TextStringLiteralListContext* MySQLParser::textStringLiteralList() {
  TextStringLiteralListContext *_localctx = _tracker.createInstance<TextStringLiteralListContext>(_ctx, getState());
  enterRule(_localctx, 1122, MySQLParser::RuleTextStringLiteralList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7974);
    textStringLiteral();
    setState(7979);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(7975);
      match(MySQLParser::COMMA_SYMBOL);
      setState(7976);
      textStringLiteral();
      setState(7981);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumLiteralContext ------------------------------------------------------------------

MySQLParser::NumLiteralContext::NumLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::NumLiteralContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::NumLiteralContext::LONG_NUMBER() {
  return getToken(MySQLParser::LONG_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::NumLiteralContext::ULONGLONG_NUMBER() {
  return getToken(MySQLParser::ULONGLONG_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::NumLiteralContext::DECIMAL_NUMBER() {
  return getToken(MySQLParser::DECIMAL_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::NumLiteralContext::FLOAT_NUMBER() {
  return getToken(MySQLParser::FLOAT_NUMBER, 0);
}


size_t MySQLParser::NumLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleNumLiteral;
}

void MySQLParser::NumLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumLiteral(this);
}

void MySQLParser::NumLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumLiteral(this);
}


antlrcpp::Any MySQLParser::NumLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitNumLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::NumLiteralContext* MySQLParser::numLiteral() {
  NumLiteralContext *_localctx = _tracker.createInstance<NumLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1124, MySQLParser::RuleNumLiteral);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7982);
    _la = _input->LA(1);
    if (!(((((_la - 380) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 380)) & ((1ULL << (MySQLParser::INT_NUMBER - 380))
      | (1ULL << (MySQLParser::LONG_NUMBER - 380))
      | (1ULL << (MySQLParser::ULONGLONG_NUMBER - 380))
      | (1ULL << (MySQLParser::DECIMAL_NUMBER - 380))
      | (1ULL << (MySQLParser::FLOAT_NUMBER - 380)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BoolLiteralContext ------------------------------------------------------------------

MySQLParser::BoolLiteralContext::BoolLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::BoolLiteralContext::TRUE_SYMBOL() {
  return getToken(MySQLParser::TRUE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::BoolLiteralContext::FALSE_SYMBOL() {
  return getToken(MySQLParser::FALSE_SYMBOL, 0);
}


size_t MySQLParser::BoolLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleBoolLiteral;
}

void MySQLParser::BoolLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBoolLiteral(this);
}

void MySQLParser::BoolLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBoolLiteral(this);
}


antlrcpp::Any MySQLParser::BoolLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitBoolLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::BoolLiteralContext* MySQLParser::boolLiteral() {
  BoolLiteralContext *_localctx = _tracker.createInstance<BoolLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1126, MySQLParser::RuleBoolLiteral);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7984);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::FALSE_SYMBOL || _la == MySQLParser::TRUE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NullLiteralContext ------------------------------------------------------------------

MySQLParser::NullLiteralContext::NullLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::NullLiteralContext::NULL_SYMBOL() {
  return getToken(MySQLParser::NULL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NullLiteralContext::NULL2_SYMBOL() {
  return getToken(MySQLParser::NULL2_SYMBOL, 0);
}


size_t MySQLParser::NullLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleNullLiteral;
}

void MySQLParser::NullLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullLiteral(this);
}

void MySQLParser::NullLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullLiteral(this);
}


antlrcpp::Any MySQLParser::NullLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitNullLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::NullLiteralContext* MySQLParser::nullLiteral() {
  NullLiteralContext *_localctx = _tracker.createInstance<NullLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1128, MySQLParser::RuleNullLiteral);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7986);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::NULL2_SYMBOL || _la == MySQLParser::NULL_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TemporalLiteralContext ------------------------------------------------------------------

MySQLParser::TemporalLiteralContext::TemporalLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TemporalLiteralContext::DATE_SYMBOL() {
  return getToken(MySQLParser::DATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TemporalLiteralContext::SINGLE_QUOTED_TEXT() {
  return getToken(MySQLParser::SINGLE_QUOTED_TEXT, 0);
}

tree::TerminalNode* MySQLParser::TemporalLiteralContext::TIME_SYMBOL() {
  return getToken(MySQLParser::TIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TemporalLiteralContext::TIMESTAMP_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_SYMBOL, 0);
}


size_t MySQLParser::TemporalLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleTemporalLiteral;
}

void MySQLParser::TemporalLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemporalLiteral(this);
}

void MySQLParser::TemporalLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemporalLiteral(this);
}


antlrcpp::Any MySQLParser::TemporalLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTemporalLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TemporalLiteralContext* MySQLParser::temporalLiteral() {
  TemporalLiteralContext *_localctx = _tracker.createInstance<TemporalLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1130, MySQLParser::RuleTemporalLiteral);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7994);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::DATE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7988);
        match(MySQLParser::DATE_SYMBOL);
        setState(7989);
        match(MySQLParser::SINGLE_QUOTED_TEXT);
        break;
      }

      case MySQLParser::TIME_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7990);
        match(MySQLParser::TIME_SYMBOL);
        setState(7991);
        match(MySQLParser::SINGLE_QUOTED_TEXT);
        break;
      }

      case MySQLParser::TIMESTAMP_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(7992);
        match(MySQLParser::TIMESTAMP_SYMBOL);
        setState(7993);
        match(MySQLParser::SINGLE_QUOTED_TEXT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FloatOptionsContext ------------------------------------------------------------------

MySQLParser::FloatOptionsContext::FloatOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::FieldLengthContext* MySQLParser::FloatOptionsContext::fieldLength() {
  return getRuleContext<MySQLParser::FieldLengthContext>(0);
}

MySQLParser::PrecisionContext* MySQLParser::FloatOptionsContext::precision() {
  return getRuleContext<MySQLParser::PrecisionContext>(0);
}


size_t MySQLParser::FloatOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleFloatOptions;
}

void MySQLParser::FloatOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFloatOptions(this);
}

void MySQLParser::FloatOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFloatOptions(this);
}


antlrcpp::Any MySQLParser::FloatOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitFloatOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FloatOptionsContext* MySQLParser::floatOptions() {
  FloatOptionsContext *_localctx = _tracker.createInstance<FloatOptionsContext>(_ctx, getState());
  enterRule(_localctx, 1132, MySQLParser::RuleFloatOptions);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7998);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1074, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7996);
      fieldLength();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7997);
      precision();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrecisionContext ------------------------------------------------------------------

MySQLParser::PrecisionContext::PrecisionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::PrecisionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::PrecisionContext::INT_NUMBER() {
  return getTokens(MySQLParser::INT_NUMBER);
}

tree::TerminalNode* MySQLParser::PrecisionContext::INT_NUMBER(size_t i) {
  return getToken(MySQLParser::INT_NUMBER, i);
}

tree::TerminalNode* MySQLParser::PrecisionContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PrecisionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::PrecisionContext::getRuleIndex() const {
  return MySQLParser::RulePrecision;
}

void MySQLParser::PrecisionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrecision(this);
}

void MySQLParser::PrecisionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrecision(this);
}


antlrcpp::Any MySQLParser::PrecisionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitPrecision(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PrecisionContext* MySQLParser::precision() {
  PrecisionContext *_localctx = _tracker.createInstance<PrecisionContext>(_ctx, getState());
  enterRule(_localctx, 1134, MySQLParser::RulePrecision);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8000);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(8001);
    match(MySQLParser::INT_NUMBER);
    setState(8002);
    match(MySQLParser::COMMA_SYMBOL);
    setState(8003);
    match(MySQLParser::INT_NUMBER);
    setState(8004);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextOrIdentifierContext ------------------------------------------------------------------

MySQLParser::TextOrIdentifierContext::TextOrIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TextOrIdentifierContext::SINGLE_QUOTED_TEXT() {
  return getToken(MySQLParser::SINGLE_QUOTED_TEXT, 0);
}

MySQLParser::IdentifierContext* MySQLParser::TextOrIdentifierContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::TextOrIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleTextOrIdentifier;
}

void MySQLParser::TextOrIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextOrIdentifier(this);
}

void MySQLParser::TextOrIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextOrIdentifier(this);
}


antlrcpp::Any MySQLParser::TextOrIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitTextOrIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::textOrIdentifier() {
  TextOrIdentifierContext *_localctx = _tracker.createInstance<TextOrIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1136, MySQLParser::RuleTextOrIdentifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8008);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1075, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8006);
      match(MySQLParser::SINGLE_QUOTED_TEXT);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8007);
      identifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleIdentifierOrTextContext ------------------------------------------------------------------

MySQLParser::RoleIdentifierOrTextContext::RoleIdentifierOrTextContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RoleIdentifierContext* MySQLParser::RoleIdentifierOrTextContext::roleIdentifier() {
  return getRuleContext<MySQLParser::RoleIdentifierContext>(0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::RoleIdentifierOrTextContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}


size_t MySQLParser::RoleIdentifierOrTextContext::getRuleIndex() const {
  return MySQLParser::RuleRoleIdentifierOrText;
}

void MySQLParser::RoleIdentifierOrTextContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleIdentifierOrText(this);
}

void MySQLParser::RoleIdentifierOrTextContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleIdentifierOrText(this);
}


antlrcpp::Any MySQLParser::RoleIdentifierOrTextContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRoleIdentifierOrText(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoleIdentifierOrTextContext* MySQLParser::roleIdentifierOrText() {
  RoleIdentifierOrTextContext *_localctx = _tracker.createInstance<RoleIdentifierOrTextContext>(_ctx, getState());
  enterRule(_localctx, 1138, MySQLParser::RuleRoleIdentifierOrText);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8012);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1076, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8010);
      roleIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8011);
      textStringLiteral();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SizeNumberContext ------------------------------------------------------------------

MySQLParser::SizeNumberContext::SizeNumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::Real_ulonglong_numberContext* MySQLParser::SizeNumberContext::real_ulonglong_number() {
  return getRuleContext<MySQLParser::Real_ulonglong_numberContext>(0);
}

MySQLParser::PureIdentifierContext* MySQLParser::SizeNumberContext::pureIdentifier() {
  return getRuleContext<MySQLParser::PureIdentifierContext>(0);
}


size_t MySQLParser::SizeNumberContext::getRuleIndex() const {
  return MySQLParser::RuleSizeNumber;
}

void MySQLParser::SizeNumberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSizeNumber(this);
}

void MySQLParser::SizeNumberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSizeNumber(this);
}


antlrcpp::Any MySQLParser::SizeNumberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSizeNumber(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SizeNumberContext* MySQLParser::sizeNumber() {
  SizeNumberContext *_localctx = _tracker.createInstance<SizeNumberContext>(_ctx, getState());
  enterRule(_localctx, 1140, MySQLParser::RuleSizeNumber);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8016);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1077, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8014);
      real_ulonglong_number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8015);
      pureIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParenthesesContext ------------------------------------------------------------------

MySQLParser::ParenthesesContext::ParenthesesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ParenthesesContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ParenthesesContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::ParenthesesContext::getRuleIndex() const {
  return MySQLParser::RuleParentheses;
}

void MySQLParser::ParenthesesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParentheses(this);
}

void MySQLParser::ParenthesesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParentheses(this);
}


antlrcpp::Any MySQLParser::ParenthesesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitParentheses(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ParenthesesContext* MySQLParser::parentheses() {
  ParenthesesContext *_localctx = _tracker.createInstance<ParenthesesContext>(_ctx, getState());
  enterRule(_localctx, 1142, MySQLParser::RuleParentheses);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8018);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(8019);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EqualContext ------------------------------------------------------------------

MySQLParser::EqualContext::EqualContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::EqualContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::EqualContext::ASSIGN_OPERATOR() {
  return getToken(MySQLParser::ASSIGN_OPERATOR, 0);
}


size_t MySQLParser::EqualContext::getRuleIndex() const {
  return MySQLParser::RuleEqual;
}

void MySQLParser::EqualContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEqual(this);
}

void MySQLParser::EqualContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEqual(this);
}


antlrcpp::Any MySQLParser::EqualContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitEqual(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::EqualContext* MySQLParser::equal() {
  EqualContext *_localctx = _tracker.createInstance<EqualContext>(_ctx, getState());
  enterRule(_localctx, 1144, MySQLParser::RuleEqual);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8021);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::EQUAL_OPERATOR

    || _la == MySQLParser::ASSIGN_OPERATOR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionTypeContext ------------------------------------------------------------------

MySQLParser::OptionTypeContext::OptionTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::OptionTypeContext::PERSIST_SYMBOL() {
  return getToken(MySQLParser::PERSIST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OptionTypeContext::PERSIST_ONLY_SYMBOL() {
  return getToken(MySQLParser::PERSIST_ONLY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OptionTypeContext::GLOBAL_SYMBOL() {
  return getToken(MySQLParser::GLOBAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OptionTypeContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OptionTypeContext::SESSION_SYMBOL() {
  return getToken(MySQLParser::SESSION_SYMBOL, 0);
}


size_t MySQLParser::OptionTypeContext::getRuleIndex() const {
  return MySQLParser::RuleOptionType;
}

void MySQLParser::OptionTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionType(this);
}

void MySQLParser::OptionTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionType(this);
}


antlrcpp::Any MySQLParser::OptionTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitOptionType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OptionTypeContext* MySQLParser::optionType() {
  OptionTypeContext *_localctx = _tracker.createInstance<OptionTypeContext>(_ctx, getState());
  enterRule(_localctx, 1146, MySQLParser::RuleOptionType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8023);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::GLOBAL_SYMBOL

    || _la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::SESSION_SYMBOL || _la == MySQLParser::PERSIST_SYMBOL

    || _la == MySQLParser::PERSIST_ONLY_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarIdentTypeContext ------------------------------------------------------------------

MySQLParser::VarIdentTypeContext::VarIdentTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::VarIdentTypeContext::GLOBAL_SYMBOL() {
  return getToken(MySQLParser::GLOBAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::VarIdentTypeContext::DOT_SYMBOL() {
  return getToken(MySQLParser::DOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::VarIdentTypeContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::VarIdentTypeContext::SESSION_SYMBOL() {
  return getToken(MySQLParser::SESSION_SYMBOL, 0);
}


size_t MySQLParser::VarIdentTypeContext::getRuleIndex() const {
  return MySQLParser::RuleVarIdentType;
}

void MySQLParser::VarIdentTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarIdentType(this);
}

void MySQLParser::VarIdentTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarIdentType(this);
}


antlrcpp::Any MySQLParser::VarIdentTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitVarIdentType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::VarIdentTypeContext* MySQLParser::varIdentType() {
  VarIdentTypeContext *_localctx = _tracker.createInstance<VarIdentTypeContext>(_ctx, getState());
  enterRule(_localctx, 1148, MySQLParser::RuleVarIdentType);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8031);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::GLOBAL_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(8025);
        match(MySQLParser::GLOBAL_SYMBOL);
        setState(8026);
        match(MySQLParser::DOT_SYMBOL);
        break;
      }

      case MySQLParser::LOCAL_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(8027);
        match(MySQLParser::LOCAL_SYMBOL);
        setState(8028);
        match(MySQLParser::DOT_SYMBOL);
        break;
      }

      case MySQLParser::SESSION_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(8029);
        match(MySQLParser::SESSION_SYMBOL);
        setState(8030);
        match(MySQLParser::DOT_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetVarIdentTypeContext ------------------------------------------------------------------

MySQLParser::SetVarIdentTypeContext::SetVarIdentTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SetVarIdentTypeContext::PERSIST_SYMBOL() {
  return getToken(MySQLParser::PERSIST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetVarIdentTypeContext::DOT_SYMBOL() {
  return getToken(MySQLParser::DOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetVarIdentTypeContext::PERSIST_ONLY_SYMBOL() {
  return getToken(MySQLParser::PERSIST_ONLY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetVarIdentTypeContext::GLOBAL_SYMBOL() {
  return getToken(MySQLParser::GLOBAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetVarIdentTypeContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetVarIdentTypeContext::SESSION_SYMBOL() {
  return getToken(MySQLParser::SESSION_SYMBOL, 0);
}


size_t MySQLParser::SetVarIdentTypeContext::getRuleIndex() const {
  return MySQLParser::RuleSetVarIdentType;
}

void MySQLParser::SetVarIdentTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetVarIdentType(this);
}

void MySQLParser::SetVarIdentTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetVarIdentType(this);
}


antlrcpp::Any MySQLParser::SetVarIdentTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitSetVarIdentType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SetVarIdentTypeContext* MySQLParser::setVarIdentType() {
  SetVarIdentTypeContext *_localctx = _tracker.createInstance<SetVarIdentTypeContext>(_ctx, getState());
  enterRule(_localctx, 1150, MySQLParser::RuleSetVarIdentType);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8043);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::PERSIST_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(8033);
        match(MySQLParser::PERSIST_SYMBOL);
        setState(8034);
        match(MySQLParser::DOT_SYMBOL);
        break;
      }

      case MySQLParser::PERSIST_ONLY_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(8035);
        match(MySQLParser::PERSIST_ONLY_SYMBOL);
        setState(8036);
        match(MySQLParser::DOT_SYMBOL);
        break;
      }

      case MySQLParser::GLOBAL_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(8037);
        match(MySQLParser::GLOBAL_SYMBOL);
        setState(8038);
        match(MySQLParser::DOT_SYMBOL);
        break;
      }

      case MySQLParser::LOCAL_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(8039);
        match(MySQLParser::LOCAL_SYMBOL);
        setState(8040);
        match(MySQLParser::DOT_SYMBOL);
        break;
      }

      case MySQLParser::SESSION_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(8041);
        match(MySQLParser::SESSION_SYMBOL);
        setState(8042);
        match(MySQLParser::DOT_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierKeywordContext ------------------------------------------------------------------

MySQLParser::IdentifierKeywordContext::IdentifierKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LabelKeywordContext* MySQLParser::IdentifierKeywordContext::labelKeyword() {
  return getRuleContext<MySQLParser::LabelKeywordContext>(0);
}

MySQLParser::RoleOrIdentifierKeywordContext* MySQLParser::IdentifierKeywordContext::roleOrIdentifierKeyword() {
  return getRuleContext<MySQLParser::RoleOrIdentifierKeywordContext>(0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordContext::EXECUTE_SYMBOL() {
  return getToken(MySQLParser::EXECUTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordContext::SHUTDOWN_SYMBOL() {
  return getToken(MySQLParser::SHUTDOWN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordContext::RESTART_SYMBOL() {
  return getToken(MySQLParser::RESTART_SYMBOL, 0);
}


size_t MySQLParser::IdentifierKeywordContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifierKeyword;
}

void MySQLParser::IdentifierKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierKeyword(this);
}

void MySQLParser::IdentifierKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierKeyword(this);
}


antlrcpp::Any MySQLParser::IdentifierKeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitIdentifierKeyword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentifierKeywordContext* MySQLParser::identifierKeyword() {
  IdentifierKeywordContext *_localctx = _tracker.createInstance<IdentifierKeywordContext>(_ctx, getState());
  enterRule(_localctx, 1152, MySQLParser::RuleIdentifierKeyword);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8052);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1080, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8045);
      labelKeyword();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8046);
      roleOrIdentifierKeyword();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(8047);
      match(MySQLParser::EXECUTE_SYMBOL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(8048);

      if (!(serverVersion >= 50709)) throw FailedPredicateException(this, "serverVersion >= 50709");
      setState(8049);
      match(MySQLParser::SHUTDOWN_SYMBOL);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(8050);

      if (!(serverVersion >= 80011)) throw FailedPredicateException(this, "serverVersion >= 80011");
      setState(8051);
      match(MySQLParser::RESTART_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelKeywordContext ------------------------------------------------------------------

MySQLParser::LabelKeywordContext::LabelKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RoleOrLabelKeywordContext* MySQLParser::LabelKeywordContext::roleOrLabelKeyword() {
  return getRuleContext<MySQLParser::RoleOrLabelKeywordContext>(0);
}

tree::TerminalNode* MySQLParser::LabelKeywordContext::EVENT_SYMBOL() {
  return getToken(MySQLParser::EVENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LabelKeywordContext::FILE_SYMBOL() {
  return getToken(MySQLParser::FILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LabelKeywordContext::NONE_SYMBOL() {
  return getToken(MySQLParser::NONE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LabelKeywordContext::PROCESS_SYMBOL() {
  return getToken(MySQLParser::PROCESS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LabelKeywordContext::PROXY_SYMBOL() {
  return getToken(MySQLParser::PROXY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LabelKeywordContext::RELOAD_SYMBOL() {
  return getToken(MySQLParser::RELOAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LabelKeywordContext::REPLICATION_SYMBOL() {
  return getToken(MySQLParser::REPLICATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LabelKeywordContext::RESOURCE_SYMBOL() {
  return getToken(MySQLParser::RESOURCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LabelKeywordContext::SUPER_SYMBOL() {
  return getToken(MySQLParser::SUPER_SYMBOL, 0);
}


size_t MySQLParser::LabelKeywordContext::getRuleIndex() const {
  return MySQLParser::RuleLabelKeyword;
}

void MySQLParser::LabelKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabelKeyword(this);
}

void MySQLParser::LabelKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabelKeyword(this);
}


antlrcpp::Any MySQLParser::LabelKeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitLabelKeyword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LabelKeywordContext* MySQLParser::labelKeyword() {
  LabelKeywordContext *_localctx = _tracker.createInstance<LabelKeywordContext>(_ctx, getState());
  enterRule(_localctx, 1154, MySQLParser::RuleLabelKeyword);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8064);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1081, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8054);
      roleOrLabelKeyword();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8055);
      match(MySQLParser::EVENT_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(8056);
      match(MySQLParser::FILE_SYMBOL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(8057);
      match(MySQLParser::NONE_SYMBOL);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(8058);
      match(MySQLParser::PROCESS_SYMBOL);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(8059);
      match(MySQLParser::PROXY_SYMBOL);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(8060);
      match(MySQLParser::RELOAD_SYMBOL);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(8061);
      match(MySQLParser::REPLICATION_SYMBOL);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(8062);
      match(MySQLParser::RESOURCE_SYMBOL);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(8063);
      match(MySQLParser::SUPER_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleOrIdentifierKeywordContext ------------------------------------------------------------------

MySQLParser::RoleOrIdentifierKeywordContext::RoleOrIdentifierKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::ACCOUNT_SYMBOL() {
  return getToken(MySQLParser::ACCOUNT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::ASCII_SYMBOL() {
  return getToken(MySQLParser::ASCII_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::ALWAYS_SYMBOL() {
  return getToken(MySQLParser::ALWAYS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::BACKUP_SYMBOL() {
  return getToken(MySQLParser::BACKUP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::BEGIN_SYMBOL() {
  return getToken(MySQLParser::BEGIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::BYTE_SYMBOL() {
  return getToken(MySQLParser::BYTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::CACHE_SYMBOL() {
  return getToken(MySQLParser::CACHE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::CHARSET_SYMBOL() {
  return getToken(MySQLParser::CHARSET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::CHECKSUM_SYMBOL() {
  return getToken(MySQLParser::CHECKSUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::CLONE_SYMBOL() {
  return getToken(MySQLParser::CLONE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::CLOSE_SYMBOL() {
  return getToken(MySQLParser::CLOSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::COMMIT_SYMBOL() {
  return getToken(MySQLParser::COMMIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::CONTAINS_SYMBOL() {
  return getToken(MySQLParser::CONTAINS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::DEALLOCATE_SYMBOL() {
  return getToken(MySQLParser::DEALLOCATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::DO_SYMBOL() {
  return getToken(MySQLParser::DO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::FLUSH_SYMBOL() {
  return getToken(MySQLParser::FLUSH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::FOLLOWS_SYMBOL() {
  return getToken(MySQLParser::FOLLOWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::FORMAT_SYMBOL() {
  return getToken(MySQLParser::FORMAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::GROUP_REPLICATION_SYMBOL() {
  return getToken(MySQLParser::GROUP_REPLICATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::HANDLER_SYMBOL() {
  return getToken(MySQLParser::HANDLER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::HELP_SYMBOL() {
  return getToken(MySQLParser::HELP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::HOST_SYMBOL() {
  return getToken(MySQLParser::HOST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::INSTALL_SYMBOL() {
  return getToken(MySQLParser::INSTALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::INVISIBLE_SYMBOL() {
  return getToken(MySQLParser::INVISIBLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::LANGUAGE_SYMBOL() {
  return getToken(MySQLParser::LANGUAGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::NO_SYMBOL() {
  return getToken(MySQLParser::NO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::OPEN_SYMBOL() {
  return getToken(MySQLParser::OPEN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::OPTIONS_SYMBOL() {
  return getToken(MySQLParser::OPTIONS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::OWNER_SYMBOL() {
  return getToken(MySQLParser::OWNER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::PARSER_SYMBOL() {
  return getToken(MySQLParser::PARSER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::PORT_SYMBOL() {
  return getToken(MySQLParser::PORT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::PRECEDES_SYMBOL() {
  return getToken(MySQLParser::PRECEDES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::PREPARE_SYMBOL() {
  return getToken(MySQLParser::PREPARE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::REMOVE_SYMBOL() {
  return getToken(MySQLParser::REMOVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::REPAIR_SYMBOL() {
  return getToken(MySQLParser::REPAIR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::RESET_SYMBOL() {
  return getToken(MySQLParser::RESET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::RESTORE_SYMBOL() {
  return getToken(MySQLParser::RESTORE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::ROLLBACK_SYMBOL() {
  return getToken(MySQLParser::ROLLBACK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SAVEPOINT_SYMBOL() {
  return getToken(MySQLParser::SAVEPOINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SECONDARY_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SECONDARY_ENGINE_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_ENGINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SECONDARY_LOAD_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_LOAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SECONDARY_UNLOAD_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_UNLOAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SECURITY_SYMBOL() {
  return getToken(MySQLParser::SECURITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SERVER_SYMBOL() {
  return getToken(MySQLParser::SERVER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SIGNED_SYMBOL() {
  return getToken(MySQLParser::SIGNED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SOCKET_SYMBOL() {
  return getToken(MySQLParser::SOCKET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SLAVE_SYMBOL() {
  return getToken(MySQLParser::SLAVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SONAME_SYMBOL() {
  return getToken(MySQLParser::SONAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::START_SYMBOL() {
  return getToken(MySQLParser::START_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::STOP_SYMBOL() {
  return getToken(MySQLParser::STOP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::TRUNCATE_SYMBOL() {
  return getToken(MySQLParser::TRUNCATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::UNICODE_SYMBOL() {
  return getToken(MySQLParser::UNICODE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::UNINSTALL_SYMBOL() {
  return getToken(MySQLParser::UNINSTALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::UPGRADE_SYMBOL() {
  return getToken(MySQLParser::UPGRADE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::VISIBLE_SYMBOL() {
  return getToken(MySQLParser::VISIBLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::WRAPPER_SYMBOL() {
  return getToken(MySQLParser::WRAPPER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::XA_SYMBOL() {
  return getToken(MySQLParser::XA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SHUTDOWN_SYMBOL() {
  return getToken(MySQLParser::SHUTDOWN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::IMPORT_SYMBOL() {
  return getToken(MySQLParser::IMPORT_SYMBOL, 0);
}


size_t MySQLParser::RoleOrIdentifierKeywordContext::getRuleIndex() const {
  return MySQLParser::RuleRoleOrIdentifierKeyword;
}

void MySQLParser::RoleOrIdentifierKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleOrIdentifierKeyword(this);
}

void MySQLParser::RoleOrIdentifierKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleOrIdentifierKeyword(this);
}


antlrcpp::Any MySQLParser::RoleOrIdentifierKeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRoleOrIdentifierKeyword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoleOrIdentifierKeywordContext* MySQLParser::roleOrIdentifierKeyword() {
  RoleOrIdentifierKeywordContext *_localctx = _tracker.createInstance<RoleOrIdentifierKeywordContext>(_ctx, getState());
  enterRule(_localctx, 1156, MySQLParser::RuleRoleOrIdentifierKeyword);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8071);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1082, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8066);
      _la = _input->LA(1);
      if (!((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MySQLParser::ACCOUNT_SYMBOL)
        | (1ULL << MySQLParser::ASCII_SYMBOL)
        | (1ULL << MySQLParser::ALWAYS_SYMBOL)
        | (1ULL << MySQLParser::BACKUP_SYMBOL)
        | (1ULL << MySQLParser::BEGIN_SYMBOL)
        | (1ULL << MySQLParser::BYTE_SYMBOL)
        | (1ULL << MySQLParser::CACHE_SYMBOL)
        | (1ULL << MySQLParser::CHARSET_SYMBOL)
        | (1ULL << MySQLParser::CHECKSUM_SYMBOL)
        | (1ULL << MySQLParser::CLOSE_SYMBOL)
        | (1ULL << MySQLParser::COMMENT_SYMBOL)
        | (1ULL << MySQLParser::COMMIT_SYMBOL)
        | (1ULL << MySQLParser::CONTAINS_SYMBOL)
        | (1ULL << MySQLParser::DEALLOCATE_SYMBOL)
        | (1ULL << MySQLParser::DO_SYMBOL)
        | (1ULL << MySQLParser::END_SYMBOL)
        | (1ULL << MySQLParser::FLUSH_SYMBOL)
        | (1ULL << MySQLParser::FOLLOWS_SYMBOL)
        | (1ULL << MySQLParser::FORMAT_SYMBOL)
        | (1ULL << MySQLParser::GROUP_REPLICATION_SYMBOL)
        | (1ULL << MySQLParser::HANDLER_SYMBOL)
        | (1ULL << MySQLParser::HELP_SYMBOL)
        | (1ULL << MySQLParser::HOST_SYMBOL)
        | (1ULL << MySQLParser::INSTALL_SYMBOL)
        | (1ULL << MySQLParser::LANGUAGE_SYMBOL)
        | (1ULL << MySQLParser::NO_SYMBOL)
        | (1ULL << MySQLParser::OPEN_SYMBOL)
        | (1ULL << MySQLParser::OPTIONS_SYMBOL)
        | (1ULL << MySQLParser::OWNER_SYMBOL)
        | (1ULL << MySQLParser::PARSER_SYMBOL)
        | (1ULL << MySQLParser::PARTITION_SYMBOL)
        | (1ULL << MySQLParser::PORT_SYMBOL)
        | (1ULL << MySQLParser::PRECEDES_SYMBOL)
        | (1ULL << MySQLParser::PREPARE_SYMBOL)
        | (1ULL << MySQLParser::REMOVE_SYMBOL)
        | (1ULL << MySQLParser::REPAIR_SYMBOL)
        | (1ULL << MySQLParser::RESET_SYMBOL)
        | (1ULL << MySQLParser::RESTORE_SYMBOL)
        | (1ULL << MySQLParser::ROLLBACK_SYMBOL)
        | (1ULL << MySQLParser::SAVEPOINT_SYMBOL)
        | (1ULL << MySQLParser::SECURITY_SYMBOL)
        | (1ULL << MySQLParser::SERVER_SYMBOL)
        | (1ULL << MySQLParser::SIGNED_SYMBOL)
        | (1ULL << MySQLParser::SLAVE_SYMBOL)
        | (1ULL << MySQLParser::SOCKET_SYMBOL)
        | (1ULL << MySQLParser::SONAME_SYMBOL)
        | (1ULL << MySQLParser::START_SYMBOL)
        | (1ULL << MySQLParser::STOP_SYMBOL)
        | (1ULL << MySQLParser::TRUNCATE_SYMBOL)
        | (1ULL << MySQLParser::UNICODE_SYMBOL)
        | (1ULL << MySQLParser::UNINSTALL_SYMBOL)
        | (1ULL << MySQLParser::UPGRADE_SYMBOL)
        | (1ULL << MySQLParser::WRAPPER_SYMBOL)
        | (1ULL << MySQLParser::XA_SYMBOL))) != 0) || ((((_la - 690) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 690)) & ((1ULL << (MySQLParser::ROLE_SYMBOL - 690))
        | (1ULL << (MySQLParser::INVISIBLE_SYMBOL - 690))
        | (1ULL << (MySQLParser::VISIBLE_SYMBOL - 690))
        | (1ULL << (MySQLParser::CLONE_SYMBOL - 690))
        | (1ULL << (MySQLParser::SECONDARY_SYMBOL - 690))
        | (1ULL << (MySQLParser::SECONDARY_ENGINE_SYMBOL - 690))
        | (1ULL << (MySQLParser::SECONDARY_LOAD_SYMBOL - 690)))) != 0) || _la == MySQLParser::SECONDARY_UNLOAD_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8067);

      if (!(serverVersion >= 50709)) throw FailedPredicateException(this, "serverVersion >= 50709");
      setState(8068);
      match(MySQLParser::SHUTDOWN_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(8069);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(8070);
      match(MySQLParser::IMPORT_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleOrLabelKeywordContext ------------------------------------------------------------------

MySQLParser::RoleOrLabelKeywordContext::RoleOrLabelKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ACTION_SYMBOL() {
  return getToken(MySQLParser::ACTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ACTIVE_SYMBOL() {
  return getToken(MySQLParser::ACTIVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ADDDATE_SYMBOL() {
  return getToken(MySQLParser::ADDDATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::AFTER_SYMBOL() {
  return getToken(MySQLParser::AFTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::AGAINST_SYMBOL() {
  return getToken(MySQLParser::AGAINST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::AGGREGATE_SYMBOL() {
  return getToken(MySQLParser::AGGREGATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ALGORITHM_SYMBOL() {
  return getToken(MySQLParser::ALGORITHM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ANALYSE_SYMBOL() {
  return getToken(MySQLParser::ANALYSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ANY_SYMBOL() {
  return getToken(MySQLParser::ANY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::AT_SYMBOL() {
  return getToken(MySQLParser::AT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::AUTHORS_SYMBOL() {
  return getToken(MySQLParser::AUTHORS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::AUTO_INCREMENT_SYMBOL() {
  return getToken(MySQLParser::AUTO_INCREMENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::AUTOEXTEND_SIZE_SYMBOL() {
  return getToken(MySQLParser::AUTOEXTEND_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::AVG_ROW_LENGTH_SYMBOL() {
  return getToken(MySQLParser::AVG_ROW_LENGTH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::AVG_SYMBOL() {
  return getToken(MySQLParser::AVG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::BINLOG_SYMBOL() {
  return getToken(MySQLParser::BINLOG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::BIT_SYMBOL() {
  return getToken(MySQLParser::BIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::BLOCK_SYMBOL() {
  return getToken(MySQLParser::BLOCK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::BOOL_SYMBOL() {
  return getToken(MySQLParser::BOOL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::BOOLEAN_SYMBOL() {
  return getToken(MySQLParser::BOOLEAN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::BTREE_SYMBOL() {
  return getToken(MySQLParser::BTREE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::BUCKETS_SYMBOL() {
  return getToken(MySQLParser::BUCKETS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CASCADED_SYMBOL() {
  return getToken(MySQLParser::CASCADED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CATALOG_NAME_SYMBOL() {
  return getToken(MySQLParser::CATALOG_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CHAIN_SYMBOL() {
  return getToken(MySQLParser::CHAIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CHANGED_SYMBOL() {
  return getToken(MySQLParser::CHANGED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CHANNEL_SYMBOL() {
  return getToken(MySQLParser::CHANNEL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CIPHER_SYMBOL() {
  return getToken(MySQLParser::CIPHER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CLIENT_SYMBOL() {
  return getToken(MySQLParser::CLIENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CLASS_ORIGIN_SYMBOL() {
  return getToken(MySQLParser::CLASS_ORIGIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::COALESCE_SYMBOL() {
  return getToken(MySQLParser::COALESCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CODE_SYMBOL() {
  return getToken(MySQLParser::CODE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::COLLATION_SYMBOL() {
  return getToken(MySQLParser::COLLATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::COLUMN_NAME_SYMBOL() {
  return getToken(MySQLParser::COLUMN_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::COLUMN_FORMAT_SYMBOL() {
  return getToken(MySQLParser::COLUMN_FORMAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::COLUMNS_SYMBOL() {
  return getToken(MySQLParser::COLUMNS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::COMMITTED_SYMBOL() {
  return getToken(MySQLParser::COMMITTED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::COMPACT_SYMBOL() {
  return getToken(MySQLParser::COMPACT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::COMPLETION_SYMBOL() {
  return getToken(MySQLParser::COMPLETION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::COMPONENT_SYMBOL() {
  return getToken(MySQLParser::COMPONENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::COMPRESSED_SYMBOL() {
  return getToken(MySQLParser::COMPRESSED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::COMPRESSION_SYMBOL() {
  return getToken(MySQLParser::COMPRESSION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CONCURRENT_SYMBOL() {
  return getToken(MySQLParser::CONCURRENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CONNECTION_SYMBOL() {
  return getToken(MySQLParser::CONNECTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CONSISTENT_SYMBOL() {
  return getToken(MySQLParser::CONSISTENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CONSTRAINT_CATALOG_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_CATALOG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CONSTRAINT_SCHEMA_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_SCHEMA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CONSTRAINT_NAME_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CONTEXT_SYMBOL() {
  return getToken(MySQLParser::CONTEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CONTRIBUTORS_SYMBOL() {
  return getToken(MySQLParser::CONTRIBUTORS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CPU_SYMBOL() {
  return getToken(MySQLParser::CPU_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CURRENT_SYMBOL() {
  return getToken(MySQLParser::CURRENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CURSOR_NAME_SYMBOL() {
  return getToken(MySQLParser::CURSOR_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DATAFILE_SYMBOL() {
  return getToken(MySQLParser::DATAFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DATETIME_SYMBOL() {
  return getToken(MySQLParser::DATETIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DATE_SYMBOL() {
  return getToken(MySQLParser::DATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DAY_SYMBOL() {
  return getToken(MySQLParser::DAY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DEFAULT_AUTH_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_AUTH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DEFINER_SYMBOL() {
  return getToken(MySQLParser::DEFINER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DELAY_KEY_WRITE_SYMBOL() {
  return getToken(MySQLParser::DELAY_KEY_WRITE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DES_KEY_FILE_SYMBOL() {
  return getToken(MySQLParser::DES_KEY_FILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DESCRIPTION_SYMBOL() {
  return getToken(MySQLParser::DESCRIPTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DIAGNOSTICS_SYMBOL() {
  return getToken(MySQLParser::DIAGNOSTICS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DIRECTORY_SYMBOL() {
  return getToken(MySQLParser::DIRECTORY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DISABLE_SYMBOL() {
  return getToken(MySQLParser::DISABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DISCARD_SYMBOL() {
  return getToken(MySQLParser::DISCARD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DISK_SYMBOL() {
  return getToken(MySQLParser::DISK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DUMPFILE_SYMBOL() {
  return getToken(MySQLParser::DUMPFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DUPLICATE_SYMBOL() {
  return getToken(MySQLParser::DUPLICATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DYNAMIC_SYMBOL() {
  return getToken(MySQLParser::DYNAMIC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ENCRYPTION_SYMBOL() {
  return getToken(MySQLParser::ENCRYPTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ENDS_SYMBOL() {
  return getToken(MySQLParser::ENDS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ENUM_SYMBOL() {
  return getToken(MySQLParser::ENUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ENGINES_SYMBOL() {
  return getToken(MySQLParser::ENGINES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ERROR_SYMBOL() {
  return getToken(MySQLParser::ERROR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ERRORS_SYMBOL() {
  return getToken(MySQLParser::ERRORS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ESCAPE_SYMBOL() {
  return getToken(MySQLParser::ESCAPE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::EVENTS_SYMBOL() {
  return getToken(MySQLParser::EVENTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::EVERY_SYMBOL() {
  return getToken(MySQLParser::EVERY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::EXCLUDE_SYMBOL() {
  return getToken(MySQLParser::EXCLUDE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::EXPANSION_SYMBOL() {
  return getToken(MySQLParser::EXPANSION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::EXPORT_SYMBOL() {
  return getToken(MySQLParser::EXPORT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::EXTENT_SIZE_SYMBOL() {
  return getToken(MySQLParser::EXTENT_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::FAULTS_SYMBOL() {
  return getToken(MySQLParser::FAULTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::FAST_SYMBOL() {
  return getToken(MySQLParser::FAST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::FOLLOWING_SYMBOL() {
  return getToken(MySQLParser::FOLLOWING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::FOUND_SYMBOL() {
  return getToken(MySQLParser::FOUND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ENABLE_SYMBOL() {
  return getToken(MySQLParser::ENABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::FULL_SYMBOL() {
  return getToken(MySQLParser::FULL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::FILE_BLOCK_SIZE_SYMBOL() {
  return getToken(MySQLParser::FILE_BLOCK_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::FILTER_SYMBOL() {
  return getToken(MySQLParser::FILTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::FIRST_SYMBOL() {
  return getToken(MySQLParser::FIRST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::FIXED_SYMBOL() {
  return getToken(MySQLParser::FIXED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::GENERAL_SYMBOL() {
  return getToken(MySQLParser::GENERAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::GEOMETRY_SYMBOL() {
  return getToken(MySQLParser::GEOMETRY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::GEOMETRYCOLLECTION_SYMBOL() {
  return getToken(MySQLParser::GEOMETRYCOLLECTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::GET_FORMAT_SYMBOL() {
  return getToken(MySQLParser::GET_FORMAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::GRANTS_SYMBOL() {
  return getToken(MySQLParser::GRANTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::GLOBAL_SYMBOL() {
  return getToken(MySQLParser::GLOBAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::HASH_SYMBOL() {
  return getToken(MySQLParser::HASH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::HISTOGRAM_SYMBOL() {
  return getToken(MySQLParser::HISTOGRAM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::HISTORY_SYMBOL() {
  return getToken(MySQLParser::HISTORY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::HOSTS_SYMBOL() {
  return getToken(MySQLParser::HOSTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::HOUR_SYMBOL() {
  return getToken(MySQLParser::HOUR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::IGNORE_SERVER_IDS_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SERVER_IDS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::INVOKER_SYMBOL() {
  return getToken(MySQLParser::INVOKER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::INDEXES_SYMBOL() {
  return getToken(MySQLParser::INDEXES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::INITIAL_SIZE_SYMBOL() {
  return getToken(MySQLParser::INITIAL_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::INSTANCE_SYMBOL() {
  return getToken(MySQLParser::INSTANCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::INACTIVE_SYMBOL() {
  return getToken(MySQLParser::INACTIVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::IO_SYMBOL() {
  return getToken(MySQLParser::IO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::IPC_SYMBOL() {
  return getToken(MySQLParser::IPC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ISOLATION_SYMBOL() {
  return getToken(MySQLParser::ISOLATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ISSUER_SYMBOL() {
  return getToken(MySQLParser::ISSUER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::INSERT_METHOD_SYMBOL() {
  return getToken(MySQLParser::INSERT_METHOD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::JSON_SYMBOL() {
  return getToken(MySQLParser::JSON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::KEY_BLOCK_SIZE_SYMBOL() {
  return getToken(MySQLParser::KEY_BLOCK_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::LAST_SYMBOL() {
  return getToken(MySQLParser::LAST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::LEAVES_SYMBOL() {
  return getToken(MySQLParser::LEAVES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::LESS_SYMBOL() {
  return getToken(MySQLParser::LESS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::LEVEL_SYMBOL() {
  return getToken(MySQLParser::LEVEL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::LINESTRING_SYMBOL() {
  return getToken(MySQLParser::LINESTRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::LIST_SYMBOL() {
  return getToken(MySQLParser::LIST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::LOCKED_SYMBOL() {
  return getToken(MySQLParser::LOCKED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::LOCKS_SYMBOL() {
  return getToken(MySQLParser::LOCKS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::LOGFILE_SYMBOL() {
  return getToken(MySQLParser::LOGFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::LOGS_SYMBOL() {
  return getToken(MySQLParser::LOGS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MAX_ROWS_SYMBOL() {
  return getToken(MySQLParser::MAX_ROWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_HEARTBEAT_PERIOD_SYMBOL() {
  return getToken(MySQLParser::MASTER_HEARTBEAT_PERIOD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_HOST_SYMBOL() {
  return getToken(MySQLParser::MASTER_HOST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_PORT_SYMBOL() {
  return getToken(MySQLParser::MASTER_PORT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_LOG_FILE_SYMBOL() {
  return getToken(MySQLParser::MASTER_LOG_FILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_LOG_POS_SYMBOL() {
  return getToken(MySQLParser::MASTER_LOG_POS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_USER_SYMBOL() {
  return getToken(MySQLParser::MASTER_USER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_PASSWORD_SYMBOL() {
  return getToken(MySQLParser::MASTER_PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_PUBLIC_KEY_PATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_PUBLIC_KEY_PATH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_SERVER_ID_SYMBOL() {
  return getToken(MySQLParser::MASTER_SERVER_ID_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_CONNECT_RETRY_SYMBOL() {
  return getToken(MySQLParser::MASTER_CONNECT_RETRY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_RETRY_COUNT_SYMBOL() {
  return getToken(MySQLParser::MASTER_RETRY_COUNT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_DELAY_SYMBOL() {
  return getToken(MySQLParser::MASTER_DELAY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_CA_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_CAPATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CAPATH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_TLS_VERSION_SYMBOL() {
  return getToken(MySQLParser::MASTER_TLS_VERSION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_CERT_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CERT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_CIPHER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CIPHER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_CRL_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CRL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_CRLPATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CRLPATH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_KEY_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_AUTO_POSITION_SYMBOL() {
  return getToken(MySQLParser::MASTER_AUTO_POSITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MAX_CONNECTIONS_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MAX_QUERIES_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MAX_STATEMENT_TIME_SYMBOL() {
  return getToken(MySQLParser::MAX_STATEMENT_TIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MAX_SIZE_SYMBOL() {
  return getToken(MySQLParser::MAX_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MAX_UPDATES_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MAX_USER_CONNECTIONS_SYMBOL() {
  return getToken(MySQLParser::MAX_USER_CONNECTIONS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MEDIUM_SYMBOL() {
  return getToken(MySQLParser::MEDIUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MEMORY_SYMBOL() {
  return getToken(MySQLParser::MEMORY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MERGE_SYMBOL() {
  return getToken(MySQLParser::MERGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MESSAGE_TEXT_SYMBOL() {
  return getToken(MySQLParser::MESSAGE_TEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MIGRATE_SYMBOL() {
  return getToken(MySQLParser::MIGRATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MINUTE_SYMBOL() {
  return getToken(MySQLParser::MINUTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MIN_ROWS_SYMBOL() {
  return getToken(MySQLParser::MIN_ROWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MODIFY_SYMBOL() {
  return getToken(MySQLParser::MODIFY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MODE_SYMBOL() {
  return getToken(MySQLParser::MODE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MONTH_SYMBOL() {
  return getToken(MySQLParser::MONTH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MULTILINESTRING_SYMBOL() {
  return getToken(MySQLParser::MULTILINESTRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MULTIPOINT_SYMBOL() {
  return getToken(MySQLParser::MULTIPOINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MULTIPOLYGON_SYMBOL() {
  return getToken(MySQLParser::MULTIPOLYGON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MUTEX_SYMBOL() {
  return getToken(MySQLParser::MUTEX_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MYSQL_ERRNO_SYMBOL() {
  return getToken(MySQLParser::MYSQL_ERRNO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NAME_SYMBOL() {
  return getToken(MySQLParser::NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NAMES_SYMBOL() {
  return getToken(MySQLParser::NAMES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NATIONAL_SYMBOL() {
  return getToken(MySQLParser::NATIONAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NCHAR_SYMBOL() {
  return getToken(MySQLParser::NCHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NDBCLUSTER_SYMBOL() {
  return getToken(MySQLParser::NDBCLUSTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NESTED_SYMBOL() {
  return getToken(MySQLParser::NESTED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NEVER_SYMBOL() {
  return getToken(MySQLParser::NEVER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NEXT_SYMBOL() {
  return getToken(MySQLParser::NEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NEW_SYMBOL() {
  return getToken(MySQLParser::NEW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NO_WAIT_SYMBOL() {
  return getToken(MySQLParser::NO_WAIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NODEGROUP_SYMBOL() {
  return getToken(MySQLParser::NODEGROUP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NULLS_SYMBOL() {
  return getToken(MySQLParser::NULLS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NOWAIT_SYMBOL() {
  return getToken(MySQLParser::NOWAIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NUMBER_SYMBOL() {
  return getToken(MySQLParser::NUMBER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NVARCHAR_SYMBOL() {
  return getToken(MySQLParser::NVARCHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::OFFSET_SYMBOL() {
  return getToken(MySQLParser::OFFSET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::OLD_SYMBOL() {
  return getToken(MySQLParser::OLD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::OLD_PASSWORD_SYMBOL() {
  return getToken(MySQLParser::OLD_PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ONE_SHOT_SYMBOL() {
  return getToken(MySQLParser::ONE_SHOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ONE_SYMBOL() {
  return getToken(MySQLParser::ONE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::OPTIONAL_SYMBOL() {
  return getToken(MySQLParser::OPTIONAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ORDINALITY_SYMBOL() {
  return getToken(MySQLParser::ORDINALITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ORGANIZATION_SYMBOL() {
  return getToken(MySQLParser::ORGANIZATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::OTHERS_SYMBOL() {
  return getToken(MySQLParser::OTHERS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PACK_KEYS_SYMBOL() {
  return getToken(MySQLParser::PACK_KEYS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PAGE_SYMBOL() {
  return getToken(MySQLParser::PAGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PARTIAL_SYMBOL() {
  return getToken(MySQLParser::PARTIAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PARTITIONING_SYMBOL() {
  return getToken(MySQLParser::PARTITIONING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PARTITIONS_SYMBOL() {
  return getToken(MySQLParser::PARTITIONS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PATH_SYMBOL() {
  return getToken(MySQLParser::PATH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PHASE_SYMBOL() {
  return getToken(MySQLParser::PHASE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PLUGIN_DIR_SYMBOL() {
  return getToken(MySQLParser::PLUGIN_DIR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PLUGIN_SYMBOL() {
  return getToken(MySQLParser::PLUGIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PLUGINS_SYMBOL() {
  return getToken(MySQLParser::PLUGINS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::POINT_SYMBOL() {
  return getToken(MySQLParser::POINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::POLYGON_SYMBOL() {
  return getToken(MySQLParser::POLYGON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PRECEDING_SYMBOL() {
  return getToken(MySQLParser::PRECEDING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PRESERVE_SYMBOL() {
  return getToken(MySQLParser::PRESERVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PREV_SYMBOL() {
  return getToken(MySQLParser::PREV_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::THREAD_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::THREAD_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PRIVILEGES_SYMBOL() {
  return getToken(MySQLParser::PRIVILEGES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PROCESSLIST_SYMBOL() {
  return getToken(MySQLParser::PROCESSLIST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PROFILE_SYMBOL() {
  return getToken(MySQLParser::PROFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PROFILES_SYMBOL() {
  return getToken(MySQLParser::PROFILES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::QUARTER_SYMBOL() {
  return getToken(MySQLParser::QUARTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::QUERY_SYMBOL() {
  return getToken(MySQLParser::QUERY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::QUICK_SYMBOL() {
  return getToken(MySQLParser::QUICK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::READ_ONLY_SYMBOL() {
  return getToken(MySQLParser::READ_ONLY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REBUILD_SYMBOL() {
  return getToken(MySQLParser::REBUILD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RECOVER_SYMBOL() {
  return getToken(MySQLParser::RECOVER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REDO_BUFFER_SIZE_SYMBOL() {
  return getToken(MySQLParser::REDO_BUFFER_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REDOFILE_SYMBOL() {
  return getToken(MySQLParser::REDOFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REDUNDANT_SYMBOL() {
  return getToken(MySQLParser::REDUNDANT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RELAY_SYMBOL() {
  return getToken(MySQLParser::RELAY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RELAYLOG_SYMBOL() {
  return getToken(MySQLParser::RELAYLOG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RELAY_LOG_FILE_SYMBOL() {
  return getToken(MySQLParser::RELAY_LOG_FILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RELAY_LOG_POS_SYMBOL() {
  return getToken(MySQLParser::RELAY_LOG_POS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RELAY_THREAD_SYMBOL() {
  return getToken(MySQLParser::RELAY_THREAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REMOTE_SYMBOL() {
  return getToken(MySQLParser::REMOTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REORGANIZE_SYMBOL() {
  return getToken(MySQLParser::REORGANIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REPEATABLE_SYMBOL() {
  return getToken(MySQLParser::REPEATABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REPLICATE_DO_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_DO_DB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REPLICATE_IGNORE_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_IGNORE_DB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REPLICATE_DO_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_DO_TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REPLICATE_IGNORE_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_IGNORE_TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REPLICATE_WILD_DO_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_WILD_DO_TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REPLICATE_WILD_IGNORE_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_WILD_IGNORE_TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REPLICATE_REWRITE_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_REWRITE_DB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::USER_RESOURCES_SYMBOL() {
  return getToken(MySQLParser::USER_RESOURCES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RESPECT_SYMBOL() {
  return getToken(MySQLParser::RESPECT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RESUME_SYMBOL() {
  return getToken(MySQLParser::RESUME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RETAIN_SYMBOL() {
  return getToken(MySQLParser::RETAIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RETURNED_SQLSTATE_SYMBOL() {
  return getToken(MySQLParser::RETURNED_SQLSTATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RETURNS_SYMBOL() {
  return getToken(MySQLParser::RETURNS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REUSE_SYMBOL() {
  return getToken(MySQLParser::REUSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REVERSE_SYMBOL() {
  return getToken(MySQLParser::REVERSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ROLLUP_SYMBOL() {
  return getToken(MySQLParser::ROLLUP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ROTATE_SYMBOL() {
  return getToken(MySQLParser::ROTATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ROUTINE_SYMBOL() {
  return getToken(MySQLParser::ROUTINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ROW_COUNT_SYMBOL() {
  return getToken(MySQLParser::ROW_COUNT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ROW_FORMAT_SYMBOL() {
  return getToken(MySQLParser::ROW_FORMAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RTREE_SYMBOL() {
  return getToken(MySQLParser::RTREE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SCHEDULE_SYMBOL() {
  return getToken(MySQLParser::SCHEDULE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SCHEMA_NAME_SYMBOL() {
  return getToken(MySQLParser::SCHEMA_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SECOND_SYMBOL() {
  return getToken(MySQLParser::SECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SERIAL_SYMBOL() {
  return getToken(MySQLParser::SERIAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SERIALIZABLE_SYMBOL() {
  return getToken(MySQLParser::SERIALIZABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SESSION_SYMBOL() {
  return getToken(MySQLParser::SESSION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SHARE_SYMBOL() {
  return getToken(MySQLParser::SHARE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SIMPLE_SYMBOL() {
  return getToken(MySQLParser::SIMPLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SKIP_SYMBOL() {
  return getToken(MySQLParser::SKIP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SLOW_SYMBOL() {
  return getToken(MySQLParser::SLOW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SNAPSHOT_SYMBOL() {
  return getToken(MySQLParser::SNAPSHOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SOUNDS_SYMBOL() {
  return getToken(MySQLParser::SOUNDS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SOURCE_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SQL_AFTER_GTIDS_SYMBOL() {
  return getToken(MySQLParser::SQL_AFTER_GTIDS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SQL_AFTER_MTS_GAPS_SYMBOL() {
  return getToken(MySQLParser::SQL_AFTER_MTS_GAPS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SQL_BEFORE_GTIDS_SYMBOL() {
  return getToken(MySQLParser::SQL_BEFORE_GTIDS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SQL_CACHE_SYMBOL() {
  return getToken(MySQLParser::SQL_CACHE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SQL_BUFFER_RESULT_SYMBOL() {
  return getToken(MySQLParser::SQL_BUFFER_RESULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SQL_NO_CACHE_SYMBOL() {
  return getToken(MySQLParser::SQL_NO_CACHE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SQL_THREAD_SYMBOL() {
  return getToken(MySQLParser::SQL_THREAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SRID_SYMBOL() {
  return getToken(MySQLParser::SRID_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::STACKED_SYMBOL() {
  return getToken(MySQLParser::STACKED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::STARTS_SYMBOL() {
  return getToken(MySQLParser::STARTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::STATS_AUTO_RECALC_SYMBOL() {
  return getToken(MySQLParser::STATS_AUTO_RECALC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::STATS_PERSISTENT_SYMBOL() {
  return getToken(MySQLParser::STATS_PERSISTENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::STATS_SAMPLE_PAGES_SYMBOL() {
  return getToken(MySQLParser::STATS_SAMPLE_PAGES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::STATUS_SYMBOL() {
  return getToken(MySQLParser::STATUS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::STORAGE_SYMBOL() {
  return getToken(MySQLParser::STORAGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::STRING_SYMBOL() {
  return getToken(MySQLParser::STRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SUBCLASS_ORIGIN_SYMBOL() {
  return getToken(MySQLParser::SUBCLASS_ORIGIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SUBDATE_SYMBOL() {
  return getToken(MySQLParser::SUBDATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SUBJECT_SYMBOL() {
  return getToken(MySQLParser::SUBJECT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SUBPARTITION_SYMBOL() {
  return getToken(MySQLParser::SUBPARTITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SUBPARTITIONS_SYMBOL() {
  return getToken(MySQLParser::SUBPARTITIONS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SUPER_SYMBOL() {
  return getToken(MySQLParser::SUPER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SUSPEND_SYMBOL() {
  return getToken(MySQLParser::SUSPEND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SWAPS_SYMBOL() {
  return getToken(MySQLParser::SWAPS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SWITCHES_SYMBOL() {
  return getToken(MySQLParser::SWITCHES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TABLE_NAME_SYMBOL() {
  return getToken(MySQLParser::TABLE_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TABLE_CHECKSUM_SYMBOL() {
  return getToken(MySQLParser::TABLE_CHECKSUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TEMPORARY_SYMBOL() {
  return getToken(MySQLParser::TEMPORARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TEMPTABLE_SYMBOL() {
  return getToken(MySQLParser::TEMPTABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TEXT_SYMBOL() {
  return getToken(MySQLParser::TEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::THAN_SYMBOL() {
  return getToken(MySQLParser::THAN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TIES_SYMBOL() {
  return getToken(MySQLParser::TIES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TRANSACTION_SYMBOL() {
  return getToken(MySQLParser::TRANSACTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TRIGGERS_SYMBOL() {
  return getToken(MySQLParser::TRIGGERS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TIMESTAMP_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TIMESTAMP_ADD_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_ADD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TIMESTAMP_DIFF_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_DIFF_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TIME_SYMBOL() {
  return getToken(MySQLParser::TIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TYPES_SYMBOL() {
  return getToken(MySQLParser::TYPES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TYPE_SYMBOL() {
  return getToken(MySQLParser::TYPE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::UDF_RETURNS_SYMBOL() {
  return getToken(MySQLParser::UDF_RETURNS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::UNBOUNDED_SYMBOL() {
  return getToken(MySQLParser::UNBOUNDED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::UNCOMMITTED_SYMBOL() {
  return getToken(MySQLParser::UNCOMMITTED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::UNDEFINED_SYMBOL() {
  return getToken(MySQLParser::UNDEFINED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::UNDO_BUFFER_SIZE_SYMBOL() {
  return getToken(MySQLParser::UNDO_BUFFER_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::UNDOFILE_SYMBOL() {
  return getToken(MySQLParser::UNDOFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::UNKNOWN_SYMBOL() {
  return getToken(MySQLParser::UNKNOWN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::UNTIL_SYMBOL() {
  return getToken(MySQLParser::UNTIL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::USE_FRM_SYMBOL() {
  return getToken(MySQLParser::USE_FRM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::VARIABLES_SYMBOL() {
  return getToken(MySQLParser::VARIABLES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::VCPU_SYMBOL() {
  return getToken(MySQLParser::VCPU_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::VIEW_SYMBOL() {
  return getToken(MySQLParser::VIEW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::VALUE_SYMBOL() {
  return getToken(MySQLParser::VALUE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::WARNINGS_SYMBOL() {
  return getToken(MySQLParser::WARNINGS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::WAIT_SYMBOL() {
  return getToken(MySQLParser::WAIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::WEEK_SYMBOL() {
  return getToken(MySQLParser::WEEK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::WORK_SYMBOL() {
  return getToken(MySQLParser::WORK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::WEIGHT_STRING_SYMBOL() {
  return getToken(MySQLParser::WEIGHT_STRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::X509_SYMBOL() {
  return getToken(MySQLParser::X509_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::XID_SYMBOL() {
  return getToken(MySQLParser::XID_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::XML_SYMBOL() {
  return getToken(MySQLParser::XML_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::YEAR_SYMBOL() {
  return getToken(MySQLParser::YEAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SHUTDOWN_SYMBOL() {
  return getToken(MySQLParser::SHUTDOWN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CUBE_SYMBOL() {
  return getToken(MySQLParser::CUBE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::IMPORT_SYMBOL() {
  return getToken(MySQLParser::IMPORT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::FUNCTION_SYMBOL() {
  return getToken(MySQLParser::FUNCTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ROWS_SYMBOL() {
  return getToken(MySQLParser::ROWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ROW_SYMBOL() {
  return getToken(MySQLParser::ROW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::EXCHANGE_SYMBOL() {
  return getToken(MySQLParser::EXCHANGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::EXPIRE_SYMBOL() {
  return getToken(MySQLParser::EXPIRE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ONLY_SYMBOL() {
  return getToken(MySQLParser::ONLY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::VALIDATION_SYMBOL() {
  return getToken(MySQLParser::VALIDATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::WITHOUT_SYMBOL() {
  return getToken(MySQLParser::WITHOUT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ADMIN_SYMBOL() {
  return getToken(MySQLParser::ADMIN_SYMBOL, 0);
}


size_t MySQLParser::RoleOrLabelKeywordContext::getRuleIndex() const {
  return MySQLParser::RuleRoleOrLabelKeyword;
}

void MySQLParser::RoleOrLabelKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleOrLabelKeyword(this);
}

void MySQLParser::RoleOrLabelKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleOrLabelKeyword(this);
}


antlrcpp::Any MySQLParser::RoleOrLabelKeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRoleOrLabelKeyword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoleOrLabelKeywordContext* MySQLParser::roleOrLabelKeyword() {
  RoleOrLabelKeywordContext *_localctx = _tracker.createInstance<RoleOrLabelKeywordContext>(_ctx, getState());
  enterRule(_localctx, 1158, MySQLParser::RuleRoleOrLabelKeyword);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8082);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1083, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8073);
      _la = _input->LA(1);
      if (!(((((_la - 57) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 57)) & ((1ULL << (MySQLParser::ACTION_SYMBOL - 57))
        | (1ULL << (MySQLParser::ADDDATE_SYMBOL - 57))
        | (1ULL << (MySQLParser::AFTER_SYMBOL - 57))
        | (1ULL << (MySQLParser::AGAINST_SYMBOL - 57))
        | (1ULL << (MySQLParser::AGGREGATE_SYMBOL - 57))
        | (1ULL << (MySQLParser::ALGORITHM_SYMBOL - 57))
        | (1ULL << (MySQLParser::ANY_SYMBOL - 57))
        | (1ULL << (MySQLParser::AT_SYMBOL - 57))
        | (1ULL << (MySQLParser::AUTHORS_SYMBOL - 57))
        | (1ULL << (MySQLParser::AUTO_INCREMENT_SYMBOL - 57))
        | (1ULL << (MySQLParser::AUTOEXTEND_SIZE_SYMBOL - 57))
        | (1ULL << (MySQLParser::AVG_ROW_LENGTH_SYMBOL - 57))
        | (1ULL << (MySQLParser::AVG_SYMBOL - 57))
        | (1ULL << (MySQLParser::BINLOG_SYMBOL - 57))
        | (1ULL << (MySQLParser::BIT_SYMBOL - 57))
        | (1ULL << (MySQLParser::BLOCK_SYMBOL - 57))
        | (1ULL << (MySQLParser::BOOL_SYMBOL - 57))
        | (1ULL << (MySQLParser::BOOLEAN_SYMBOL - 57))
        | (1ULL << (MySQLParser::BTREE_SYMBOL - 57))
        | (1ULL << (MySQLParser::CASCADED_SYMBOL - 57))
        | (1ULL << (MySQLParser::CATALOG_NAME_SYMBOL - 57))
        | (1ULL << (MySQLParser::CHAIN_SYMBOL - 57))
        | (1ULL << (MySQLParser::CHANGED_SYMBOL - 57))
        | (1ULL << (MySQLParser::CHANNEL_SYMBOL - 57))
        | (1ULL << (MySQLParser::CIPHER_SYMBOL - 57))
        | (1ULL << (MySQLParser::CLIENT_SYMBOL - 57))
        | (1ULL << (MySQLParser::CLASS_ORIGIN_SYMBOL - 57))
        | (1ULL << (MySQLParser::COALESCE_SYMBOL - 57))
        | (1ULL << (MySQLParser::CODE_SYMBOL - 57))
        | (1ULL << (MySQLParser::COLLATION_SYMBOL - 57))
        | (1ULL << (MySQLParser::COLUMN_NAME_SYMBOL - 57))
        | (1ULL << (MySQLParser::COLUMN_FORMAT_SYMBOL - 57))
        | (1ULL << (MySQLParser::COLUMNS_SYMBOL - 57))
        | (1ULL << (MySQLParser::COMMITTED_SYMBOL - 57))
        | (1ULL << (MySQLParser::COMPACT_SYMBOL - 57))
        | (1ULL << (MySQLParser::COMPLETION_SYMBOL - 57))
        | (1ULL << (MySQLParser::COMPRESSED_SYMBOL - 57))
        | (1ULL << (MySQLParser::COMPRESSION_SYMBOL - 57))
        | (1ULL << (MySQLParser::ENCRYPTION_SYMBOL - 57))
        | (1ULL << (MySQLParser::CONCURRENT_SYMBOL - 57))
        | (1ULL << (MySQLParser::CONNECTION_SYMBOL - 57))
        | (1ULL << (MySQLParser::CONSISTENT_SYMBOL - 57))
        | (1ULL << (MySQLParser::CONSTRAINT_CATALOG_SYMBOL - 57))
        | (1ULL << (MySQLParser::CONSTRAINT_SCHEMA_SYMBOL - 57))
        | (1ULL << (MySQLParser::CONSTRAINT_NAME_SYMBOL - 57))
        | (1ULL << (MySQLParser::CONTEXT_SYMBOL - 57))
        | (1ULL << (MySQLParser::CONTRIBUTORS_SYMBOL - 57))
        | (1ULL << (MySQLParser::CPU_SYMBOL - 57))
        | (1ULL << (MySQLParser::CURRENT_SYMBOL - 57))
        | (1ULL << (MySQLParser::CURSOR_NAME_SYMBOL - 57))
        | (1ULL << (MySQLParser::DATA_SYMBOL - 57))
        | (1ULL << (MySQLParser::DATAFILE_SYMBOL - 57))
        | (1ULL << (MySQLParser::DATETIME_SYMBOL - 57))
        | (1ULL << (MySQLParser::DATE_SYMBOL - 57))
        | (1ULL << (MySQLParser::DAY_SYMBOL - 57))
        | (1ULL << (MySQLParser::DEFAULT_AUTH_SYMBOL - 57))
        | (1ULL << (MySQLParser::DEFINER_SYMBOL - 57))
        | (1ULL << (MySQLParser::DELAY_KEY_WRITE_SYMBOL - 57))
        | (1ULL << (MySQLParser::DES_KEY_FILE_SYMBOL - 57))
        | (1ULL << (MySQLParser::DIAGNOSTICS_SYMBOL - 57))
        | (1ULL << (MySQLParser::DIRECTORY_SYMBOL - 57))
        | (1ULL << (MySQLParser::DISABLE_SYMBOL - 57)))) != 0) || ((((_la - 121) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 121)) & ((1ULL << (MySQLParser::DISCARD_SYMBOL - 121))
        | (1ULL << (MySQLParser::DISK_SYMBOL - 121))
        | (1ULL << (MySQLParser::DUMPFILE_SYMBOL - 121))
        | (1ULL << (MySQLParser::DUPLICATE_SYMBOL - 121))
        | (1ULL << (MySQLParser::DYNAMIC_SYMBOL - 121))
        | (1ULL << (MySQLParser::ENDS_SYMBOL - 121))
        | (1ULL << (MySQLParser::ENUM_SYMBOL - 121))
        | (1ULL << (MySQLParser::ENGINE_SYMBOL - 121))
        | (1ULL << (MySQLParser::ENGINES_SYMBOL - 121))
        | (1ULL << (MySQLParser::ERROR_SYMBOL - 121))
        | (1ULL << (MySQLParser::ERRORS_SYMBOL - 121))
        | (1ULL << (MySQLParser::ESCAPE_SYMBOL - 121))
        | (1ULL << (MySQLParser::EVENTS_SYMBOL - 121))
        | (1ULL << (MySQLParser::EVERY_SYMBOL - 121))
        | (1ULL << (MySQLParser::EXPANSION_SYMBOL - 121))
        | (1ULL << (MySQLParser::EXPORT_SYMBOL - 121))
        | (1ULL << (MySQLParser::EXTENDED_SYMBOL - 121))
        | (1ULL << (MySQLParser::EXTENT_SIZE_SYMBOL - 121))
        | (1ULL << (MySQLParser::FAULTS_SYMBOL - 121))
        | (1ULL << (MySQLParser::FAST_SYMBOL - 121))
        | (1ULL << (MySQLParser::FOUND_SYMBOL - 121))
        | (1ULL << (MySQLParser::ENABLE_SYMBOL - 121))
        | (1ULL << (MySQLParser::FULL_SYMBOL - 121))
        | (1ULL << (MySQLParser::FILE_BLOCK_SIZE_SYMBOL - 121))
        | (1ULL << (MySQLParser::FILTER_SYMBOL - 121))
        | (1ULL << (MySQLParser::FIRST_SYMBOL - 121))
        | (1ULL << (MySQLParser::FIXED_SYMBOL - 121))
        | (1ULL << (MySQLParser::GENERAL_SYMBOL - 121))
        | (1ULL << (MySQLParser::GEOMETRY_SYMBOL - 121))
        | (1ULL << (MySQLParser::GEOMETRYCOLLECTION_SYMBOL - 121))
        | (1ULL << (MySQLParser::GET_FORMAT_SYMBOL - 121))
        | (1ULL << (MySQLParser::GRANTS_SYMBOL - 121))
        | (1ULL << (MySQLParser::GLOBAL_SYMBOL - 121))
        | (1ULL << (MySQLParser::HASH_SYMBOL - 121))
        | (1ULL << (MySQLParser::HOSTS_SYMBOL - 121))
        | (1ULL << (MySQLParser::HOUR_SYMBOL - 121))
        | (1ULL << (MySQLParser::IDENTIFIED_SYMBOL - 121))
        | (1ULL << (MySQLParser::IGNORE_SERVER_IDS_SYMBOL - 121))
        | (1ULL << (MySQLParser::INVOKER_SYMBOL - 121))
        | (1ULL << (MySQLParser::INDEXES_SYMBOL - 121))
        | (1ULL << (MySQLParser::INITIAL_SIZE_SYMBOL - 121))
        | (1ULL << (MySQLParser::INSTANCE_SYMBOL - 121))
        | (1ULL << (MySQLParser::IO_SYMBOL - 121))
        | (1ULL << (MySQLParser::IPC_SYMBOL - 121))
        | (1ULL << (MySQLParser::ISOLATION_SYMBOL - 121))
        | (1ULL << (MySQLParser::ISSUER_SYMBOL - 121))
        | (1ULL << (MySQLParser::INSERT_METHOD_SYMBOL - 121))
        | (1ULL << (MySQLParser::JSON_SYMBOL - 121))
        | (1ULL << (MySQLParser::KEY_BLOCK_SIZE_SYMBOL - 121))
        | (1ULL << (MySQLParser::LAST_SYMBOL - 121))
        | (1ULL << (MySQLParser::LEAVES_SYMBOL - 121))
        | (1ULL << (MySQLParser::LESS_SYMBOL - 121))
        | (1ULL << (MySQLParser::LEVEL_SYMBOL - 121))
        | (1ULL << (MySQLParser::LINESTRING_SYMBOL - 121))
        | (1ULL << (MySQLParser::LIST_SYMBOL - 121))
        | (1ULL << (MySQLParser::LOCAL_SYMBOL - 121))
        | (1ULL << (MySQLParser::LOCKS_SYMBOL - 121))
        | (1ULL << (MySQLParser::LOGFILE_SYMBOL - 121))
        | (1ULL << (MySQLParser::LOGS_SYMBOL - 121))
        | (1ULL << (MySQLParser::MAX_ROWS_SYMBOL - 121)))) != 0) || ((((_la - 185) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 185)) & ((1ULL << (MySQLParser::MASTER_SYMBOL - 185))
        | (1ULL << (MySQLParser::MASTER_HEARTBEAT_PERIOD_SYMBOL - 185))
        | (1ULL << (MySQLParser::MASTER_HOST_SYMBOL - 185))
        | (1ULL << (MySQLParser::MASTER_PORT_SYMBOL - 185))
        | (1ULL << (MySQLParser::MASTER_LOG_FILE_SYMBOL - 185))
        | (1ULL << (MySQLParser::MASTER_LOG_POS_SYMBOL - 185))
        | (1ULL << (MySQLParser::MASTER_USER_SYMBOL - 185))
        | (1ULL << (MySQLParser::MASTER_PASSWORD_SYMBOL - 185))
        | (1ULL << (MySQLParser::MASTER_SERVER_ID_SYMBOL - 185))
        | (1ULL << (MySQLParser::MASTER_CONNECT_RETRY_SYMBOL - 185))
        | (1ULL << (MySQLParser::MASTER_RETRY_COUNT_SYMBOL - 185))
        | (1ULL << (MySQLParser::MASTER_DELAY_SYMBOL - 185))
        | (1ULL << (MySQLParser::MASTER_SSL_SYMBOL - 185))
        | (1ULL << (MySQLParser::MASTER_SSL_CA_SYMBOL - 185))
        | (1ULL << (MySQLParser::MASTER_SSL_CAPATH_SYMBOL - 185))
        | (1ULL << (MySQLParser::MASTER_TLS_VERSION_SYMBOL - 185))
        | (1ULL << (MySQLParser::MASTER_SSL_CERT_SYMBOL - 185))
        | (1ULL << (MySQLParser::MASTER_SSL_CIPHER_SYMBOL - 185))
        | (1ULL << (MySQLParser::MASTER_SSL_CRL_SYMBOL - 185))
        | (1ULL << (MySQLParser::MASTER_SSL_CRLPATH_SYMBOL - 185))
        | (1ULL << (MySQLParser::MASTER_SSL_KEY_SYMBOL - 185))
        | (1ULL << (MySQLParser::MASTER_AUTO_POSITION_SYMBOL - 185))
        | (1ULL << (MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL - 185))
        | (1ULL << (MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL - 185))
        | (1ULL << (MySQLParser::MAX_STATEMENT_TIME_SYMBOL - 185))
        | (1ULL << (MySQLParser::MAX_SIZE_SYMBOL - 185))
        | (1ULL << (MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL - 185))
        | (1ULL << (MySQLParser::MAX_USER_CONNECTIONS_SYMBOL - 185))
        | (1ULL << (MySQLParser::MEDIUM_SYMBOL - 185))
        | (1ULL << (MySQLParser::MEMORY_SYMBOL - 185))
        | (1ULL << (MySQLParser::MERGE_SYMBOL - 185))
        | (1ULL << (MySQLParser::MESSAGE_TEXT_SYMBOL - 185))
        | (1ULL << (MySQLParser::MICROSECOND_SYMBOL - 185))
        | (1ULL << (MySQLParser::MIGRATE_SYMBOL - 185))
        | (1ULL << (MySQLParser::MINUTE_SYMBOL - 185))
        | (1ULL << (MySQLParser::MIN_ROWS_SYMBOL - 185))
        | (1ULL << (MySQLParser::MODIFY_SYMBOL - 185))
        | (1ULL << (MySQLParser::MODE_SYMBOL - 185))
        | (1ULL << (MySQLParser::MONTH_SYMBOL - 185))
        | (1ULL << (MySQLParser::MULTILINESTRING_SYMBOL - 185))
        | (1ULL << (MySQLParser::MULTIPOINT_SYMBOL - 185))
        | (1ULL << (MySQLParser::MULTIPOLYGON_SYMBOL - 185))
        | (1ULL << (MySQLParser::MUTEX_SYMBOL - 185))
        | (1ULL << (MySQLParser::MYSQL_ERRNO_SYMBOL - 185))
        | (1ULL << (MySQLParser::NAME_SYMBOL - 185))
        | (1ULL << (MySQLParser::NAMES_SYMBOL - 185))
        | (1ULL << (MySQLParser::NATIONAL_SYMBOL - 185))
        | (1ULL << (MySQLParser::NCHAR_SYMBOL - 185))
        | (1ULL << (MySQLParser::NDBCLUSTER_SYMBOL - 185))
        | (1ULL << (MySQLParser::NEVER_SYMBOL - 185))
        | (1ULL << (MySQLParser::NEXT_SYMBOL - 185))
        | (1ULL << (MySQLParser::NEW_SYMBOL - 185))
        | (1ULL << (MySQLParser::NO_WAIT_SYMBOL - 185))
        | (1ULL << (MySQLParser::NODEGROUP_SYMBOL - 185))
        | (1ULL << (MySQLParser::NUMBER_SYMBOL - 185))
        | (1ULL << (MySQLParser::NVARCHAR_SYMBOL - 185))
        | (1ULL << (MySQLParser::OFFSET_SYMBOL - 185))
        | (1ULL << (MySQLParser::OLD_PASSWORD_SYMBOL - 185))
        | (1ULL << (MySQLParser::ONE_SHOT_SYMBOL - 185))
        | (1ULL << (MySQLParser::ONE_SYMBOL - 185))
        | (1ULL << (MySQLParser::PACK_KEYS_SYMBOL - 185))
        | (1ULL << (MySQLParser::PAGE_SYMBOL - 185))
        | (1ULL << (MySQLParser::PARTIAL_SYMBOL - 185)))) != 0) || ((((_la - 249) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 249)) & ((1ULL << (MySQLParser::PARTITIONING_SYMBOL - 249))
        | (1ULL << (MySQLParser::PARTITIONS_SYMBOL - 249))
        | (1ULL << (MySQLParser::PASSWORD_SYMBOL - 249))
        | (1ULL << (MySQLParser::PHASE_SYMBOL - 249))
        | (1ULL << (MySQLParser::PLUGIN_DIR_SYMBOL - 249))
        | (1ULL << (MySQLParser::PLUGIN_SYMBOL - 249))
        | (1ULL << (MySQLParser::PLUGINS_SYMBOL - 249))
        | (1ULL << (MySQLParser::POINT_SYMBOL - 249))
        | (1ULL << (MySQLParser::POLYGON_SYMBOL - 249))
        | (1ULL << (MySQLParser::PRESERVE_SYMBOL - 249))
        | (1ULL << (MySQLParser::PREV_SYMBOL - 249))
        | (1ULL << (MySQLParser::PRIVILEGES_SYMBOL - 249))
        | (1ULL << (MySQLParser::PROCESSLIST_SYMBOL - 249))
        | (1ULL << (MySQLParser::PROFILE_SYMBOL - 249))
        | (1ULL << (MySQLParser::PROFILES_SYMBOL - 249))
        | (1ULL << (MySQLParser::QUARTER_SYMBOL - 249))
        | (1ULL << (MySQLParser::QUERY_SYMBOL - 249))
        | (1ULL << (MySQLParser::QUICK_SYMBOL - 249))
        | (1ULL << (MySQLParser::READ_ONLY_SYMBOL - 249))
        | (1ULL << (MySQLParser::REBUILD_SYMBOL - 249))
        | (1ULL << (MySQLParser::RECOVER_SYMBOL - 249))
        | (1ULL << (MySQLParser::REDO_BUFFER_SIZE_SYMBOL - 249))
        | (1ULL << (MySQLParser::REDOFILE_SYMBOL - 249))
        | (1ULL << (MySQLParser::REDUNDANT_SYMBOL - 249))
        | (1ULL << (MySQLParser::RELAY_SYMBOL - 249))
        | (1ULL << (MySQLParser::RELAYLOG_SYMBOL - 249))
        | (1ULL << (MySQLParser::RELAY_LOG_FILE_SYMBOL - 249))
        | (1ULL << (MySQLParser::RELAY_LOG_POS_SYMBOL - 249))
        | (1ULL << (MySQLParser::RELAY_THREAD_SYMBOL - 249))
        | (1ULL << (MySQLParser::REORGANIZE_SYMBOL - 249))
        | (1ULL << (MySQLParser::REPEATABLE_SYMBOL - 249))
        | (1ULL << (MySQLParser::REPLICATE_DO_DB_SYMBOL - 249))
        | (1ULL << (MySQLParser::REPLICATE_IGNORE_DB_SYMBOL - 249))
        | (1ULL << (MySQLParser::REPLICATE_DO_TABLE_SYMBOL - 249))
        | (1ULL << (MySQLParser::REPLICATE_IGNORE_TABLE_SYMBOL - 249))
        | (1ULL << (MySQLParser::REPLICATE_WILD_DO_TABLE_SYMBOL - 249))
        | (1ULL << (MySQLParser::REPLICATE_WILD_IGNORE_TABLE_SYMBOL - 249))
        | (1ULL << (MySQLParser::REPLICATE_REWRITE_DB_SYMBOL - 249))
        | (1ULL << (MySQLParser::RESUME_SYMBOL - 249))
        | (1ULL << (MySQLParser::RETURNED_SQLSTATE_SYMBOL - 249))
        | (1ULL << (MySQLParser::RETURNS_SYMBOL - 249))
        | (1ULL << (MySQLParser::REVERSE_SYMBOL - 249))
        | (1ULL << (MySQLParser::ROLLUP_SYMBOL - 249))
        | (1ULL << (MySQLParser::ROTATE_SYMBOL - 249))
        | (1ULL << (MySQLParser::ROUTINE_SYMBOL - 249))
        | (1ULL << (MySQLParser::ROW_COUNT_SYMBOL - 249))
        | (1ULL << (MySQLParser::ROW_FORMAT_SYMBOL - 249))
        | (1ULL << (MySQLParser::RTREE_SYMBOL - 249))
        | (1ULL << (MySQLParser::SCHEDULE_SYMBOL - 249))
        | (1ULL << (MySQLParser::SCHEMA_NAME_SYMBOL - 249))
        | (1ULL << (MySQLParser::SECOND_SYMBOL - 249))
        | (1ULL << (MySQLParser::SERIAL_SYMBOL - 249))
        | (1ULL << (MySQLParser::SERIALIZABLE_SYMBOL - 249))
        | (1ULL << (MySQLParser::SESSION_SYMBOL - 249))
        | (1ULL << (MySQLParser::SIMPLE_SYMBOL - 249))
        | (1ULL << (MySQLParser::SHARE_SYMBOL - 249))
        | (1ULL << (MySQLParser::SLOW_SYMBOL - 249))
        | (1ULL << (MySQLParser::SNAPSHOT_SYMBOL - 249)))) != 0) || ((((_la - 313) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 313)) & ((1ULL << (MySQLParser::SOUNDS_SYMBOL - 313))
        | (1ULL << (MySQLParser::SOURCE_SYMBOL - 313))
        | (1ULL << (MySQLParser::SQL_AFTER_GTIDS_SYMBOL - 313))
        | (1ULL << (MySQLParser::SQL_AFTER_MTS_GAPS_SYMBOL - 313))
        | (1ULL << (MySQLParser::SQL_BEFORE_GTIDS_SYMBOL - 313))
        | (1ULL << (MySQLParser::SQL_CACHE_SYMBOL - 313))
        | (1ULL << (MySQLParser::SQL_BUFFER_RESULT_SYMBOL - 313))
        | (1ULL << (MySQLParser::SQL_NO_CACHE_SYMBOL - 313))
        | (1ULL << (MySQLParser::SQL_THREAD_SYMBOL - 313))
        | (1ULL << (MySQLParser::STACKED_SYMBOL - 313))
        | (1ULL << (MySQLParser::STARTS_SYMBOL - 313))
        | (1ULL << (MySQLParser::STATS_AUTO_RECALC_SYMBOL - 313))
        | (1ULL << (MySQLParser::STATS_PERSISTENT_SYMBOL - 313))
        | (1ULL << (MySQLParser::STATS_SAMPLE_PAGES_SYMBOL - 313))
        | (1ULL << (MySQLParser::STATUS_SYMBOL - 313))
        | (1ULL << (MySQLParser::STORAGE_SYMBOL - 313))
        | (1ULL << (MySQLParser::STRING_SYMBOL - 313))
        | (1ULL << (MySQLParser::SUBCLASS_ORIGIN_SYMBOL - 313))
        | (1ULL << (MySQLParser::SUBDATE_SYMBOL - 313))
        | (1ULL << (MySQLParser::SUBJECT_SYMBOL - 313))
        | (1ULL << (MySQLParser::SUBPARTITION_SYMBOL - 313))
        | (1ULL << (MySQLParser::SUBPARTITIONS_SYMBOL - 313))
        | (1ULL << (MySQLParser::SUPER_SYMBOL - 313))
        | (1ULL << (MySQLParser::SUSPEND_SYMBOL - 313))
        | (1ULL << (MySQLParser::SWAPS_SYMBOL - 313))
        | (1ULL << (MySQLParser::SWITCHES_SYMBOL - 313))
        | (1ULL << (MySQLParser::TABLE_NAME_SYMBOL - 313))
        | (1ULL << (MySQLParser::TABLES_SYMBOL - 313))
        | (1ULL << (MySQLParser::TABLE_CHECKSUM_SYMBOL - 313))
        | (1ULL << (MySQLParser::TABLESPACE_SYMBOL - 313))
        | (1ULL << (MySQLParser::TEMPORARY_SYMBOL - 313))
        | (1ULL << (MySQLParser::TEMPTABLE_SYMBOL - 313))
        | (1ULL << (MySQLParser::TEXT_SYMBOL - 313))
        | (1ULL << (MySQLParser::THAN_SYMBOL - 313))
        | (1ULL << (MySQLParser::TRANSACTION_SYMBOL - 313))
        | (1ULL << (MySQLParser::TRIGGERS_SYMBOL - 313))
        | (1ULL << (MySQLParser::TIMESTAMP_SYMBOL - 313))
        | (1ULL << (MySQLParser::TIMESTAMP_ADD_SYMBOL - 313))
        | (1ULL << (MySQLParser::TIMESTAMP_DIFF_SYMBOL - 313))
        | (1ULL << (MySQLParser::TIME_SYMBOL - 313))
        | (1ULL << (MySQLParser::TYPES_SYMBOL - 313))
        | (1ULL << (MySQLParser::TYPE_SYMBOL - 313))
        | (1ULL << (MySQLParser::UDF_RETURNS_SYMBOL - 313))
        | (1ULL << (MySQLParser::UNCOMMITTED_SYMBOL - 313))
        | (1ULL << (MySQLParser::UNDEFINED_SYMBOL - 313))
        | (1ULL << (MySQLParser::UNDO_BUFFER_SIZE_SYMBOL - 313))
        | (1ULL << (MySQLParser::UNDOFILE_SYMBOL - 313))
        | (1ULL << (MySQLParser::UNKNOWN_SYMBOL - 313))
        | (1ULL << (MySQLParser::UNTIL_SYMBOL - 313))
        | (1ULL << (MySQLParser::USER_RESOURCES_SYMBOL - 313))
        | (1ULL << (MySQLParser::USER_SYMBOL - 313))
        | (1ULL << (MySQLParser::USE_FRM_SYMBOL - 313))
        | (1ULL << (MySQLParser::VARIABLES_SYMBOL - 313))
        | (1ULL << (MySQLParser::VIEW_SYMBOL - 313))
        | (1ULL << (MySQLParser::VALUE_SYMBOL - 313))
        | (1ULL << (MySQLParser::WARNINGS_SYMBOL - 313))
        | (1ULL << (MySQLParser::WAIT_SYMBOL - 313))
        | (1ULL << (MySQLParser::WEEK_SYMBOL - 313))
        | (1ULL << (MySQLParser::WORK_SYMBOL - 313))
        | (1ULL << (MySQLParser::WEIGHT_STRING_SYMBOL - 313))
        | (1ULL << (MySQLParser::X509_SYMBOL - 313))
        | (1ULL << (MySQLParser::XID_SYMBOL - 313))
        | (1ULL << (MySQLParser::XML_SYMBOL - 313)))) != 0) || _la == MySQLParser::YEAR_SYMBOL

      || _la == MySQLParser::ANALYSE_SYMBOL || ((((_la - 695) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 695)) & ((1ULL << (MySQLParser::COMPONENT_SYMBOL - 695))
        | (1ULL << (MySQLParser::SKIP_SYMBOL - 695))
        | (1ULL << (MySQLParser::LOCKED_SYMBOL - 695))
        | (1ULL << (MySQLParser::NOWAIT_SYMBOL - 695))
        | (1ULL << (MySQLParser::HISTOGRAM_SYMBOL - 695))
        | (1ULL << (MySQLParser::BUCKETS_SYMBOL - 695))
        | (1ULL << (MySQLParser::REMOTE_SYMBOL - 695))
        | (1ULL << (MySQLParser::EXCLUDE_SYMBOL - 695))
        | (1ULL << (MySQLParser::FOLLOWING_SYMBOL - 695))
        | (1ULL << (MySQLParser::NULLS_SYMBOL - 695))
        | (1ULL << (MySQLParser::OTHERS_SYMBOL - 695))
        | (1ULL << (MySQLParser::PRECEDING_SYMBOL - 695))
        | (1ULL << (MySQLParser::RESPECT_SYMBOL - 695))
        | (1ULL << (MySQLParser::TIES_SYMBOL - 695))
        | (1ULL << (MySQLParser::UNBOUNDED_SYMBOL - 695))
        | (1ULL << (MySQLParser::NESTED_SYMBOL - 695))
        | (1ULL << (MySQLParser::ORDINALITY_SYMBOL - 695))
        | (1ULL << (MySQLParser::PATH_SYMBOL - 695))
        | (1ULL << (MySQLParser::HISTORY_SYMBOL - 695))
        | (1ULL << (MySQLParser::REUSE_SYMBOL - 695))
        | (1ULL << (MySQLParser::SRID_SYMBOL - 695))
        | (1ULL << (MySQLParser::THREAD_PRIORITY_SYMBOL - 695))
        | (1ULL << (MySQLParser::VCPU_SYMBOL - 695))
        | (1ULL << (MySQLParser::MASTER_PUBLIC_KEY_PATH_SYMBOL - 695))
        | (1ULL << (MySQLParser::DESCRIPTION_SYMBOL - 695))
        | (1ULL << (MySQLParser::ORGANIZATION_SYMBOL - 695))
        | (1ULL << (MySQLParser::OPTIONAL_SYMBOL - 695))
        | (1ULL << (MySQLParser::ACTIVE_SYMBOL - 695))
        | (1ULL << (MySQLParser::INACTIVE_SYMBOL - 695))
        | (1ULL << (MySQLParser::RETAIN_SYMBOL - 695)))) != 0) || _la == MySQLParser::OLD_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8074);

      if (!(serverVersion < 50709)) throw FailedPredicateException(this, "serverVersion < 50709");
      setState(8075);
      match(MySQLParser::SHUTDOWN_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(8076);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(8077);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::CUBE_SYMBOL

      || _la == MySQLParser::IMPORT_SYMBOL || ((((_la - 298) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 298)) & ((1ULL << (MySQLParser::ROWS_SYMBOL - 298))
        | (1ULL << (MySQLParser::ROW_SYMBOL - 298))
        | (1ULL << (MySQLParser::FUNCTION_SYMBOL - 298)))) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(8078);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(8079);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::SUPER_SYMBOL || _la == MySQLParser::EXCHANGE_SYMBOL

      || _la == MySQLParser::EXPIRE_SYMBOL || _la == MySQLParser::ONLY_SYMBOL || _la == MySQLParser::VALIDATION_SYMBOL

      || _la == MySQLParser::WITHOUT_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(8080);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(8081);
      match(MySQLParser::ADMIN_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleKeywordContext ------------------------------------------------------------------

MySQLParser::RoleKeywordContext::RoleKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RoleOrLabelKeywordContext* MySQLParser::RoleKeywordContext::roleOrLabelKeyword() {
  return getRuleContext<MySQLParser::RoleOrLabelKeywordContext>(0);
}

MySQLParser::RoleOrIdentifierKeywordContext* MySQLParser::RoleKeywordContext::roleOrIdentifierKeyword() {
  return getRuleContext<MySQLParser::RoleOrIdentifierKeywordContext>(0);
}


size_t MySQLParser::RoleKeywordContext::getRuleIndex() const {
  return MySQLParser::RuleRoleKeyword;
}

void MySQLParser::RoleKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleKeyword(this);
}

void MySQLParser::RoleKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleKeyword(this);
}


antlrcpp::Any MySQLParser::RoleKeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor*>(visitor))
    return parserVisitor->visitRoleKeyword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoleKeywordContext* MySQLParser::roleKeyword() {
  RoleKeywordContext *_localctx = _tracker.createInstance<RoleKeywordContext>(_ctx, getState());
  enterRule(_localctx, 1160, MySQLParser::RuleRoleKeyword);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8086);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1084, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8084);
      roleOrLabelKeyword();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8085);
      roleOrIdentifierKeyword();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool MySQLParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 1: return simpleStatementSempred(dynamic_cast<SimpleStatementContext *>(context), predicateIndex);
    case 2: return alterStatementSempred(dynamic_cast<AlterStatementContext *>(context), predicateIndex);
    case 3: return alterDatabaseSempred(dynamic_cast<AlterDatabaseContext *>(context), predicateIndex);
    case 9: return alterTableSempred(dynamic_cast<AlterTableContext *>(context), predicateIndex);
    case 13: return standaloneAlterCommandsSempred(dynamic_cast<StandaloneAlterCommandsContext *>(context), predicateIndex);
    case 14: return alterPartitionSempred(dynamic_cast<AlterPartitionContext *>(context), predicateIndex);
    case 16: return alterCommandsModifierSempred(dynamic_cast<AlterCommandsModifierContext *>(context), predicateIndex);
    case 17: return alterListItemSempred(dynamic_cast<AlterListItemContext *>(context), predicateIndex);
    case 23: return indexLockAndAlgorithmSempred(dynamic_cast<IndexLockAndAlgorithmContext *>(context), predicateIndex);
    case 24: return withValidationSempred(dynamic_cast<WithValidationContext *>(context), predicateIndex);
    case 28: return alterTablespaceSempred(dynamic_cast<AlterTablespaceContext *>(context), predicateIndex);
    case 39: return createStatementSempred(dynamic_cast<CreateStatementContext *>(context), predicateIndex);
    case 41: return createDatabaseOptionSempred(dynamic_cast<CreateDatabaseOptionContext *>(context), predicateIndex);
    case 54: return createIndexSempred(dynamic_cast<CreateIndexContext *>(context), predicateIndex);
    case 65: return tsDataFileNameSempred(dynamic_cast<TsDataFileNameContext *>(context), predicateIndex);
    case 68: return tablespaceOptionSempred(dynamic_cast<TablespaceOptionContext *>(context), predicateIndex);
    case 85: return triggerFollowsPrecedesClauseSempred(dynamic_cast<TriggerFollowsPrecedesClauseContext *>(context), predicateIndex);
    case 90: return dropStatementSempred(dynamic_cast<DropStatementContext *>(context), predicateIndex);
    case 111: return deleteStatementSempred(dynamic_cast<DeleteStatementContext *>(context), predicateIndex);
    case 112: return partitionDeleteSempred(dynamic_cast<PartitionDeleteContext *>(context), predicateIndex);
    case 114: return doStatementSempred(dynamic_cast<DoStatementContext *>(context), predicateIndex);
    case 127: return dataOrXmlSempred(dynamic_cast<DataOrXmlContext *>(context), predicateIndex);
    case 128: return xmlRowsIdentifiedBySempred(dynamic_cast<XmlRowsIdentifiedByContext *>(context), predicateIndex);
    case 135: return queryExpressionSempred(dynamic_cast<QueryExpressionContext *>(context), predicateIndex);
    case 136: return queryExpressionBodySempred(dynamic_cast<QueryExpressionBodyContext *>(context), predicateIndex);
    case 138: return querySpecificationSempred(dynamic_cast<QuerySpecificationContext *>(context), predicateIndex);
    case 162: return olapOptionSempred(dynamic_cast<OlapOptionContext *>(context), predicateIndex);
    case 167: return selectOptionSempred(dynamic_cast<SelectOptionContext *>(context), predicateIndex);
    case 168: return lockingClauseSempred(dynamic_cast<LockingClauseContext *>(context), predicateIndex);
    case 169: return lockStrenghSempred(dynamic_cast<LockStrenghContext *>(context), predicateIndex);
    case 181: return tableFactorSempred(dynamic_cast<TableFactorContext *>(context), predicateIndex);
    case 184: return derivedTableSempred(dynamic_cast<DerivedTableContext *>(context), predicateIndex);
    case 188: return jtColumnSempred(dynamic_cast<JtColumnContext *>(context), predicateIndex);
    case 203: return updateStatementSempred(dynamic_cast<UpdateStatementContext *>(context), predicateIndex);
    case 207: return transactionCharacteristicSempred(dynamic_cast<TransactionCharacteristicContext *>(context), predicateIndex);
    case 208: return setTransactionCharacteristicSempred(dynamic_cast<SetTransactionCharacteristicContext *>(context), predicateIndex);
    case 211: return lockStatementSempred(dynamic_cast<LockStatementContext *>(context), predicateIndex);
    case 215: return xaConvertSempred(dynamic_cast<XaConvertContext *>(context), predicateIndex);
    case 217: return replicationStatementSempred(dynamic_cast<ReplicationStatementContext *>(context), predicateIndex);
    case 218: return resetOptionSempred(dynamic_cast<ResetOptionContext *>(context), predicateIndex);
    case 219: return masterResetOptionsSempred(dynamic_cast<MasterResetOptionsContext *>(context), predicateIndex);
    case 226: return changeReplicationSempred(dynamic_cast<ChangeReplicationContext *>(context), predicateIndex);
    case 234: return slaveUntilOptionsSempred(dynamic_cast<SlaveUntilOptionsContext *>(context), predicateIndex);
    case 235: return slaveConnectionOptionsSempred(dynamic_cast<SlaveConnectionOptionsContext *>(context), predicateIndex);
    case 242: return cloneStatementSempred(dynamic_cast<CloneStatementContext *>(context), predicateIndex);
    case 245: return accountManagementStatementSempred(dynamic_cast<AccountManagementStatementContext *>(context), predicateIndex);
    case 246: return alterUserSempred(dynamic_cast<AlterUserContext *>(context), predicateIndex);
    case 247: return alterUserTailSempred(dynamic_cast<AlterUserTailContext *>(context), predicateIndex);
    case 248: return createUserSempred(dynamic_cast<CreateUserContext *>(context), predicateIndex);
    case 249: return createUserTailSempred(dynamic_cast<CreateUserTailContext *>(context), predicateIndex);
    case 250: return defaultRoleClauseSempred(dynamic_cast<DefaultRoleClauseContext *>(context), predicateIndex);
    case 253: return accountLockPasswordExpireOptionsSempred(dynamic_cast<AccountLockPasswordExpireOptionsContext *>(context), predicateIndex);
    case 254: return dropUserSempred(dynamic_cast<DropUserContext *>(context), predicateIndex);
    case 255: return grantSempred(dynamic_cast<GrantContext *>(context), predicateIndex);
    case 256: return grantTargetListSempred(dynamic_cast<GrantTargetListContext *>(context), predicateIndex);
    case 257: return grantOptionsSempred(dynamic_cast<GrantOptionsContext *>(context), predicateIndex);
    case 258: return versionedRequireClauseSempred(dynamic_cast<VersionedRequireClauseContext *>(context), predicateIndex);
    case 260: return revokeSempred(dynamic_cast<RevokeContext *>(context), predicateIndex);
    case 261: return onTypeToSempred(dynamic_cast<OnTypeToContext *>(context), predicateIndex);
    case 263: return setPasswordSempred(dynamic_cast<SetPasswordContext *>(context), predicateIndex);
    case 265: return roleOrPrivilegeSempred(dynamic_cast<RoleOrPrivilegeContext *>(context), predicateIndex);
    case 273: return tableAdministrationStatementSempred(dynamic_cast<TableAdministrationStatementContext *>(context), predicateIndex);
    case 279: return optionValueNoOptionTypeSempred(dynamic_cast<OptionValueNoOptionTypeContext *>(context), predicateIndex);
    case 282: return setExprOrDefaultSempred(dynamic_cast<SetExprOrDefaultContext *>(context), predicateIndex);
    case 285: return showStatementSempred(dynamic_cast<ShowStatementContext *>(context), predicateIndex);
    case 286: return showCommandTypeSempred(dynamic_cast<ShowCommandTypeContext *>(context), predicateIndex);
    case 287: return nonBlockingSempred(dynamic_cast<NonBlockingContext *>(context), predicateIndex);
    case 291: return otherAdministrativeStatementSempred(dynamic_cast<OtherAdministrativeStatementContext *>(context), predicateIndex);
    case 299: return flushOptionSempred(dynamic_cast<FlushOptionContext *>(context), predicateIndex);
    case 302: return flushTablesOptionsSempred(dynamic_cast<FlushTablesOptionsContext *>(context), predicateIndex);
    case 306: return adminPartitionSempred(dynamic_cast<AdminPartitionContext *>(context), predicateIndex);
    case 317: return utilityStatementSempred(dynamic_cast<UtilityStatementContext *>(context), predicateIndex);
    case 319: return explainCommandSempred(dynamic_cast<ExplainCommandContext *>(context), predicateIndex);
    case 320: return explainableStatementSempred(dynamic_cast<ExplainableStatementContext *>(context), predicateIndex);
    case 324: return exprSempred(dynamic_cast<ExprContext *>(context), predicateIndex);
    case 325: return boolPriSempred(dynamic_cast<BoolPriContext *>(context), predicateIndex);
    case 329: return bitExprSempred(dynamic_cast<BitExprContext *>(context), predicateIndex);
    case 330: return simpleExprSempred(dynamic_cast<SimpleExprContext *>(context), predicateIndex);
    case 331: return jsonOperatorSempred(dynamic_cast<JsonOperatorContext *>(context), predicateIndex);
    case 332: return sumExprSempred(dynamic_cast<SumExprContext *>(context), predicateIndex);
    case 343: return runtimeFunctionCallSempred(dynamic_cast<RuntimeFunctionCallContext *>(context), predicateIndex);
    case 344: return geometryFunctionSempred(dynamic_cast<GeometryFunctionContext *>(context), predicateIndex);
    case 346: return fractionalPrecisionSempred(dynamic_cast<FractionalPrecisionContext *>(context), predicateIndex);
    case 362: return castTypeSempred(dynamic_cast<CastTypeContext *>(context), predicateIndex);
    case 375: return channelSempred(dynamic_cast<ChannelContext *>(context), predicateIndex);
    case 404: return getDiagnosticsSempred(dynamic_cast<GetDiagnosticsContext *>(context), predicateIndex);
    case 420: return fieldDefinitionSempred(dynamic_cast<FieldDefinitionContext *>(context), predicateIndex);
    case 421: return columnAttributeSempred(dynamic_cast<ColumnAttributeContext *>(context), predicateIndex);
    case 429: return keyListVariantsSempred(dynamic_cast<KeyListVariantsContext *>(context), predicateIndex);
    case 432: return commonIndexOptionSempred(dynamic_cast<CommonIndexOptionContext *>(context), predicateIndex);
    case 438: return dataTypeSempred(dynamic_cast<DataTypeContext *>(context), predicateIndex);
    case 448: return typeDatetimePrecisionSempred(dynamic_cast<TypeDatetimePrecisionContext *>(context), predicateIndex);
    case 449: return charsetNameSempred(dynamic_cast<CharsetNameContext *>(context), predicateIndex);
    case 450: return collationNameSempred(dynamic_cast<CollationNameContext *>(context), predicateIndex);
    case 453: return createTableOptionSempred(dynamic_cast<CreateTableOptionContext *>(context), predicateIndex);
    case 461: return partitionKeyAlgorithmSempred(dynamic_cast<PartitionKeyAlgorithmContext *>(context), predicateIndex);
    case 488: return createUserEntrySempred(dynamic_cast<CreateUserEntryContext *>(context), predicateIndex);
    case 496: return onlineOptionSempred(dynamic_cast<OnlineOptionContext *>(context), predicateIndex);
    case 498: return usePartitionSempred(dynamic_cast<UsePartitionContext *>(context), predicateIndex);
    case 500: return columnNameSempred(dynamic_cast<ColumnNameContext *>(context), predicateIndex);
    case 543: return pureIdentifierSempred(dynamic_cast<PureIdentifierContext *>(context), predicateIndex);
    case 548: return simpleIdentifierSempred(dynamic_cast<SimpleIdentifierContext *>(context), predicateIndex);
    case 557: return textStringLiteralSempred(dynamic_cast<TextStringLiteralContext *>(context), predicateIndex);
    case 576: return identifierKeywordSempred(dynamic_cast<IdentifierKeywordContext *>(context), predicateIndex);
    case 578: return roleOrIdentifierKeywordSempred(dynamic_cast<RoleOrIdentifierKeywordContext *>(context), predicateIndex);
    case 579: return roleOrLabelKeywordSempred(dynamic_cast<RoleOrLabelKeywordContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool MySQLParser::simpleStatementSempred(SimpleStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return serverVersion >= 80000;
    case 1: return serverVersion >= 80000;
    case 2: return serverVersion >= 80000;
    case 3: return serverVersion >= 50604;
    case 4: return serverVersion >= 50500;
    case 5: return serverVersion >= 50500;

  default:
    break;
  }
  return true;
}

bool MySQLParser::alterStatementSempred(AlterStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 6: return serverVersion >= 80014;
    case 7: return serverVersion >= 50713;

  default:
    break;
  }
  return true;
}

bool MySQLParser::alterDatabaseSempred(AlterDatabaseContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 8: return serverVersion < 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::alterTableSempred(AlterTableContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 9: return serverVersion < 50700;

  default:
    break;
  }
  return true;
}

bool MySQLParser::standaloneAlterCommandsSempred(StandaloneAlterCommandsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 10: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::alterPartitionSempred(AlterPartitionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 11: return serverVersion >= 50500;
    case 12: return serverVersion >= 50704;
    case 13: return serverVersion >= 50704;

  default:
    break;
  }
  return true;
}

bool MySQLParser::alterCommandsModifierSempred(AlterCommandsModifierContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 14: return serverVersion >= 50600;
    case 15: return serverVersion >= 50600;

  default:
    break;
  }
  return true;
}

bool MySQLParser::alterListItemSempred(AlterListItemContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 16: return serverVersion >= 50700;
    case 17: return serverVersion < 50700;
    case 18: return serverVersion >= 80014;
    case 19: return serverVersion >= 80000;
    case 20: return serverVersion >= 50700;
    case 21: return serverVersion >= 80014;
    case 22: return serverVersion >= 50708 && serverVersion < 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::indexLockAndAlgorithmSempred(IndexLockAndAlgorithmContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 23: return serverVersion >= 50600;

  default:
    break;
  }
  return true;
}

bool MySQLParser::withValidationSempred(WithValidationContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 24: return serverVersion >= 50706;

  default:
    break;
  }
  return true;
}

bool MySQLParser::alterTablespaceSempred(AlterTablespaceContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 25: return serverVersion < 80000;
    case 26: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::createStatementSempred(CreateStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 27: return serverVersion >= 80000;
    case 28: return serverVersion >= 80011;
    case 29: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::createDatabaseOptionSempred(CreateDatabaseOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 30: return serverVersion >= 80016;

  default:
    break;
  }
  return true;
}

bool MySQLParser::createIndexSempred(CreateIndexContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 31: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::tsDataFileNameSempred(TsDataFileNameContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 32: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::tablespaceOptionSempred(TablespaceOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 33: return serverVersion >= 50707;
    case 34: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::triggerFollowsPrecedesClauseSempred(TriggerFollowsPrecedesClauseContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 35: return serverVersion >= 50700;

  default:
    break;
  }
  return true;
}

bool MySQLParser::dropStatementSempred(DropStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 36: return serverVersion >= 80000;
    case 37: return serverVersion >= 80011;
    case 38: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::deleteStatementSempred(DeleteStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 39: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::partitionDeleteSempred(PartitionDeleteContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 40: return serverVersion >= 50602;

  default:
    break;
  }
  return true;
}

bool MySQLParser::doStatementSempred(DoStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 41: return serverVersion < 50709;
    case 42: return serverVersion >= 50709;

  default:
    break;
  }
  return true;
}

bool MySQLParser::dataOrXmlSempred(DataOrXmlContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 43: return serverVersion >= 50500;

  default:
    break;
  }
  return true;
}

bool MySQLParser::xmlRowsIdentifiedBySempred(XmlRowsIdentifiedByContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 44: return serverVersion >= 50500;

  default:
    break;
  }
  return true;
}

bool MySQLParser::queryExpressionSempred(QueryExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 45: return serverVersion >= 80000;
    case 46: return serverVersion < 80000;
    case 47: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::queryExpressionBodySempred(QueryExpressionBodyContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 48: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool MySQLParser::querySpecificationSempred(QuerySpecificationContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 49: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::olapOptionSempred(OlapOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 50: return serverVersion < 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::selectOptionSempred(SelectOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 51: return serverVersion < 80000;
    case 52: return serverVersion >= 50704 && serverVersion < 50708;

  default:
    break;
  }
  return true;
}

bool MySQLParser::lockingClauseSempred(LockingClauseContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 53: return serverVersion >= 80000;
    case 54: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::lockStrenghSempred(LockStrenghContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 55: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::tableFactorSempred(TableFactorContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 56: return serverVersion >= 80004;

  default:
    break;
  }
  return true;
}

bool MySQLParser::derivedTableSempred(DerivedTableContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 57: return serverVersion >= 80000;
    case 58: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::jtColumnSempred(JtColumnContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 59: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::updateStatementSempred(UpdateStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 60: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::transactionCharacteristicSempred(TransactionCharacteristicContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 61: return serverVersion >= 50605;

  default:
    break;
  }
  return true;
}

bool MySQLParser::setTransactionCharacteristicSempred(SetTransactionCharacteristicContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 62: return serverVersion >= 50605;

  default:
    break;
  }
  return true;
}

bool MySQLParser::lockStatementSempred(LockStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 63: return serverVersion >= 80000;
    case 64: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::xaConvertSempred(XaConvertContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 65: return serverVersion >= 50704;

  default:
    break;
  }
  return true;
}

bool MySQLParser::replicationStatementSempred(ReplicationStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 66: return serverVersion > 80000;
    case 67: return serverVersion >= 50700;
    case 68: return serverVersion < 50500;
    case 69: return serverVersion > 50706;

  default:
    break;
  }
  return true;
}

bool MySQLParser::resetOptionSempred(ResetOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 70: return serverVersion < 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::masterResetOptionsSempred(MasterResetOptionsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 71: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::changeReplicationSempred(ChangeReplicationContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 72: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::slaveUntilOptionsSempred(SlaveUntilOptionsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 73: return serverVersion >= 50606;
    case 74: return serverVersion >= 50606;

  default:
    break;
  }
  return true;
}

bool MySQLParser::slaveConnectionOptionsSempred(SlaveConnectionOptionsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 75: return serverVersion >= 50604;

  default:
    break;
  }
  return true;
}

bool MySQLParser::cloneStatementSempred(CloneStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 76: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::accountManagementStatementSempred(AccountManagementStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 77: return serverVersion >= 50606;
    case 78: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::alterUserSempred(AlterUserContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 79: return serverVersion >= 50706;

  default:
    break;
  }
  return true;
}

bool MySQLParser::alterUserTailSempred(AlterUserTailContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 80: return serverVersion < 80014;
    case 81: return serverVersion >= 80014;
    case 82: return serverVersion >= 50706;
    case 83: return serverVersion >= 80014;
    case 84: return serverVersion >= 80014;
    case 85: return serverVersion >= 80014;
    case 86: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::createUserSempred(CreateUserContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 87: return serverVersion >= 50706;

  default:
    break;
  }
  return true;
}

bool MySQLParser::createUserTailSempred(CreateUserTailContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 88: return serverVersion >= 50706;

  default:
    break;
  }
  return true;
}

bool MySQLParser::defaultRoleClauseSempred(DefaultRoleClauseContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 89: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::accountLockPasswordExpireOptionsSempred(AccountLockPasswordExpireOptionsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 90: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::dropUserSempred(DropUserContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 91: return serverVersion >= 50706;

  default:
    break;
  }
  return true;
}

bool MySQLParser::grantSempred(GrantContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 92: return serverVersion >= 80000;
    case 93: return serverVersion >= 50500;

  default:
    break;
  }
  return true;
}

bool MySQLParser::grantTargetListSempred(GrantTargetListContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 94: return serverVersion < 80011;
    case 95: return serverVersion >= 80011;

  default:
    break;
  }
  return true;
}

bool MySQLParser::grantOptionsSempred(GrantOptionsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 96: return serverVersion < 80011;
    case 97: return serverVersion >= 80011;

  default:
    break;
  }
  return true;
}

bool MySQLParser::versionedRequireClauseSempred(VersionedRequireClauseContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 98: return serverVersion < 80011;

  default:
    break;
  }
  return true;
}

bool MySQLParser::revokeSempred(RevokeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 99: return serverVersion >= 80000;
    case 100: return serverVersion >= 80000;
    case 101: return serverVersion >= 50500;

  default:
    break;
  }
  return true;
}

bool MySQLParser::onTypeToSempred(OnTypeToContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 102: return serverVersion < 80000;
    case 103: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::setPasswordSempred(SetPasswordContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 104: return serverVersion < 50706;
    case 105: return serverVersion >= 80014;
    case 106: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::roleOrPrivilegeSempred(RoleOrPrivilegeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 107: return serverVersion > 80000;
    case 108: return serverVersion > 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::tableAdministrationStatementSempred(TableAdministrationStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 109: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::optionValueNoOptionTypeSempred(OptionValueNoOptionTypeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 110: return serverVersion >= 80011;

  default:
    break;
  }
  return true;
}

bool MySQLParser::setExprOrDefaultSempred(SetExprOrDefaultContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 111: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::showStatementSempred(ShowStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 112: return serverVersion < 50700;
    case 113: return serverVersion >= 50500;
    case 114: return serverVersion >= 80000;
    case 115: return serverVersion < 50700;
    case 116: return serverVersion >= 50500;
    case 117: return serverVersion >= 50704;

  default:
    break;
  }
  return true;
}

bool MySQLParser::showCommandTypeSempred(ShowCommandTypeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 118: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::nonBlockingSempred(NonBlockingContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 119: return serverVersion >= 50700 && serverVersion < 50706;

  default:
    break;
  }
  return true;
}

bool MySQLParser::otherAdministrativeStatementSempred(OtherAdministrativeStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 120: return serverVersion >= 50709;

  default:
    break;
  }
  return true;
}

bool MySQLParser::flushOptionSempred(FlushOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 121: return serverVersion < 80000;
    case 122: return serverVersion >= 50706;

  default:
    break;
  }
  return true;
}

bool MySQLParser::flushTablesOptionsSempred(FlushTablesOptionsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 123: return serverVersion >= 50606;

  default:
    break;
  }
  return true;
}

bool MySQLParser::adminPartitionSempred(AdminPartitionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 124: return serverVersion >= 50500;

  default:
    break;
  }
  return true;
}

bool MySQLParser::utilityStatementSempred(UtilityStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 125: return serverVersion >= 80011;

  default:
    break;
  }
  return true;
}

bool MySQLParser::explainCommandSempred(ExplainCommandContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 126: return serverVersion < 80000;
    case 127: return serverVersion < 80000;
    case 128: return serverVersion >= 50605;

  default:
    break;
  }
  return true;
}

bool MySQLParser::explainableStatementSempred(ExplainableStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 129: return serverVersion >= 50603;
    case 130: return serverVersion >= 50700;

  default:
    break;
  }
  return true;
}

bool MySQLParser::exprSempred(ExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 131: return precpred(_ctx, 3);
    case 132: return precpred(_ctx, 2);
    case 133: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool MySQLParser::boolPriSempred(BoolPriContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 134: return precpred(_ctx, 3);
    case 135: return precpred(_ctx, 2);
    case 136: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool MySQLParser::bitExprSempred(BitExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 137: return precpred(_ctx, 7);
    case 138: return precpred(_ctx, 6);
    case 139: return precpred(_ctx, 5);
    case 140: return precpred(_ctx, 3);
    case 141: return precpred(_ctx, 2);
    case 142: return precpred(_ctx, 1);
    case 143: return precpred(_ctx, 4);

  default:
    break;
  }
  return true;
}

bool MySQLParser::simpleExprSempred(SimpleExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 144: return serverVersion >= 80000;
    case 145: return serverVersion >= 80000;
    case 146: return precpred(_ctx, 15);
    case 147: return precpred(_ctx, 21);

  default:
    break;
  }
  return true;
}

bool MySQLParser::jsonOperatorSempred(JsonOperatorContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 148: return serverVersion >= 50708;
    case 149: return serverVersion >= 50713;

  default:
    break;
  }
  return true;
}

bool MySQLParser::sumExprSempred(SumExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 150: return serverVersion >= 80000;
    case 151: return serverVersion >= 80000;
    case 152: return serverVersion >= 80000;
    case 153: return serverVersion >= 80000;
    case 154: return serverVersion >= 80000;
    case 155: return serverVersion >= 80000;
    case 156: return serverVersion >= 80000;
    case 157: return serverVersion >= 80000;
    case 158: return serverVersion >= 80000;
    case 159: return serverVersion >= 80000;
    case 160: return serverVersion >= 80000;
    case 161: return serverVersion >= 80000;
    case 162: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::runtimeFunctionCallSempred(RuntimeFunctionCallContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 163: return serverVersion < 50607;
    case 164: return serverVersion < 80011;
    case 165: return serverVersion >= 50600;
    case 166: return serverVersion < 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::geometryFunctionSempred(GeometryFunctionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 167: return serverVersion < 50706;

  default:
    break;
  }
  return true;
}

bool MySQLParser::fractionalPrecisionSempred(FractionalPrecisionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 168: return serverVersion >= 50604;

  default:
    break;
  }
  return true;
}

bool MySQLParser::castTypeSempred(CastTypeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 169: return serverVersion >= 50708;

  default:
    break;
  }
  return true;
}

bool MySQLParser::channelSempred(ChannelContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 170: return serverVersion >= 50706;

  default:
    break;
  }
  return true;
}

bool MySQLParser::getDiagnosticsSempred(GetDiagnosticsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 171: return serverVersion >= 50700;

  default:
    break;
  }
  return true;
}

bool MySQLParser::fieldDefinitionSempred(FieldDefinitionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 172: return serverVersion >= 50707;
    case 173: return serverVersion < 80000;
    case 174: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::columnAttributeSempred(ColumnAttributeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 175: return serverVersion >= 80014;
    case 176: return serverVersion >= 80013;
    case 177: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::keyListVariantsSempred(KeyListVariantsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 178: return serverVersion >= 80013;
    case 179: return serverVersion < 80013;

  default:
    break;
  }
  return true;
}

bool MySQLParser::commonIndexOptionSempred(CommonIndexOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 180: return serverVersion >= 50600;
    case 181: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::dataTypeSempred(DataTypeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 182: return serverVersion >= 50708;

  default:
    break;
  }
  return true;
}

bool MySQLParser::typeDatetimePrecisionSempred(TypeDatetimePrecisionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 183: return serverVersion >= 50600;

  default:
    break;
  }
  return true;
}

bool MySQLParser::charsetNameSempred(CharsetNameContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 184: return serverVersion < 80011;

  default:
    break;
  }
  return true;
}

bool MySQLParser::collationNameSempred(CollationNameContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 185: return serverVersion < 80011;

  default:
    break;
  }
  return true;
}

bool MySQLParser::createTableOptionSempred(CreateTableOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 186: return serverVersion >= 80014;
    case 187: return serverVersion >= 50708;
    case 188: return serverVersion >= 50711;
    case 189: return serverVersion >= 50600;
    case 190: return serverVersion >= 50707;

  default:
    break;
  }
  return true;
}

bool MySQLParser::partitionKeyAlgorithmSempred(PartitionKeyAlgorithmContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 191: return serverVersion >= 50700;

  default:
    break;
  }
  return true;
}

bool MySQLParser::createUserEntrySempred(CreateUserEntryContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 192: return serverVersion < 80011;
    case 193: return serverVersion >= 50600;
    case 194: return serverVersion >= 50706;

  default:
    break;
  }
  return true;
}

bool MySQLParser::onlineOptionSempred(OnlineOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 195: return serverVersion < 50600;

  default:
    break;
  }
  return true;
}

bool MySQLParser::usePartitionSempred(UsePartitionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 196: return serverVersion >= 50602;

  default:
    break;
  }
  return true;
}

bool MySQLParser::columnNameSempred(ColumnNameContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 197: return serverVersion >= 80000;
    case 198: return serverVersion < 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::pureIdentifierSempred(PureIdentifierContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 199: return isSqlModeActive(AnsiQuotes);

  default:
    break;
  }
  return true;
}

bool MySQLParser::simpleIdentifierSempred(SimpleIdentifierContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 200: return serverVersion < 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::textStringLiteralSempred(TextStringLiteralContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 201: return !isSqlModeActive(AnsiQuotes);

  default:
    break;
  }
  return true;
}

bool MySQLParser::identifierKeywordSempred(IdentifierKeywordContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 202: return serverVersion >= 50709;
    case 203: return serverVersion >= 80011;

  default:
    break;
  }
  return true;
}

bool MySQLParser::roleOrIdentifierKeywordSempred(RoleOrIdentifierKeywordContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 204: return serverVersion >= 50709;
    case 205: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::roleOrLabelKeywordSempred(RoleOrLabelKeywordContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 206: return serverVersion < 50709;
    case 207: return serverVersion < 80000;
    case 208: return serverVersion >= 80000;
    case 209: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

// Static vars and initialization.
std::vector<dfa::DFA> MySQLParser::_decisionToDFA;
atn::PredictionContextCache MySQLParser::_sharedContextCache;

// We own the ATN which in turn owns the ATN states.
atn::ATN MySQLParser::_atn;
std::vector<uint16_t> MySQLParser::_serializedATN;

std::vector<std::string> MySQLParser::_ruleNames = {
  "query", "simpleStatement", "alterStatement", "alterDatabase", "alterEvent", 
  "alterLogfileGroup", "alterLogfileGroupOptions", "alterLogfileGroupOption", 
  "alterServer", "alterTable", "alterTableActions", "alterCommandList", 
  "alterCommandsModifierList", "standaloneAlterCommands", "alterPartition", 
  "alterList", "alterCommandsModifier", "alterListItem", "place", "restrict", 
  "alterOrderList", "alterAlgorithmOption", "alterLockOption", "indexLockAndAlgorithm", 
  "withValidation", "removePartitioning", "allOrPartitionNameList", "reorgPartitionRule", 
  "alterTablespace", "alterUndoTablespace", "undoTableSpaceOptions", "undoTableSpaceOption", 
  "alterTablespaceOptions", "alterTablespaceOption", "changeTablespaceOption", 
  "alterView", "viewTail", "viewSelect", "viewCheckOption", "createStatement", 
  "createDatabase", "createDatabaseOption", "createTable", "tableElementList", 
  "tableElement", "duplicateAsQueryExpression", "queryExpressionOrParens", 
  "createRoutine", "createProcedure", "createFunction", "createUdf", "routineCreateOption", 
  "routineAlterOptions", "routineOption", "createIndex", "indexNameAndType", 
  "createIndexTarget", "createLogfileGroup", "logfileGroupOptions", "logfileGroupOption", 
  "createServer", "serverOptions", "serverOption", "createTablespace", "createUndoTablespace", 
  "tsDataFileName", "tsDataFile", "tablespaceOptions", "tablespaceOption", 
  "tsOptionInitialSize", "tsOptionUndoRedoBufferSize", "tsOptionAutoextendSize", 
  "tsOptionMaxSize", "tsOptionExtentSize", "tsOptionNodegroup", "tsOptionEngine", 
  "tsOptionWait", "tsOptionComment", "tsOptionFileblockSize", "tsOptionEncryption", 
  "createView", "viewReplaceOrAlgorithm", "viewAlgorithm", "viewSuid", "createTrigger", 
  "triggerFollowsPrecedesClause", "createEvent", "createRole", "createSpatialReference", 
  "srsAttribute", "dropStatement", "dropDatabase", "dropEvent", "dropFunction", 
  "dropProcedure", "dropIndex", "dropLogfileGroup", "dropLogfileGroupOption", 
  "dropServer", "dropTable", "dropTableSpace", "dropTrigger", "dropView", 
  "dropRole", "dropSpatialReference", "dropUndoTablespace", "renameTableStatement", 
  "renamePair", "truncateTableStatement", "importStatement", "callStatement", 
  "deleteStatement", "partitionDelete", "deleteStatementOption", "doStatement", 
  "handlerStatement", "handlerReadOrScan", "insertStatement", "insertLockOption", 
  "insertFromConstructor", "fields", "insertValues", "insertQueryExpression", 
  "valueList", "values", "insertUpdateList", "loadStatement", "dataOrXml", 
  "xmlRowsIdentifiedBy", "loadDataFileTail", "loadDataFileTargetList", "fieldOrVariableList", 
  "replaceStatement", "selectStatement", "selectStatementWithInto", "queryExpression", 
  "queryExpressionBody", "queryExpressionParens", "querySpecification", 
  "subquery", "querySpecOption", "limitClause", "simpleLimitClause", "limitOptions", 
  "limitOption", "intoClause", "procedureAnalyseClause", "havingClause", 
  "windowClause", "windowDefinition", "windowSpec", "windowSpecDetails", 
  "windowFrameClause", "windowFrameUnits", "windowFrameExtent", "windowFrameStart", 
  "windowFrameBetween", "windowFrameBound", "windowFrameExclusion", "withClause", 
  "commonTableExpression", "groupByClause", "olapOption", "orderClause", 
  "direction", "fromClause", "tableReferenceList", "selectOption", "lockingClause", 
  "lockStrengh", "lockedRowAction", "selectItemList", "selectItem", "selectAlias", 
  "whereClause", "tableReference", "escapedTableReference", "joinedTable", 
  "naturalJoinType", "innerJoinType", "outerJoinType", "tableFactor", "singleTable", 
  "singleTableParens", "derivedTable", "tableReferenceListParens", "tableFunction", 
  "columnsClause", "jtColumn", "onEmptyOrError", "onEmpty", "onError", "jtOnResponse", 
  "unionOption", "tableAlias", "indexHintList", "indexHint", "indexHintType", 
  "keyOrIndex", "constraintKeyType", "indexHintClause", "indexList", "indexListElement", 
  "updateStatement", "transactionOrLockingStatement", "transactionStatement", 
  "beginWork", "transactionCharacteristic", "setTransactionCharacteristic", 
  "isolationLevel", "savepointStatement", "lockStatement", "lockItem", "lockOption", 
  "xaStatement", "xaConvert", "xid", "replicationStatement", "resetOption", 
  "masterResetOptions", "replicationLoad", "changeMaster", "changeMasterOptions", 
  "masterOption", "masterFileDef", "serverIdList", "changeReplication", 
  "filterDefinition", "filterDbList", "filterTableList", "filterStringList", 
  "filterWildDbTableString", "filterDbPairList", "slave", "slaveUntilOptions", 
  "slaveConnectionOptions", "slaveThreadOptions", "slaveThreadOption", "groupReplication", 
  "preparedStatement", "executeStatement", "executeVarList", "cloneStatement", 
  "dataDirSSL", "ssl", "accountManagementStatement", "alterUser", "alterUserTail", 
  "createUser", "createUserTail", "defaultRoleClause", "requireClause", 
  "connectOptions", "accountLockPasswordExpireOptions", "dropUser", "grant", 
  "grantTargetList", "grantOptions", "versionedRequireClause", "renameUser", 
  "revoke", "onTypeTo", "aclType", "setPassword", "roleOrPrivilegesList", 
  "roleOrPrivilege", "grantIdentifier", "requireList", "requireListElement", 
  "grantOption", "setRole", "roleList", "role", "tableAdministrationStatement", 
  "histogram", "checkOption", "repairType", "installUninstallStatment", 
  "setStatement", "optionValueNoOptionType", "setSystemVariable", "optionValueFollowingOptionType", 
  "setExprOrDefault", "optionValueList", "optionValue", "showStatement", 
  "showCommandType", "nonBlocking", "fromOrIn", "inDb", "profileType", "otherAdministrativeStatement", 
  "keyCacheListOrParts", "keyCacheList", "assignToKeycache", "assignToKeycachePartition", 
  "cacheKeyList", "keyUsageElement", "keyUsageList", "flushOption", "logType", 
  "flushTables", "flushTablesOptions", "preloadTail", "preloadList", "preloadKeys", 
  "adminPartition", "resourceGroupManagement", "createResourceGroup", "resourceGroupVcpuList", 
  "vcpuNumOrRange", "resourceGroupPriority", "resourceGroupEnableDisable", 
  "alterResourceGroup", "setResourceGroup", "threadIdList", "dropResourceGroup", 
  "utilityStatement", "describeCommand", "explainCommand", "explainableStatement", 
  "helpCommand", "useCommand", "restartServer", "expr", "boolPri", "compOp", 
  "predicate", "predicateOperations", "bitExpr", "simpleExpr", "jsonOperator", 
  "sumExpr", "groupingOperation", "windowFunctionCall", "windowingClause", 
  "leadLagInfo", "nullTreatment", "jsonFunction", "inSumExpr", "identListArg", 
  "identList", "fulltextOptions", "runtimeFunctionCall", "geometryFunction", 
  "timeFunctionParameters", "fractionalPrecision", "weightStringLevels", 
  "weightStringLevelListItem", "dateTimeTtype", "trimFunction", "substringFunction", 
  "functionCall", "udfExprList", "udfExpr", "variable", "userVariable", 
  "systemVariable", "internalVariableName", "whenExpression", "thenExpression", 
  "elseExpression", "castType", "exprList", "charset", "notRule", "not2Rule", 
  "interval", "intervalTimeStamp", "exprListWithParentheses", "exprWithParentheses", 
  "orderList", "orderExpression", "groupList", "groupingExpression", "channel", 
  "compoundStatement", "returnStatement", "ifStatement", "ifBody", "thenStatement", 
  "compoundStatementList", "caseStatement", "elseStatement", "labeledBlock", 
  "unlabeledBlock", "label", "beginEndBlock", "labeledControl", "unlabeledControl", 
  "loopBlock", "whileDoBlock", "repeatUntilBlock", "spDeclarations", "spDeclaration", 
  "variableDeclaration", "conditionDeclaration", "spCondition", "sqlstate", 
  "handlerDeclaration", "handlerCondition", "cursorDeclaration", "iterateStatement", 
  "leaveStatement", "getDiagnostics", "signalAllowedExpr", "statementInformationItem", 
  "conditionInformationItem", "signalInformationItemName", "signalStatement", 
  "resignalStatement", "signalInformationItem", "cursorOpen", "cursorClose", 
  "cursorFetch", "schedule", "columnDefinition", "checkOrReferences", "checkConstraint", 
  "tableConstraintDef", "fieldDefinition", "columnAttribute", "gcolAttribute", 
  "references", "deleteOption", "keyList", "keyPart", "keyListWithExpression", 
  "keyPartOrExpression", "keyListVariants", "indexType", "indexOption", 
  "commonIndexOption", "visibility", "indexTypeClause", "fulltextIndexOption", 
  "spatialIndexOption", "dataTypeDefinition", "dataType", "nchar", "varchar", 
  "nvarchar", "fieldLength", "fieldOptions", "charsetWithOptBinary", "ascii", 
  "unicode", "wsNumCodepoints", "typeDatetimePrecision", "charsetName", 
  "collationName", "createTableOptions", "createTableOptionsSpaceSeparated", 
  "createTableOption", "ternaryOption", "defaultCollation", "defaultEncryption", 
  "defaultCharset", "partitionClause", "partitionTypeDef", "subPartitions", 
  "partitionKeyAlgorithm", "partitionDefinitions", "partitionDefinition", 
  "partitionValuesIn", "partitionOption", "subpartitionDefinition", "partitionValueItemListParen", 
  "partitionValueItem", "definerClause", "ifExists", "ifNotExists", "procedureParameter", 
  "functionParameter", "collate", "typeWithOptCollate", "schemaIdentifierPair", 
  "viewRefList", "updateList", "updateElement", "charsetClause", "fieldsClause", 
  "fieldTerm", "linesClause", "lineTerm", "userList", "createUserList", 
  "alterUserList", "createUserEntry", "alterUserEntry", "retainCurrentPassword", 
  "discardOldPassword", "replacePassword", "user", "likeClause", "likeOrWhere", 
  "onlineOption", "noWriteToBinLog", "usePartition", "fieldIdentifier", 
  "columnName", "columnInternalRef", "columnInternalRefList", "columnRef", 
  "insertIdentifier", "indexName", "indexRef", "tableWild", "schemaName", 
  "schemaRef", "procedureName", "procedureRef", "functionName", "functionRef", 
  "triggerName", "triggerRef", "viewName", "viewRef", "tablespaceName", 
  "tablespaceRef", "logfileGroupName", "logfileGroupRef", "eventName", "eventRef", 
  "udfName", "serverName", "serverRef", "engineRef", "tableName", "filterTableRef", 
  "tableRefWithWildcard", "tableRef", "tableRefList", "tableAliasRefList", 
  "parameterName", "labelIdentifier", "labelRef", "roleIdentifier", "roleRef", 
  "pluginRef", "componentRef", "resourceGroupRef", "windowName", "pureIdentifier", 
  "identifier", "identifierList", "identifierListWithParentheses", "qualifiedIdentifier", 
  "simpleIdentifier", "dotIdentifier", "ulong_number", "real_ulong_number", 
  "ulonglong_number", "real_ulonglong_number", "literal", "signedLiteral", 
  "stringList", "textStringLiteral", "textString", "textLiteral", "textStringNoLinebreak", 
  "textStringLiteralList", "numLiteral", "boolLiteral", "nullLiteral", "temporalLiteral", 
  "floatOptions", "precision", "textOrIdentifier", "roleIdentifierOrText", 
  "sizeNumber", "parentheses", "equal", "optionType", "varIdentType", "setVarIdentType", 
  "identifierKeyword", "labelKeyword", "roleOrIdentifierKeyword", "roleOrLabelKeyword", 
  "roleKeyword"
};

std::vector<std::string> MySQLParser::_literalNames = {
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "'='", "':='", "'<=>'", "'>='", "'>'", "'<='", "'<'", 
  "'!='", "'+'", "'-'", "'*'", "'/'", "'%'", "'!'", "'~'", "'<<'", "'>>'", 
  "'&&'", "'&'", "'^'", "'||'", "'|'", "'.'", "','", "';'", "':'", "'('", 
  "')'", "'{'", "'}'", "'_'", "'->'", "'->>'", "'@'", "", "'@@'", "'\\N'", 
  "'?'", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "'<>'"
};

std::vector<std::string> MySQLParser::_symbolicNames = {
  "", "ACCOUNT_SYMBOL", "ASCII_SYMBOL", "ALWAYS_SYMBOL", "BACKUP_SYMBOL", 
  "BEGIN_SYMBOL", "BYTE_SYMBOL", "CACHE_SYMBOL", "CHARSET_SYMBOL", "CHECKSUM_SYMBOL", 
  "CLOSE_SYMBOL", "COMMENT_SYMBOL", "COMMIT_SYMBOL", "CONTAINS_SYMBOL", 
  "DEALLOCATE_SYMBOL", "DO_SYMBOL", "END_SYMBOL", "EXECUTE_SYMBOL", "FLUSH_SYMBOL", 
  "FOLLOWS_SYMBOL", "FORMAT_SYMBOL", "GROUP_REPLICATION_SYMBOL", "HANDLER_SYMBOL", 
  "HELP_SYMBOL", "HOST_SYMBOL", "INSTALL_SYMBOL", "LANGUAGE_SYMBOL", "NO_SYMBOL", 
  "OPEN_SYMBOL", "OPTIONS_SYMBOL", "OWNER_SYMBOL", "PARSER_SYMBOL", "PARTITION_SYMBOL", 
  "PORT_SYMBOL", "PRECEDES_SYMBOL", "PREPARE_SYMBOL", "REMOVE_SYMBOL", "REPAIR_SYMBOL", 
  "RESET_SYMBOL", "RESTORE_SYMBOL", "ROLLBACK_SYMBOL", "SAVEPOINT_SYMBOL", 
  "SECURITY_SYMBOL", "SERVER_SYMBOL", "SIGNED_SYMBOL", "SLAVE_SYMBOL", "SOCKET_SYMBOL", 
  "SONAME_SYMBOL", "START_SYMBOL", "STOP_SYMBOL", "TRUNCATE_SYMBOL", "UNICODE_SYMBOL", 
  "UNINSTALL_SYMBOL", "UPGRADE_SYMBOL", "WRAPPER_SYMBOL", "XA_SYMBOL", "SHUTDOWN_SYMBOL", 
  "ACTION_SYMBOL", "ADDDATE_SYMBOL", "AFTER_SYMBOL", "AGAINST_SYMBOL", "AGGREGATE_SYMBOL", 
  "ALGORITHM_SYMBOL", "ANALYZE_SYMBOL", "ANY_SYMBOL", "AT_SYMBOL", "AUTHORS_SYMBOL", 
  "AUTO_INCREMENT_SYMBOL", "AUTOEXTEND_SIZE_SYMBOL", "AVG_ROW_LENGTH_SYMBOL", 
  "AVG_SYMBOL", "BINLOG_SYMBOL", "BIT_SYMBOL", "BLOCK_SYMBOL", "BOOL_SYMBOL", 
  "BOOLEAN_SYMBOL", "BTREE_SYMBOL", "CASCADED_SYMBOL", "CATALOG_NAME_SYMBOL", 
  "CHAIN_SYMBOL", "CHANGED_SYMBOL", "CHANNEL_SYMBOL", "CIPHER_SYMBOL", "CLIENT_SYMBOL", 
  "CLASS_ORIGIN_SYMBOL", "COALESCE_SYMBOL", "CODE_SYMBOL", "COLLATION_SYMBOL", 
  "COLUMN_NAME_SYMBOL", "COLUMN_FORMAT_SYMBOL", "COLUMNS_SYMBOL", "COMMITTED_SYMBOL", 
  "COMPACT_SYMBOL", "COMPLETION_SYMBOL", "COMPRESSED_SYMBOL", "COMPRESSION_SYMBOL", 
  "ENCRYPTION_SYMBOL", "CONCURRENT_SYMBOL", "CONNECTION_SYMBOL", "CONSISTENT_SYMBOL", 
  "CONSTRAINT_CATALOG_SYMBOL", "CONSTRAINT_SCHEMA_SYMBOL", "CONSTRAINT_NAME_SYMBOL", 
  "CONTEXT_SYMBOL", "CONTRIBUTORS_SYMBOL", "CPU_SYMBOL", "CUBE_SYMBOL", 
  "CURRENT_SYMBOL", "CURSOR_NAME_SYMBOL", "DATA_SYMBOL", "DATAFILE_SYMBOL", 
  "DATETIME_SYMBOL", "DATE_SYMBOL", "DAY_SYMBOL", "DEFAULT_AUTH_SYMBOL", 
  "DEFINER_SYMBOL", "DELAY_KEY_WRITE_SYMBOL", "DES_KEY_FILE_SYMBOL", "DIAGNOSTICS_SYMBOL", 
  "DIRECTORY_SYMBOL", "DISABLE_SYMBOL", "DISCARD_SYMBOL", "DISK_SYMBOL", 
  "DUMPFILE_SYMBOL", "DUPLICATE_SYMBOL", "DYNAMIC_SYMBOL", "ENDS_SYMBOL", 
  "ENUM_SYMBOL", "ENGINE_SYMBOL", "ENGINES_SYMBOL", "ERROR_SYMBOL", "ERRORS_SYMBOL", 
  "ESCAPE_SYMBOL", "EVENT_SYMBOL", "EVENTS_SYMBOL", "EVERY_SYMBOL", "EXPANSION_SYMBOL", 
  "EXPORT_SYMBOL", "EXTENDED_SYMBOL", "EXTENT_SIZE_SYMBOL", "FAULTS_SYMBOL", 
  "FAST_SYMBOL", "FOUND_SYMBOL", "ENABLE_SYMBOL", "FULL_SYMBOL", "FILE_SYMBOL", 
  "FILE_BLOCK_SIZE_SYMBOL", "FILTER_SYMBOL", "FIRST_SYMBOL", "FIXED_SYMBOL", 
  "GENERAL_SYMBOL", "GEOMETRY_SYMBOL", "GEOMETRYCOLLECTION_SYMBOL", "GET_FORMAT_SYMBOL", 
  "GRANTS_SYMBOL", "GLOBAL_SYMBOL", "HASH_SYMBOL", "HOSTS_SYMBOL", "HOUR_SYMBOL", 
  "IDENTIFIED_SYMBOL", "IGNORE_SERVER_IDS_SYMBOL", "INVOKER_SYMBOL", "IMPORT_SYMBOL", 
  "INDEXES_SYMBOL", "INITIAL_SIZE_SYMBOL", "INSTANCE_SYMBOL", "INNODB_SYMBOL", 
  "IO_SYMBOL", "IPC_SYMBOL", "ISOLATION_SYMBOL", "ISSUER_SYMBOL", "INSERT_METHOD_SYMBOL", 
  "JSON_SYMBOL", "KEY_BLOCK_SIZE_SYMBOL", "LAST_SYMBOL", "LEAVES_SYMBOL", 
  "LESS_SYMBOL", "LEVEL_SYMBOL", "LINESTRING_SYMBOL", "LIST_SYMBOL", "LOCAL_SYMBOL", 
  "LOCKS_SYMBOL", "LOGFILE_SYMBOL", "LOGS_SYMBOL", "MAX_ROWS_SYMBOL", "MASTER_SYMBOL", 
  "MASTER_HEARTBEAT_PERIOD_SYMBOL", "MASTER_HOST_SYMBOL", "MASTER_PORT_SYMBOL", 
  "MASTER_LOG_FILE_SYMBOL", "MASTER_LOG_POS_SYMBOL", "MASTER_USER_SYMBOL", 
  "MASTER_PASSWORD_SYMBOL", "MASTER_SERVER_ID_SYMBOL", "MASTER_CONNECT_RETRY_SYMBOL", 
  "MASTER_RETRY_COUNT_SYMBOL", "MASTER_DELAY_SYMBOL", "MASTER_SSL_SYMBOL", 
  "MASTER_SSL_CA_SYMBOL", "MASTER_SSL_CAPATH_SYMBOL", "MASTER_TLS_VERSION_SYMBOL", 
  "MASTER_SSL_CERT_SYMBOL", "MASTER_SSL_CIPHER_SYMBOL", "MASTER_SSL_CRL_SYMBOL", 
  "MASTER_SSL_CRLPATH_SYMBOL", "MASTER_SSL_KEY_SYMBOL", "MASTER_AUTO_POSITION_SYMBOL", 
  "MAX_CONNECTIONS_PER_HOUR_SYMBOL", "MAX_QUERIES_PER_HOUR_SYMBOL", "MAX_STATEMENT_TIME_SYMBOL", 
  "MAX_SIZE_SYMBOL", "MAX_UPDATES_PER_HOUR_SYMBOL", "MAX_USER_CONNECTIONS_SYMBOL", 
  "MEDIUM_SYMBOL", "MEMORY_SYMBOL", "MERGE_SYMBOL", "MESSAGE_TEXT_SYMBOL", 
  "MICROSECOND_SYMBOL", "MIGRATE_SYMBOL", "MINUTE_SYMBOL", "MIN_ROWS_SYMBOL", 
  "MODIFY_SYMBOL", "MODE_SYMBOL", "MONTH_SYMBOL", "MULTILINESTRING_SYMBOL", 
  "MULTIPOINT_SYMBOL", "MULTIPOLYGON_SYMBOL", "MUTEX_SYMBOL", "MYSQL_ERRNO_SYMBOL", 
  "NAME_SYMBOL", "NAMES_SYMBOL", "NATIONAL_SYMBOL", "NCHAR_SYMBOL", "NDBCLUSTER_SYMBOL", 
  "NEVER_SYMBOL", "NEXT_SYMBOL", "NEW_SYMBOL", "NO_WAIT_SYMBOL", "NODEGROUP_SYMBOL", 
  "NONE_SYMBOL", "NUMBER_SYMBOL", "NVARCHAR_SYMBOL", "OFFSET_SYMBOL", "OLD_PASSWORD_SYMBOL", 
  "ONE_SHOT_SYMBOL", "ONE_SYMBOL", "PACK_KEYS_SYMBOL", "PAGE_SYMBOL", "PARTIAL_SYMBOL", 
  "PARTITIONING_SYMBOL", "PARTITIONS_SYMBOL", "PASSWORD_SYMBOL", "PHASE_SYMBOL", 
  "PLUGIN_DIR_SYMBOL", "PLUGIN_SYMBOL", "PLUGINS_SYMBOL", "POINT_SYMBOL", 
  "POLYGON_SYMBOL", "PRESERVE_SYMBOL", "PREV_SYMBOL", "PRIVILEGES_SYMBOL", 
  "PROCESS_SYMBOL", "PROCESSLIST_SYMBOL", "PROFILE_SYMBOL", "PROFILES_SYMBOL", 
  "PROXY_SYMBOL", "QUARTER_SYMBOL", "QUERY_SYMBOL", "QUICK_SYMBOL", "READ_ONLY_SYMBOL", 
  "REBUILD_SYMBOL", "RECOVER_SYMBOL", "REDO_BUFFER_SIZE_SYMBOL", "REDOFILE_SYMBOL", 
  "REDUNDANT_SYMBOL", "RELAY_SYMBOL", "RELAYLOG_SYMBOL", "RELAY_LOG_FILE_SYMBOL", 
  "RELAY_LOG_POS_SYMBOL", "RELAY_THREAD_SYMBOL", "RELOAD_SYMBOL", "REORGANIZE_SYMBOL", 
  "REPEATABLE_SYMBOL", "REPLICATION_SYMBOL", "REPLICATE_DO_DB_SYMBOL", "REPLICATE_IGNORE_DB_SYMBOL", 
  "REPLICATE_DO_TABLE_SYMBOL", "REPLICATE_IGNORE_TABLE_SYMBOL", "REPLICATE_WILD_DO_TABLE_SYMBOL", 
  "REPLICATE_WILD_IGNORE_TABLE_SYMBOL", "REPLICATE_REWRITE_DB_SYMBOL", "RESUME_SYMBOL", 
  "RETURNED_SQLSTATE_SYMBOL", "RETURNS_SYMBOL", "REVERSE_SYMBOL", "ROLLUP_SYMBOL", 
  "ROTATE_SYMBOL", "ROUTINE_SYMBOL", "ROWS_SYMBOL", "ROW_COUNT_SYMBOL", 
  "ROW_FORMAT_SYMBOL", "ROW_SYMBOL", "RTREE_SYMBOL", "SCHEDULE_SYMBOL", 
  "SCHEMA_NAME_SYMBOL", "SECOND_SYMBOL", "SERIAL_SYMBOL", "SERIALIZABLE_SYMBOL", 
  "SESSION_SYMBOL", "SIMPLE_SYMBOL", "SHARE_SYMBOL", "SLOW_SYMBOL", "SNAPSHOT_SYMBOL", 
  "SOUNDS_SYMBOL", "SOURCE_SYMBOL", "SQL_AFTER_GTIDS_SYMBOL", "SQL_AFTER_MTS_GAPS_SYMBOL", 
  "SQL_BEFORE_GTIDS_SYMBOL", "SQL_CACHE_SYMBOL", "SQL_BUFFER_RESULT_SYMBOL", 
  "SQL_NO_CACHE_SYMBOL", "SQL_THREAD_SYMBOL", "STACKED_SYMBOL", "STARTS_SYMBOL", 
  "STATS_AUTO_RECALC_SYMBOL", "STATS_PERSISTENT_SYMBOL", "STATS_SAMPLE_PAGES_SYMBOL", 
  "STATUS_SYMBOL", "STORAGE_SYMBOL", "STRING_SYMBOL", "SUBCLASS_ORIGIN_SYMBOL", 
  "SUBDATE_SYMBOL", "SUBJECT_SYMBOL", "SUBPARTITION_SYMBOL", "SUBPARTITIONS_SYMBOL", 
  "SUPER_SYMBOL", "SUSPEND_SYMBOL", "SWAPS_SYMBOL", "SWITCHES_SYMBOL", "TABLE_NAME_SYMBOL", 
  "TABLES_SYMBOL", "TABLE_CHECKSUM_SYMBOL", "TABLESPACE_SYMBOL", "TEMPORARY_SYMBOL", 
  "TEMPTABLE_SYMBOL", "TEXT_SYMBOL", "THAN_SYMBOL", "TRANSACTION_SYMBOL", 
  "TRIGGERS_SYMBOL", "TIMESTAMP_SYMBOL", "TIMESTAMP_ADD_SYMBOL", "TIMESTAMP_DIFF_SYMBOL", 
  "TIME_SYMBOL", "TYPES_SYMBOL", "TYPE_SYMBOL", "UDF_RETURNS_SYMBOL", "FUNCTION_SYMBOL", 
  "UNCOMMITTED_SYMBOL", "UNDEFINED_SYMBOL", "UNDO_BUFFER_SIZE_SYMBOL", "UNDOFILE_SYMBOL", 
  "UNKNOWN_SYMBOL", "UNTIL_SYMBOL", "USER_RESOURCES_SYMBOL", "USER_SYMBOL", 
  "USE_FRM_SYMBOL", "VARIABLES_SYMBOL", "VIEW_SYMBOL", "VALUE_SYMBOL", "WARNINGS_SYMBOL", 
  "WAIT_SYMBOL", "WEEK_SYMBOL", "WORK_SYMBOL", "WEIGHT_STRING_SYMBOL", "X509_SYMBOL", 
  "XID_SYMBOL", "XML_SYMBOL", "YEAR_SYMBOL", "NOT2_SYMBOL", "CONCAT_PIPES_SYMBOL", 
  "INT_NUMBER", "LONG_NUMBER", "ULONGLONG_NUMBER", "EQUAL_OPERATOR", "ASSIGN_OPERATOR", 
  "NULL_SAFE_EQUAL_OPERATOR", "GREATER_OR_EQUAL_OPERATOR", "GREATER_THAN_OPERATOR", 
  "LESS_OR_EQUAL_OPERATOR", "LESS_THAN_OPERATOR", "NOT_EQUAL_OPERATOR", 
  "PLUS_OPERATOR", "MINUS_OPERATOR", "MULT_OPERATOR", "DIV_OPERATOR", "MOD_OPERATOR", 
  "LOGICAL_NOT_OPERATOR", "BITWISE_NOT_OPERATOR", "SHIFT_LEFT_OPERATOR", 
  "SHIFT_RIGHT_OPERATOR", "LOGICAL_AND_OPERATOR", "BITWISE_AND_OPERATOR", 
  "BITWISE_XOR_OPERATOR", "LOGICAL_OR_OPERATOR", "BITWISE_OR_OPERATOR", 
  "DOT_SYMBOL", "COMMA_SYMBOL", "SEMICOLON_SYMBOL", "COLON_SYMBOL", "OPEN_PAR_SYMBOL", 
  "CLOSE_PAR_SYMBOL", "OPEN_CURLY_SYMBOL", "CLOSE_CURLY_SYMBOL", "UNDERLINE_SYMBOL", 
  "JSON_SEPARATOR_SYMBOL", "JSON_UNQUOTED_SEPARATOR_SYMBOL", "AT_SIGN_SYMBOL", 
  "AT_TEXT_SUFFIX", "AT_AT_SIGN_SYMBOL", "NULL2_SYMBOL", "PARAM_MARKER", 
  "HEX_NUMBER", "BIN_NUMBER", "DECIMAL_NUMBER", "FLOAT_NUMBER", "ACCESSIBLE_SYMBOL", 
  "ADD_SYMBOL", "ALL_SYMBOL", "ALTER_SYMBOL", "ANALYSE_SYMBOL", "AND_SYMBOL", 
  "AS_SYMBOL", "ASC_SYMBOL", "ASENSITIVE_SYMBOL", "BEFORE_SYMBOL", "BETWEEN_SYMBOL", 
  "BIGINT_SYMBOL", "BINARY_SYMBOL", "BIN_NUM_SYMBOL", "BIT_AND_SYMBOL", 
  "BIT_OR_SYMBOL", "BIT_XOR_SYMBOL", "BLOB_SYMBOL", "BOTH_SYMBOL", "BY_SYMBOL", 
  "CALL_SYMBOL", "CASCADE_SYMBOL", "CASE_SYMBOL", "CAST_SYMBOL", "CHANGE_SYMBOL", 
  "CHAR_SYMBOL", "CHECK_SYMBOL", "COLLATE_SYMBOL", "COLUMN_SYMBOL", "CONDITION_SYMBOL", 
  "CONSTRAINT_SYMBOL", "CONTINUE_SYMBOL", "CONVERT_SYMBOL", "COUNT_SYMBOL", 
  "CREATE_SYMBOL", "CROSS_SYMBOL", "CURDATE_SYMBOL", "CURRENT_DATE_SYMBOL", 
  "CURRENT_TIME_SYMBOL", "CURRENT_USER_SYMBOL", "CURSOR_SYMBOL", "CURTIME_SYMBOL", 
  "DATABASE_SYMBOL", "DATABASES_SYMBOL", "DATE_ADD_SYMBOL", "DATE_SUB_SYMBOL", 
  "DAY_HOUR_SYMBOL", "DAY_MICROSECOND_SYMBOL", "DAY_MINUTE_SYMBOL", "DAY_SECOND_SYMBOL", 
  "DECIMAL_NUM_SYMBOL", "DECIMAL_SYMBOL", "DECLARE_SYMBOL", "DEFAULT_SYMBOL", 
  "DELAYED_SYMBOL", "DELETE_SYMBOL", "DESC_SYMBOL", "DESCRIBE_SYMBOL", "DETERMINISTIC_SYMBOL", 
  "DISTINCT_SYMBOL", "DIV_SYMBOL", "DOUBLE_SYMBOL", "DROP_SYMBOL", "DUAL_SYMBOL", 
  "EACH_SYMBOL", "ELSE_SYMBOL", "ELSEIF_SYMBOL", "ENCLOSED_SYMBOL", "END_OF_INPUT_SYMBOL", 
  "ESCAPED_SYMBOL", "EXCHANGE_SYMBOL", "EXISTS_SYMBOL", "EXIT_SYMBOL", "EXPIRE_SYMBOL", 
  "EXTRACT_SYMBOL", "FALSE_SYMBOL", "FETCH_SYMBOL", "FLOAT_SYMBOL", "FORCE_SYMBOL", 
  "FOREIGN_SYMBOL", "FOR_SYMBOL", "FROM_SYMBOL", "FULLTEXT_SYMBOL", "GET_SYMBOL", 
  "GENERATED_SYMBOL", "GRANT_SYMBOL", "GROUP_SYMBOL", "GROUP_CONCAT_SYMBOL", 
  "HAVING_SYMBOL", "HIGH_PRIORITY_SYMBOL", "HOUR_MICROSECOND_SYMBOL", "HOUR_MINUTE_SYMBOL", 
  "HOUR_SECOND_SYMBOL", "IF_SYMBOL", "IGNORE_SYMBOL", "INDEX_SYMBOL", "INFILE_SYMBOL", 
  "INNER_SYMBOL", "INOUT_SYMBOL", "INSENSITIVE_SYMBOL", "INSERT_SYMBOL", 
  "INTERVAL_SYMBOL", "INTO_SYMBOL", "INT_SYMBOL", "IN_SYMBOL", "IO_AFTER_GTIDS_SYMBOL", 
  "IO_BEFORE_GTIDS_SYMBOL", "IS_SYMBOL", "ITERATE_SYMBOL", "JOIN_SYMBOL", 
  "KEYS_SYMBOL", "KEY_SYMBOL", "KILL_SYMBOL", "LEADING_SYMBOL", "LEAVE_SYMBOL", 
  "LEFT_SYMBOL", "LIKE_SYMBOL", "LIMIT_SYMBOL", "LINEAR_SYMBOL", "LINES_SYMBOL", 
  "LOAD_SYMBOL", "LOCATOR_SYMBOL", "LOCK_SYMBOL", "LONGBLOB_SYMBOL", "LONGTEXT_SYMBOL", 
  "LONG_NUM_SYMBOL", "LONG_SYMBOL", "LOOP_SYMBOL", "LOW_PRIORITY_SYMBOL", 
  "MASTER_BIND_SYMBOL", "MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL", "MATCH_SYMBOL", 
  "MAX_SYMBOL", "MAXVALUE_SYMBOL", "MEDIUMBLOB_SYMBOL", "MEDIUMINT_SYMBOL", 
  "MEDIUMTEXT_SYMBOL", "MID_SYMBOL", "MINUTE_MICROSECOND_SYMBOL", "MINUTE_SECOND_SYMBOL", 
  "MIN_SYMBOL", "MODIFIES_SYMBOL", "MOD_SYMBOL", "NATURAL_SYMBOL", "NCHAR_STRING_SYMBOL", 
  "NEG_SYMBOL", "NONBLOCKING_SYMBOL", "NOT_SYMBOL", "NOW_SYMBOL", "NO_WRITE_TO_BINLOG_SYMBOL", 
  "NULL_SYMBOL", "NUMERIC_SYMBOL", "OFFLINE_SYMBOL", "ON_SYMBOL", "ONLINE_SYMBOL", 
  "ONLY_SYMBOL", "OPTIMIZE_SYMBOL", "OPTIMIZER_COSTS_SYMBOL", "OPTION_SYMBOL", 
  "OPTIONALLY_SYMBOL", "ORDER_SYMBOL", "OR_SYMBOL", "OUTER_SYMBOL", "OUTFILE_SYMBOL", 
  "OUT_SYMBOL", "POSITION_SYMBOL", "PRECISION_SYMBOL", "PRIMARY_SYMBOL", 
  "PROCEDURE_SYMBOL", "PURGE_SYMBOL", "RANGE_SYMBOL", "READS_SYMBOL", "READ_SYMBOL", 
  "READ_WRITE_SYMBOL", "REAL_SYMBOL", "REFERENCES_SYMBOL", "REGEXP_SYMBOL", 
  "RELEASE_SYMBOL", "RENAME_SYMBOL", "REPEAT_SYMBOL", "REPLACE_SYMBOL", 
  "REQUIRE_SYMBOL", "RESIGNAL_SYMBOL", "RESTRICT_SYMBOL", "RETURN_SYMBOL", 
  "REVOKE_SYMBOL", "RIGHT_SYMBOL", "SECOND_MICROSECOND_SYMBOL", "SELECT_SYMBOL", 
  "SENSITIVE_SYMBOL", "SEPARATOR_SYMBOL", "SERVER_OPTIONS_SYMBOL", "SESSION_USER_SYMBOL", 
  "SET_SYMBOL", "SET_VAR_SYMBOL", "SHOW_SYMBOL", "SIGNAL_SYMBOL", "SMALLINT_SYMBOL", 
  "SPATIAL_SYMBOL", "SPECIFIC_SYMBOL", "SQLEXCEPTION_SYMBOL", "SQLSTATE_SYMBOL", 
  "SQLWARNING_SYMBOL", "SQL_BIG_RESULT_SYMBOL", "SQL_CALC_FOUND_ROWS_SYMBOL", 
  "SQL_SMALL_RESULT_SYMBOL", "SQL_SYMBOL", "SSL_SYMBOL", "STARTING_SYMBOL", 
  "STDDEV_SAMP_SYMBOL", "STDDEV_SYMBOL", "STDDEV_POP_SYMBOL", "STD_SYMBOL", 
  "STORED_SYMBOL", "STRAIGHT_JOIN_SYMBOL", "SUBSTR_SYMBOL", "SUBSTRING_SYMBOL", 
  "SUM_SYMBOL", "SYSDATE_SYMBOL", "SYSTEM_USER_SYMBOL", "TABLE_REF_PRIORITY_SYMBOL", 
  "TABLE_SYMBOL", "TERMINATED_SYMBOL", "THEN_SYMBOL", "TINYBLOB_SYMBOL", 
  "TINYINT_SYMBOL", "TINYTEXT_SYMBOL", "TO_SYMBOL", "TRAILING_SYMBOL", "TRIGGER_SYMBOL", 
  "TRIM_SYMBOL", "TRUE_SYMBOL", "UNDO_SYMBOL", "UNION_SYMBOL", "UNIQUE_SYMBOL", 
  "UNLOCK_SYMBOL", "UNSIGNED_SYMBOL", "UPDATE_SYMBOL", "USAGE_SYMBOL", "USE_SYMBOL", 
  "USING_SYMBOL", "UTC_DATE_SYMBOL", "UTC_TIMESTAMP_SYMBOL", "UTC_TIME_SYMBOL", 
  "VALIDATION_SYMBOL", "VALUES_SYMBOL", "VARBINARY_SYMBOL", "VARCHAR_SYMBOL", 
  "VARIANCE_SYMBOL", "VARYING_SYMBOL", "VAR_POP_SYMBOL", "VAR_SAMP_SYMBOL", 
  "VIRTUAL_SYMBOL", "WHEN_SYMBOL", "WHERE_SYMBOL", "WHILE_SYMBOL", "WITH_SYMBOL", 
  "WITH_CUBE_SYMBOL", "WITH_ROLLUP_SYMBOL", "WITHOUT_SYMBOL", "WRITE_SYMBOL", 
  "XOR_SYMBOL", "YEAR_MONTH_SYMBOL", "ZEROFILL_SYMBOL", "PERSIST_SYMBOL", 
  "ROLE_SYMBOL", "ADMIN_SYMBOL", "INVISIBLE_SYMBOL", "VISIBLE_SYMBOL", "EXCEPT_SYMBOL", 
  "COMPONENT_SYMBOL", "RECURSIVE_SYMBOL", "JSON_OBJECTAGG_SYMBOL", "JSON_ARRAYAGG_SYMBOL", 
  "OF_SYMBOL", "SKIP_SYMBOL", "LOCKED_SYMBOL", "NOWAIT_SYMBOL", "GROUPING_SYMBOL", 
  "PERSIST_ONLY_SYMBOL", "HISTOGRAM_SYMBOL", "BUCKETS_SYMBOL", "REMOTE_SYMBOL", 
  "CLONE_SYMBOL", "CUME_DIST_SYMBOL", "DENSE_RANK_SYMBOL", "EXCLUDE_SYMBOL", 
  "FIRST_VALUE_SYMBOL", "FOLLOWING_SYMBOL", "GROUPS_SYMBOL", "LAG_SYMBOL", 
  "LAST_VALUE_SYMBOL", "LEAD_SYMBOL", "NTH_VALUE_SYMBOL", "NTILE_SYMBOL", 
  "NULLS_SYMBOL", "OTHERS_SYMBOL", "OVER_SYMBOL", "PERCENT_RANK_SYMBOL", 
  "PRECEDING_SYMBOL", "RANK_SYMBOL", "RESPECT_SYMBOL", "ROW_NUMBER_SYMBOL", 
  "TIES_SYMBOL", "UNBOUNDED_SYMBOL", "WINDOW_SYMBOL", "EMPTY_SYMBOL", "JSON_TABLE_SYMBOL", 
  "NESTED_SYMBOL", "ORDINALITY_SYMBOL", "PATH_SYMBOL", "HISTORY_SYMBOL", 
  "REUSE_SYMBOL", "SRID_SYMBOL", "THREAD_PRIORITY_SYMBOL", "RESOURCE_SYMBOL", 
  "SYSTEM_SYMBOL", "VCPU_SYMBOL", "MASTER_PUBLIC_KEY_PATH_SYMBOL", "GET_MASTER_PUBLIC_KEY_SYM", 
  "RESTART_SYMBOL", "DEFINITION_SYMBOL", "DESCRIPTION_SYMBOL", "ORGANIZATION_SYMBOL", 
  "REFERENCE_SYMBOL", "OPTIONAL_SYMBOL", "SECONDARY_SYMBOL", "SECONDARY_ENGINE_SYMBOL", 
  "SECONDARY_LOAD_SYMBOL", "SECONDARY_UNLOAD_SYMBOL", "ACTIVE_SYMBOL", "INACTIVE_SYMBOL", 
  "LATERAL_SYMBOL", "RETAIN_SYMBOL", "OLD_SYMBOL", "WHITESPACE", "INVALID_INPUT", 
  "UNDERSCORE_CHARSET", "IDENTIFIER", "NCHAR_TEXT", "BACK_TICK_QUOTED_ID", 
  "DOUBLE_QUOTED_TEXT", "SINGLE_QUOTED_TEXT", "VERSION_COMMENT_START", "MYSQL_COMMENT_START", 
  "VERSION_COMMENT_END", "BLOCK_COMMENT", "POUND_COMMENT", "DASHDASH_COMMENT", 
  "NOT_EQUAL2_OPERATOR"
};

dfa::Vocabulary MySQLParser::_vocabulary(_literalNames, _symbolicNames);

std::vector<std::string> MySQLParser::_tokenNames;

MySQLParser::Initializer::Initializer() {
	for (size_t i = 0; i < _symbolicNames.size(); ++i) {
		std::string name = _vocabulary.getLiteralName(i);
		if (name.empty()) {
			name = _vocabulary.getSymbolicName(i);
		}

		if (name.empty()) {
			_tokenNames.push_back("<INVALID>");
		} else {
      _tokenNames.push_back(name);
    }
	}

  static uint16_t serializedATNSegment0[] = {
    0x3, 0x608b, 0xa72a, 0x8133, 0xb9ed, 0x417c, 0x3be7, 0x7786, 0x5964, 
       0x3, 0x308, 0x1f9b, 0x4, 0x2, 0x9, 0x2, 0x4, 0x3, 0x9, 0x3, 0x4, 
       0x4, 0x9, 0x4, 0x4, 0x5, 0x9, 0x5, 0x4, 0x6, 0x9, 0x6, 0x4, 0x7, 
       0x9, 0x7, 0x4, 0x8, 0x9, 0x8, 0x4, 0x9, 0x9, 0x9, 0x4, 0xa, 0x9, 
       0xa, 0x4, 0xb, 0x9, 0xb, 0x4, 0xc, 0x9, 0xc, 0x4, 0xd, 0x9, 0xd, 
       0x4, 0xe, 0x9, 0xe, 0x4, 0xf, 0x9, 0xf, 0x4, 0x10, 0x9, 0x10, 0x4, 
       0x11, 0x9, 0x11, 0x4, 0x12, 0x9, 0x12, 0x4, 0x13, 0x9, 0x13, 0x4, 
       0x14, 0x9, 0x14, 0x4, 0x15, 0x9, 0x15, 0x4, 0x16, 0x9, 0x16, 0x4, 
       0x17, 0x9, 0x17, 0x4, 0x18, 0x9, 0x18, 0x4, 0x19, 0x9, 0x19, 0x4, 
       0x1a, 0x9, 0x1a, 0x4, 0x1b, 0x9, 0x1b, 0x4, 0x1c, 0x9, 0x1c, 0x4, 
       0x1d, 0x9, 0x1d, 0x4, 0x1e, 0x9, 0x1e, 0x4, 0x1f, 0x9, 0x1f, 0x4, 
       0x20, 0x9, 0x20, 0x4, 0x21, 0x9, 0x21, 0x4, 0x22, 0x9, 0x22, 0x4, 
       0x23, 0x9, 0x23, 0x4, 0x24, 0x9, 0x24, 0x4, 0x25, 0x9, 0x25, 0x4, 
       0x26, 0x9, 0x26, 0x4, 0x27, 0x9, 0x27, 0x4, 0x28, 0x9, 0x28, 0x4, 
       0x29, 0x9, 0x29, 0x4, 0x2a, 0x9, 0x2a, 0x4, 0x2b, 0x9, 0x2b, 0x4, 
       0x2c, 0x9, 0x2c, 0x4, 0x2d, 0x9, 0x2d, 0x4, 0x2e, 0x9, 0x2e, 0x4, 
       0x2f, 0x9, 0x2f, 0x4, 0x30, 0x9, 0x30, 0x4, 0x31, 0x9, 0x31, 0x4, 
       0x32, 0x9, 0x32, 0x4, 0x33, 0x9, 0x33, 0x4, 0x34, 0x9, 0x34, 0x4, 
       0x35, 0x9, 0x35, 0x4, 0x36, 0x9, 0x36, 0x4, 0x37, 0x9, 0x37, 0x4, 
       0x38, 0x9, 0x38, 0x4, 0x39, 0x9, 0x39, 0x4, 0x3a, 0x9, 0x3a, 0x4, 
       0x3b, 0x9, 0x3b, 0x4, 0x3c, 0x9, 0x3c, 0x4, 0x3d, 0x9, 0x3d, 0x4, 
       0x3e, 0x9, 0x3e, 0x4, 0x3f, 0x9, 0x3f, 0x4, 0x40, 0x9, 0x40, 0x4, 
       0x41, 0x9, 0x41, 0x4, 0x42, 0x9, 0x42, 0x4, 0x43, 0x9, 0x43, 0x4, 
       0x44, 0x9, 0x44, 0x4, 0x45, 0x9, 0x45, 0x4, 0x46, 0x9, 0x46, 0x4, 
       0x47, 0x9, 0x47, 0x4, 0x48, 0x9, 0x48, 0x4, 0x49, 0x9, 0x49, 0x4, 
       0x4a, 0x9, 0x4a, 0x4, 0x4b, 0x9, 0x4b, 0x4, 0x4c, 0x9, 0x4c, 0x4, 
       0x4d, 0x9, 0x4d, 0x4, 0x4e, 0x9, 0x4e, 0x4, 0x4f, 0x9, 0x4f, 0x4, 
       0x50, 0x9, 0x50, 0x4, 0x51, 0x9, 0x51, 0x4, 0x52, 0x9, 0x52, 0x4, 
       0x53, 0x9, 0x53, 0x4, 0x54, 0x9, 0x54, 0x4, 0x55, 0x9, 0x55, 0x4, 
       0x56, 0x9, 0x56, 0x4, 0x57, 0x9, 0x57, 0x4, 0x58, 0x9, 0x58, 0x4, 
       0x59, 0x9, 0x59, 0x4, 0x5a, 0x9, 0x5a, 0x4, 0x5b, 0x9, 0x5b, 0x4, 
       0x5c, 0x9, 0x5c, 0x4, 0x5d, 0x9, 0x5d, 0x4, 0x5e, 0x9, 0x5e, 0x4, 
       0x5f, 0x9, 0x5f, 0x4, 0x60, 0x9, 0x60, 0x4, 0x61, 0x9, 0x61, 0x4, 
       0x62, 0x9, 0x62, 0x4, 0x63, 0x9, 0x63, 0x4, 0x64, 0x9, 0x64, 0x4, 
       0x65, 0x9, 0x65, 0x4, 0x66, 0x9, 0x66, 0x4, 0x67, 0x9, 0x67, 0x4, 
       0x68, 0x9, 0x68, 0x4, 0x69, 0x9, 0x69, 0x4, 0x6a, 0x9, 0x6a, 0x4, 
       0x6b, 0x9, 0x6b, 0x4, 0x6c, 0x9, 0x6c, 0x4, 0x6d, 0x9, 0x6d, 0x4, 
       0x6e, 0x9, 0x6e, 0x4, 0x6f, 0x9, 0x6f, 0x4, 0x70, 0x9, 0x70, 0x4, 
       0x71, 0x9, 0x71, 0x4, 0x72, 0x9, 0x72, 0x4, 0x73, 0x9, 0x73, 0x4, 
       0x74, 0x9, 0x74, 0x4, 0x75, 0x9, 0x75, 0x4, 0x76, 0x9, 0x76, 0x4, 
       0x77, 0x9, 0x77, 0x4, 0x78, 0x9, 0x78, 0x4, 0x79, 0x9, 0x79, 0x4, 
       0x7a, 0x9, 0x7a, 0x4, 0x7b, 0x9, 0x7b, 0x4, 0x7c, 0x9, 0x7c, 0x4, 
       0x7d, 0x9, 0x7d, 0x4, 0x7e, 0x9, 0x7e, 0x4, 0x7f, 0x9, 0x7f, 0x4, 
       0x80, 0x9, 0x80, 0x4, 0x81, 0x9, 0x81, 0x4, 0x82, 0x9, 0x82, 0x4, 
       0x83, 0x9, 0x83, 0x4, 0x84, 0x9, 0x84, 0x4, 0x85, 0x9, 0x85, 0x4, 
       0x86, 0x9, 0x86, 0x4, 0x87, 0x9, 0x87, 0x4, 0x88, 0x9, 0x88, 0x4, 
       0x89, 0x9, 0x89, 0x4, 0x8a, 0x9, 0x8a, 0x4, 0x8b, 0x9, 0x8b, 0x4, 
       0x8c, 0x9, 0x8c, 0x4, 0x8d, 0x9, 0x8d, 0x4, 0x8e, 0x9, 0x8e, 0x4, 
       0x8f, 0x9, 0x8f, 0x4, 0x90, 0x9, 0x90, 0x4, 0x91, 0x9, 0x91, 0x4, 
       0x92, 0x9, 0x92, 0x4, 0x93, 0x9, 0x93, 0x4, 0x94, 0x9, 0x94, 0x4, 
       0x95, 0x9, 0x95, 0x4, 0x96, 0x9, 0x96, 0x4, 0x97, 0x9, 0x97, 0x4, 
       0x98, 0x9, 0x98, 0x4, 0x99, 0x9, 0x99, 0x4, 0x9a, 0x9, 0x9a, 0x4, 
       0x9b, 0x9, 0x9b, 0x4, 0x9c, 0x9, 0x9c, 0x4, 0x9d, 0x9, 0x9d, 0x4, 
       0x9e, 0x9, 0x9e, 0x4, 0x9f, 0x9, 0x9f, 0x4, 0xa0, 0x9, 0xa0, 0x4, 
       0xa1, 0x9, 0xa1, 0x4, 0xa2, 0x9, 0xa2, 0x4, 0xa3, 0x9, 0xa3, 0x4, 
       0xa4, 0x9, 0xa4, 0x4, 0xa5, 0x9, 0xa5, 0x4, 0xa6, 0x9, 0xa6, 0x4, 
       0xa7, 0x9, 0xa7, 0x4, 0xa8, 0x9, 0xa8, 0x4, 0xa9, 0x9, 0xa9, 0x4, 
       0xaa, 0x9, 0xaa, 0x4, 0xab, 0x9, 0xab, 0x4, 0xac, 0x9, 0xac, 0x4, 
       0xad, 0x9, 0xad, 0x4, 0xae, 0x9, 0xae, 0x4, 0xaf, 0x9, 0xaf, 0x4, 
       0xb0, 0x9, 0xb0, 0x4, 0xb1, 0x9, 0xb1, 0x4, 0xb2, 0x9, 0xb2, 0x4, 
       0xb3, 0x9, 0xb3, 0x4, 0xb4, 0x9, 0xb4, 0x4, 0xb5, 0x9, 0xb5, 0x4, 
       0xb6, 0x9, 0xb6, 0x4, 0xb7, 0x9, 0xb7, 0x4, 0xb8, 0x9, 0xb8, 0x4, 
       0xb9, 0x9, 0xb9, 0x4, 0xba, 0x9, 0xba, 0x4, 0xbb, 0x9, 0xbb, 0x4, 
       0xbc, 0x9, 0xbc, 0x4, 0xbd, 0x9, 0xbd, 0x4, 0xbe, 0x9, 0xbe, 0x4, 
       0xbf, 0x9, 0xbf, 0x4, 0xc0, 0x9, 0xc0, 0x4, 0xc1, 0x9, 0xc1, 0x4, 
       0xc2, 0x9, 0xc2, 0x4, 0xc3, 0x9, 0xc3, 0x4, 0xc4, 0x9, 0xc4, 0x4, 
       0xc5, 0x9, 0xc5, 0x4, 0xc6, 0x9, 0xc6, 0x4, 0xc7, 0x9, 0xc7, 0x4, 
       0xc8, 0x9, 0xc8, 0x4, 0xc9, 0x9, 0xc9, 0x4, 0xca, 0x9, 0xca, 0x4, 
       0xcb, 0x9, 0xcb, 0x4, 0xcc, 0x9, 0xcc, 0x4, 0xcd, 0x9, 0xcd, 0x4, 
       0xce, 0x9, 0xce, 0x4, 0xcf, 0x9, 0xcf, 0x4, 0xd0, 0x9, 0xd0, 0x4, 
       0xd1, 0x9, 0xd1, 0x4, 0xd2, 0x9, 0xd2, 0x4, 0xd3, 0x9, 0xd3, 0x4, 
       0xd4, 0x9, 0xd4, 0x4, 0xd5, 0x9, 0xd5, 0x4, 0xd6, 0x9, 0xd6, 0x4, 
       0xd7, 0x9, 0xd7, 0x4, 0xd8, 0x9, 0xd8, 0x4, 0xd9, 0x9, 0xd9, 0x4, 
       0xda, 0x9, 0xda, 0x4, 0xdb, 0x9, 0xdb, 0x4, 0xdc, 0x9, 0xdc, 0x4, 
       0xdd, 0x9, 0xdd, 0x4, 0xde, 0x9, 0xde, 0x4, 0xdf, 0x9, 0xdf, 0x4, 
       0xe0, 0x9, 0xe0, 0x4, 0xe1, 0x9, 0xe1, 0x4, 0xe2, 0x9, 0xe2, 0x4, 
       0xe3, 0x9, 0xe3, 0x4, 0xe4, 0x9, 0xe4, 0x4, 0xe5, 0x9, 0xe5, 0x4, 
       0xe6, 0x9, 0xe6, 0x4, 0xe7, 0x9, 0xe7, 0x4, 0xe8, 0x9, 0xe8, 0x4, 
       0xe9, 0x9, 0xe9, 0x4, 0xea, 0x9, 0xea, 0x4, 0xeb, 0x9, 0xeb, 0x4, 
       0xec, 0x9, 0xec, 0x4, 0xed, 0x9, 0xed, 0x4, 0xee, 0x9, 0xee, 0x4, 
       0xef, 0x9, 0xef, 0x4, 0xf0, 0x9, 0xf0, 0x4, 0xf1, 0x9, 0xf1, 0x4, 
       0xf2, 0x9, 0xf2, 0x4, 0xf3, 0x9, 0xf3, 0x4, 0xf4, 0x9, 0xf4, 0x4, 
       0xf5, 0x9, 0xf5, 0x4, 0xf6, 0x9, 0xf6, 0x4, 0xf7, 0x9, 0xf7, 0x4, 
       0xf8, 0x9, 0xf8, 0x4, 0xf9, 0x9, 0xf9, 0x4, 0xfa, 0x9, 0xfa, 0x4, 
       0xfb, 0x9, 0xfb, 0x4, 0xfc, 0x9, 0xfc, 0x4, 0xfd, 0x9, 0xfd, 0x4, 
       0xfe, 0x9, 0xfe, 0x4, 0xff, 0x9, 0xff, 0x4, 0x100, 0x9, 0x100, 0x4, 
       0x101, 0x9, 0x101, 0x4, 0x102, 0x9, 0x102, 0x4, 0x103, 0x9, 0x103, 
       0x4, 0x104, 0x9, 0x104, 0x4, 0x105, 0x9, 0x105, 0x4, 0x106, 0x9, 
       0x106, 0x4, 0x107, 0x9, 0x107, 0x4, 0x108, 0x9, 0x108, 0x4, 0x109, 
       0x9, 0x109, 0x4, 0x10a, 0x9, 0x10a, 0x4, 0x10b, 0x9, 0x10b, 0x4, 
       0x10c, 0x9, 0x10c, 0x4, 0x10d, 0x9, 0x10d, 0x4, 0x10e, 0x9, 0x10e, 
       0x4, 0x10f, 0x9, 0x10f, 0x4, 0x110, 0x9, 0x110, 0x4, 0x111, 0x9, 
       0x111, 0x4, 0x112, 0x9, 0x112, 0x4, 0x113, 0x9, 0x113, 0x4, 0x114, 
       0x9, 0x114, 0x4, 0x115, 0x9, 0x115, 0x4, 0x116, 0x9, 0x116, 0x4, 
       0x117, 0x9, 0x117, 0x4, 0x118, 0x9, 0x118, 0x4, 0x119, 0x9, 0x119, 
       0x4, 0x11a, 0x9, 0x11a, 0x4, 0x11b, 0x9, 0x11b, 0x4, 0x11c, 0x9, 
       0x11c, 0x4, 0x11d, 0x9, 0x11d, 0x4, 0x11e, 0x9, 0x11e, 0x4, 0x11f, 
       0x9, 0x11f, 0x4, 0x120, 0x9, 0x120, 0x4, 0x121, 0x9, 0x121, 0x4, 
       0x122, 0x9, 0x122, 0x4, 0x123, 0x9, 0x123, 0x4, 0x124, 0x9, 0x124, 
       0x4, 0x125, 0x9, 0x125, 0x4, 0x126, 0x9, 0x126, 0x4, 0x127, 0x9, 
       0x127, 0x4, 0x128, 0x9, 0x128, 0x4, 0x129, 0x9, 0x129, 0x4, 0x12a, 
       0x9, 0x12a, 0x4, 0x12b, 0x9, 0x12b, 0x4, 0x12c, 0x9, 0x12c, 0x4, 
       0x12d, 0x9, 0x12d, 0x4, 0x12e, 0x9, 0x12e, 0x4, 0x12f, 0x9, 0x12f, 
       0x4, 0x130, 0x9, 0x130, 0x4, 0x131, 0x9, 0x131, 0x4, 0x132, 0x9, 
       0x132, 0x4, 0x133, 0x9, 0x133, 0x4, 0x134, 0x9, 0x134, 0x4, 0x135, 
       0x9, 0x135, 0x4, 0x136, 0x9, 0x136, 0x4, 0x137, 0x9, 0x137, 0x4, 
       0x138, 0x9, 0x138, 0x4, 0x139, 0x9, 0x139, 0x4, 0x13a, 0x9, 0x13a, 
       0x4, 0x13b, 0x9, 0x13b, 0x4, 0x13c, 0x9, 0x13c, 0x4, 0x13d, 0x9, 
       0x13d, 0x4, 0x13e, 0x9, 0x13e, 0x4, 0x13f, 0x9, 0x13f, 0x4, 0x140, 
       0x9, 0x140, 0x4, 0x141, 0x9, 0x141, 0x4, 0x142, 0x9, 0x142, 0x4, 
       0x143, 0x9, 0x143, 0x4, 0x144, 0x9, 0x144, 0x4, 0x145, 0x9, 0x145, 
       0x4, 0x146, 0x9, 0x146, 0x4, 0x147, 0x9, 0x147, 0x4, 0x148, 0x9, 
       0x148, 0x4, 0x149, 0x9, 0x149, 0x4, 0x14a, 0x9, 0x14a, 0x4, 0x14b, 
       0x9, 0x14b, 0x4, 0x14c, 0x9, 0x14c, 0x4, 0x14d, 0x9, 0x14d, 0x4, 
       0x14e, 0x9, 0x14e, 0x4, 0x14f, 0x9, 0x14f, 0x4, 0x150, 0x9, 0x150, 
       0x4, 0x151, 0x9, 0x151, 0x4, 0x152, 0x9, 0x152, 0x4, 0x153, 0x9, 
       0x153, 0x4, 0x154, 0x9, 0x154, 0x4, 0x155, 0x9, 0x155, 0x4, 0x156, 
       0x9, 0x156, 0x4, 0x157, 0x9, 0x157, 0x4, 0x158, 0x9, 0x158, 0x4, 
       0x159, 0x9, 0x159, 0x4, 0x15a, 0x9, 0x15a, 0x4, 0x15b, 0x9, 0x15b, 
       0x4, 0x15c, 0x9, 0x15c, 0x4, 0x15d, 0x9, 0x15d, 0x4, 0x15e, 0x9, 
       0x15e, 0x4, 0x15f, 0x9, 0x15f, 0x4, 0x160, 0x9, 0x160, 0x4, 0x161, 
       0x9, 0x161, 0x4, 0x162, 0x9, 0x162, 0x4, 0x163, 0x9, 0x163, 0x4, 
       0x164, 0x9, 0x164, 0x4, 0x165, 0x9, 0x165, 0x4, 0x166, 0x9, 0x166, 
       0x4, 0x167, 0x9, 0x167, 0x4, 0x168, 0x9, 0x168, 0x4, 0x169, 0x9, 
       0x169, 0x4, 0x16a, 0x9, 0x16a, 0x4, 0x16b, 0x9, 0x16b, 0x4, 0x16c, 
       0x9, 0x16c, 0x4, 0x16d, 0x9, 0x16d, 0x4, 0x16e, 0x9, 0x16e, 0x4, 
       0x16f, 0x9, 0x16f, 0x4, 0x170, 0x9, 0x170, 0x4, 0x171, 0x9, 0x171, 
       0x4, 0x172, 0x9, 0x172, 0x4, 0x173, 0x9, 0x173, 0x4, 0x174, 0x9, 
       0x174, 0x4, 0x175, 0x9, 0x175, 0x4, 0x176, 0x9, 0x176, 0x4, 0x177, 
       0x9, 0x177, 0x4, 0x178, 0x9, 0x178, 0x4, 0x179, 0x9, 0x179, 0x4, 
       0x17a, 0x9, 0x17a, 0x4, 0x17b, 0x9, 0x17b, 0x4, 0x17c, 0x9, 0x17c, 
       0x4, 0x17d, 0x9, 0x17d, 0x4, 0x17e, 0x9, 0x17e, 0x4, 0x17f, 0x9, 
       0x17f, 0x4, 0x180, 0x9, 0x180, 0x4, 0x181, 0x9, 0x181, 0x4, 0x182, 
       0x9, 0x182, 0x4, 0x183, 0x9, 0x183, 0x4, 0x184, 0x9, 0x184, 0x4, 
       0x185, 0x9, 0x185, 0x4, 0x186, 0x9, 0x186, 0x4, 0x187, 0x9, 0x187, 
       0x4, 0x188, 0x9, 0x188, 0x4, 0x189, 0x9, 0x189, 0x4, 0x18a, 0x9, 
       0x18a, 0x4, 0x18b, 0x9, 0x18b, 0x4, 0x18c, 0x9, 0x18c, 0x4, 0x18d, 
       0x9, 0x18d, 0x4, 0x18e, 0x9, 0x18e, 0x4, 0x18f, 0x9, 0x18f, 0x4, 
       0x190, 0x9, 0x190, 0x4, 0x191, 0x9, 0x191, 0x4, 0x192, 0x9, 0x192, 
       0x4, 0x193, 0x9, 0x193, 0x4, 0x194, 0x9, 0x194, 0x4, 0x195, 0x9, 
       0x195, 0x4, 0x196, 0x9, 0x196, 0x4, 0x197, 0x9, 0x197, 0x4, 0x198, 
       0x9, 0x198, 0x4, 0x199, 0x9, 0x199, 0x4, 0x19a, 0x9, 0x19a, 0x4, 
       0x19b, 0x9, 0x19b, 0x4, 0x19c, 0x9, 0x19c, 0x4, 0x19d, 0x9, 0x19d, 
       0x4, 0x19e, 0x9, 0x19e, 0x4, 0x19f, 0x9, 0x19f, 0x4, 0x1a0, 0x9, 
       0x1a0, 0x4, 0x1a1, 0x9, 0x1a1, 0x4, 0x1a2, 0x9, 0x1a2, 0x4, 0x1a3, 
       0x9, 0x1a3, 0x4, 0x1a4, 0x9, 0x1a4, 0x4, 0x1a5, 0x9, 0x1a5, 0x4, 
       0x1a6, 0x9, 0x1a6, 0x4, 0x1a7, 0x9, 0x1a7, 0x4, 0x1a8, 0x9, 0x1a8, 
       0x4, 0x1a9, 0x9, 0x1a9, 0x4, 0x1aa, 0x9, 0x1aa, 0x4, 0x1ab, 0x9, 
       0x1ab, 0x4, 0x1ac, 0x9, 0x1ac, 0x4, 0x1ad, 0x9, 0x1ad, 0x4, 0x1ae, 
       0x9, 0x1ae, 0x4, 0x1af, 0x9, 0x1af, 0x4, 0x1b0, 0x9, 0x1b0, 0x4, 
       0x1b1, 0x9, 0x1b1, 0x4, 0x1b2, 0x9, 0x1b2, 0x4, 0x1b3, 0x9, 0x1b3, 
       0x4, 0x1b4, 0x9, 0x1b4, 0x4, 0x1b5, 0x9, 0x1b5, 0x4, 0x1b6, 0x9, 
       0x1b6, 0x4, 0x1b7, 0x9, 0x1b7, 0x4, 0x1b8, 0x9, 0x1b8, 0x4, 0x1b9, 
       0x9, 0x1b9, 0x4, 0x1ba, 0x9, 0x1ba, 0x4, 0x1bb, 0x9, 0x1bb, 0x4, 
       0x1bc, 0x9, 0x1bc, 0x4, 0x1bd, 0x9, 0x1bd, 0x4, 0x1be, 0x9, 0x1be, 
       0x4, 0x1bf, 0x9, 0x1bf, 0x4, 0x1c0, 0x9, 0x1c0, 0x4, 0x1c1, 0x9, 
       0x1c1, 0x4, 0x1c2, 0x9, 0x1c2, 0x4, 0x1c3, 0x9, 0x1c3, 0x4, 0x1c4, 
       0x9, 0x1c4, 0x4, 0x1c5, 0x9, 0x1c5, 0x4, 0x1c6, 0x9, 0x1c6, 0x4, 
       0x1c7, 0x9, 0x1c7, 0x4, 0x1c8, 0x9, 0x1c8, 0x4, 0x1c9, 0x9, 0x1c9, 
       0x4, 0x1ca, 0x9, 0x1ca, 0x4, 0x1cb, 0x9, 0x1cb, 0x4, 0x1cc, 0x9, 
       0x1cc, 0x4, 0x1cd, 0x9, 0x1cd, 0x4, 0x1ce, 0x9, 0x1ce, 0x4, 0x1cf, 
       0x9, 0x1cf, 0x4, 0x1d0, 0x9, 0x1d0, 0x4, 0x1d1, 0x9, 0x1d1, 0x4, 
       0x1d2, 0x9, 0x1d2, 0x4, 0x1d3, 0x9, 0x1d3, 0x4, 0x1d4, 0x9, 0x1d4, 
       0x4, 0x1d5, 0x9, 0x1d5, 0x4, 0x1d6, 0x9, 0x1d6, 0x4, 0x1d7, 0x9, 
       0x1d7, 0x4, 0x1d8, 0x9, 0x1d8, 0x4, 0x1d9, 0x9, 0x1d9, 0x4, 0x1da, 
       0x9, 0x1da, 0x4, 0x1db, 0x9, 0x1db, 0x4, 0x1dc, 0x9, 0x1dc, 0x4, 
       0x1dd, 0x9, 0x1dd, 0x4, 0x1de, 0x9, 0x1de, 0x4, 0x1df, 0x9, 0x1df, 
       0x4, 0x1e0, 0x9, 0x1e0, 0x4, 0x1e1, 0x9, 0x1e1, 0x4, 0x1e2, 0x9, 
       0x1e2, 0x4, 0x1e3, 0x9, 0x1e3, 0x4, 0x1e4, 0x9, 0x1e4, 0x4, 0x1e5, 
       0x9, 0x1e5, 0x4, 0x1e6, 0x9, 0x1e6, 0x4, 0x1e7, 0x9, 0x1e7, 0x4, 
       0x1e8, 0x9, 0x1e8, 0x4, 0x1e9, 0x9, 0x1e9, 0x4, 0x1ea, 0x9, 0x1ea, 
       0x4, 0x1eb, 0x9, 0x1eb, 0x4, 0x1ec, 0x9, 0x1ec, 0x4, 0x1ed, 0x9, 
       0x1ed, 0x4, 0x1ee, 0x9, 0x1ee, 0x4, 0x1ef, 0x9, 0x1ef, 0x4, 0x1f0, 
       0x9, 0x1f0, 0x4, 0x1f1, 0x9, 0x1f1, 0x4, 0x1f2, 0x9, 0x1f2, 0x4, 
       0x1f3, 0x9, 0x1f3, 0x4, 0x1f4, 0x9, 0x1f4, 0x4, 0x1f5, 0x9, 0x1f5, 
       0x4, 0x1f6, 0x9, 0x1f6, 0x4, 0x1f7, 0x9, 0x1f7, 0x4, 0x1f8, 0x9, 
       0x1f8, 0x4, 0x1f9, 0x9, 0x1f9, 0x4, 0x1fa, 0x9, 0x1fa, 0x4, 0x1fb, 
       0x9, 0x1fb, 0x4, 0x1fc, 0x9, 0x1fc, 0x4, 0x1fd, 0x9, 0x1fd, 0x4, 
       0x1fe, 0x9, 0x1fe, 0x4, 0x1ff, 0x9, 0x1ff, 0x4, 0x200, 0x9, 0x200, 
       0x4, 0x201, 0x9, 0x201, 0x4, 0x202, 0x9, 0x202, 0x4, 0x203, 0x9, 
       0x203, 0x4, 0x204, 0x9, 0x204, 0x4, 0x205, 0x9, 0x205, 0x4, 0x206, 
       0x9, 0x206, 0x4, 0x207, 0x9, 0x207, 0x4, 0x208, 0x9, 0x208, 0x4, 
       0x209, 0x9, 0x209, 0x4, 0x20a, 0x9, 0x20a, 0x4, 0x20b, 0x9, 0x20b, 
       0x4, 0x20c, 0x9, 0x20c, 0x4, 0x20d, 0x9, 0x20d, 0x4, 0x20e, 0x9, 
       0x20e, 0x4, 0x20f, 0x9, 0x20f, 0x4, 0x210, 0x9, 0x210, 0x4, 0x211, 
       0x9, 0x211, 0x4, 0x212, 0x9, 0x212, 0x4, 0x213, 0x9, 0x213, 0x4, 
       0x214, 0x9, 0x214, 0x4, 0x215, 0x9, 0x215, 0x4, 0x216, 0x9, 0x216, 
       0x4, 0x217, 0x9, 0x217, 0x4, 0x218, 0x9, 0x218, 0x4, 0x219, 0x9, 
       0x219, 0x4, 0x21a, 0x9, 0x21a, 0x4, 0x21b, 0x9, 0x21b, 0x4, 0x21c, 
       0x9, 0x21c, 0x4, 0x21d, 0x9, 0x21d, 0x4, 0x21e, 0x9, 0x21e, 0x4, 
       0x21f, 0x9, 0x21f, 0x4, 0x220, 0x9, 0x220, 0x4, 0x221, 0x9, 0x221, 
       0x4, 0x222, 0x9, 0x222, 0x4, 0x223, 0x9, 0x223, 0x4, 0x224, 0x9, 
       0x224, 0x4, 0x225, 0x9, 0x225, 0x4, 0x226, 0x9, 0x226, 0x4, 0x227, 
       0x9, 0x227, 0x4, 0x228, 0x9, 0x228, 0x4, 0x229, 0x9, 0x229, 0x4, 
       0x22a, 0x9, 0x22a, 0x4, 0x22b, 0x9, 0x22b, 0x4, 0x22c, 0x9, 0x22c, 
       0x4, 0x22d, 0x9, 0x22d, 0x4, 0x22e, 0x9, 0x22e, 0x4, 0x22f, 0x9, 
       0x22f, 0x4, 0x230, 0x9, 0x230, 0x4, 0x231, 0x9, 0x231, 0x4, 0x232, 
       0x9, 0x232, 0x4, 0x233, 0x9, 0x233, 0x4, 0x234, 0x9, 0x234, 0x4, 
       0x235, 0x9, 0x235, 0x4, 0x236, 0x9, 0x236, 0x4, 0x237, 0x9, 0x237, 
       0x4, 0x238, 0x9, 0x238, 0x4, 0x239, 0x9, 0x239, 0x4, 0x23a, 0x9, 
       0x23a, 0x4, 0x23b, 0x9, 0x23b, 0x4, 0x23c, 0x9, 0x23c, 0x4, 0x23d, 
       0x9, 0x23d, 0x4, 0x23e, 0x9, 0x23e, 0x4, 0x23f, 0x9, 0x23f, 0x4, 
       0x240, 0x9, 0x240, 0x4, 0x241, 0x9, 0x241, 0x4, 0x242, 0x9, 0x242, 
       0x4, 0x243, 0x9, 0x243, 0x4, 0x244, 0x9, 0x244, 0x4, 0x245, 0x9, 
       0x245, 0x4, 0x246, 0x9, 0x246, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x5, 
       0x2, 0x490, 0xa, 0x2, 0x3, 0x2, 0x3, 0x2, 0x5, 0x2, 0x494, 0xa, 0x2, 
       0x3, 0x2, 0x5, 0x2, 0x497, 0xa, 0x2, 0x5, 0x2, 0x499, 0xa, 0x2, 0x3, 
       0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 
       0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 
       0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 
       0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 
       0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 
       0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x5, 0x3, 0x4bf, 0xa, 0x3, 0x3, 0x4, 
       0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x5, 0x4, 0x4c7, 
       0xa, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x5, 0x4, 0x4cc, 0xa, 0x4, 
       0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 
       0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 
       0x3, 0x4, 0x5, 0x4, 0x4dc, 0xa, 0x4, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 
       0x6, 0x5, 0x4e1, 0xa, 0x5, 0xd, 0x5, 0xe, 0x5, 0x4e2, 0x3, 0x5, 0x3, 
       0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x4ea, 0xa, 0x5, 0x3, 
       0x6, 0x5, 0x6, 0x4ed, 0xa, 0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 
       0x6, 0x3, 0x6, 0x5, 0x6, 0x4f4, 0xa, 0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 
       0x6, 0x5, 0x6, 0x4f9, 0xa, 0x6, 0x3, 0x6, 0x5, 0x6, 0x4fc, 0xa, 0x6, 
       0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x5, 0x6, 0x501, 0xa, 0x6, 0x3, 0x6, 
       0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x5, 0x6, 0x507, 0xa, 0x6, 0x5, 0x6, 
       0x509, 0xa, 0x6, 0x3, 0x6, 0x3, 0x6, 0x5, 0x6, 0x50d, 0xa, 0x6, 0x3, 
       0x6, 0x3, 0x6, 0x5, 0x6, 0x511, 0xa, 0x6, 0x3, 0x7, 0x3, 0x7, 0x3, 
       0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x5, 0x7, 0x51a, 0xa, 
       0x7, 0x3, 0x8, 0x3, 0x8, 0x5, 0x8, 0x51e, 0xa, 0x8, 0x3, 0x8, 0x7, 
       0x8, 0x521, 0xa, 0x8, 0xc, 0x8, 0xe, 0x8, 0x524, 0xb, 0x8, 0x3, 0x9, 
       0x3, 0x9, 0x3, 0x9, 0x5, 0x9, 0x529, 0xa, 0x9, 0x3, 0xa, 0x3, 0xa, 
       0x3, 0xa, 0x3, 0xa, 0x3, 0xb, 0x5, 0xb, 0x530, 0xa, 0xb, 0x3, 0xb, 
       0x3, 0xb, 0x5, 0xb, 0x534, 0xa, 0xb, 0x3, 0xb, 0x3, 0xb, 0x3, 0xb, 
       0x5, 0xb, 0x539, 0xa, 0xb, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x5, 0xc, 
       0x53e, 0xa, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 
       0x5, 0xc, 0x545, 0xa, 0xc, 0x3, 0xc, 0x5, 0xc, 0x548, 0xa, 0xc, 0x3, 
       0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x5, 0xd, 0x54e, 0xa, 0xd, 0x3, 
       0xd, 0x5, 0xd, 0x551, 0xa, 0xd, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x7, 
       0xe, 0x556, 0xa, 0xe, 0xc, 0xe, 0xe, 0xe, 0x559, 0xb, 0xe, 0x3, 0xf, 
       0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x5, 
       0xf, 0x562, 0xa, 0xf, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x5, 0x10, 
       0x567, 0xa, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x5, 0x10, 0x56c, 
       0xa, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 
       0x3, 0x10, 0x5, 0x10, 0x574, 0xa, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 
       0x10, 0x3, 0x10, 0x5, 0x10, 0x57a, 0xa, 0x10, 0x3, 0x10, 0x3, 0x10, 
       0x5, 0x10, 0x57e, 0xa, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x5, 
       0x10, 0x583, 0xa, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 
       0x3, 0x10, 0x7, 0x10, 0x58a, 0xa, 0x10, 0xc, 0x10, 0xe, 0x10, 0x58d, 
       0xb, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x5, 0x10, 0x592, 0xa, 
       0x10, 0x3, 0x10, 0x3, 0x10, 0x7, 0x10, 0x596, 0xa, 0x10, 0xc, 0x10, 
       0xe, 0x10, 0x599, 0xb, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x5, 
       0x10, 0x59e, 0xa, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 
       0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x5, 0x10, 
       0x5a9, 0xa, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x5, 
       0x10, 0x5af, 0xa, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 
       0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x5, 0x10, 0x5b8, 0xa, 0x10, 0x3, 
       0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 
       0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x5, 
       0x10, 0x5c6, 0xa, 0x10, 0x3, 0x11, 0x3, 0x11, 0x5, 0x11, 0x5ca, 0xa, 
       0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x5, 0x11, 0x5d0, 
       0xa, 0x11, 0x7, 0x11, 0x5d2, 0xa, 0x11, 0xc, 0x11, 0xe, 0x11, 0x5d5, 
       0xb, 0x11, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 
       0x5, 0x12, 0x5dc, 0xa, 0x12, 0x3, 0x13, 0x3, 0x13, 0x5, 0x13, 0x5e0, 
       0xa, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x5, 0x13, 0x5e5, 0xa, 
       0x13, 0x3, 0x13, 0x5, 0x13, 0x5e8, 0xa, 0x13, 0x3, 0x13, 0x3, 0x13, 
       0x3, 0x13, 0x3, 0x13, 0x5, 0x13, 0x5ee, 0xa, 0x13, 0x3, 0x13, 0x3, 
       0x13, 0x3, 0x13, 0x3, 0x13, 0x5, 0x13, 0x5f4, 0xa, 0x13, 0x3, 0x13, 
       0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x5, 0x13, 0x5fa, 0xa, 0x13, 0x3, 
       0x13, 0x3, 0x13, 0x5, 0x13, 0x5fe, 0xa, 0x13, 0x3, 0x13, 0x3, 0x13, 
       0x3, 0x13, 0x5, 0x13, 0x603, 0xa, 0x13, 0x3, 0x13, 0x3, 0x13, 0x5, 
       0x13, 0x607, 0xa, 0x13, 0x3, 0x13, 0x3, 0x13, 0x5, 0x13, 0x60b, 0xa, 
       0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 
       0x13, 0x5, 0x13, 0x613, 0xa, 0x13, 0x5, 0x13, 0x615, 0xa, 0x13, 0x3, 
       0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x5, 0x13, 0x61c, 
       0xa, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 
       0x3, 0x13, 0x5, 0x13, 0x624, 0xa, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 
       0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x5, 0x13, 0x62c, 0xa, 0x13, 
       0x3, 0x13, 0x3, 0x13, 0x5, 0x13, 0x630, 0xa, 0x13, 0x3, 0x13, 0x3, 
       0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 
       0x13, 0x5, 0x13, 0x63a, 0xa, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 
       0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 
       0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x5, 0x13, 
       0x64a, 0xa, 0x13, 0x3, 0x13, 0x5, 0x13, 0x64d, 0xa, 0x13, 0x3, 0x13, 
       0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 
       0x5, 0x13, 0x656, 0xa, 0x13, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x5, 
       0x14, 0x65b, 0xa, 0x14, 0x3, 0x15, 0x3, 0x15, 0x3, 0x16, 0x3, 0x16, 
       0x5, 0x16, 0x661, 0xa, 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x5, 
       0x16, 0x666, 0xa, 0x16, 0x7, 0x16, 0x668, 0xa, 0x16, 0xc, 0x16, 0xe, 
       0x16, 0x66b, 0xb, 0x16, 0x3, 0x17, 0x3, 0x17, 0x5, 0x17, 0x66f, 0xa, 
       0x17, 0x3, 0x17, 0x3, 0x17, 0x5, 0x17, 0x673, 0xa, 0x17, 0x3, 0x18, 
       0x3, 0x18, 0x5, 0x18, 0x677, 0xa, 0x18, 0x3, 0x18, 0x3, 0x18, 0x5, 
       0x18, 0x67b, 0xa, 0x18, 0x3, 0x19, 0x3, 0x19, 0x3, 0x19, 0x5, 0x19, 
       0x680, 0xa, 0x19, 0x3, 0x19, 0x3, 0x19, 0x5, 0x19, 0x684, 0xa, 0x19, 
       0x5, 0x19, 0x686, 0xa, 0x19, 0x3, 0x1a, 0x3, 0x1a, 0x3, 0x1a, 0x3, 
       0x1a, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1c, 0x3, 0x1c, 0x5, 
       0x1c, 0x691, 0xa, 0x1c, 0x3, 0x1d, 0x3, 0x1d, 0x3, 0x1d, 0x5, 0x1d, 
       0x696, 0xa, 0x1d, 0x3, 0x1d, 0x3, 0x1d, 0x3, 0x1d, 0x3, 0x1d, 0x5, 
       0x1d, 0x69c, 0xa, 0x1d, 0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 
       0x3, 0x1e, 0x3, 0x1e, 0x5, 0x1e, 0x6a4, 0xa, 0x1e, 0x3, 0x1e, 0x3, 
       0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x5, 
       0x1e, 0x6ad, 0xa, 0x1e, 0x3, 0x1e, 0x7, 0x1e, 0x6b0, 0xa, 0x1e, 0xc, 
       0x1e, 0xe, 0x1e, 0x6b3, 0xb, 0x1e, 0x5, 0x1e, 0x6b5, 0xa, 0x1e, 0x3, 
       0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x5, 0x1e, 0x6ba, 0xa, 0x1e, 0x3, 0x1e, 
       0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x5, 0x1e, 0x6c1, 0xa, 
       0x1e, 0x3, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x3, 
       0x1f, 0x5, 0x1f, 0x6c9, 0xa, 0x1f, 0x3, 0x20, 0x3, 0x20, 0x5, 0x20, 
       0x6cd, 0xa, 0x20, 0x3, 0x20, 0x7, 0x20, 0x6d0, 0xa, 0x20, 0xc, 0x20, 
       0xe, 0x20, 0x6d3, 0xb, 0x20, 0x3, 0x21, 0x3, 0x21, 0x3, 0x22, 0x3, 
       0x22, 0x5, 0x22, 0x6d9, 0xa, 0x22, 0x3, 0x22, 0x7, 0x22, 0x6dc, 0xa, 
       0x22, 0xc, 0x22, 0xe, 0x22, 0x6df, 0xb, 0x22, 0x3, 0x23, 0x3, 0x23, 
       0x5, 0x23, 0x6e3, 0xa, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 
       0x23, 0x3, 0x23, 0x3, 0x23, 0x5, 0x23, 0x6eb, 0xa, 0x23, 0x3, 0x24, 
       0x3, 0x24, 0x5, 0x24, 0x6ef, 0xa, 0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 
       0x24, 0x5, 0x24, 0x6f4, 0xa, 0x24, 0x3, 0x25, 0x5, 0x25, 0x6f7, 0xa, 
       0x25, 0x3, 0x25, 0x5, 0x25, 0x6fa, 0xa, 0x25, 0x3, 0x25, 0x5, 0x25, 
       0x6fd, 0xa, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 
       0x26, 0x5, 0x26, 0x704, 0xa, 0x26, 0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 
       0x3, 0x27, 0x3, 0x27, 0x5, 0x27, 0x70b, 0xa, 0x27, 0x3, 0x28, 0x3, 
       0x28, 0x5, 0x28, 0x70f, 0xa, 0x28, 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 
       0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 
       0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 
       0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 
       0x3, 0x29, 0x5, 0x29, 0x727, 0xa, 0x29, 0x3, 0x2a, 0x3, 0x2a, 0x5, 
       0x2a, 0x72b, 0xa, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x7, 0x2a, 0x72f, 0xa, 
       0x2a, 0xc, 0x2a, 0xe, 0x2a, 0x732, 0xb, 0x2a, 0x3, 0x2b, 0x3, 0x2b, 
       0x3, 0x2b, 0x3, 0x2b, 0x5, 0x2b, 0x738, 0xa, 0x2b, 0x3, 0x2c, 0x5, 
       0x2c, 0x73b, 0xa, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x5, 0x2c, 0x73f, 0xa, 
       0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x5, 
       0x2c, 0x746, 0xa, 0x2c, 0x3, 0x2c, 0x5, 0x2c, 0x749, 0xa, 0x2c, 0x3, 
       0x2c, 0x5, 0x2c, 0x74c, 0xa, 0x2c, 0x3, 0x2c, 0x5, 0x2c, 0x74f, 0xa, 
       0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 
       0x2c, 0x3, 0x2c, 0x5, 0x2c, 0x758, 0xa, 0x2c, 0x3, 0x2d, 0x3, 0x2d, 
       0x3, 0x2d, 0x7, 0x2d, 0x75d, 0xa, 0x2d, 0xc, 0x2d, 0xe, 0x2d, 0x760, 
       0xb, 0x2d, 0x3, 0x2e, 0x3, 0x2e, 0x5, 0x2e, 0x764, 0xa, 0x2e, 0x3, 
       0x2f, 0x5, 0x2f, 0x767, 0xa, 0x2f, 0x3, 0x2f, 0x5, 0x2f, 0x76a, 0xa, 
       0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x30, 0x3, 0x30, 0x5, 0x30, 0x770, 
       0xa, 0x30, 0x3, 0x31, 0x3, 0x31, 0x3, 0x31, 0x3, 0x31, 0x5, 0x31, 
       0x776, 0xa, 0x31, 0x3, 0x31, 0x5, 0x31, 0x779, 0xa, 0x31, 0x3, 0x31, 
       0x3, 0x31, 0x3, 0x32, 0x5, 0x32, 0x77e, 0xa, 0x32, 0x3, 0x32, 0x3, 
       0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 0x7, 0x32, 0x786, 
       0xa, 0x32, 0xc, 0x32, 0xe, 0x32, 0x789, 0xb, 0x32, 0x5, 0x32, 0x78b, 
       0xa, 0x32, 0x3, 0x32, 0x3, 0x32, 0x7, 0x32, 0x78f, 0xa, 0x32, 0xc, 
       0x32, 0xe, 0x32, 0x792, 0xb, 0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 0x33, 
       0x5, 0x33, 0x797, 0xa, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 
       0x33, 0x3, 0x33, 0x3, 0x33, 0x7, 0x33, 0x79f, 0xa, 0x33, 0xc, 0x33, 
       0xe, 0x33, 0x7a2, 0xb, 0x33, 0x5, 0x33, 0x7a4, 0xa, 0x33, 0x3, 0x33, 
       0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x7, 0x33, 0x7aa, 0xa, 0x33, 0xc, 
       0x33, 0xe, 0x33, 0x7ad, 0xb, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x34, 
       0x5, 0x34, 0x7b2, 0xa, 0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 
       0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 0x35, 0x3, 0x35, 0x5, 
       0x35, 0x7bd, 0xa, 0x35, 0x3, 0x35, 0x5, 0x35, 0x7c0, 0xa, 0x35, 0x3, 
       0x36, 0x6, 0x36, 0x7c3, 0xa, 0x36, 0xd, 0x36, 0xe, 0x36, 0x7c4, 0x3, 
       0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 
       0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 
       0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x5, 0x37, 0x7d8, 
       0xa, 0x37, 0x3, 0x38, 0x5, 0x38, 0x7db, 0xa, 0x38, 0x3, 0x38, 0x5, 
       0x38, 0x7de, 0xa, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 
       0x5, 0x38, 0x7e4, 0xa, 0x38, 0x3, 0x38, 0x5, 0x38, 0x7e7, 0xa, 0x38, 
       0x5, 0x38, 0x7e9, 0xa, 0x38, 0x3, 0x38, 0x3, 0x38, 0x7, 0x38, 0x7ed, 
       0xa, 0x38, 0xc, 0x38, 0xe, 0x38, 0x7f0, 0xb, 0x38, 0x3, 0x38, 0x3, 
       0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x7, 0x38, 0x7f7, 0xa, 0x38, 
       0xc, 0x38, 0xe, 0x38, 0x7fa, 0xb, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 
       0x38, 0x3, 0x38, 0x3, 0x38, 0x7, 0x38, 0x801, 0xa, 0x38, 0xc, 0x38, 
       0xe, 0x38, 0x804, 0xb, 0x38, 0x5, 0x38, 0x806, 0xa, 0x38, 0x3, 0x38, 
       0x5, 0x38, 0x809, 0xa, 0x38, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x5, 
       0x39, 0x80e, 0xa, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 
       0x5, 0x39, 0x814, 0xa, 0x39, 0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, 
       0x3a, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x3, 
       0x3b, 0x3, 0x3b, 0x5, 0x3b, 0x821, 0xa, 0x3b, 0x3, 0x3c, 0x3, 0x3c, 
       0x5, 0x3c, 0x825, 0xa, 0x3c, 0x3, 0x3c, 0x7, 0x3c, 0x828, 0xa, 0x3c, 
       0xc, 0x3c, 0xe, 0x3c, 0x82b, 0xb, 0x3c, 0x3, 0x3d, 0x3, 0x3d, 0x3, 
       0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x5, 0x3d, 0x833, 0xa, 0x3d, 
       0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 
       0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 
       0x3, 0x3f, 0x7, 0x3f, 0x842, 0xa, 0x3f, 0xc, 0x3f, 0xe, 0x3f, 0x845, 
       0xb, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 
       0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 
       0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x5, 0x40, 
       0x857, 0xa, 0x40, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 
       0x41, 0x3, 0x41, 0x3, 0x41, 0x5, 0x41, 0x860, 0xa, 0x41, 0x3, 0x41, 
       0x5, 0x41, 0x863, 0xa, 0x41, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 
       0x42, 0x3, 0x42, 0x3, 0x42, 0x5, 0x42, 0x86b, 0xa, 0x42, 0x3, 0x43, 
       0x3, 0x43, 0x3, 0x43, 0x5, 0x43, 0x870, 0xa, 0x43, 0x3, 0x43, 0x3, 
       0x43, 0x5, 0x43, 0x874, 0xa, 0x43, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 
       0x3, 0x45, 0x3, 0x45, 0x5, 0x45, 0x87b, 0xa, 0x45, 0x3, 0x45, 0x7, 
       0x45, 0x87e, 0xa, 0x45, 0xc, 0x45, 0xe, 0x45, 0x881, 0xb, 0x45, 0x3, 
       0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 
       0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x5, 
       0x46, 0x88f, 0xa, 0x46, 0x3, 0x47, 0x3, 0x47, 0x5, 0x47, 0x893, 0xa, 
       0x47, 0x3, 0x47, 0x3, 0x47, 0x3, 0x48, 0x3, 0x48, 0x5, 0x48, 0x899, 
       0xa, 0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 0x49, 0x3, 0x49, 0x5, 0x49, 
       0x89f, 0xa, 0x49, 0x3, 0x49, 0x3, 0x49, 0x3, 0x4a, 0x3, 0x4a, 0x5, 
       0x4a, 0x8a5, 0xa, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x3, 0x4b, 0x3, 0x4b, 
       0x5, 0x4b, 0x8ab, 0xa, 0x4b, 0x3, 0x4b, 0x3, 0x4b, 0x3, 0x4c, 0x3, 
       0x4c, 0x5, 0x4c, 0x8b1, 0xa, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4d, 
       0x5, 0x4d, 0x8b6, 0xa, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x5, 0x4d, 0x8ba, 
       0xa, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4e, 0x3, 0x4e, 0x3, 0x4f, 
       0x3, 0x4f, 0x5, 0x4f, 0x8c2, 0xa, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 
       0x50, 0x3, 0x50, 0x5, 0x50, 0x8c8, 0xa, 0x50, 0x3, 0x50, 0x3, 0x50, 
       0x3, 0x51, 0x3, 0x51, 0x5, 0x51, 0x8ce, 0xa, 0x51, 0x3, 0x51, 0x3, 
       0x51, 0x3, 0x52, 0x5, 0x52, 0x8d3, 0xa, 0x52, 0x3, 0x52, 0x5, 0x52, 
       0x8d6, 0xa, 0x52, 0x3, 0x52, 0x5, 0x52, 0x8d9, 0xa, 0x52, 0x3, 0x52, 
       0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x53, 0x3, 0x53, 0x3, 0x53, 
       0x5, 0x53, 0x8e2, 0xa, 0x53, 0x3, 0x53, 0x5, 0x53, 0x8e5, 0xa, 0x53, 
       0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x55, 0x3, 0x55, 
       0x3, 0x55, 0x3, 0x55, 0x3, 0x56, 0x5, 0x56, 0x8f0, 0xa, 0x56, 0x3, 
       0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 
       0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x5, 0x56, 0x8fc, 0xa, 0x56, 
       0x3, 0x56, 0x3, 0x56, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 
       0x3, 0x58, 0x5, 0x58, 0x905, 0xa, 0x58, 0x3, 0x58, 0x3, 0x58, 0x5, 
       0x58, 0x909, 0xa, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 
       0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x5, 0x58, 0x912, 0xa, 0x58, 0x3, 
       0x58, 0x5, 0x58, 0x915, 0xa, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 
       0x3, 0x58, 0x5, 0x58, 0x91b, 0xa, 0x58, 0x5, 0x58, 0x91d, 0xa, 0x58, 
       0x3, 0x58, 0x3, 0x58, 0x5, 0x58, 0x921, 0xa, 0x58, 0x3, 0x58, 0x3, 
       0x58, 0x3, 0x58, 0x3, 0x59, 0x3, 0x59, 0x5, 0x59, 0x928, 0xa, 0x59, 
       0x3, 0x59, 0x3, 0x59, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 
       0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x7, 0x5a, 0x933, 0xa, 0x5a, 0xc, 
       0x5a, 0xe, 0x5a, 0x936, 0xb, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 
       0x3, 0x5a, 0x5, 0x5a, 0x93c, 0xa, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x7, 
       0x5a, 0x940, 0xa, 0x5a, 0xc, 0x5a, 0xe, 0x5a, 0x943, 0xb, 0x5a, 0x5, 
       0x5a, 0x945, 0xa, 0x5a, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 
       0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 
       0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x5, 0x5b, 
       0x956, 0xa, 0x5b, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 
       0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 
       0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 
       0x5c, 0x3, 0x5c, 0x5, 0x5c, 0x96a, 0xa, 0x5c, 0x3, 0x5d, 0x3, 0x5d, 
       0x5, 0x5d, 0x96e, 0xa, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5e, 0x3, 
       0x5e, 0x5, 0x5e, 0x974, 0xa, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5f, 
       0x3, 0x5f, 0x5, 0x5f, 0x97a, 0xa, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, 
       0x60, 0x3, 0x60, 0x5, 0x60, 0x980, 0xa, 0x60, 0x3, 0x60, 0x3, 0x60, 
       0x3, 0x61, 0x5, 0x61, 0x985, 0xa, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 
       0x61, 0x3, 0x61, 0x3, 0x61, 0x5, 0x61, 0x98c, 0xa, 0x61, 0x3, 0x62, 
       0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 0x5, 0x62, 0x993, 0xa, 
       0x62, 0x3, 0x62, 0x7, 0x62, 0x996, 0xa, 0x62, 0xc, 0x62, 0xe, 0x62, 
       0x999, 0xb, 0x62, 0x5, 0x62, 0x99b, 0xa, 0x62, 0x3, 0x63, 0x3, 0x63, 
       0x5, 0x63, 0x99f, 0xa, 0x63, 0x3, 0x64, 0x3, 0x64, 0x5, 0x64, 0x9a3, 
       0xa, 0x64, 0x3, 0x64, 0x3, 0x64, 0x3, 0x65, 0x5, 0x65, 0x9a8, 0xa, 
       0x65, 0x3, 0x65, 0x3, 0x65, 0x5, 0x65, 0x9ac, 0xa, 0x65, 0x3, 0x65, 
       0x3, 0x65, 0x5, 0x65, 0x9b0, 0xa, 0x65, 0x3, 0x66, 0x3, 0x66, 0x3, 
       0x66, 0x3, 0x66, 0x5, 0x66, 0x9b6, 0xa, 0x66, 0x3, 0x66, 0x7, 0x66, 
       0x9b9, 0xa, 0x66, 0xc, 0x66, 0xe, 0x66, 0x9bc, 0xb, 0x66, 0x5, 0x66, 
       0x9be, 0xa, 0x66, 0x3, 0x67, 0x3, 0x67, 0x5, 0x67, 0x9c2, 0xa, 0x67, 
       0x3, 0x67, 0x3, 0x67, 0x3, 0x68, 0x3, 0x68, 0x5, 0x68, 0x9c8, 0xa, 
       0x68, 0x3, 0x68, 0x3, 0x68, 0x5, 0x68, 0x9cc, 0xa, 0x68, 0x3, 0x69, 
       0x3, 0x69, 0x5, 0x69, 0x9d0, 0xa, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 
       0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x5, 0x6a, 0x9d8, 0xa, 0x6a, 
       0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6b, 
       0x5, 0x6b, 0x9e0, 0xa, 0x6b, 0x3, 0x6c, 0x3, 0x6c, 0x3, 0x6c, 0x3, 
       0x6c, 0x3, 0x6c, 0x7, 0x6c, 0x9e7, 0xa, 0x6c, 0xc, 0x6c, 0xe, 0x6c, 
       0x9ea, 0xb, 0x6c, 0x3, 0x6d, 0x3, 0x6d, 0x3, 0x6d, 0x3, 0x6d, 0x3, 
       0x6e, 0x3, 0x6e, 0x5, 0x6e, 0x9f2, 0xa, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 
       0x3, 0x6f, 0x3, 0x6f, 0x3, 0x6f, 0x3, 0x6f, 0x3, 0x6f, 0x3, 0x70, 
       0x3, 0x70, 0x3, 0x70, 0x3, 0x70, 0x5, 0x70, 0x9ff, 0xa, 0x70, 0x3, 
       0x70, 0x5, 0x70, 0xa02, 0xa, 0x70, 0x3, 0x71, 0x3, 0x71, 0x5, 0x71, 
       0xa06, 0xa, 0x71, 0x3, 0x71, 0x3, 0x71, 0x7, 0x71, 0xa0a, 0xa, 0x71, 
       0xc, 0x71, 0xe, 0x71, 0xa0d, 0xb, 0x71, 0x3, 0x71, 0x3, 0x71, 0x3, 
       0x71, 0x3, 0x71, 0x3, 0x71, 0x5, 0x71, 0xa14, 0xa, 0x71, 0x3, 0x71, 
       0x3, 0x71, 0x5, 0x71, 0xa18, 0xa, 0x71, 0x3, 0x71, 0x5, 0x71, 0xa1b, 
       0xa, 0x71, 0x3, 0x71, 0x5, 0x71, 0xa1e, 0xa, 0x71, 0x3, 0x71, 0x5, 
       0x71, 0xa21, 0xa, 0x71, 0x5, 0x71, 0xa23, 0xa, 0x71, 0x3, 0x71, 0x3, 
       0x71, 0x3, 0x71, 0x3, 0x71, 0x5, 0x71, 0xa29, 0xa, 0x71, 0x5, 0x71, 
       0xa2b, 0xa, 0x71, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 
       0x72, 0x3, 0x72, 0x3, 0x73, 0x3, 0x73, 0x3, 0x74, 0x3, 0x74, 0x3, 
       0x74, 0x3, 0x74, 0x3, 0x74, 0x5, 0x74, 0xa3a, 0xa, 0x74, 0x3, 0x75, 
       0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 0x5, 0x75, 0xa40, 0xa, 0x75, 0x3, 
       0x75, 0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 0x5, 0x75, 0xa47, 
       0xa, 0x75, 0x3, 0x75, 0x5, 0x75, 0xa4a, 0xa, 0x75, 0x5, 0x75, 0xa4c, 
       0xa, 0x75, 0x5, 0x75, 0xa4e, 0xa, 0x75, 0x3, 0x76, 0x3, 0x76, 0x3, 
       0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x5, 
       0x76, 0xa58, 0xa, 0x76, 0x5, 0x76, 0xa5a, 0xa, 0x76, 0x3, 0x77, 0x3, 
       0x77, 0x5, 0x77, 0xa5e, 0xa, 0x77, 0x3, 0x77, 0x5, 0x77, 0xa61, 0xa, 
       0x77, 0x3, 0x77, 0x5, 0x77, 0xa64, 0xa, 0x77, 0x3, 0x77, 0x3, 0x77, 
       0x5, 0x77, 0xa68, 0xa, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 
       0x77, 0x5, 0x77, 0xa6e, 0xa, 0x77, 0x3, 0x77, 0x5, 0x77, 0xa71, 0xa, 
       0x77, 0x3, 0x78, 0x3, 0x78, 0x3, 0x79, 0x3, 0x79, 0x5, 0x79, 0xa77, 
       0xa, 0x79, 0x3, 0x79, 0x5, 0x79, 0xa7a, 0xa, 0x79, 0x3, 0x79, 0x3, 
       0x79, 0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x7, 0x7a, 0xa81, 0xa, 0x7a, 
       0xc, 0x7a, 0xe, 0x7a, 0xa84, 0xb, 0x7a, 0x3, 0x7b, 0x3, 0x7b, 0x3, 
       0x7b, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x5, 0x7c, 0xa8c, 0xa, 0x7c, 
       0x3, 0x7c, 0x3, 0x7c, 0x5, 0x7c, 0xa90, 0xa, 0x7c, 0x3, 0x7d, 0x3, 
       0x7d, 0x5, 0x7d, 0xa94, 0xa, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 
       0x3, 0x7d, 0x5, 0x7d, 0xa9a, 0xa, 0x7d, 0x3, 0x7d, 0x7, 0x7d, 0xa9d, 
       0xa, 0x7d, 0xc, 0x7d, 0xe, 0x7d, 0xaa0, 0xb, 0x7d, 0x3, 0x7e, 0x3, 
       0x7e, 0x5, 0x7e, 0xaa4, 0xa, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 
       0x5, 0x7e, 0xaa9, 0xa, 0x7e, 0x7, 0x7e, 0xaab, 0xa, 0x7e, 0xc, 0x7e, 
       0xe, 0x7e, 0xaae, 0xb, 0x7e, 0x3, 0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x3, 
       0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 0x5, 
       0x80, 0xab9, 0xa, 0x80, 0x3, 0x80, 0x5, 0x80, 0xabc, 0xa, 0x80, 0x3, 
       0x80, 0x3, 0x80, 0x3, 0x80, 0x5, 0x80, 0xac1, 0xa, 0x80, 0x3, 0x80, 
       0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 0x5, 0x80, 0xac7, 0xa, 0x80, 0x3, 
       0x80, 0x5, 0x80, 0xaca, 0xa, 0x80, 0x3, 0x80, 0x5, 0x80, 0xacd, 0xa, 
       0x80, 0x3, 0x80, 0x5, 0x80, 0xad0, 0xa, 0x80, 0x3, 0x80, 0x5, 0x80, 
       0xad3, 0xa, 0x80, 0x3, 0x80, 0x3, 0x80, 0x3, 0x81, 0x3, 0x81, 0x3, 
       0x81, 0x5, 0x81, 0xada, 0xa, 0x81, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 
       0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 
       0x5, 0x83, 0xae5, 0xa, 0x83, 0x3, 0x83, 0x5, 0x83, 0xae8, 0xa, 0x83, 
       0x3, 0x83, 0x3, 0x83, 0x5, 0x83, 0xaec, 0xa, 0x83, 0x3, 0x84, 0x3, 
       0x84, 0x5, 0x84, 0xaf0, 0xa, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x85, 
       0x3, 0x85, 0x5, 0x85, 0xaf6, 0xa, 0x85, 0x3, 0x85, 0x3, 0x85, 0x3, 
       0x85, 0x5, 0x85, 0xafb, 0xa, 0x85, 0x7, 0x85, 0xafd, 0xa, 0x85, 0xc, 
       0x85, 0xe, 0x85, 0xb00, 0xb, 0x85, 0x3, 0x86, 0x3, 0x86, 0x5, 0x86, 
       0xb04, 0xa, 0x86, 0x3, 0x86, 0x5, 0x86, 0xb07, 0xa, 0x86, 0x3, 0x86, 
       0x3, 0x86, 0x5, 0x86, 0xb0b, 0xa, 0x86, 0x3, 0x86, 0x3, 0x86, 0x3, 
       0x86, 0x3, 0x86, 0x5, 0x86, 0xb11, 0xa, 0x86, 0x3, 0x87, 0x3, 0x87, 
       0x3, 0x87, 0x5, 0x87, 0xb16, 0xa, 0x87, 0x3, 0x88, 0x3, 0x88, 0x3, 
       0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x5, 0x88, 0xb1f, 
       0xa, 0x88, 0x3, 0x89, 0x3, 0x89, 0x5, 0x89, 0xb23, 0xa, 0x89, 0x3, 
       0x89, 0x3, 0x89, 0x5, 0x89, 0xb27, 0xa, 0x89, 0x3, 0x89, 0x5, 0x89, 
       0xb2a, 0xa, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x5, 0x89, 0xb2f, 
       0xa, 0x89, 0x3, 0x89, 0x5, 0x89, 0xb32, 0xa, 0x89, 0x5, 0x89, 0xb34, 
       0xa, 0x89, 0x3, 0x89, 0x3, 0x89, 0x5, 0x89, 0xb38, 0xa, 0x89, 0x3, 
       0x89, 0x5, 0x89, 0xb3b, 0xa, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 
       0x3, 0x89, 0x5, 0x89, 0xb41, 0xa, 0x89, 0x5, 0x89, 0xb43, 0xa, 0x89, 
       0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x5, 0x8a, 
       0xb4a, 0xa, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x5, 0x8a, 0xb4e, 0xa, 0x8a, 
       0x5, 0x8a, 0xb50, 0xa, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x5, 
       0x8a, 0xb55, 0xa, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x5, 0x8a, 0xb59, 0xa, 
       0x8a, 0x7, 0x8a, 0xb5b, 0xa, 0x8a, 0xc, 0x8a, 0xe, 0x8a, 0xb5e, 0xb, 
       0x8a, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x5, 0x8b, 0xb63, 0xa, 0x8b, 
       0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8c, 0x3, 0x8c, 0x7, 0x8c, 0xb69, 0xa, 
       0x8c, 0xc, 0x8c, 0xe, 0x8c, 0xb6c, 0xb, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 
       0x5, 0x8c, 0xb70, 0xa, 0x8c, 0x3, 0x8c, 0x5, 0x8c, 0xb73, 0xa, 0x8c, 
       0x3, 0x8c, 0x5, 0x8c, 0xb76, 0xa, 0x8c, 0x3, 0x8c, 0x5, 0x8c, 0xb79, 
       0xa, 0x8c, 0x3, 0x8c, 0x5, 0x8c, 0xb7c, 0xa, 0x8c, 0x3, 0x8c, 0x3, 
       0x8c, 0x5, 0x8c, 0xb80, 0xa, 0x8c, 0x3, 0x8d, 0x3, 0x8d, 0x3, 0x8e, 
       0x3, 0x8e, 0x3, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x3, 0x90, 0x3, 0x90, 
       0x3, 0x90, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x5, 0x91, 0xb8f, 0xa, 
       0x91, 0x3, 0x92, 0x3, 0x92, 0x5, 0x92, 0xb93, 0xa, 0x92, 0x3, 0x93, 
       0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x5, 0x93, 0xb99, 0xa, 0x93, 0x3, 
       0x93, 0x5, 0x93, 0xb9c, 0xa, 0x93, 0x3, 0x93, 0x5, 0x93, 0xb9f, 0xa, 
       0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x5, 0x93, 0xba5, 
       0xa, 0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x5, 0x93, 0xbaa, 0xa, 
       0x93, 0x7, 0x93, 0xbac, 0xa, 0x93, 0xc, 0x93, 0xe, 0x93, 0xbaf, 0xb, 
       0x93, 0x5, 0x93, 0xbb1, 0xa, 0x93, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 
       0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x5, 0x94, 0xbb9, 0xa, 0x94, 0x5, 
       0x94, 0xbbb, 0xa, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x95, 0x3, 0x95, 
       0x3, 0x95, 0x3, 0x96, 0x3, 0x96, 0x3, 0x96, 0x3, 0x96, 0x7, 0x96, 
       0xbc6, 0xa, 0x96, 0xc, 0x96, 0xe, 0x96, 0xbc9, 0xb, 0x96, 0x3, 0x97, 
       0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 0x3, 0x98, 0x3, 0x98, 0x3, 0x98, 
       0x3, 0x98, 0x3, 0x99, 0x5, 0x99, 0xbd4, 0xa, 0x99, 0x3, 0x99, 0x3, 
       0x99, 0x3, 0x99, 0x5, 0x99, 0xbd9, 0xa, 0x99, 0x3, 0x99, 0x5, 0x99, 
       0xbdc, 0xa, 0x99, 0x3, 0x99, 0x5, 0x99, 0xbdf, 0xa, 0x99, 0x3, 0x9a, 
       0x3, 0x9a, 0x3, 0x9a, 0x5, 0x9a, 0xbe4, 0xa, 0x9a, 0x3, 0x9b, 0x3, 
       0x9b, 0x3, 0x9c, 0x3, 0x9c, 0x5, 0x9c, 0xbea, 0xa, 0x9c, 0x3, 0x9d, 
       0x3, 0x9d, 0x3, 0x9d, 0x3, 0x9d, 0x3, 0x9d, 0x3, 0x9d, 0x3, 0x9d, 
       0x3, 0x9d, 0x3, 0x9d, 0x3, 0x9d, 0x3, 0x9d, 0x3, 0x9d, 0x3, 0x9d, 
       0x3, 0x9d, 0x5, 0x9d, 0xbfa, 0xa, 0x9d, 0x3, 0x9e, 0x3, 0x9e, 0x3, 
       0x9e, 0x3, 0x9e, 0x3, 0x9e, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 
       0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 
       0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x5, 0x9f, 0xc0e, 0xa, 0x9f, 
       0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 
       0x3, 0xa0, 0x5, 0xa0, 0xc17, 0xa, 0xa0, 0x3, 0xa1, 0x3, 0xa1, 0x5, 
       0xa1, 0xc1b, 0xa, 0xa1, 0x3, 0xa1, 0x3, 0xa1, 0x3, 0xa1, 0x7, 0xa1, 
       0xc20, 0xa, 0xa1, 0xc, 0xa1, 0xe, 0xa1, 0xc23, 0xb, 0xa1, 0x3, 0xa2, 
       0x3, 0xa2, 0x5, 0xa2, 0xc27, 0xa, 0xa2, 0x3, 0xa2, 0x3, 0xa2, 0x3, 
       0xa2, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x5, 0xa3, 0xc30, 
       0xa, 0xa3, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 
       0x5, 0xa4, 0xc37, 0xa, 0xa4, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 
       0xa5, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa7, 0x3, 0xa7, 0x3, 0xa7, 0x5, 
       0xa7, 0xc42, 0xa, 0xa7, 0x3, 0xa8, 0x3, 0xa8, 0x3, 0xa8, 0x7, 0xa8, 
       0xc47, 0xa, 0xa8, 0xc, 0xa8, 0xe, 0xa8, 0xc4a, 0xb, 0xa8, 0x3, 0xa9, 
       0x3, 0xa9, 0x3, 0xa9, 0x3, 0xa9, 0x3, 0xa9, 0x3, 0xa9, 0x3, 0xa9, 
       0x3, 0xa9, 0x5, 0xa9, 0xc54, 0xa, 0xa9, 0x3, 0xaa, 0x3, 0xaa, 0x3, 
       0xaa, 0x3, 0xaa, 0x3, 0xaa, 0x5, 0xaa, 0xc5b, 0xa, 0xaa, 0x3, 0xaa, 
       0x3, 0xaa, 0x5, 0xaa, 0xc5f, 0xa, 0xaa, 0x3, 0xaa, 0x3, 0xaa, 0x3, 
       0xaa, 0x3, 0xaa, 0x5, 0xaa, 0xc65, 0xa, 0xaa, 0x3, 0xab, 0x3, 0xab, 
       0x3, 0xab, 0x5, 0xab, 0xc6a, 0xa, 0xab, 0x3, 0xac, 0x3, 0xac, 0x3, 
       0xac, 0x5, 0xac, 0xc6f, 0xa, 0xac, 0x3, 0xad, 0x3, 0xad, 0x5, 0xad, 
       0xc73, 0xa, 0xad, 0x3, 0xad, 0x3, 0xad, 0x7, 0xad, 0xc77, 0xa, 0xad, 
       0xc, 0xad, 0xe, 0xad, 0xc7a, 0xb, 0xad, 0x3, 0xae, 0x3, 0xae, 0x3, 
       0xae, 0x5, 0xae, 0xc7f, 0xa, 0xae, 0x5, 0xae, 0xc81, 0xa, 0xae, 0x3, 
       0xaf, 0x5, 0xaf, 0xc84, 0xa, 0xaf, 0x3, 0xaf, 0x3, 0xaf, 0x5, 0xaf, 
       0xc88, 0xa, 0xaf, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb1, 0x3, 
       0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x5, 0xb1, 0xc93, 
       0xa, 0xb1, 0x3, 0xb1, 0x7, 0xb1, 0xc96, 0xa, 0xb1, 0xc, 0xb1, 0xe, 
       0xb1, 0xc99, 0xb, 0xb1, 0x3, 0xb2, 0x3, 0xb2, 0x7, 0xb2, 0xc9d, 0xa, 
       0xb2, 0xc, 0xb2, 0xe, 0xb2, 0xca0, 0xb, 0xb2, 0x3, 0xb3, 0x3, 0xb3, 
       0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xca8, 0xa, 
       0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 
       0xb3, 0x5, 0xb3, 0xcb0, 0xa, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 
       0x5, 0xb3, 0xcb5, 0xa, 0xb3, 0x3, 0xb4, 0x3, 0xb4, 0x5, 0xb4, 0xcb9, 
       0xa, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x5, 0xb4, 
       0xcbf, 0xa, 0xb4, 0x3, 0xb4, 0x5, 0xb4, 0xcc2, 0xa, 0xb4, 0x3, 0xb5, 
       0x5, 0xb5, 0xcc5, 0xa, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x5, 0xb5, 0xcc9, 
       0xa, 0xb5, 0x3, 0xb6, 0x3, 0xb6, 0x5, 0xb6, 0xccd, 0xa, 0xb6, 0x3, 
       0xb6, 0x3, 0xb6, 0x3, 0xb7, 0x3, 0xb7, 0x3, 0xb7, 0x3, 0xb7, 0x3, 
       0xb7, 0x3, 0xb7, 0x5, 0xb7, 0xcd7, 0xa, 0xb7, 0x3, 0xb8, 0x3, 0xb8, 
       0x5, 0xb8, 0xcdb, 0xa, 0xb8, 0x3, 0xb8, 0x5, 0xb8, 0xcde, 0xa, 0xb8, 
       0x3, 0xb8, 0x5, 0xb8, 0xce1, 0xa, 0xb8, 0x3, 0xb9, 0x3, 0xb9, 0x3, 
       0xb9, 0x5, 0xb9, 0xce6, 0xa, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xba, 
       0x3, 0xba, 0x5, 0xba, 0xcec, 0xa, 0xba, 0x3, 0xba, 0x3, 0xba, 0x5, 
       0xba, 0xcf0, 0xa, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 
       0x5, 0xba, 0xcf6, 0xa, 0xba, 0x3, 0xba, 0x5, 0xba, 0xcf9, 0xa, 0xba, 
       0x5, 0xba, 0xcfb, 0xa, 0xba, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x5, 
       0xbb, 0xd00, 0xa, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbc, 0x3, 0xbc, 
       0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 
       0x5, 0xbc, 0xd0c, 0xa, 0xbc, 0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbd, 0x3, 
       0xbd, 0x3, 0xbd, 0x7, 0xbd, 0xd13, 0xa, 0xbd, 0xc, 0xbd, 0xe, 0xbd, 
       0xd16, 0xb, 0xbd, 0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbe, 0x3, 0xbe, 0x3, 
       0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x5, 
       0xbe, 0xd22, 0xa, 0xbe, 0x3, 0xbe, 0x5, 0xbe, 0xd25, 0xa, 0xbe, 0x3, 
       0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x5, 0xbe, 0xd2a, 0xa, 0xbe, 0x3, 0xbe, 
       0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x5, 0xbe, 0xd31, 0xa, 
       0xbe, 0x3, 0xbf, 0x3, 0xbf, 0x5, 0xbf, 0xd35, 0xa, 0xbf, 0x3, 0xbf, 
       0x3, 0xbf, 0x5, 0xbf, 0xd39, 0xa, 0xbf, 0x5, 0xbf, 0xd3b, 0xa, 0xbf, 
       0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc1, 0x3, 0xc1, 
       0x3, 0xc1, 0x3, 0xc1, 0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc2, 
       0x5, 0xc2, 0xd49, 0xa, 0xc2, 0x3, 0xc3, 0x3, 0xc3, 0x3, 0xc4, 0x5, 
       0xc4, 0xd4e, 0xa, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc5, 0x3, 0xc5, 
       0x3, 0xc5, 0x7, 0xc5, 0xd55, 0xa, 0xc5, 0xc, 0xc5, 0xe, 0xc5, 0xd58, 
       0xb, 0xc5, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x5, 0xc6, 0xd5d, 0xa, 
       0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 
       0xc6, 0x3, 0xc6, 0x5, 0xc6, 0xd66, 0xa, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 
       0x5, 0xc6, 0xd6a, 0xa, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x5, 0xc6, 0xd6e, 
       0xa, 0xc6, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc9, 
       0x3, 0xc9, 0x3, 0xc9, 0x3, 0xc9, 0x5, 0xc9, 0xd78, 0xa, 0xc9, 0x5, 
       0xc9, 0xd7a, 0xa, 0xc9, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 
       0x3, 0xca, 0x3, 0xca, 0x5, 0xca, 0xd82, 0xa, 0xca, 0x3, 0xcb, 0x3, 
       0xcb, 0x3, 0xcb, 0x7, 0xcb, 0xd87, 0xa, 0xcb, 0xc, 0xcb, 0xe, 0xcb, 
       0xd8a, 0xb, 0xcb, 0x3, 0xcc, 0x3, 0xcc, 0x5, 0xcc, 0xd8e, 0xa, 0xcc, 
       0x3, 0xcd, 0x3, 0xcd, 0x5, 0xcd, 0xd92, 0xa, 0xcd, 0x3, 0xcd, 0x3, 
       0xcd, 0x5, 0xcd, 0xd96, 0xa, 0xcd, 0x3, 0xcd, 0x5, 0xcd, 0xd99, 0xa, 
       0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x5, 0xcd, 0xd9f, 
       0xa, 0xcd, 0x3, 0xcd, 0x5, 0xcd, 0xda2, 0xa, 0xcd, 0x3, 0xcd, 0x5, 
       0xcd, 0xda5, 0xa, 0xcd, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 
       0x5, 0xce, 0xdab, 0xa, 0xce, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x7, 
       0xcf, 0xdb0, 0xa, 0xcf, 0xc, 0xcf, 0xe, 0xcf, 0xdb3, 0xb, 0xcf, 0x3, 
       0xcf, 0x3, 0xcf, 0x5, 0xcf, 0xdb7, 0xa, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 
       0x5, 0xcf, 0xdbb, 0xa, 0xcf, 0x3, 0xcf, 0x5, 0xcf, 0xdbe, 0xa, 0xcf, 
       0x3, 0xcf, 0x5, 0xcf, 0xdc1, 0xa, 0xcf, 0x3, 0xcf, 0x5, 0xcf, 0xdc4, 
       0xa, 0xcf, 0x5, 0xcf, 0xdc6, 0xa, 0xcf, 0x3, 0xd0, 0x3, 0xd0, 0x5, 
       0xd0, 0xdca, 0xa, 0xd0, 0x3, 0xd1, 0x3, 0xd1, 0x3, 0xd1, 0x3, 0xd1, 
       0x3, 0xd1, 0x3, 0xd1, 0x5, 0xd1, 0xdd2, 0xa, 0xd1, 0x3, 0xd2, 0x3, 
       0xd2, 0x3, 0xd2, 0x3, 0xd2, 0x3, 0xd2, 0x3, 0xd2, 0x5, 0xd2, 0xdda, 
       0xa, 0xd2, 0x3, 0xd3, 0x3, 0xd3, 0x3, 0xd3, 0x3, 0xd3, 0x3, 0xd3, 
       0x5, 0xd3, 0xde1, 0xa, 0xd3, 0x3, 0xd4, 0x3, 0xd4, 0x3, 0xd4, 0x3, 
       0xd4, 0x5, 0xd4, 0xde7, 0xa, 0xd4, 0x3, 0xd4, 0x3, 0xd4, 0x5, 0xd4, 
       0xdeb, 0xa, 0xd4, 0x3, 0xd4, 0x3, 0xd4, 0x3, 0xd4, 0x5, 0xd4, 0xdf0, 
       0xa, 0xd4, 0x3, 0xd4, 0x5, 0xd4, 0xdf3, 0xa, 0xd4, 0x3, 0xd4, 0x5, 
       0xd4, 0xdf6, 0xa, 0xd4, 0x3, 0xd4, 0x5, 0xd4, 0xdf9, 0xa, 0xd4, 0x5, 
       0xd4, 0xdfb, 0xa, 0xd4, 0x3, 0xd4, 0x3, 0xd4, 0x3, 0xd4, 0x5, 0xd4, 
       0xe00, 0xa, 0xd4, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x3, 
       0xd5, 0x7, 0xd5, 0xe07, 0xa, 0xd5, 0xc, 0xd5, 0xe, 0xd5, 0xe0a, 0xb, 
       0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x3, 
       0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x5, 0xd5, 0xe16, 
       0xa, 0xd5, 0x5, 0xd5, 0xe18, 0xa, 0xd5, 0x3, 0xd6, 0x3, 0xd6, 0x5, 
       0xd6, 0xe1c, 0xa, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd7, 0x3, 0xd7, 
       0x5, 0xd7, 0xe22, 0xa, 0xd7, 0x3, 0xd7, 0x5, 0xd7, 0xe25, 0xa, 0xd7, 
       0x3, 0xd7, 0x5, 0xd7, 0xe28, 0xa, 0xd7, 0x3, 0xd8, 0x3, 0xd8, 0x3, 
       0xd8, 0x3, 0xd8, 0x5, 0xd8, 0xe2e, 0xa, 0xd8, 0x3, 0xd8, 0x3, 0xd8, 
       0x3, 0xd8, 0x3, 0xd8, 0x3, 0xd8, 0x5, 0xd8, 0xe35, 0xa, 0xd8, 0x5, 
       0xd8, 0xe37, 0xa, 0xd8, 0x3, 0xd8, 0x3, 0xd8, 0x3, 0xd8, 0x3, 0xd8, 
       0x3, 0xd8, 0x3, 0xd8, 0x5, 0xd8, 0xe3f, 0xa, 0xd8, 0x3, 0xd8, 0x3, 
       0xd8, 0x3, 0xd8, 0x3, 0xd8, 0x5, 0xd8, 0xe45, 0xa, 0xd8, 0x3, 0xd9, 
       0x3, 0xd9, 0x3, 0xd9, 0x5, 0xd9, 0xe4a, 0xa, 0xd9, 0x3, 0xd9, 0x5, 
       0xd9, 0xe4d, 0xa, 0xd9, 0x3, 0xda, 0x3, 0xda, 0x3, 0xda, 0x3, 0xda, 
       0x3, 0xda, 0x5, 0xda, 0xe54, 0xa, 0xda, 0x5, 0xda, 0xe56, 0xa, 0xda, 
       0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 
       0x3, 0xdb, 0x5, 0xdb, 0xe5f, 0xa, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 
       0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x7, 0xdb, 0xe66, 0xa, 0xdb, 0xc, 0xdb, 
       0xe, 0xdb, 0xe69, 0xb, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 
       0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x5, 0xdb, 0xe71, 0xa, 0xdb, 0x3, 0xdb, 
       0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 
       0x5, 0xdb, 0xe7a, 0xa, 0xdb, 0x3, 0xdc, 0x3, 0xdc, 0x5, 0xdc, 0xe7e, 
       0xa, 0xdc, 0x3, 0xdc, 0x3, 0xdc, 0x3, 0xdc, 0x3, 0xdc, 0x3, 0xdc, 
       0x5, 0xdc, 0xe85, 0xa, 0xdc, 0x3, 0xdc, 0x5, 0xdc, 0xe88, 0xa, 0xdc, 
       0x5, 0xdc, 0xe8a, 0xa, 0xdc, 0x3, 0xdd, 0x3, 0xdd, 0x3, 0xdd, 0x3, 
       0xdd, 0x3, 0xde, 0x3, 0xde, 0x3, 0xde, 0x3, 0xde, 0x5, 0xde, 0xe94, 
       0xa, 0xde, 0x3, 0xde, 0x3, 0xde, 0x3, 0xde, 0x3, 0xdf, 0x3, 0xdf, 
       0x3, 0xdf, 0x3, 0xdf, 0x3, 0xdf, 0x5, 0xdf, 0xe9e, 0xa, 0xdf, 0x3, 
       0xe0, 0x3, 0xe0, 0x3, 0xe0, 0x7, 0xe0, 0xea3, 0xa, 0xe0, 0xc, 0xe0, 
       0xe, 0xe0, 0xea6, 0xb, 0xe0, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 
       0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 
       0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 
       0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 
       0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 
       0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 
       0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 
       0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 
       0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 
       0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 
       0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 
       0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 
       0xe1, 0x5, 0xe1, 0xeee, 0xa, 0xe1, 0x3, 0xe2, 0x3, 0xe2, 0x3, 0xe2, 
       0x3, 0xe2, 0x3, 0xe2, 0x3, 0xe2, 0x3, 0xe2, 0x3, 0xe2, 0x3, 0xe2, 
       0x3, 0xe2, 0x3, 0xe2, 0x3, 0xe2, 0x5, 0xe2, 0xefc, 0xa, 0xe2, 0x3, 
       0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x7, 0xe3, 0xf02, 0xa, 0xe3, 
       0xc, 0xe3, 0xe, 0xe3, 0xf05, 0xb, 0xe3, 0x5, 0xe3, 0xf07, 0xa, 0xe3, 
       0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe4, 0x3, 0xe4, 0x3, 0xe4, 0x3, 0xe4, 
       0x3, 0xe4, 0x3, 0xe4, 0x7, 0xe4, 0xf11, 0xa, 0xe4, 0xc, 0xe4, 0xe, 
       0xe4, 0xf14, 0xb, 0xe4, 0x3, 0xe4, 0x3, 0xe4, 0x5, 0xe4, 0xf18, 0xa, 
       0xe4, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x5, 0xe5, 0xf1e, 
       0xa, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 
       0x5, 0xe5, 0xf25, 0xa, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 
       0xe5, 0x3, 0xe5, 0x5, 0xe5, 0xf2c, 0xa, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 
       0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x5, 0xe5, 0xf33, 0xa, 0xe5, 0x3, 
       0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x5, 0xe5, 0xf3a, 
       0xa, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 
       0x5, 0xe5, 0xf41, 0xa, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 
       0xe5, 0x3, 0xe5, 0x5, 0xe5, 0xf48, 0xa, 0xe5, 0x3, 0xe5, 0x5, 0xe5, 
       0xf4b, 0xa, 0xe5, 0x3, 0xe6, 0x3, 0xe6, 0x3, 0xe6, 0x7, 0xe6, 0xf50, 
       0xa, 0xe6, 0xc, 0xe6, 0xe, 0xe6, 0xf53, 0xb, 0xe6, 0x3, 0xe7, 0x3, 
       0xe7, 0x3, 0xe7, 0x7, 0xe7, 0xf58, 0xa, 0xe7, 0xc, 0xe7, 0xe, 0xe7, 
       0xf5b, 0xb, 0xe7, 0x3, 0xe8, 0x3, 0xe8, 0x3, 0xe8, 0x7, 0xe8, 0xf60, 
       0xa, 0xe8, 0xc, 0xe8, 0xe, 0xe8, 0xf63, 0xb, 0xe8, 0x3, 0xe9, 0x3, 
       0xe9, 0x3, 0xea, 0x3, 0xea, 0x3, 0xea, 0x7, 0xea, 0xf6a, 0xa, 0xea, 
       0xc, 0xea, 0xe, 0xea, 0xf6d, 0xb, 0xea, 0x3, 0xeb, 0x3, 0xeb, 0x3, 
       0xeb, 0x5, 0xeb, 0xf72, 0xa, 0xeb, 0x3, 0xeb, 0x3, 0xeb, 0x5, 0xeb, 
       0xf76, 0xa, 0xeb, 0x3, 0xeb, 0x3, 0xeb, 0x5, 0xeb, 0xf7a, 0xa, 0xeb, 
       0x3, 0xeb, 0x3, 0xeb, 0x3, 0xeb, 0x5, 0xeb, 0xf7f, 0xa, 0xeb, 0x3, 
       0xeb, 0x5, 0xeb, 0xf82, 0xa, 0xeb, 0x5, 0xeb, 0xf84, 0xa, 0xeb, 0x3, 
       0xec, 0x3, 0xec, 0x3, 0xec, 0x3, 0xec, 0x3, 0xec, 0x3, 0xec, 0x3, 
       0xec, 0x5, 0xec, 0xf8d, 0xa, 0xec, 0x3, 0xec, 0x3, 0xec, 0x7, 0xec, 
       0xf91, 0xa, 0xec, 0xc, 0xec, 0xe, 0xec, 0xf94, 0xb, 0xec, 0x3, 0xed, 
       0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x5, 0xed, 0xf9a, 0xa, 0xed, 0x3, 
       0xed, 0x3, 0xed, 0x3, 0xed, 0x5, 0xed, 0xf9f, 0xa, 0xed, 0x3, 0xed, 
       0x3, 0xed, 0x3, 0xed, 0x5, 0xed, 0xfa4, 0xa, 0xed, 0x3, 0xed, 0x3, 
       0xed, 0x3, 0xed, 0x5, 0xed, 0xfa9, 0xa, 0xed, 0x3, 0xed, 0x5, 0xed, 
       0xfac, 0xa, 0xed, 0x3, 0xee, 0x3, 0xee, 0x3, 0xee, 0x7, 0xee, 0xfb1, 
       0xa, 0xee, 0xc, 0xee, 0xe, 0xee, 0xfb4, 0xb, 0xee, 0x3, 0xef, 0x3, 
       0xef, 0x3, 0xf0, 0x3, 0xf0, 0x3, 0xf0, 0x3, 0xf1, 0x3, 0xf1, 0x3, 
       0xf1, 0x3, 0xf1, 0x3, 0xf1, 0x5, 0xf1, 0xfc0, 0xa, 0xf1, 0x3, 0xf1, 
       0x3, 0xf1, 0x3, 0xf1, 0x3, 0xf1, 0x5, 0xf1, 0xfc6, 0xa, 0xf1, 0x3, 
       0xf2, 0x3, 0xf2, 0x3, 0xf2, 0x3, 0xf2, 0x5, 0xf2, 0xfcc, 0xa, 0xf2, 
       0x3, 0xf3, 0x3, 0xf3, 0x3, 0xf3, 0x7, 0xf3, 0xfd1, 0xa, 0xf3, 0xc, 
       0xf3, 0xe, 0xf3, 0xfd4, 0xb, 0xf3, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 
       0x3, 0xf4, 0x3, 0xf4, 0x5, 0xf4, 0xfdb, 0xa, 0xf4, 0x3, 0xf4, 0x3, 
       0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x5, 0xf4, 0xfe1, 0xa, 0xf4, 0x3, 0xf4, 
       0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 
       0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x5, 0xf4, 0xfed, 0xa, 0xf4, 0x5, 
       0xf4, 0xfef, 0xa, 0xf4, 0x3, 0xf5, 0x3, 0xf5, 0x3, 0xf5, 0x3, 0xf5, 
       0x5, 0xf5, 0xff5, 0xa, 0xf5, 0x3, 0xf5, 0x3, 0xf5, 0x5, 0xf5, 0xff9, 
       0xa, 0xf5, 0x5, 0xf5, 0xffb, 0xa, 0xf5, 0x3, 0xf6, 0x3, 0xf6, 0x5, 
       0xf6, 0xfff, 0xa, 0xf6, 0x3, 0xf6, 0x3, 0xf6, 0x3, 0xf7, 0x3, 0xf7, 
       0x3, 0xf7, 0x3, 0xf7, 0x3, 0xf7, 0x3, 0xf7, 0x3, 0xf7, 0x3, 0xf7, 
       0x3, 0xf7, 0x3, 0xf7, 0x5, 0xf7, 0x100d, 0xa, 0xf7, 0x3, 0xf8, 0x3, 
       0xf8, 0x3, 0xf8, 0x3, 0xf8, 0x5, 0xf8, 0x1013, 0xa, 0xf8, 0x3, 0xf8, 
       0x3, 0xf8, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x5, 0xf9, 
       0x101b, 0xa, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x3, 
       0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x5, 
       0xf9, 0x1027, 0xa, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x5, 0xf9, 0x102b, 
       0xa, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 
       0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 
       0x3, 0xf9, 0x5, 0xf9, 0x1039, 0xa, 0xf9, 0x5, 0xf9, 0x103b, 0xa, 
       0xf9, 0x3, 0xfa, 0x3, 0xfa, 0x3, 0xfa, 0x3, 0xfa, 0x3, 0xfa, 0x5, 
       0xfa, 0x1042, 0xa, 0xfa, 0x3, 0xfa, 0x3, 0xfa, 0x3, 0xfa, 0x3, 0xfa, 
       0x3, 0xfb, 0x3, 0xfb, 0x5, 0xfb, 0x104a, 0xa, 0xfb, 0x3, 0xfb, 0x5, 
       0xfb, 0x104d, 0xa, 0xfb, 0x3, 0xfb, 0x5, 0xfb, 0x1050, 0xa, 0xfb, 
       0x3, 0xfb, 0x5, 0xfb, 0x1053, 0xa, 0xfb, 0x3, 0xfc, 0x3, 0xfc, 0x3, 
       0xfc, 0x3, 0xfc, 0x5, 0xfc, 0x1059, 0xa, 0xfc, 0x3, 0xfc, 0x5, 0xfc, 
       0x105c, 0xa, 0xfc, 0x3, 0xfd, 0x3, 0xfd, 0x3, 0xfd, 0x5, 0xfd, 0x1061, 
       0xa, 0xfd, 0x3, 0xfe, 0x3, 0xfe, 0x3, 0xfe, 0x3, 0xfe, 0x3, 0xfe, 
       0x3, 0xfe, 0x3, 0xfe, 0x3, 0xfe, 0x3, 0xfe, 0x6, 0xfe, 0x106c, 0xa, 
       0xfe, 0xd, 0xfe, 0xe, 0xfe, 0x106d, 0x3, 0xff, 0x3, 0xff, 0x3, 0xff, 
       0x3, 0xff, 0x3, 0xff, 0x3, 0xff, 0x3, 0xff, 0x3, 0xff, 0x3, 0xff, 
       0x5, 0xff, 0x1079, 0xa, 0xff, 0x3, 0xff, 0x3, 0xff, 0x3, 0xff, 0x5, 
       0xff, 0x107e, 0xa, 0xff, 0x3, 0xff, 0x3, 0xff, 0x3, 0xff, 0x3, 0xff, 
       0x3, 0xff, 0x3, 0xff, 0x5, 0xff, 0x1086, 0xa, 0xff, 0x3, 0xff, 0x3, 
       0xff, 0x3, 0xff, 0x3, 0xff, 0x5, 0xff, 0x108c, 0xa, 0xff, 0x5, 0xff, 
       0x108e, 0xa, 0xff, 0x5, 0xff, 0x1090, 0xa, 0xff, 0x3, 0x100, 0x3, 
       0x100, 0x3, 0x100, 0x3, 0x100, 0x5, 0x100, 0x1096, 0xa, 0x100, 0x3, 
       0x100, 0x3, 0x100, 0x3, 0x101, 0x3, 0x101, 0x3, 0x101, 0x3, 0x101, 
       0x3, 0x101, 0x3, 0x101, 0x3, 0x101, 0x3, 0x101, 0x5, 0x101, 0x10a2, 
       0xa, 0x101, 0x3, 0x101, 0x3, 0x101, 0x3, 0x101, 0x5, 0x101, 0x10a7, 
       0xa, 0x101, 0x5, 0x101, 0x10a9, 0xa, 0x101, 0x3, 0x101, 0x3, 0x101, 
       0x5, 0x101, 0x10ad, 0xa, 0x101, 0x3, 0x101, 0x3, 0x101, 0x3, 0x101, 
       0x3, 0x101, 0x5, 0x101, 0x10b3, 0xa, 0x101, 0x3, 0x101, 0x5, 0x101, 
       0x10b6, 0xa, 0x101, 0x3, 0x101, 0x3, 0x101, 0x3, 0x101, 0x3, 0x101, 
       0x3, 0x101, 0x3, 0x101, 0x3, 0x101, 0x3, 0x101, 0x3, 0x101, 0x5, 
       0x101, 0x10c1, 0xa, 0x101, 0x5, 0x101, 0x10c3, 0xa, 0x101, 0x3, 0x102, 
       0x3, 0x102, 0x3, 0x102, 0x3, 0x102, 0x5, 0x102, 0x10c9, 0xa, 0x102, 
       0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x6, 0x103, 0x10ce, 0xa, 0x103, 
       0xd, 0x103, 0xe, 0x103, 0x10cf, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 
       0x3, 0x103, 0x5, 0x103, 0x10d6, 0xa, 0x103, 0x3, 0x104, 0x3, 0x104, 
       0x3, 0x104, 0x3, 0x105, 0x3, 0x105, 0x3, 0x105, 0x3, 0x105, 0x3, 
       0x105, 0x3, 0x105, 0x3, 0x105, 0x3, 0x105, 0x3, 0x105, 0x3, 0x105, 
       0x7, 0x105, 0x10e5, 0xa, 0x105, 0xc, 0x105, 0xe, 0x105, 0x10e8, 0xb, 
       0x105, 0x3, 0x106, 0x3, 0x106, 0x3, 0x106, 0x3, 0x106, 0x3, 0x106, 
       0x3, 0x106, 0x3, 0x106, 0x3, 0x106, 0x3, 0x106, 0x3, 0x106, 0x3, 
       0x106, 0x3, 0x106, 0x3, 0x106, 0x5, 0x106, 0x10f7, 0xa, 0x106, 0x3, 
       0x106, 0x3, 0x106, 0x3, 0x106, 0x5, 0x106, 0x10fc, 0xa, 0x106, 0x3, 
       0x106, 0x3, 0x106, 0x3, 0x106, 0x3, 0x106, 0x3, 0x106, 0x3, 0x106, 
       0x5, 0x106, 0x1104, 0xa, 0x106, 0x3, 0x106, 0x3, 0x106, 0x3, 0x106, 
       0x3, 0x106, 0x3, 0x106, 0x3, 0x106, 0x3, 0x106, 0x5, 0x106, 0x110d, 
       0xa, 0x106, 0x3, 0x107, 0x3, 0x107, 0x3, 0x107, 0x5, 0x107, 0x1112, 
       0xa, 0x107, 0x3, 0x107, 0x3, 0x107, 0x3, 0x107, 0x3, 0x107, 0x5, 
       0x107, 0x1118, 0xa, 0x107, 0x3, 0x107, 0x5, 0x107, 0x111b, 0xa, 0x107, 
       0x5, 0x107, 0x111d, 0xa, 0x107, 0x3, 0x108, 0x3, 0x108, 0x3, 0x109, 
       0x3, 0x109, 0x3, 0x109, 0x3, 0x109, 0x5, 0x109, 0x1125, 0xa, 0x109, 
       0x3, 0x109, 0x3, 0x109, 0x3, 0x109, 0x3, 0x109, 0x3, 0x109, 0x3, 
       0x109, 0x3, 0x109, 0x3, 0x109, 0x3, 0x109, 0x3, 0x109, 0x3, 0x109, 
       0x3, 0x109, 0x3, 0x109, 0x5, 0x109, 0x1134, 0xa, 0x109, 0x3, 0x109, 
       0x3, 0x109, 0x5, 0x109, 0x1138, 0xa, 0x109, 0x3, 0x109, 0x3, 0x109, 
       0x5, 0x109, 0x113c, 0xa, 0x109, 0x3, 0x10a, 0x3, 0x10a, 0x3, 0x10a, 
       0x7, 0x10a, 0x1141, 0xa, 0x10a, 0xc, 0x10a, 0xe, 0x10a, 0x1144, 0xb, 
       0x10a, 0x3, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x5, 0x10b, 0x1149, 0xa, 
       0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x5, 0x10b, 
       0x114f, 0xa, 0x10b, 0x5, 0x10b, 0x1151, 0xa, 0x10b, 0x3, 0x10b, 0x3, 
       0x10b, 0x5, 0x10b, 0x1155, 0xa, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x3, 
       0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 
       0x3, 0x10b, 0x5, 0x10b, 0x1160, 0xa, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 
       0x3, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x3, 
       0x10b, 0x5, 0x10b, 0x116a, 0xa, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x3, 
       0x10b, 0x5, 0x10b, 0x116f, 0xa, 0x10b, 0x3, 0x10c, 0x3, 0x10c, 0x3, 
       0x10c, 0x5, 0x10c, 0x1174, 0xa, 0x10c, 0x3, 0x10c, 0x3, 0x10c, 0x3, 
       0x10c, 0x5, 0x10c, 0x1179, 0xa, 0x10c, 0x3, 0x10c, 0x5, 0x10c, 0x117c, 
       0xa, 0x10c, 0x3, 0x10d, 0x3, 0x10d, 0x5, 0x10d, 0x1180, 0xa, 0x10d, 
       0x3, 0x10d, 0x7, 0x10d, 0x1183, 0xa, 0x10d, 0xc, 0x10d, 0xe, 0x10d, 
       0x1186, 0xb, 0x10d, 0x3, 0x10e, 0x3, 0x10e, 0x3, 0x10e, 0x3, 0x10e, 
       0x3, 0x10e, 0x3, 0x10e, 0x5, 0x10e, 0x118e, 0xa, 0x10e, 0x3, 0x10f, 
       0x3, 0x10f, 0x3, 0x10f, 0x3, 0x10f, 0x3, 0x10f, 0x3, 0x10f, 0x3, 
       0x10f, 0x3, 0x10f, 0x3, 0x10f, 0x3, 0x10f, 0x5, 0x10f, 0x119a, 0xa, 
       0x10f, 0x3, 0x110, 0x3, 0x110, 0x3, 0x110, 0x3, 0x110, 0x3, 0x110, 
       0x3, 0x110, 0x3, 0x110, 0x3, 0x110, 0x3, 0x110, 0x3, 0x110, 0x3, 
       0x110, 0x3, 0x110, 0x5, 0x110, 0x11a8, 0xa, 0x110, 0x3, 0x110, 0x3, 
       0x110, 0x3, 0x110, 0x3, 0x110, 0x3, 0x110, 0x3, 0x110, 0x3, 0x110, 
       0x5, 0x110, 0x11b1, 0xa, 0x110, 0x5, 0x110, 0x11b3, 0xa, 0x110, 0x3, 
       0x111, 0x3, 0x111, 0x3, 0x111, 0x7, 0x111, 0x11b8, 0xa, 0x111, 0xc, 
       0x111, 0xe, 0x111, 0x11bb, 0xb, 0x111, 0x3, 0x112, 0x3, 0x112, 0x3, 
       0x112, 0x5, 0x112, 0x11c0, 0xa, 0x112, 0x3, 0x113, 0x3, 0x113, 0x5, 
       0x113, 0x11c4, 0xa, 0x113, 0x3, 0x113, 0x3, 0x113, 0x3, 0x113, 0x3, 
       0x113, 0x3, 0x113, 0x3, 0x113, 0x7, 0x113, 0x11cc, 0xa, 0x113, 0xc, 
       0x113, 0xe, 0x113, 0x11cf, 0xb, 0x113, 0x3, 0x113, 0x3, 0x113, 0x3, 
       0x113, 0x3, 0x113, 0x5, 0x113, 0x11d5, 0xa, 0x113, 0x3, 0x113, 0x3, 
       0x113, 0x5, 0x113, 0x11d9, 0xa, 0x113, 0x3, 0x113, 0x3, 0x113, 0x3, 
       0x113, 0x3, 0x113, 0x5, 0x113, 0x11df, 0xa, 0x113, 0x3, 0x113, 0x3, 
       0x113, 0x5, 0x113, 0x11e3, 0xa, 0x113, 0x3, 0x113, 0x3, 0x113, 0x3, 
       0x113, 0x7, 0x113, 0x11e8, 0xa, 0x113, 0xc, 0x113, 0xe, 0x113, 0x11eb, 
       0xb, 0x113, 0x5, 0x113, 0x11ed, 0xa, 0x113, 0x3, 0x114, 0x3, 0x114, 
       0x3, 0x114, 0x3, 0x114, 0x3, 0x114, 0x3, 0x114, 0x3, 0x114, 0x5, 
       0x114, 0x11f6, 0xa, 0x114, 0x3, 0x114, 0x3, 0x114, 0x3, 0x114, 0x3, 
       0x114, 0x5, 0x114, 0x11fc, 0xa, 0x114, 0x3, 0x115, 0x3, 0x115, 0x3, 
       0x115, 0x5, 0x115, 0x1201, 0xa, 0x115, 0x3, 0x116, 0x3, 0x116, 0x3, 
       0x117, 0x3, 0x117, 0x3, 0x117, 0x3, 0x117, 0x3, 0x117, 0x3, 0x117, 
       0x3, 0x117, 0x3, 0x117, 0x3, 0x117, 0x3, 0x117, 0x3, 0x117, 0x3, 
       0x117, 0x3, 0x117, 0x3, 0x117, 0x3, 0x117, 0x3, 0x117, 0x3, 0x117, 
       0x7, 0x117, 0x1216, 0xa, 0x117, 0xc, 0x117, 0xe, 0x117, 0x1219, 0xb, 
       0x117, 0x5, 0x117, 0x121b, 0xa, 0x117, 0x3, 0x118, 0x3, 0x118, 0x5, 
       0x118, 0x121f, 0xa, 0x118, 0x3, 0x118, 0x3, 0x118, 0x3, 0x118, 0x3, 
       0x118, 0x3, 0x118, 0x5, 0x118, 0x1226, 0xa, 0x118, 0x5, 0x118, 0x1228, 
       0xa, 0x118, 0x3, 0x118, 0x5, 0x118, 0x122b, 0xa, 0x118, 0x3, 0x118, 
       0x3, 0x118, 0x3, 0x118, 0x5, 0x118, 0x1230, 0xa, 0x118, 0x5, 0x118, 
       0x1232, 0xa, 0x118, 0x3, 0x119, 0x3, 0x119, 0x3, 0x119, 0x3, 0x119, 
       0x3, 0x119, 0x3, 0x119, 0x3, 0x119, 0x3, 0x119, 0x3, 0x119, 0x3, 
       0x119, 0x3, 0x119, 0x3, 0x119, 0x3, 0x119, 0x3, 0x119, 0x3, 0x119, 
       0x3, 0x119, 0x3, 0x119, 0x3, 0x119, 0x3, 0x119, 0x5, 0x119, 0x1247, 
       0xa, 0x119, 0x3, 0x119, 0x3, 0x119, 0x5, 0x119, 0x124b, 0xa, 0x119, 
       0x5, 0x119, 0x124d, 0xa, 0x119, 0x3, 0x11a, 0x3, 0x11a, 0x5, 0x11a, 
       0x1251, 0xa, 0x11a, 0x3, 0x11a, 0x3, 0x11a, 0x3, 0x11b, 0x3, 0x11b, 
       0x3, 0x11b, 0x3, 0x11b, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 
       0x11c, 0x5, 0x11c, 0x125d, 0xa, 0x11c, 0x3, 0x11d, 0x3, 0x11d, 0x3, 
       0x11d, 0x7, 0x11d, 0x1262, 0xa, 0x11d, 0xc, 0x11d, 0xe, 0x11d, 0x1265, 
       0xb, 0x11d, 0x3, 0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x3, 
       0x11e, 0x3, 0x11e, 0x5, 0x11e, 0x126d, 0xa, 0x11e, 0x3, 0x11f, 0x3, 
       0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x1274, 0xa, 
       0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x1277, 0xa, 0x11f, 0x3, 0x11f, 0x3, 
       0x11f, 0x5, 0x11f, 0x127b, 0xa, 0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x127e, 
       0xa, 0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x1281, 0xa, 0x11f, 0x3, 0x11f, 
       0x3, 0x11f, 0x5, 0x11f, 0x1285, 0xa, 0x11f, 0x3, 0x11f, 0x5, 0x11f, 
       0x1288, 0xa, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x128c, 0xa, 
       0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x128f, 0xa, 0x11f, 0x3, 0x11f, 0x3, 
       0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x1294, 0xa, 0x11f, 0x3, 0x11f, 0x5, 
       0x11f, 0x1297, 0xa, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x5, 
       0x11f, 0x129c, 0xa, 0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x129f, 0xa, 0x11f, 
       0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x5, 
       0x11f, 0x12a6, 0xa, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x12aa, 
       0xa, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x5, 
       0x11f, 0x12b0, 0xa, 0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x12b3, 0xa, 0x11f, 
       0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 
       0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x12bc, 0xa, 0x11f, 0x5, 0x11f, 0x12be, 
       0xa, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x5, 
       0x11f, 0x12c4, 0xa, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x12c8, 
       0xa, 0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x12cb, 0xa, 0x11f, 0x3, 0x11f, 
       0x5, 0x11f, 0x12ce, 0xa, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x5, 0x11f, 
       0x12d2, 0xa, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 
       0x5, 0x11f, 0x12d8, 0xa, 0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x12db, 0xa, 
       0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x12de, 0xa, 0x11f, 0x3, 0x11f, 0x3, 
       0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 
       0x3, 0x11f, 0x5, 0x11f, 0x12e8, 0xa, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 
       0x5, 0x11f, 0x12ec, 0xa, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 
       0x3, 0x11f, 0x3, 0x11f, 0x7, 0x11f, 0x12f3, 0xa, 0x11f, 0xc, 0x11f, 
       0xe, 0x11f, 0x12f6, 0xb, 0x11f, 0x5, 0x11f, 0x12f8, 0xa, 0x11f, 0x3, 
       0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x12fd, 0xa, 0x11f, 0x3, 
       0x11f, 0x5, 0x11f, 0x1300, 0xa, 0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x1303, 
       0xa, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x1307, 0xa, 0x11f, 
       0x3, 0x11f, 0x5, 0x11f, 0x130a, 0xa, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 
       0x3, 0x11f, 0x5, 0x11f, 0x130f, 0xa, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 
       0x5, 0x11f, 0x1313, 0xa, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 
       0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x131b, 0xa, 0x11f, 
       0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 
       0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 
       0x3, 0x11f, 0x5, 0x11f, 0x1329, 0xa, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 
       0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 
       0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 
       0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x133b, 0xa, 0x11f, 
       0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x1340, 0xa, 0x11f, 
       0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x1345, 0xa, 0x11f, 
       0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 
       0x11f, 0x5, 0x11f, 0x134d, 0xa, 0x11f, 0x3, 0x120, 0x3, 0x120, 0x3, 
       0x120, 0x3, 0x120, 0x5, 0x120, 0x1353, 0xa, 0x120, 0x5, 0x120, 0x1355, 
       0xa, 0x120, 0x3, 0x121, 0x3, 0x121, 0x5, 0x121, 0x1359, 0xa, 0x121, 
       0x3, 0x121, 0x5, 0x121, 0x135c, 0xa, 0x121, 0x3, 0x122, 0x3, 0x122, 
       0x3, 0x123, 0x3, 0x123, 0x3, 0x123, 0x3, 0x124, 0x3, 0x124, 0x3, 
       0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x5, 0x124, 
       0x136a, 0xa, 0x124, 0x3, 0x125, 0x3, 0x125, 0x3, 0x125, 0x3, 0x125, 
       0x3, 0x125, 0x3, 0x125, 0x3, 0x125, 0x3, 0x125, 0x5, 0x125, 0x1374, 
       0xa, 0x125, 0x3, 0x125, 0x3, 0x125, 0x5, 0x125, 0x1378, 0xa, 0x125, 
       0x3, 0x125, 0x3, 0x125, 0x3, 0x125, 0x3, 0x125, 0x7, 0x125, 0x137e, 
       0xa, 0x125, 0xc, 0x125, 0xe, 0x125, 0x1381, 0xb, 0x125, 0x5, 0x125, 
       0x1383, 0xa, 0x125, 0x3, 0x125, 0x3, 0x125, 0x5, 0x125, 0x1387, 0xa, 
       0x125, 0x3, 0x125, 0x3, 0x125, 0x3, 0x125, 0x3, 0x125, 0x3, 0x125, 
       0x3, 0x125, 0x3, 0x125, 0x3, 0x125, 0x5, 0x125, 0x1391, 0xa, 0x125, 
       0x3, 0x126, 0x3, 0x126, 0x5, 0x126, 0x1395, 0xa, 0x126, 0x3, 0x127, 
       0x3, 0x127, 0x3, 0x127, 0x7, 0x127, 0x139a, 0xa, 0x127, 0xc, 0x127, 
       0xe, 0x127, 0x139d, 0xb, 0x127, 0x3, 0x128, 0x3, 0x128, 0x5, 0x128, 
       0x13a1, 0xa, 0x128, 0x3, 0x129, 0x3, 0x129, 0x3, 0x129, 0x3, 0x129, 
       0x3, 0x129, 0x3, 0x129, 0x5, 0x129, 0x13a9, 0xa, 0x129, 0x3, 0x12a, 
       0x3, 0x12a, 0x3, 0x12a, 0x5, 0x12a, 0x13ae, 0xa, 0x12a, 0x3, 0x12a, 
       0x3, 0x12a, 0x3, 0x12b, 0x3, 0x12b, 0x5, 0x12b, 0x13b4, 0xa, 0x12b, 
       0x3, 0x12c, 0x3, 0x12c, 0x3, 0x12c, 0x7, 0x12c, 0x13b9, 0xa, 0x12c, 
       0xc, 0x12c, 0xe, 0x12c, 0x13bc, 0xb, 0x12c, 0x3, 0x12d, 0x3, 0x12d, 
       0x5, 0x12d, 0x13c0, 0xa, 0x12d, 0x3, 0x12d, 0x3, 0x12d, 0x3, 0x12d, 
       0x3, 0x12d, 0x5, 0x12d, 0x13c6, 0xa, 0x12d, 0x3, 0x12d, 0x3, 0x12d, 
       0x3, 0x12d, 0x3, 0x12d, 0x3, 0x12d, 0x5, 0x12d, 0x13cd, 0xa, 0x12d, 
       0x3, 0x12e, 0x3, 0x12e, 0x3, 0x12f, 0x3, 0x12f, 0x3, 0x12f, 0x3, 
       0x12f, 0x3, 0x12f, 0x3, 0x12f, 0x5, 0x12f, 0x13d7, 0xa, 0x12f, 0x5, 
       0x12f, 0x13d9, 0xa, 0x12f, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 
       0x130, 0x3, 0x130, 0x3, 0x130, 0x5, 0x130, 0x13e1, 0xa, 0x130, 0x3, 
       0x131, 0x3, 0x131, 0x3, 0x131, 0x5, 0x131, 0x13e6, 0xa, 0x131, 0x3, 
       0x131, 0x3, 0x131, 0x5, 0x131, 0x13ea, 0xa, 0x131, 0x3, 0x131, 0x5, 
       0x131, 0x13ed, 0xa, 0x131, 0x3, 0x132, 0x3, 0x132, 0x3, 0x132, 0x7, 
       0x132, 0x13f2, 0xa, 0x132, 0xc, 0x132, 0xe, 0x132, 0x13f5, 0xb, 0x132, 
       0x3, 0x133, 0x3, 0x133, 0x5, 0x133, 0x13f9, 0xa, 0x133, 0x3, 0x133, 
       0x3, 0x133, 0x5, 0x133, 0x13fd, 0xa, 0x133, 0x3, 0x134, 0x3, 0x134, 
       0x3, 0x134, 0x3, 0x134, 0x3, 0x134, 0x3, 0x134, 0x3, 0x135, 0x3, 
       0x135, 0x3, 0x135, 0x3, 0x135, 0x5, 0x135, 0x1409, 0xa, 0x135, 0x3, 
       0x136, 0x3, 0x136, 0x3, 0x136, 0x3, 0x136, 0x3, 0x136, 0x3, 0x136, 
       0x5, 0x136, 0x1411, 0xa, 0x136, 0x3, 0x136, 0x3, 0x136, 0x5, 0x136, 
       0x1415, 0xa, 0x136, 0x3, 0x136, 0x5, 0x136, 0x1418, 0xa, 0x136, 0x3, 
       0x136, 0x5, 0x136, 0x141b, 0xa, 0x136, 0x3, 0x137, 0x3, 0x137, 0x5, 
       0x137, 0x141f, 0xa, 0x137, 0x3, 0x137, 0x3, 0x137, 0x5, 0x137, 0x1423, 
       0xa, 0x137, 0x3, 0x137, 0x7, 0x137, 0x1426, 0xa, 0x137, 0xc, 0x137, 
       0xe, 0x137, 0x1429, 0xb, 0x137, 0x3, 0x138, 0x3, 0x138, 0x3, 0x138, 
       0x5, 0x138, 0x142e, 0xa, 0x138, 0x3, 0x139, 0x3, 0x139, 0x5, 0x139, 
       0x1432, 0xa, 0x139, 0x3, 0x139, 0x3, 0x139, 0x3, 0x13a, 0x3, 0x13a, 
       0x3, 0x13b, 0x3, 0x13b, 0x3, 0x13b, 0x3, 0x13b, 0x3, 0x13b, 0x5, 
       0x13b, 0x143d, 0xa, 0x13b, 0x3, 0x13b, 0x5, 0x13b, 0x1440, 0xa, 0x13b, 
       0x3, 0x13b, 0x5, 0x13b, 0x1443, 0xa, 0x13b, 0x3, 0x13b, 0x5, 0x13b, 
       0x1446, 0xa, 0x13b, 0x3, 0x13c, 0x3, 0x13c, 0x3, 0x13c, 0x3, 0x13c, 
       0x3, 0x13c, 0x3, 0x13c, 0x5, 0x13c, 0x144e, 0xa, 0x13c, 0x3, 0x13d, 
       0x3, 0x13d, 0x5, 0x13d, 0x1452, 0xa, 0x13d, 0x3, 0x13d, 0x7, 0x13d, 
       0x1455, 0xa, 0x13d, 0xc, 0x13d, 0xe, 0x13d, 0x1458, 0xb, 0x13d, 0x3, 
       0x13e, 0x3, 0x13e, 0x3, 0x13e, 0x3, 0x13e, 0x3, 0x13e, 0x5, 0x13e, 
       0x145f, 0xa, 0x13e, 0x3, 0x13f, 0x3, 0x13f, 0x3, 0x13f, 0x3, 0x13f, 
       0x3, 0x13f, 0x3, 0x13f, 0x5, 0x13f, 0x1467, 0xa, 0x13f, 0x3, 0x140, 
       0x3, 0x140, 0x3, 0x140, 0x3, 0x140, 0x5, 0x140, 0x146d, 0xa, 0x140, 
       0x3, 0x141, 0x3, 0x141, 0x3, 0x141, 0x3, 0x141, 0x3, 0x141, 0x3, 
       0x141, 0x3, 0x141, 0x3, 0x141, 0x3, 0x141, 0x5, 0x141, 0x1478, 0xa, 
       0x141, 0x3, 0x141, 0x3, 0x141, 0x3, 0x142, 0x3, 0x142, 0x3, 0x142, 
       0x3, 0x142, 0x3, 0x142, 0x3, 0x142, 0x5, 0x142, 0x1482, 0xa, 0x142, 
       0x3, 0x142, 0x3, 0x142, 0x3, 0x142, 0x3, 0x142, 0x5, 0x142, 0x1488, 
       0xa, 0x142, 0x3, 0x143, 0x3, 0x143, 0x3, 0x143, 0x3, 0x144, 0x3, 
       0x144, 0x3, 0x144, 0x3, 0x145, 0x3, 0x145, 0x3, 0x146, 0x3, 0x146, 
       0x3, 0x146, 0x3, 0x146, 0x5, 0x146, 0x1496, 0xa, 0x146, 0x3, 0x146, 
       0x5, 0x146, 0x1499, 0xa, 0x146, 0x3, 0x146, 0x3, 0x146, 0x5, 0x146, 
       0x149d, 0xa, 0x146, 0x3, 0x146, 0x3, 0x146, 0x3, 0x146, 0x3, 0x146, 
       0x3, 0x146, 0x3, 0x146, 0x3, 0x146, 0x3, 0x146, 0x3, 0x146, 0x7, 
       0x146, 0x14a8, 0xa, 0x146, 0xc, 0x146, 0xe, 0x146, 0x14ab, 0xb, 0x146, 
       0x3, 0x147, 0x3, 0x147, 0x3, 0x147, 0x3, 0x147, 0x3, 0x147, 0x3, 
       0x147, 0x5, 0x147, 0x14b3, 0xa, 0x147, 0x3, 0x147, 0x3, 0x147, 0x3, 
       0x147, 0x3, 0x147, 0x3, 0x147, 0x3, 0x147, 0x3, 0x147, 0x3, 0x147, 
       0x3, 0x147, 0x3, 0x147, 0x7, 0x147, 0x14bf, 0xa, 0x147, 0xc, 0x147, 
       0xe, 0x147, 0x14c2, 0xb, 0x147, 0x3, 0x148, 0x3, 0x148, 0x3, 0x149, 
       0x3, 0x149, 0x5, 0x149, 0x14c8, 0xa, 0x149, 0x3, 0x149, 0x3, 0x149, 
       0x3, 0x149, 0x3, 0x149, 0x5, 0x149, 0x14ce, 0xa, 0x149, 0x3, 0x14a, 
       0x3, 0x14a, 0x3, 0x14a, 0x3, 0x14a, 0x3, 0x14a, 0x3, 0x14a, 0x5, 
       0x14a, 0x14d6, 0xa, 0x14a, 0x3, 0x14a, 0x3, 0x14a, 0x3, 0x14a, 0x3, 
       0x14a, 0x3, 0x14a, 0x3, 0x14a, 0x3, 0x14a, 0x3, 0x14a, 0x3, 0x14a, 
       0x5, 0x14a, 0x14e1, 0xa, 0x14a, 0x3, 0x14a, 0x3, 0x14a, 0x5, 0x14a, 
       0x14e5, 0xa, 0x14a, 0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 
       0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x3, 
       0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 
       0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x3, 
       0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 
       0x3, 0x14b, 0x7, 0x14b, 0x1502, 0xa, 0x14b, 0xc, 0x14b, 0xe, 0x14b, 
       0x1505, 0xb, 0x14b, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 
       0x5, 0x14c, 0x150b, 0xa, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 
       0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 
       0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 
       0x3, 0x14c, 0x5, 0x14c, 0x151c, 0xa, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 
       0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x5, 0x14c, 0x1523, 0xa, 0x14c, 
       0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 
       0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 
       0x3, 0x14c, 0x5, 0x14c, 0x1531, 0xa, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 
       0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 
       0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 
       0x5, 0x14c, 0x1540, 0xa, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 
       0x6, 0x14c, 0x1545, 0xa, 0x14c, 0xd, 0x14c, 0xe, 0x14c, 0x1546, 0x3, 
       0x14c, 0x5, 0x14c, 0x154a, 0xa, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 
       0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 
       0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 
       0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 
       0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 
       0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 
       0x3, 0x14c, 0x3, 0x14c, 0x5, 0x14c, 0x156c, 0xa, 0x14c, 0x3, 0x14c, 
       0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x7, 
       0x14c, 0x1574, 0xa, 0x14c, 0xc, 0x14c, 0xe, 0x14c, 0x1577, 0xb, 0x14c, 
       0x3, 0x14d, 0x3, 0x14d, 0x3, 0x14d, 0x3, 0x14d, 0x3, 0x14d, 0x3, 
       0x14d, 0x5, 0x14d, 0x157f, 0xa, 0x14d, 0x3, 0x14e, 0x3, 0x14e, 0x3, 
       0x14e, 0x5, 0x14e, 0x1584, 0xa, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 
       0x14e, 0x3, 0x14e, 0x5, 0x14e, 0x158a, 0xa, 0x14e, 0x3, 0x14e, 0x3, 
       0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x5, 0x14e, 
       0x1592, 0xa, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 
       0x3, 0x14e, 0x5, 0x14e, 0x1599, 0xa, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 
       0x3, 0x14e, 0x3, 0x14e, 0x5, 0x14e, 0x159f, 0xa, 0x14e, 0x3, 0x14e, 
       0x3, 0x14e, 0x3, 0x14e, 0x5, 0x14e, 0x15a4, 0xa, 0x14e, 0x3, 0x14e, 
       0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x5, 0x14e, 0x15aa, 0xa, 0x14e, 
       0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x5, 0x14e, 0x15af, 0xa, 0x14e, 
       0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x5, 0x14e, 0x15b4, 0xa, 0x14e, 
       0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x5, 0x14e, 0x15ba, 
       0xa, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x5, 0x14e, 0x15bf, 
       0xa, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x5, 
       0x14e, 0x15c5, 0xa, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 
       0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x5, 0x14e, 0x15cd, 0xa, 0x14e, 0x3, 
       0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 
       0x5, 0x14e, 0x15d5, 0xa, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 
       0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x5, 0x14e, 0x15dd, 0xa, 0x14e, 
       0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 
       0x14e, 0x5, 0x14e, 0x15e5, 0xa, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 
       0x14e, 0x5, 0x14e, 0x15ea, 0xa, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 
       0x14e, 0x3, 0x14e, 0x5, 0x14e, 0x15f0, 0xa, 0x14e, 0x3, 0x14e, 0x3, 
       0x14e, 0x3, 0x14e, 0x5, 0x14e, 0x15f5, 0xa, 0x14e, 0x3, 0x14e, 0x3, 
       0x14e, 0x5, 0x14e, 0x15f9, 0xa, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x5, 
       0x14e, 0x15fd, 0xa, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x5, 
       0x14e, 0x1602, 0xa, 0x14e, 0x5, 0x14e, 0x1604, 0xa, 0x14e, 0x3, 0x14f, 
       0x3, 0x14f, 0x3, 0x14f, 0x3, 0x14f, 0x3, 0x14f, 0x3, 0x150, 0x3, 
       0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 
       0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 
       0x150, 0x3, 0x150, 0x5, 0x150, 0x1619, 0xa, 0x150, 0x3, 0x150, 0x3, 
       0x150, 0x5, 0x150, 0x161d, 0xa, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 
       0x150, 0x3, 0x150, 0x3, 0x150, 0x5, 0x150, 0x1624, 0xa, 0x150, 0x3, 
       0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 
       0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x5, 0x150, 0x1630, 
       0xa, 0x150, 0x3, 0x150, 0x5, 0x150, 0x1633, 0xa, 0x150, 0x3, 0x150, 
       0x3, 0x150, 0x5, 0x150, 0x1637, 0xa, 0x150, 0x3, 0x151, 0x3, 0x151, 
       0x3, 0x151, 0x5, 0x151, 0x163c, 0xa, 0x151, 0x3, 0x152, 0x3, 0x152, 
       0x3, 0x152, 0x5, 0x152, 0x1641, 0xa, 0x152, 0x3, 0x152, 0x3, 0x152, 
       0x5, 0x152, 0x1645, 0xa, 0x152, 0x3, 0x153, 0x3, 0x153, 0x3, 0x153, 
       0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x5, 
       0x154, 0x164f, 0xa, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 
       0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x5, 0x154, 0x1658, 0xa, 
       0x154, 0x5, 0x154, 0x165a, 0xa, 0x154, 0x3, 0x155, 0x5, 0x155, 0x165d, 
       0xa, 0x155, 0x3, 0x155, 0x3, 0x155, 0x3, 0x156, 0x3, 0x156, 0x3, 
       0x156, 0x3, 0x156, 0x3, 0x156, 0x5, 0x156, 0x1666, 0xa, 0x156, 0x3, 
       0x157, 0x3, 0x157, 0x3, 0x157, 0x7, 0x157, 0x166b, 0xa, 0x157, 0xc, 
       0x157, 0xe, 0x157, 0x166e, 0xb, 0x157, 0x3, 0x158, 0x3, 0x158, 0x3, 
       0x158, 0x3, 0x158, 0x3, 0x158, 0x3, 0x158, 0x3, 0x158, 0x3, 0x158, 
       0x3, 0x158, 0x3, 0x158, 0x5, 0x158, 0x167a, 0xa, 0x158, 0x3, 0x158, 
       0x3, 0x158, 0x3, 0x158, 0x5, 0x158, 0x167f, 0xa, 0x158, 0x3, 0x159, 
       0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x5, 0x159, 0x1686, 
       0xa, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x5, 
       0x159, 0x168c, 0xa, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x3, 0x159, 0x3, 0x159, 0x6, 0x159, 0x16a4, 0xa, 0x159, 0xd, 0x159, 
       0xe, 0x159, 0x16a5, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x5, 0x159, 0x16c5, 0xa, 0x159, 
       0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x5, 0x159, 0x16d9, 0xa, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x3, 0x159, 0x5, 0x159, 0x16df, 0xa, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x5, 0x159, 0x16e3, 0xa, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x5, 0x159, 0x16fe, 0xa, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x5, 0x159, 0x170a, 0xa, 0x159, 
       0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x5, 0x159, 0x1717, 0xa, 0x159, 0x3, 0x159, 0x3, 0x159, 0x5, 0x159, 
       0x171b, 0xa, 0x159, 0x3, 0x159, 0x3, 0x159, 0x5, 0x159, 0x171f, 0xa, 
       0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x5, 0x159, 
       0x173b, 0xa, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x5, 0x159, 0x1773, 0xa, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x3, 0x159, 0x5, 0x159, 0x177e, 0xa, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x5, 0x159, 0x1782, 0xa, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x5, 0x159, 0x178e, 0xa, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x5, 0x159, 0x1793, 0xa, 0x159, 0x3, 0x15a, 0x3, 
       0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 
       0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x5, 0x15a, 0x17a0, 
       0xa, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x3, 
       0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 
       0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x3, 
       0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x5, 0x15a, 0x17b4, 0xa, 0x15a, 0x3, 
       0x15b, 0x3, 0x15b, 0x5, 0x15b, 0x17b8, 0xa, 0x15b, 0x3, 0x15b, 0x3, 
       0x15b, 0x3, 0x15c, 0x3, 0x15c, 0x3, 0x15c, 0x3, 0x15d, 0x3, 0x15d, 
       0x3, 0x15d, 0x3, 0x15d, 0x3, 0x15d, 0x3, 0x15d, 0x3, 0x15d, 0x3, 
       0x15d, 0x7, 0x15d, 0x17c7, 0xa, 0x15d, 0xc, 0x15d, 0xe, 0x15d, 0x17ca, 
       0xb, 0x15d, 0x5, 0x15d, 0x17cc, 0xa, 0x15d, 0x3, 0x15e, 0x3, 0x15e, 
       0x3, 0x15e, 0x5, 0x15e, 0x17d1, 0xa, 0x15e, 0x3, 0x15e, 0x5, 0x15e, 
       0x17d4, 0xa, 0x15e, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x160, 0x3, 0x160, 
       0x3, 0x160, 0x3, 0x160, 0x3, 0x160, 0x5, 0x160, 0x17dd, 0xa, 0x160, 
       0x3, 0x160, 0x3, 0x160, 0x5, 0x160, 0x17e1, 0xa, 0x160, 0x3, 0x160, 
       0x3, 0x160, 0x3, 0x160, 0x3, 0x160, 0x5, 0x160, 0x17e7, 0xa, 0x160, 
       0x3, 0x160, 0x3, 0x160, 0x3, 0x160, 0x3, 0x160, 0x5, 0x160, 0x17ed, 
       0xa, 0x160, 0x3, 0x160, 0x3, 0x160, 0x5, 0x160, 0x17f1, 0xa, 0x160, 
       0x3, 0x160, 0x3, 0x160, 0x3, 0x161, 0x3, 0x161, 0x3, 0x161, 0x3, 
       0x161, 0x3, 0x161, 0x3, 0x161, 0x3, 0x161, 0x5, 0x161, 0x17fc, 0xa, 
       0x161, 0x3, 0x161, 0x3, 0x161, 0x3, 0x161, 0x3, 0x161, 0x5, 0x161, 
       0x1802, 0xa, 0x161, 0x5, 0x161, 0x1804, 0xa, 0x161, 0x3, 0x161, 0x3, 
       0x161, 0x3, 0x162, 0x3, 0x162, 0x3, 0x162, 0x5, 0x162, 0x180b, 0xa, 
       0x162, 0x3, 0x162, 0x3, 0x162, 0x3, 0x162, 0x3, 0x162, 0x3, 0x162, 
       0x5, 0x162, 0x1812, 0xa, 0x162, 0x3, 0x162, 0x3, 0x162, 0x5, 0x162, 
       0x1816, 0xa, 0x162, 0x3, 0x163, 0x3, 0x163, 0x3, 0x163, 0x7, 0x163, 
       0x181b, 0xa, 0x163, 0xc, 0x163, 0xe, 0x163, 0x181e, 0xb, 0x163, 0x3, 
       0x164, 0x3, 0x164, 0x5, 0x164, 0x1822, 0xa, 0x164, 0x3, 0x165, 0x3, 
       0x165, 0x3, 0x165, 0x5, 0x165, 0x1827, 0xa, 0x165, 0x3, 0x165, 0x5, 
       0x165, 0x182a, 0xa, 0x165, 0x3, 0x166, 0x3, 0x166, 0x3, 0x166, 0x5, 
       0x166, 0x182f, 0xa, 0x166, 0x3, 0x167, 0x3, 0x167, 0x5, 0x167, 0x1833, 
       0xa, 0x167, 0x3, 0x167, 0x3, 0x167, 0x5, 0x167, 0x1837, 0xa, 0x167, 
       0x3, 0x168, 0x3, 0x168, 0x5, 0x168, 0x183b, 0xa, 0x168, 0x3, 0x168, 
       0x3, 0x168, 0x5, 0x168, 0x183f, 0xa, 0x168, 0x3, 0x169, 0x3, 0x169, 
       0x3, 0x169, 0x3, 0x16a, 0x3, 0x16a, 0x3, 0x16a, 0x3, 0x16b, 0x3, 
       0x16b, 0x3, 0x16b, 0x3, 0x16c, 0x3, 0x16c, 0x5, 0x16c, 0x184c, 0xa, 
       0x16c, 0x3, 0x16c, 0x3, 0x16c, 0x5, 0x16c, 0x1850, 0xa, 0x16c, 0x3, 
       0x16c, 0x5, 0x16c, 0x1853, 0xa, 0x16c, 0x3, 0x16c, 0x3, 0x16c, 0x5, 
       0x16c, 0x1857, 0xa, 0x16c, 0x3, 0x16c, 0x3, 0x16c, 0x5, 0x16c, 0x185b, 
       0xa, 0x16c, 0x3, 0x16c, 0x3, 0x16c, 0x5, 0x16c, 0x185f, 0xa, 0x16c, 
       0x3, 0x16c, 0x3, 0x16c, 0x3, 0x16c, 0x5, 0x16c, 0x1864, 0xa, 0x16c, 
       0x3, 0x16c, 0x3, 0x16c, 0x5, 0x16c, 0x1868, 0xa, 0x16c, 0x3, 0x16c, 
       0x3, 0x16c, 0x5, 0x16c, 0x186c, 0xa, 0x16c, 0x3, 0x16c, 0x3, 0x16c, 
       0x5, 0x16c, 0x1870, 0xa, 0x16c, 0x3, 0x16d, 0x3, 0x16d, 0x3, 0x16d, 
       0x7, 0x16d, 0x1875, 0xa, 0x16d, 0xc, 0x16d, 0xe, 0x16d, 0x1878, 0xb, 
       0x16d, 0x3, 0x16e, 0x3, 0x16e, 0x3, 0x16e, 0x5, 0x16e, 0x187d, 0xa, 
       0x16e, 0x3, 0x16f, 0x3, 0x16f, 0x3, 0x170, 0x3, 0x170, 0x3, 0x171, 
       0x3, 0x171, 0x5, 0x171, 0x1885, 0xa, 0x171, 0x3, 0x172, 0x3, 0x172, 
       0x3, 0x173, 0x3, 0x173, 0x3, 0x173, 0x3, 0x173, 0x3, 0x174, 0x3, 
       0x174, 0x3, 0x174, 0x3, 0x174, 0x3, 0x175, 0x3, 0x175, 0x3, 0x175, 
       0x7, 0x175, 0x1894, 0xa, 0x175, 0xc, 0x175, 0xe, 0x175, 0x1897, 0xb, 
       0x175, 0x3, 0x176, 0x3, 0x176, 0x5, 0x176, 0x189b, 0xa, 0x176, 0x3, 
       0x177, 0x3, 0x177, 0x3, 0x177, 0x7, 0x177, 0x18a0, 0xa, 0x177, 0xc, 
       0x177, 0xe, 0x177, 0x18a3, 0xb, 0x177, 0x3, 0x178, 0x3, 0x178, 0x3, 
       0x179, 0x3, 0x179, 0x3, 0x179, 0x3, 0x179, 0x3, 0x179, 0x3, 0x17a, 
       0x3, 0x17a, 0x3, 0x17a, 0x3, 0x17a, 0x3, 0x17a, 0x3, 0x17a, 0x3, 
       0x17a, 0x3, 0x17a, 0x3, 0x17a, 0x3, 0x17a, 0x3, 0x17a, 0x3, 0x17a, 
       0x3, 0x17a, 0x5, 0x17a, 0x18b9, 0xa, 0x17a, 0x3, 0x17b, 0x3, 0x17b, 
       0x3, 0x17b, 0x3, 0x17c, 0x3, 0x17c, 0x3, 0x17c, 0x3, 0x17c, 0x3, 
       0x17c, 0x3, 0x17d, 0x3, 0x17d, 0x3, 0x17d, 0x3, 0x17d, 0x3, 0x17d, 
       0x3, 0x17d, 0x5, 0x17d, 0x18c9, 0xa, 0x17d, 0x3, 0x17e, 0x3, 0x17e, 
       0x3, 0x17e, 0x3, 0x17f, 0x3, 0x17f, 0x3, 0x17f, 0x6, 0x17f, 0x18d1, 
       0xa, 0x17f, 0xd, 0x17f, 0xe, 0x17f, 0x18d2, 0x3, 0x180, 0x3, 0x180, 
       0x5, 0x180, 0x18d7, 0xa, 0x180, 0x3, 0x180, 0x3, 0x180, 0x3, 0x180, 
       0x6, 0x180, 0x18dc, 0xa, 0x180, 0xd, 0x180, 0xe, 0x180, 0x18dd, 0x3, 
       0x180, 0x5, 0x180, 0x18e1, 0xa, 0x180, 0x3, 0x180, 0x3, 0x180, 0x3, 
       0x180, 0x3, 0x181, 0x3, 0x181, 0x3, 0x181, 0x3, 0x182, 0x3, 0x182, 
       0x3, 0x182, 0x5, 0x182, 0x18ec, 0xa, 0x182, 0x3, 0x183, 0x3, 0x183, 
       0x3, 0x184, 0x3, 0x184, 0x3, 0x184, 0x3, 0x185, 0x3, 0x185, 0x5, 
       0x185, 0x18f5, 0xa, 0x185, 0x3, 0x185, 0x5, 0x185, 0x18f8, 0xa, 0x185, 
       0x3, 0x185, 0x3, 0x185, 0x3, 0x186, 0x3, 0x186, 0x3, 0x186, 0x5, 
       0x186, 0x18ff, 0xa, 0x186, 0x3, 0x187, 0x3, 0x187, 0x3, 0x187, 0x5, 
       0x187, 0x1904, 0xa, 0x187, 0x3, 0x188, 0x3, 0x188, 0x3, 0x188, 0x3, 
       0x188, 0x3, 0x188, 0x3, 0x189, 0x3, 0x189, 0x3, 0x189, 0x3, 0x189, 
       0x3, 0x189, 0x3, 0x189, 0x3, 0x189, 0x3, 0x18a, 0x3, 0x18a, 0x3, 
       0x18a, 0x3, 0x18a, 0x3, 0x18a, 0x3, 0x18a, 0x3, 0x18a, 0x3, 0x18b, 
       0x3, 0x18b, 0x3, 0x18b, 0x6, 0x18b, 0x191c, 0xa, 0x18b, 0xd, 0x18b, 
       0xe, 0x18b, 0x191d, 0x3, 0x18c, 0x3, 0x18c, 0x3, 0x18c, 0x3, 0x18c, 
       0x5, 0x18c, 0x1924, 0xa, 0x18c, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 
       0x3, 0x18d, 0x5, 0x18d, 0x192a, 0xa, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 
       0x5, 0x18d, 0x192e, 0xa, 0x18d, 0x3, 0x18e, 0x3, 0x18e, 0x3, 0x18e, 
       0x3, 0x18e, 0x3, 0x18e, 0x3, 0x18e, 0x3, 0x18f, 0x3, 0x18f, 0x5, 
       0x18f, 0x1938, 0xa, 0x18f, 0x3, 0x190, 0x3, 0x190, 0x5, 0x190, 0x193c, 
       0xa, 0x190, 0x3, 0x190, 0x3, 0x190, 0x3, 0x191, 0x3, 0x191, 0x3, 
       0x191, 0x3, 0x191, 0x3, 0x191, 0x3, 0x191, 0x3, 0x191, 0x7, 0x191, 
       0x1947, 0xa, 0x191, 0xc, 0x191, 0xe, 0x191, 0x194a, 0xb, 0x191, 0x3, 
       0x191, 0x3, 0x191, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 
       0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x5, 0x192, 0x1955, 0xa, 0x192, 
       0x3, 0x193, 0x3, 0x193, 0x3, 0x193, 0x3, 0x193, 0x3, 0x193, 0x3, 
       0x193, 0x3, 0x194, 0x3, 0x194, 0x3, 0x194, 0x3, 0x195, 0x3, 0x195, 
       0x3, 0x195, 0x3, 0x196, 0x3, 0x196, 0x3, 0x196, 0x3, 0x196, 0x5, 
       0x196, 0x1967, 0xa, 0x196, 0x3, 0x196, 0x3, 0x196, 0x3, 0x196, 0x3, 
       0x196, 0x7, 0x196, 0x196d, 0xa, 0x196, 0xc, 0x196, 0xe, 0x196, 0x1970, 
       0xb, 0x196, 0x3, 0x196, 0x3, 0x196, 0x3, 0x196, 0x3, 0x196, 0x3, 
       0x196, 0x7, 0x196, 0x1977, 0xa, 0x196, 0xc, 0x196, 0xe, 0x196, 0x197a, 
       0xb, 0x196, 0x5, 0x196, 0x197c, 0xa, 0x196, 0x3, 0x197, 0x3, 0x197, 
       0x3, 0x197, 0x5, 0x197, 0x1981, 0xa, 0x197, 0x3, 0x198, 0x3, 0x198, 
       0x5, 0x198, 0x1985, 0xa, 0x198, 0x3, 0x198, 0x3, 0x198, 0x3, 0x198, 
       0x3, 0x199, 0x3, 0x199, 0x5, 0x199, 0x198c, 0xa, 0x199, 0x3, 0x199, 
       0x3, 0x199, 0x3, 0x199, 0x5, 0x199, 0x1991, 0xa, 0x199, 0x3, 0x19a, 
       0x3, 0x19a, 0x3, 0x19b, 0x3, 0x19b, 0x3, 0x19b, 0x5, 0x19b, 0x1998, 
       0xa, 0x19b, 0x3, 0x19b, 0x3, 0x19b, 0x3, 0x19b, 0x3, 0x19b, 0x7, 
       0x19b, 0x199e, 0xa, 0x19b, 0xc, 0x19b, 0xe, 0x19b, 0x19a1, 0xb, 0x19b, 
       0x5, 0x19b, 0x19a3, 0xa, 0x19b, 0x3, 0x19c, 0x3, 0x19c, 0x3, 0x19c, 
       0x5, 0x19c, 0x19a8, 0xa, 0x19c, 0x3, 0x19c, 0x5, 0x19c, 0x19ab, 0xa, 
       0x19c, 0x3, 0x19c, 0x3, 0x19c, 0x3, 0x19c, 0x3, 0x19c, 0x7, 0x19c, 
       0x19b1, 0xa, 0x19c, 0xc, 0x19c, 0xe, 0x19c, 0x19b4, 0xb, 0x19c, 0x5, 
       0x19c, 0x19b6, 0xa, 0x19c, 0x3, 0x19d, 0x3, 0x19d, 0x3, 0x19d, 0x3, 
       0x19d, 0x3, 0x19e, 0x3, 0x19e, 0x3, 0x19e, 0x3, 0x19f, 0x3, 0x19f, 
       0x3, 0x19f, 0x3, 0x1a0, 0x3, 0x1a0, 0x5, 0x1a0, 0x19c4, 0xa, 0x1a0, 
       0x3, 0x1a0, 0x5, 0x1a0, 0x19c7, 0xa, 0x1a0, 0x3, 0x1a0, 0x3, 0x1a0, 
       0x3, 0x1a0, 0x3, 0x1a0, 0x3, 0x1a1, 0x3, 0x1a1, 0x3, 0x1a1, 0x3, 
       0x1a1, 0x3, 0x1a1, 0x3, 0x1a1, 0x3, 0x1a1, 0x5, 0x1a1, 0x19d4, 0xa, 
       0x1a1, 0x3, 0x1a1, 0x3, 0x1a1, 0x5, 0x1a1, 0x19d8, 0xa, 0x1a1, 0x5, 
       0x1a1, 0x19da, 0xa, 0x1a1, 0x3, 0x1a2, 0x3, 0x1a2, 0x3, 0x1a2, 0x5, 
       0x1a2, 0x19df, 0xa, 0x1a2, 0x3, 0x1a3, 0x3, 0x1a3, 0x5, 0x1a3, 0x19e3, 
       0xa, 0x1a3, 0x3, 0x1a4, 0x3, 0x1a4, 0x3, 0x1a4, 0x3, 0x1a5, 0x3, 
       0x1a5, 0x5, 0x1a5, 0x19ea, 0xa, 0x1a5, 0x3, 0x1a5, 0x3, 0x1a5, 0x7, 
       0x1a5, 0x19ee, 0xa, 0x1a5, 0xc, 0x1a5, 0xe, 0x1a5, 0x19f1, 0xb, 0x1a5, 
       0x3, 0x1a5, 0x3, 0x1a5, 0x5, 0x1a5, 0x19f5, 0xa, 0x1a5, 0x3, 0x1a5, 
       0x5, 0x1a5, 0x19f8, 0xa, 0x1a5, 0x3, 0x1a5, 0x3, 0x1a5, 0x7, 0x1a5, 
       0x19fc, 0xa, 0x1a5, 0xc, 0x1a5, 0xe, 0x1a5, 0x19ff, 0xb, 0x1a5, 0x3, 
       0x1a5, 0x3, 0x1a5, 0x5, 0x1a5, 0x1a03, 0xa, 0x1a5, 0x3, 0x1a5, 0x5, 
       0x1a5, 0x1a06, 0xa, 0x1a5, 0x3, 0x1a5, 0x3, 0x1a5, 0x7, 0x1a5, 0x1a0a, 
       0xa, 0x1a5, 0xc, 0x1a5, 0xe, 0x1a5, 0x1a0d, 0xb, 0x1a5, 0x3, 0x1a5, 
       0x3, 0x1a5, 0x5, 0x1a5, 0x1a11, 0xa, 0x1a5, 0x5, 0x1a5, 0x1a13, 0xa, 
       0x1a5, 0x3, 0x1a5, 0x3, 0x1a5, 0x3, 0x1a5, 0x3, 0x1a5, 0x5, 0x1a5, 
       0x1a19, 0xa, 0x1a5, 0x5, 0x1a5, 0x1a1b, 0xa, 0x1a5, 0x3, 0x1a5, 0x5, 
       0x1a5, 0x1a1e, 0xa, 0x1a5, 0x3, 0x1a5, 0x3, 0x1a5, 0x7, 0x1a5, 0x1a22, 
       0xa, 0x1a5, 0xc, 0x1a5, 0xe, 0x1a5, 0x1a25, 0xb, 0x1a5, 0x3, 0x1a5, 
       0x3, 0x1a5, 0x3, 0x1a5, 0x5, 0x1a5, 0x1a2a, 0xa, 0x1a5, 0x3, 0x1a5, 
       0x3, 0x1a5, 0x3, 0x1a5, 0x3, 0x1a5, 0x5, 0x1a5, 0x1a30, 0xa, 0x1a5, 
       0x5, 0x1a5, 0x1a32, 0xa, 0x1a5, 0x3, 0x1a6, 0x3, 0x1a6, 0x7, 0x1a6, 
       0x1a36, 0xa, 0x1a6, 0xc, 0x1a6, 0xe, 0x1a6, 0x1a39, 0xb, 0x1a6, 0x3, 
       0x1a6, 0x3, 0x1a6, 0x5, 0x1a6, 0x1a3d, 0xa, 0x1a6, 0x3, 0x1a6, 0x3, 
       0x1a6, 0x5, 0x1a6, 0x1a41, 0xa, 0x1a6, 0x3, 0x1a6, 0x3, 0x1a6, 0x3, 
       0x1a6, 0x5, 0x1a6, 0x1a46, 0xa, 0x1a6, 0x3, 0x1a6, 0x3, 0x1a6, 0x7, 
       0x1a6, 0x1a4a, 0xa, 0x1a6, 0xc, 0x1a6, 0xe, 0x1a6, 0x1a4d, 0xb, 0x1a6, 
       0x3, 0x1a6, 0x3, 0x1a6, 0x7, 0x1a6, 0x1a51, 0xa, 0x1a6, 0xc, 0x1a6, 
       0xe, 0x1a6, 0x1a54, 0xb, 0x1a6, 0x5, 0x1a6, 0x1a56, 0xa, 0x1a6, 0x5, 
       0x1a6, 0x1a58, 0xa, 0x1a6, 0x3, 0x1a7, 0x5, 0x1a7, 0x1a5b, 0xa, 0x1a7, 
       0x3, 0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 0x3, 
       0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 0x5, 0x1a7, 0x1a65, 0xa, 0x1a7, 0x3, 
       0x1a7, 0x3, 0x1a7, 0x5, 0x1a7, 0x1a69, 0xa, 0x1a7, 0x3, 0x1a7, 0x3, 
       0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 0x5, 0x1a7, 0x1a6f, 0xa, 0x1a7, 0x3, 
       0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 
       0x5, 0x1a7, 0x1a77, 0xa, 0x1a7, 0x3, 0x1a7, 0x5, 0x1a7, 0x1a7a, 0xa, 
       0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 
       0x3, 0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 0x3, 
       0x1a7, 0x5, 0x1a7, 0x1a87, 0xa, 0x1a7, 0x3, 0x1a8, 0x3, 0x1a8, 0x5, 
       0x1a8, 0x1a8b, 0xa, 0x1a8, 0x3, 0x1a8, 0x3, 0x1a8, 0x3, 0x1a8, 0x5, 
       0x1a8, 0x1a90, 0xa, 0x1a8, 0x3, 0x1a8, 0x3, 0x1a8, 0x5, 0x1a8, 0x1a94, 
       0xa, 0x1a8, 0x3, 0x1a8, 0x5, 0x1a8, 0x1a97, 0xa, 0x1a8, 0x3, 0x1a9, 
       0x3, 0x1a9, 0x3, 0x1a9, 0x5, 0x1a9, 0x1a9c, 0xa, 0x1a9, 0x3, 0x1a9, 
       0x3, 0x1a9, 0x5, 0x1a9, 0x1aa0, 0xa, 0x1a9, 0x3, 0x1a9, 0x3, 0x1a9, 
       0x3, 0x1a9, 0x3, 0x1a9, 0x3, 0x1a9, 0x3, 0x1a9, 0x5, 0x1a9, 0x1aa8, 
       0xa, 0x1a9, 0x3, 0x1a9, 0x3, 0x1a9, 0x3, 0x1a9, 0x3, 0x1a9, 0x3, 
       0x1a9, 0x3, 0x1a9, 0x5, 0x1a9, 0x1ab0, 0xa, 0x1a9, 0x5, 0x1a9, 0x1ab2, 
       0xa, 0x1a9, 0x3, 0x1aa, 0x3, 0x1aa, 0x3, 0x1aa, 0x3, 0x1aa, 0x3, 
       0x1aa, 0x5, 0x1aa, 0x1ab9, 0xa, 0x1aa, 0x3, 0x1ab, 0x3, 0x1ab, 0x3, 
       0x1ab, 0x3, 0x1ab, 0x7, 0x1ab, 0x1abf, 0xa, 0x1ab, 0xc, 0x1ab, 0xe, 
       0x1ab, 0x1ac2, 0xb, 0x1ab, 0x3, 0x1ab, 0x3, 0x1ab, 0x3, 0x1ac, 0x3, 
       0x1ac, 0x5, 0x1ac, 0x1ac8, 0xa, 0x1ac, 0x3, 0x1ac, 0x5, 0x1ac, 0x1acb, 
       0xa, 0x1ac, 0x3, 0x1ad, 0x3, 0x1ad, 0x3, 0x1ad, 0x3, 0x1ad, 0x7, 
       0x1ad, 0x1ad1, 0xa, 0x1ad, 0xc, 0x1ad, 0xe, 0x1ad, 0x1ad4, 0xb, 0x1ad, 
       0x3, 0x1ad, 0x3, 0x1ad, 0x3, 0x1ae, 0x3, 0x1ae, 0x3, 0x1ae, 0x5, 
       0x1ae, 0x1adb, 0xa, 0x1ae, 0x5, 0x1ae, 0x1add, 0xa, 0x1ae, 0x3, 0x1af, 
       0x3, 0x1af, 0x3, 0x1af, 0x3, 0x1af, 0x5, 0x1af, 0x1ae3, 0xa, 0x1af, 
       0x3, 0x1b0, 0x3, 0x1b0, 0x3, 0x1b1, 0x3, 0x1b1, 0x5, 0x1b1, 0x1ae9, 
       0xa, 0x1b1, 0x3, 0x1b2, 0x3, 0x1b2, 0x5, 0x1b2, 0x1aed, 0xa, 0x1b2, 
       0x3, 0x1b2, 0x3, 0x1b2, 0x3, 0x1b2, 0x3, 0x1b2, 0x3, 0x1b2, 0x3, 
       0x1b2, 0x5, 0x1b2, 0x1af5, 0xa, 0x1b2, 0x3, 0x1b3, 0x3, 0x1b3, 0x3, 
       0x1b4, 0x3, 0x1b4, 0x3, 0x1b4, 0x3, 0x1b5, 0x3, 0x1b5, 0x3, 0x1b5, 
       0x3, 0x1b5, 0x5, 0x1b5, 0x1b00, 0xa, 0x1b5, 0x3, 0x1b6, 0x3, 0x1b6, 
       0x3, 0x1b7, 0x3, 0x1b7, 0x3, 0x1b7, 0x3, 0x1b8, 0x3, 0x1b8, 0x5, 
       0x1b8, 0x1b09, 0xa, 0x1b8, 0x3, 0x1b8, 0x5, 0x1b8, 0x1b0c, 0xa, 0x1b8, 
       0x3, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x5, 0x1b8, 0x1b11, 0xa, 0x1b8, 
       0x5, 0x1b8, 0x1b13, 0xa, 0x1b8, 0x3, 0x1b8, 0x5, 0x1b8, 0x1b16, 0xa, 
       0x1b8, 0x3, 0x1b8, 0x5, 0x1b8, 0x1b19, 0xa, 0x1b8, 0x3, 0x1b8, 0x3, 
       0x1b8, 0x5, 0x1b8, 0x1b1d, 0xa, 0x1b8, 0x3, 0x1b8, 0x5, 0x1b8, 0x1b20, 
       0xa, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x5, 0x1b8, 0x1b24, 0xa, 0x1b8, 
       0x3, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x5, 0x1b8, 0x1b29, 0xa, 0x1b8, 
       0x3, 0x1b8, 0x5, 0x1b8, 0x1b2c, 0xa, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 
       0x5, 0x1b8, 0x1b30, 0xa, 0x1b8, 0x3, 0x1b8, 0x5, 0x1b8, 0x1b33, 0xa, 
       0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x5, 0x1b8, 0x1b37, 0xa, 0x1b8, 0x3, 
       0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x5, 0x1b8, 0x1b3c, 0xa, 0x1b8, 0x3, 
       0x1b8, 0x3, 0x1b8, 0x5, 0x1b8, 0x1b40, 0xa, 0x1b8, 0x3, 0x1b8, 0x3, 
       0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 
       0x3, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x5, 0x1b8, 0x1b4c, 0xa, 0x1b8, 
       0x3, 0x1b8, 0x3, 0x1b8, 0x5, 0x1b8, 0x1b50, 0xa, 0x1b8, 0x3, 0x1b8, 
       0x3, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x5, 0x1b8, 0x1b56, 0xa, 0x1b8, 
       0x3, 0x1b8, 0x5, 0x1b8, 0x1b59, 0xa, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 
       0x3, 0x1b8, 0x5, 0x1b8, 0x1b5e, 0xa, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 
       0x5, 0x1b8, 0x1b62, 0xa, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x5, 0x1b8, 
       0x1b66, 0xa, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x5, 0x1b8, 
       0x1b6b, 0xa, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 
       0x3, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x5, 0x1b8, 0x1b74, 0xa, 0x1b8, 
       0x3, 0x1b8, 0x5, 0x1b8, 0x1b77, 0xa, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 
       0x5, 0x1b8, 0x1b7b, 0xa, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x5, 0x1b8, 
       0x1b7f, 0xa, 0x1b8, 0x3, 0x1b8, 0x5, 0x1b8, 0x1b82, 0xa, 0x1b8, 0x3, 
       0x1b8, 0x3, 0x1b8, 0x5, 0x1b8, 0x1b86, 0xa, 0x1b8, 0x3, 0x1b8, 0x3, 
       0x1b8, 0x5, 0x1b8, 0x1b8a, 0xa, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x3, 
       0x1b8, 0x5, 0x1b8, 0x1b8f, 0xa, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x3, 
       0x1b8, 0x5, 0x1b8, 0x1b94, 0xa, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x3, 
       0x1b8, 0x3, 0x1b8, 0x5, 0x1b8, 0x1b9a, 0xa, 0x1b8, 0x3, 0x1b9, 0x3, 
       0x1b9, 0x3, 0x1b9, 0x5, 0x1b9, 0x1b9f, 0xa, 0x1b9, 0x3, 0x1ba, 0x3, 
       0x1ba, 0x3, 0x1ba, 0x5, 0x1ba, 0x1ba4, 0xa, 0x1ba, 0x3, 0x1bb, 0x3, 
       0x1bb, 0x3, 0x1bb, 0x3, 0x1bb, 0x3, 0x1bb, 0x3, 0x1bb, 0x3, 0x1bb, 
       0x3, 0x1bb, 0x3, 0x1bb, 0x3, 0x1bb, 0x5, 0x1bb, 0x1bb0, 0xa, 0x1bb, 
       0x3, 0x1bc, 0x3, 0x1bc, 0x3, 0x1bc, 0x5, 0x1bc, 0x1bb5, 0xa, 0x1bc, 
       0x3, 0x1bc, 0x3, 0x1bc, 0x3, 0x1bd, 0x6, 0x1bd, 0x1bba, 0xa, 0x1bd, 
       0xd, 0x1bd, 0xe, 0x1bd, 0x1bbb, 0x3, 0x1be, 0x3, 0x1be, 0x3, 0x1be, 
       0x3, 0x1be, 0x3, 0x1be, 0x3, 0x1be, 0x5, 0x1be, 0x1bc4, 0xa, 0x1be, 
       0x3, 0x1be, 0x3, 0x1be, 0x3, 0x1be, 0x3, 0x1be, 0x5, 0x1be, 0x1bca, 
       0xa, 0x1be, 0x5, 0x1be, 0x1bcc, 0xa, 0x1be, 0x3, 0x1bf, 0x3, 0x1bf, 
       0x5, 0x1bf, 0x1bd0, 0xa, 0x1bf, 0x3, 0x1bf, 0x3, 0x1bf, 0x5, 0x1bf, 
       0x1bd4, 0xa, 0x1bf, 0x3, 0x1c0, 0x3, 0x1c0, 0x5, 0x1c0, 0x1bd8, 0xa, 
       0x1c0, 0x3, 0x1c0, 0x3, 0x1c0, 0x5, 0x1c0, 0x1bdc, 0xa, 0x1c0, 0x3, 
       0x1c1, 0x3, 0x1c1, 0x3, 0x1c1, 0x3, 0x1c1, 0x3, 0x1c2, 0x3, 0x1c2, 
       0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c3, 0x3, 0x1c3, 0x3, 
       0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 0x1beb, 0xa, 0x1c3, 0x3, 0x1c4, 0x3, 
       0x1c4, 0x3, 0x1c4, 0x5, 0x1c4, 0x1bf0, 0xa, 0x1c4, 0x3, 0x1c5, 0x3, 
       0x1c5, 0x5, 0x1c5, 0x1bf4, 0xa, 0x1c5, 0x3, 0x1c5, 0x7, 0x1c5, 0x1bf7, 
       0xa, 0x1c5, 0xc, 0x1c5, 0xe, 0x1c5, 0x1bfa, 0xb, 0x1c5, 0x3, 0x1c6, 
       0x6, 0x1c6, 0x1bfd, 0xa, 0x1c6, 0xd, 0x1c6, 0xe, 0x1c6, 0x1bfe, 0x3, 
       0x1c7, 0x3, 0x1c7, 0x5, 0x1c7, 0x1c03, 0xa, 0x1c7, 0x3, 0x1c7, 0x3, 
       0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x5, 0x1c7, 0x1c09, 0xa, 0x1c7, 0x3, 
       0x1c7, 0x3, 0x1c7, 0x5, 0x1c7, 0x1c0d, 0xa, 0x1c7, 0x3, 0x1c7, 0x3, 
       0x1c7, 0x5, 0x1c7, 0x1c11, 0xa, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 
       0x1c7, 0x5, 0x1c7, 0x1c16, 0xa, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 
       0x1c7, 0x5, 0x1c7, 0x1c1b, 0xa, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 
       0x1c7, 0x5, 0x1c7, 0x1c20, 0xa, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 
       0x1c7, 0x5, 0x1c7, 0x1c25, 0xa, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 
       0x1c7, 0x3, 0x1c7, 0x5, 0x1c7, 0x1c2b, 0xa, 0x1c7, 0x3, 0x1c7, 0x3, 
       0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x5, 0x1c7, 0x1c31, 0xa, 0x1c7, 0x3, 
       0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x5, 0x1c7, 0x1c36, 0xa, 0x1c7, 0x3, 
       0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x5, 0x1c7, 0x1c3b, 0xa, 0x1c7, 0x3, 
       0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x5, 0x1c7, 0x1c41, 0xa, 
       0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x5, 0x1c7, 0x1c46, 0xa, 
       0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x5, 0x1c7, 0x1c4b, 0xa, 
       0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x5, 0x1c7, 0x1c50, 0xa, 
       0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x5, 0x1c7, 0x1c55, 0xa, 
       0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 
       0x3, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x5, 0x1c7, 0x1c5f, 0xa, 0x1c7, 
       0x3, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x5, 0x1c7, 0x1c65, 
       0xa, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x5, 
       0x1c7, 0x1c6b, 0xa, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 
       0x1c7, 0x5, 0x1c7, 0x1c71, 0xa, 0x1c7, 0x3, 0x1c7, 0x5, 0x1c7, 0x1c74, 
       0xa, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 
       0x1c7, 0x5, 0x1c7, 0x1c7b, 0xa, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 
       0x1c7, 0x5, 0x1c7, 0x1c80, 0xa, 0x1c7, 0x3, 0x1c7, 0x5, 0x1c7, 0x1c83, 
       0xa, 0x1c7, 0x3, 0x1c8, 0x3, 0x1c8, 0x5, 0x1c8, 0x1c87, 0xa, 0x1c8, 
       0x3, 0x1c9, 0x5, 0x1c9, 0x1c8a, 0xa, 0x1c9, 0x3, 0x1c9, 0x3, 0x1c9, 
       0x5, 0x1c9, 0x1c8e, 0xa, 0x1c9, 0x3, 0x1c9, 0x3, 0x1c9, 0x3, 0x1ca, 
       0x5, 0x1ca, 0x1c93, 0xa, 0x1ca, 0x3, 0x1ca, 0x3, 0x1ca, 0x5, 0x1ca, 
       0x1c97, 0xa, 0x1ca, 0x3, 0x1ca, 0x3, 0x1ca, 0x3, 0x1cb, 0x5, 0x1cb, 
       0x1c9c, 0xa, 0x1cb, 0x3, 0x1cb, 0x3, 0x1cb, 0x5, 0x1cb, 0x1ca0, 0xa, 
       0x1cb, 0x3, 0x1cb, 0x3, 0x1cb, 0x3, 0x1cc, 0x3, 0x1cc, 0x3, 0x1cc, 
       0x3, 0x1cc, 0x3, 0x1cc, 0x5, 0x1cc, 0x1ca9, 0xa, 0x1cc, 0x3, 0x1cc, 
       0x5, 0x1cc, 0x1cac, 0xa, 0x1cc, 0x3, 0x1cc, 0x5, 0x1cc, 0x1caf, 0xa, 
       0x1cc, 0x3, 0x1cd, 0x5, 0x1cd, 0x1cb2, 0xa, 0x1cd, 0x3, 0x1cd, 0x3, 
       0x1cd, 0x5, 0x1cd, 0x1cb6, 0xa, 0x1cd, 0x3, 0x1cd, 0x3, 0x1cd, 0x5, 
       0x1cd, 0x1cba, 0xa, 0x1cd, 0x3, 0x1cd, 0x3, 0x1cd, 0x5, 0x1cd, 0x1cbe, 
       0xa, 0x1cd, 0x3, 0x1cd, 0x3, 0x1cd, 0x3, 0x1cd, 0x3, 0x1cd, 0x3, 
       0x1cd, 0x3, 0x1cd, 0x3, 0x1cd, 0x3, 0x1cd, 0x3, 0x1cd, 0x3, 0x1cd, 
       0x3, 0x1cd, 0x3, 0x1cd, 0x3, 0x1cd, 0x5, 0x1cd, 0x1ccd, 0xa, 0x1cd, 
       0x3, 0x1cd, 0x5, 0x1cd, 0x1cd0, 0xa, 0x1cd, 0x5, 0x1cd, 0x1cd2, 0xa, 
       0x1cd, 0x3, 0x1ce, 0x3, 0x1ce, 0x3, 0x1ce, 0x5, 0x1ce, 0x1cd7, 0xa, 
       0x1ce, 0x3, 0x1ce, 0x3, 0x1ce, 0x3, 0x1ce, 0x3, 0x1ce, 0x3, 0x1ce, 
       0x3, 0x1ce, 0x3, 0x1ce, 0x5, 0x1ce, 0x1ce0, 0xa, 0x1ce, 0x3, 0x1ce, 
       0x5, 0x1ce, 0x1ce3, 0xa, 0x1ce, 0x3, 0x1ce, 0x3, 0x1ce, 0x5, 0x1ce, 
       0x1ce7, 0xa, 0x1ce, 0x3, 0x1cf, 0x3, 0x1cf, 0x3, 0x1cf, 0x3, 0x1cf, 
       0x3, 0x1cf, 0x3, 0x1d0, 0x3, 0x1d0, 0x3, 0x1d0, 0x3, 0x1d0, 0x7, 
       0x1d0, 0x1cf2, 0xa, 0x1d0, 0xc, 0x1d0, 0xe, 0x1d0, 0x1cf5, 0xb, 0x1d0, 
       0x3, 0x1d0, 0x3, 0x1d0, 0x3, 0x1d1, 0x3, 0x1d1, 0x3, 0x1d1, 0x3, 
       0x1d1, 0x3, 0x1d1, 0x3, 0x1d1, 0x3, 0x1d1, 0x5, 0x1d1, 0x1d00, 0xa, 
       0x1d1, 0x3, 0x1d1, 0x3, 0x1d1, 0x3, 0x1d1, 0x5, 0x1d1, 0x1d05, 0xa, 
       0x1d1, 0x3, 0x1d1, 0x7, 0x1d1, 0x1d08, 0xa, 0x1d1, 0xc, 0x1d1, 0xe, 
       0x1d1, 0x1d0b, 0xb, 0x1d1, 0x3, 0x1d1, 0x3, 0x1d1, 0x3, 0x1d1, 0x3, 
       0x1d1, 0x7, 0x1d1, 0x1d11, 0xa, 0x1d1, 0xc, 0x1d1, 0xe, 0x1d1, 0x1d14, 
       0xb, 0x1d1, 0x3, 0x1d1, 0x3, 0x1d1, 0x5, 0x1d1, 0x1d18, 0xa, 0x1d1, 
       0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x7, 
       0x1d2, 0x1d1f, 0xa, 0x1d2, 0xc, 0x1d2, 0xe, 0x1d2, 0x1d22, 0xb, 0x1d2, 
       0x3, 0x1d2, 0x3, 0x1d2, 0x5, 0x1d2, 0x1d26, 0xa, 0x1d2, 0x3, 0x1d3, 
       0x3, 0x1d3, 0x5, 0x1d3, 0x1d2a, 0xa, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 
       0x5, 0x1d3, 0x1d2e, 0xa, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x5, 0x1d3, 
       0x1d32, 0xa, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x5, 0x1d3, 
       0x1d37, 0xa, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x5, 0x1d3, 
       0x1d3c, 0xa, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 
       0x5, 0x1d3, 0x1d42, 0xa, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 
       0x5, 0x1d3, 0x1d47, 0xa, 0x1d3, 0x3, 0x1d3, 0x5, 0x1d3, 0x1d4a, 0xa, 
       0x1d3, 0x3, 0x1d4, 0x3, 0x1d4, 0x3, 0x1d4, 0x7, 0x1d4, 0x1d4f, 0xa, 
       0x1d4, 0xc, 0x1d4, 0xe, 0x1d4, 0x1d52, 0xb, 0x1d4, 0x3, 0x1d5, 0x3, 
       0x1d5, 0x3, 0x1d5, 0x3, 0x1d5, 0x7, 0x1d5, 0x1d58, 0xa, 0x1d5, 0xc, 
       0x1d5, 0xe, 0x1d5, 0x1d5b, 0xb, 0x1d5, 0x3, 0x1d5, 0x3, 0x1d5, 0x3, 
       0x1d6, 0x3, 0x1d6, 0x5, 0x1d6, 0x1d61, 0xa, 0x1d6, 0x3, 0x1d7, 0x3, 
       0x1d7, 0x3, 0x1d7, 0x3, 0x1d7, 0x3, 0x1d8, 0x3, 0x1d8, 0x3, 0x1d8, 
       0x3, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 0x3, 0x1da, 0x5, 
       0x1da, 0x1d6f, 0xa, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1db, 0x3, 
       0x1db, 0x3, 0x1db, 0x3, 0x1dc, 0x3, 0x1dc, 0x3, 0x1dc, 0x3, 0x1dd, 
       0x3, 0x1dd, 0x5, 0x1dd, 0x1d7b, 0xa, 0x1dd, 0x3, 0x1de, 0x3, 0x1de, 
       0x3, 0x1de, 0x3, 0x1de, 0x3, 0x1de, 0x3, 0x1de, 0x3, 0x1df, 0x3, 
       0x1df, 0x3, 0x1df, 0x7, 0x1df, 0x1d86, 0xa, 0x1df, 0xc, 0x1df, 0xe, 
       0x1df, 0x1d89, 0xb, 0x1df, 0x3, 0x1e0, 0x3, 0x1e0, 0x3, 0x1e0, 0x7, 
       0x1e0, 0x1d8e, 0xa, 0x1e0, 0xc, 0x1e0, 0xe, 0x1e0, 0x1d91, 0xb, 0x1e0, 
       0x3, 0x1e1, 0x3, 0x1e1, 0x3, 0x1e1, 0x3, 0x1e1, 0x5, 0x1e1, 0x1d97, 
       0xa, 0x1e1, 0x3, 0x1e2, 0x3, 0x1e2, 0x3, 0x1e2, 0x3, 0x1e3, 0x3, 
       0x1e3, 0x6, 0x1e3, 0x1d9e, 0xa, 0x1e3, 0xd, 0x1e3, 0xe, 0x1e3, 0x1d9f, 
       0x3, 0x1e4, 0x3, 0x1e4, 0x3, 0x1e4, 0x3, 0x1e4, 0x5, 0x1e4, 0x1da6, 
       0xa, 0x1e4, 0x3, 0x1e4, 0x3, 0x1e4, 0x3, 0x1e4, 0x3, 0x1e4, 0x3, 
       0x1e4, 0x3, 0x1e4, 0x5, 0x1e4, 0x1dae, 0xa, 0x1e4, 0x3, 0x1e5, 0x3, 
       0x1e5, 0x6, 0x1e5, 0x1db2, 0xa, 0x1e5, 0xd, 0x1e5, 0xe, 0x1e5, 0x1db3, 
       0x3, 0x1e6, 0x3, 0x1e6, 0x3, 0x1e6, 0x3, 0x1e6, 0x3, 0x1e7, 0x3, 
       0x1e7, 0x3, 0x1e7, 0x7, 0x1e7, 0x1dbd, 0xa, 0x1e7, 0xc, 0x1e7, 0xe, 
       0x1e7, 0x1dc0, 0xb, 0x1e7, 0x3, 0x1e8, 0x3, 0x1e8, 0x3, 0x1e8, 0x7, 
       0x1e8, 0x1dc5, 0xa, 0x1e8, 0xc, 0x1e8, 0xe, 0x1e8, 0x1dc8, 0xb, 0x1e8, 
       0x3, 0x1e9, 0x3, 0x1e9, 0x3, 0x1e9, 0x7, 0x1e9, 0x1dcd, 0xa, 0x1e9, 
       0xc, 0x1e9, 0xe, 0x1e9, 0x1dd0, 0xb, 0x1e9, 0x3, 0x1ea, 0x3, 0x1ea, 
       0x3, 0x1ea, 0x3, 0x1ea, 0x3, 0x1ea, 0x5, 0x1ea, 0x1dd7, 0xa, 0x1ea, 
       0x3, 0x1ea, 0x3, 0x1ea, 0x3, 0x1ea, 0x3, 0x1ea, 0x3, 0x1ea, 0x3, 
       0x1ea, 0x3, 0x1ea, 0x3, 0x1ea, 0x3, 0x1ea, 0x5, 0x1ea, 0x1de2, 0xa, 
       0x1ea, 0x5, 0x1ea, 0x1de4, 0xa, 0x1ea, 0x5, 0x1ea, 0x1de6, 0xa, 0x1ea, 
       0x5, 0x1ea, 0x1de8, 0xa, 0x1ea, 0x3, 0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 
       0x3, 0x1eb, 0x5, 0x1eb, 0x1dee, 0xa, 0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 
       0x3, 0x1eb, 0x3, 0x1eb, 0x5, 0x1eb, 0x1df4, 0xa, 0x1eb, 0x3, 0x1eb, 
       0x5, 0x1eb, 0x1df7, 0xa, 0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 
       0x3, 0x1eb, 0x3, 0x1eb, 0x5, 0x1eb, 0x1dfe, 0xa, 0x1eb, 0x5, 0x1eb, 
       0x1e00, 0xa, 0x1eb, 0x5, 0x1eb, 0x1e02, 0xa, 0x1eb, 0x3, 0x1eb, 0x5, 
       0x1eb, 0x1e05, 0xa, 0x1eb, 0x3, 0x1ec, 0x3, 0x1ec, 0x3, 0x1ec, 0x3, 
       0x1ec, 0x3, 0x1ed, 0x3, 0x1ed, 0x3, 0x1ed, 0x3, 0x1ed, 0x3, 0x1ee, 
       0x3, 0x1ee, 0x3, 0x1ee, 0x3, 0x1ef, 0x3, 0x1ef, 0x3, 0x1ef, 0x3, 
       0x1ef, 0x5, 0x1ef, 0x1e16, 0xa, 0x1ef, 0x3, 0x1ef, 0x3, 0x1ef, 0x5, 
       0x1ef, 0x1e1a, 0xa, 0x1ef, 0x5, 0x1ef, 0x1e1c, 0xa, 0x1ef, 0x3, 0x1f0, 
       0x3, 0x1f0, 0x3, 0x1f0, 0x3, 0x1f1, 0x3, 0x1f1, 0x5, 0x1f1, 0x1e23, 
       0xa, 0x1f1, 0x3, 0x1f2, 0x3, 0x1f2, 0x3, 0x1f2, 0x3, 0x1f3, 0x3, 
       0x1f3, 0x3, 0x1f4, 0x3, 0x1f4, 0x3, 0x1f4, 0x3, 0x1f4, 0x3, 0x1f5, 
       0x3, 0x1f5, 0x3, 0x1f5, 0x5, 0x1f5, 0x1e31, 0xa, 0x1f5, 0x5, 0x1f5, 
       0x1e33, 0xa, 0x1f5, 0x3, 0x1f6, 0x3, 0x1f6, 0x3, 0x1f6, 0x3, 0x1f6, 
       0x5, 0x1f6, 0x1e39, 0xa, 0x1f6, 0x3, 0x1f7, 0x3, 0x1f7, 0x3, 0x1f8, 
       0x3, 0x1f8, 0x3, 0x1f8, 0x3, 0x1f8, 0x7, 0x1f8, 0x1e41, 0xa, 0x1f8, 
       0xc, 0x1f8, 0xe, 0x1f8, 0x1e44, 0xb, 0x1f8, 0x3, 0x1f8, 0x3, 0x1f8, 
       0x3, 0x1f9, 0x3, 0x1f9, 0x3, 0x1fa, 0x3, 0x1fa, 0x5, 0x1fa, 0x1e4c, 
       0xa, 0x1fa, 0x3, 0x1fb, 0x3, 0x1fb, 0x3, 0x1fc, 0x3, 0x1fc, 0x3, 
       0x1fd, 0x3, 0x1fd, 0x3, 0x1fd, 0x3, 0x1fd, 0x3, 0x1fd, 0x5, 0x1fd, 
       0x1e57, 0xa, 0x1fd, 0x3, 0x1fd, 0x3, 0x1fd, 0x3, 0x1fe, 0x3, 0x1fe, 
       0x3, 0x1ff, 0x3, 0x1ff, 0x3, 0x200, 0x3, 0x200, 0x3, 0x201, 0x3, 
       0x201, 0x3, 0x202, 0x3, 0x202, 0x3, 0x203, 0x3, 0x203, 0x3, 0x204, 
       0x3, 0x204, 0x3, 0x205, 0x3, 0x205, 0x3, 0x206, 0x3, 0x206, 0x5, 
       0x206, 0x1e6d, 0xa, 0x206, 0x3, 0x207, 0x3, 0x207, 0x5, 0x207, 0x1e71, 
       0xa, 0x207, 0x3, 0x208, 0x3, 0x208, 0x3, 0x209, 0x3, 0x209, 0x3, 
       0x20a, 0x3, 0x20a, 0x3, 0x20b, 0x3, 0x20b, 0x3, 0x20c, 0x3, 0x20c, 
       0x3, 0x20d, 0x3, 0x20d, 0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20f, 0x3, 
       0x20f, 0x3, 0x210, 0x3, 0x210, 0x3, 0x211, 0x3, 0x211, 0x3, 0x212, 
       0x3, 0x212, 0x5, 0x212, 0x1e89, 0xa, 0x212, 0x3, 0x213, 0x3, 0x213, 
       0x3, 0x213, 0x3, 0x214, 0x3, 0x214, 0x3, 0x214, 0x3, 0x214, 0x3, 
       0x214, 0x3, 0x214, 0x5, 0x214, 0x1e94, 0xa, 0x214, 0x5, 0x214, 0x1e96, 
       0xa, 0x214, 0x3, 0x215, 0x3, 0x215, 0x5, 0x215, 0x1e9a, 0xa, 0x215, 
       0x3, 0x216, 0x3, 0x216, 0x3, 0x216, 0x7, 0x216, 0x1e9f, 0xa, 0x216, 
       0xc, 0x216, 0xe, 0x216, 0x1ea2, 0xb, 0x216, 0x3, 0x217, 0x3, 0x217, 
       0x3, 0x217, 0x7, 0x217, 0x1ea7, 0xa, 0x217, 0xc, 0x217, 0xe, 0x217, 
       0x1eaa, 0xb, 0x217, 0x3, 0x218, 0x3, 0x218, 0x3, 0x219, 0x3, 0x219, 
       0x5, 0x219, 0x1eb0, 0xa, 0x219, 0x3, 0x21a, 0x3, 0x21a, 0x3, 0x21b, 
       0x3, 0x21b, 0x5, 0x21b, 0x1eb6, 0xa, 0x21b, 0x3, 0x21c, 0x3, 0x21c, 
       0x3, 0x21d, 0x3, 0x21d, 0x3, 0x21e, 0x3, 0x21e, 0x3, 0x21f, 0x3, 
       0x21f, 0x3, 0x220, 0x3, 0x220, 0x3, 0x221, 0x3, 0x221, 0x3, 0x221, 
       0x5, 0x221, 0x1ec5, 0xa, 0x221, 0x3, 0x222, 0x3, 0x222, 0x5, 0x222, 
       0x1ec9, 0xa, 0x222, 0x3, 0x223, 0x3, 0x223, 0x3, 0x223, 0x7, 0x223, 
       0x1ece, 0xa, 0x223, 0xc, 0x223, 0xe, 0x223, 0x1ed1, 0xb, 0x223, 0x3, 
       0x224, 0x3, 0x224, 0x3, 0x224, 0x3, 0x224, 0x3, 0x225, 0x3, 0x225, 
       0x5, 0x225, 0x1ed9, 0xa, 0x225, 0x3, 0x226, 0x3, 0x226, 0x3, 0x226, 
       0x5, 0x226, 0x1ede, 0xa, 0x226, 0x5, 0x226, 0x1ee0, 0xa, 0x226, 0x3, 
       0x226, 0x3, 0x226, 0x3, 0x226, 0x3, 0x226, 0x5, 0x226, 0x1ee6, 0xa, 
       0x226, 0x3, 0x227, 0x3, 0x227, 0x3, 0x227, 0x3, 0x228, 0x3, 0x228, 
       0x3, 0x229, 0x3, 0x229, 0x3, 0x22a, 0x3, 0x22a, 0x3, 0x22b, 0x3, 
       0x22b, 0x3, 0x22c, 0x3, 0x22c, 0x3, 0x22c, 0x3, 0x22c, 0x3, 0x22c, 
       0x3, 0x22c, 0x5, 0x22c, 0x1ef9, 0xa, 0x22c, 0x3, 0x22c, 0x5, 0x22c, 
       0x1efc, 0xa, 0x22c, 0x3, 0x22d, 0x3, 0x22d, 0x3, 0x22d, 0x3, 0x22d, 
       0x3, 0x22d, 0x5, 0x22d, 0x1f03, 0xa, 0x22d, 0x3, 0x22e, 0x3, 0x22e, 
       0x3, 0x22e, 0x3, 0x22e, 0x7, 0x22e, 0x1f09, 0xa, 0x22e, 0xc, 0x22e, 
       0xe, 0x22e, 0x1f0c, 0xb, 0x22e, 0x3, 0x22e, 0x3, 0x22e, 0x3, 0x22f, 
       0x3, 0x22f, 0x3, 0x22f, 0x5, 0x22f, 0x1f13, 0xa, 0x22f, 0x3, 0x230, 
       0x3, 0x230, 0x3, 0x230, 0x5, 0x230, 0x1f18, 0xa, 0x230, 0x3, 0x231, 
       0x5, 0x231, 0x1f1b, 0xa, 0x231, 0x3, 0x231, 0x3, 0x231, 0x5, 0x231, 
       0x1f1f, 0xa, 0x231, 0x3, 0x231, 0x7, 0x231, 0x1f22, 0xa, 0x231, 0xc, 
       0x231, 0xe, 0x231, 0x1f25, 0xb, 0x231, 0x3, 0x232, 0x3, 0x232, 0x3, 
       0x233, 0x3, 0x233, 0x3, 0x233, 0x7, 0x233, 0x1f2c, 0xa, 0x233, 0xc, 
       0x233, 0xe, 0x233, 0x1f2f, 0xb, 0x233, 0x3, 0x234, 0x3, 0x234, 0x3, 
       0x235, 0x3, 0x235, 0x3, 0x236, 0x3, 0x236, 0x3, 0x237, 0x3, 0x237, 
       0x3, 0x237, 0x3, 0x237, 0x3, 0x237, 0x3, 0x237, 0x5, 0x237, 0x1f3d, 
       0xa, 0x237, 0x3, 0x238, 0x3, 0x238, 0x5, 0x238, 0x1f41, 0xa, 0x238, 
       0x3, 0x239, 0x3, 0x239, 0x3, 0x239, 0x3, 0x239, 0x3, 0x239, 0x3, 
       0x239, 0x3, 0x23a, 0x3, 0x23a, 0x5, 0x23a, 0x1f4b, 0xa, 0x23a, 0x3, 
       0x23b, 0x3, 0x23b, 0x5, 0x23b, 0x1f4f, 0xa, 0x23b, 0x3, 0x23c, 0x3, 
       0x23c, 0x5, 0x23c, 0x1f53, 0xa, 0x23c, 0x3, 0x23d, 0x3, 0x23d, 0x3, 
       0x23d, 0x3, 0x23e, 0x3, 0x23e, 0x3, 0x23f, 0x3, 0x23f, 0x3, 0x240, 
       0x3, 0x240, 0x3, 0x240, 0x3, 0x240, 0x3, 0x240, 0x3, 0x240, 0x5, 
       0x240, 0x1f62, 0xa, 0x240, 0x3, 0x241, 0x3, 0x241, 0x3, 0x241, 0x3, 
       0x241, 0x3, 0x241, 0x3, 0x241, 0x3, 0x241, 0x3, 0x241, 0x3, 0x241, 
       0x3, 0x241, 0x5, 0x241, 0x1f6e, 0xa, 0x241, 0x3, 0x242, 0x3, 0x242, 
       0x3, 0x242, 0x3, 0x242, 0x3, 0x242, 0x3, 0x242, 0x3, 0x242, 0x5, 
       0x242, 0x1f77, 0xa, 0x242, 0x3, 0x243, 0x3, 0x243, 0x3, 0x243, 0x3, 
       0x243, 0x3, 0x243, 0x3, 0x243, 0x3, 0x243, 0x3, 0x243, 0x3, 0x243, 
       0x3, 0x243, 0x5, 0x243, 0x1f83, 0xa, 0x243, 0x3, 0x244, 0x3, 0x244, 
       0x3, 0x244, 0x3, 0x244, 0x3, 0x244, 0x5, 0x244, 0x1f8a, 0xa, 0x244, 
       0x3, 0x245, 0x3, 0x245, 0x3, 0x245, 0x3, 0x245, 0x3, 0x245, 0x3, 
       0x245, 0x3, 0x245, 0x3, 0x245, 0x3, 0x245, 0x5, 0x245, 0x1f95, 0xa, 
       0x245, 0x3, 0x246, 0x3, 0x246, 0x5, 0x246, 0x1f99, 0xa, 0x246, 0x3, 
       0x246, 0x2, 0x7, 0x112, 0x28a, 0x28c, 0x294, 0x296, 0x247, 0x2, 0x4, 
       0x6, 0x8, 0xa, 0xc, 0xe, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 
       0x1e, 0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 
       0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e, 0x40, 0x42, 0x44, 0x46, 0x48, 
       0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e, 
       0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 
       0x76, 0x78, 0x7a, 0x7c, 0x7e, 0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 
       0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e, 0xa0, 
       0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 
       0xb8, 0xba, 0xbc, 0xbe, 0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 
       0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde, 0xe0, 0xe2, 
       0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 
       0xfa, 0xfc, 0xfe, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10a, 0x10c, 
       0x10e, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11a, 0x11c, 0x11e, 0x120, 
       0x122, 0x124, 0x126, 0x128, 0x12a, 0x12c, 0x12e, 0x130, 0x132, 0x134, 
       0x136, 0x138, 0x13a, 0x13c, 0x13e, 0x140, 0x142, 0x144, 0x146, 0x148, 
       0x14a, 0x14c, 0x14e, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15a, 0x15c, 
       0x15e, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16a, 0x16c, 0x16e, 0x170, 
       0x172, 0x174, 0x176, 0x178, 0x17a, 0x17c, 0x17e, 0x180, 0x182, 0x184, 
       0x186, 0x188, 0x18a, 0x18c, 0x18e, 0x190, 0x192, 0x194, 0x196, 0x198, 
       0x19a, 0x19c, 0x19e, 0x1a0, 0x1a2, 0x1a4, 0x1a6, 0x1a8, 0x1aa, 0x1ac, 
       0x1ae, 0x1b0, 0x1b2, 0x1b4, 0x1b6, 0x1b8, 0x1ba, 0x1bc, 0x1be, 0x1c0, 
       0x1c2, 0x1c4, 0x1c6, 0x1c8, 0x1ca, 0x1cc, 0x1ce, 0x1d0, 0x1d2, 0x1d4, 
       0x1d6, 0x1d8, 0x1da, 0x1dc, 0x1de, 0x1e0, 0x1e2, 0x1e4, 0x1e6, 0x1e8, 
       0x1ea, 0x1ec, 0x1ee, 0x1f0, 0x1f2, 0x1f4, 0x1f6, 0x1f8, 0x1fa, 0x1fc, 
       0x1fe, 0x200, 0x202, 0x204, 0x206, 0x208, 0x20a, 0x20c, 0x20e, 0x210, 
       0x212, 0x214, 0x216, 0x218, 0x21a, 0x21c, 0x21e, 0x220, 0x222, 0x224, 
       0x226, 0x228, 0x22a, 0x22c, 0x22e, 0x230, 0x232, 0x234, 0x236, 0x238, 
       0x23a, 0x23c, 0x23e, 0x240, 0x242, 0x244, 0x246, 0x248, 0x24a, 0x24c, 
       0x24e, 0x250, 0x252, 0x254, 0x256, 0x258, 0x25a, 0x25c, 0x25e, 0x260, 
       0x262, 0x264, 0x266, 0x268, 0x26a, 0x26c, 0x26e, 0x270, 0x272, 0x274, 
       0x276, 0x278, 0x27a, 0x27c, 0x27e, 0x280, 0x282, 0x284, 0x286, 0x288, 
       0x28a, 0x28c, 0x28e, 0x290, 0x292, 0x294, 0x296, 0x298, 0x29a, 0x29c, 
       0x29e, 0x2a0, 0x2a2, 0x2a4, 0x2a6, 0x2a8, 0x2aa, 0x2ac, 0x2ae, 0x2b0, 
       0x2b2, 0x2b4, 0x2b6, 0x2b8, 0x2ba, 0x2bc, 0x2be, 0x2c0, 0x2c2, 0x2c4, 
       0x2c6, 0x2c8, 0x2ca, 0x2cc, 0x2ce, 0x2d0, 0x2d2, 0x2d4, 0x2d6, 0x2d8, 
       0x2da, 0x2dc, 0x2de, 0x2e0, 0x2e2, 0x2e4, 0x2e6, 0x2e8, 0x2ea, 0x2ec, 
       0x2ee, 0x2f0, 0x2f2, 0x2f4, 0x2f6, 0x2f8, 0x2fa, 0x2fc, 0x2fe, 0x300, 
       0x302, 0x304, 0x306, 0x308, 0x30a, 0x30c, 0x30e, 0x310, 0x312, 0x314, 
       0x316, 0x318, 0x31a, 0x31c, 0x31e, 0x320, 0x322, 0x324, 0x326, 0x328, 
       0x32a, 0x32c, 0x32e, 0x330, 0x332, 0x334, 0x336, 0x338, 0x33a, 0x33c, 
       0x33e, 0x340, 0x342, 0x344, 0x346, 0x348, 0x34a, 0x34c, 0x34e, 0x350, 
       0x352, 0x354, 0x356, 0x358, 0x35a, 0x35c, 0x35e, 0x360, 0x362, 0x364, 
       0x366, 0x368, 0x36a, 0x36c, 0x36e, 0x370, 0x372, 0x374, 0x376, 0x378, 
       0x37a, 0x37c, 0x37e, 0x380, 0x382, 0x384, 0x386, 0x388, 0x38a, 0x38c, 
       0x38e, 0x390, 0x392, 0x394, 0x396, 0x398, 0x39a, 0x39c, 0x39e, 0x3a0, 
       0x3a2, 0x3a4, 0x3a6, 0x3a8, 0x3aa, 0x3ac, 0x3ae, 0x3b0, 0x3b2, 0x3b4, 
       0x3b6, 0x3b8, 0x3ba, 0x3bc, 0x3be, 0x3c0, 0x3c2, 0x3c4, 0x3c6, 0x3c8, 
       0x3ca, 0x3cc, 0x3ce, 0x3d0, 0x3d2, 0x3d4, 0x3d6, 0x3d8, 0x3da, 0x3dc, 
       0x3de, 0x3e0, 0x3e2, 0x3e4, 0x3e6, 0x3e8, 0x3ea, 0x3ec, 0x3ee, 0x3f0, 
       0x3f2, 0x3f4, 0x3f6, 0x3f8, 0x3fa, 0x3fc, 0x3fe, 0x400, 0x402, 0x404, 
       0x406, 0x408, 0x40a, 0x40c, 0x40e, 0x410, 0x412, 0x414, 0x416, 0x418, 
       0x41a, 0x41c, 0x41e, 0x420, 0x422, 0x424, 0x426, 0x428, 0x42a, 0x42c, 
       0x42e, 0x430, 0x432, 0x434, 0x436, 0x438, 0x43a, 0x43c, 0x43e, 0x440, 
       0x442, 0x444, 0x446, 0x448, 0x44a, 0x44c, 0x44e, 0x450, 0x452, 0x454, 
       0x456, 0x458, 0x45a, 0x45c, 0x45e, 0x460, 0x462, 0x464, 0x466, 0x468, 
       0x46a, 0x46c, 0x46e, 0x470, 0x472, 0x474, 0x476, 0x478, 0x47a, 0x47c, 
       0x47e, 0x480, 0x482, 0x484, 0x486, 0x488, 0x48a, 0x2, 0x90, 0x3, 
       0x2, 0x2f3, 0x2f4, 0x4, 0x2, 0x1b1, 0x1b1, 0x28e, 0x28e, 0x4, 0x2, 
       0x1c0, 0x1c0, 0x262, 0x262, 0x4, 0x2, 0x2ab, 0x2ab, 0x2ae, 0x2ae, 
       0x4, 0x2, 0x1ac, 0x1ac, 0x1e9, 0x1e9, 0x4, 0x2, 0x10f, 0x10f, 0x258, 
       0x258, 0x3, 0x2, 0x2f5, 0x2f6, 0x4, 0x2, 0x4f, 0x4f, 0xb6, 0xb6, 
       0x4, 0x2, 0x209, 0x209, 0x25f, 0x25f, 0x6, 0x2, 0x14b, 0x14b, 0x1de, 
       0x1de, 0x212, 0x212, 0x259, 0x259, 0x4, 0x2, 0x75, 0x75, 0xa3, 0xa3, 
       0x4, 0x2, 0x113, 0x113, 0x16a, 0x16a, 0x4, 0x2, 0x112, 0x112, 0x169, 
       0x169, 0x4, 0x2, 0xef, 0xef, 0x174, 0x174, 0x5, 0x2, 0xd9, 0xd9, 
       0x15a, 0x15a, 0x168, 0x168, 0x4, 0x2, 0x3d, 0x3d, 0x1b4, 0x1b4, 0x5, 
       0x2, 0x1e2, 0x1e2, 0x20f, 0x20f, 0x298, 0x298, 0x4, 0x2, 0x15, 0x15, 
       0x24, 0x24, 0x4, 0x2, 0x156, 0x156, 0x288, 0x288, 0x5, 0x2, 0x10e, 
       0x10e, 0x209, 0x209, 0x22b, 0x22b, 0x4, 0x2, 0x96, 0x96, 0xed, 0xed, 
       0x6, 0x2, 0x96, 0x96, 0xb0, 0xb0, 0xed, 0xed, 0x105, 0x105, 0x4, 
       0x2, 0x181, 0x181, 0x184, 0x187, 0x5, 0x2, 0x1e1, 0x1e1, 0x204, 0x204, 
       0x22b, 0x22b, 0x4, 0x2, 0x172, 0x172, 0x2a0, 0x2a0, 0x4, 0x2, 0x63, 
       0x63, 0x22b, 0x22b, 0x4, 0x2, 0x12c, 0x12c, 0x222, 0x222, 0x4, 0x2, 
       0x1e1, 0x1e1, 0x22b, 0x22b, 0x8, 0x2, 0x141, 0x141, 0x1ad, 0x1ad, 
       0x1e6, 0x1e6, 0x204, 0x204, 0x276, 0x278, 0x281, 0x281, 0x4, 0x2, 
       0xf4, 0xf4, 0x198, 0x198, 0x4, 0x2, 0x17e, 0x180, 0x1a6, 0x1a6, 0x5, 
       0x2, 0x12c, 0x12c, 0x255, 0x255, 0x2cc, 0x2cc, 0x4, 0x2, 0x1b2, 0x1b2, 
       0x1e3, 0x1e3, 0x4, 0x2, 0x21e, 0x21e, 0x265, 0x265, 0x4, 0x2, 0x1ce, 
       0x1ce, 0x20c, 0x20c, 0x4, 0x2, 0x1ad, 0x1ad, 0x1e6, 0x1e6, 0x4, 0x2, 
       0x181, 0x181, 0x1b1, 0x1b1, 0x4, 0x2, 0x1f9, 0x1f9, 0x209, 0x209, 
       0x4, 0x2, 0x20a, 0x20a, 0x21a, 0x21a, 0x4, 0x2, 0x246, 0x246, 0x2af, 
       0x2af, 0x4, 0x2, 0x5d, 0x5d, 0x167, 0x167, 0x4, 0x2, 0x7, 0x7, 0x32, 
       0x32, 0x4, 0x2, 0x125, 0x125, 0x218, 0x218, 0x4, 0x2, 0xbb, 0xbb, 
       0x1b7, 0x1b7, 0x4, 0x2, 0x13d, 0x13d, 0x13f, 0x13f, 0x4, 0x2, 0x119, 
       0x119, 0x143, 0x143, 0x3, 0x2, 0x32, 0x33, 0x4, 0x2, 0x10, 0x10, 
       0x1e9, 0x1e9, 0x5, 0x2, 0xf1, 0xf1, 0x178, 0x178, 0x27a, 0x27a, 0x4, 
       0x2, 0x225, 0x225, 0x296, 0x296, 0x4, 0x2, 0xec, 0xec, 0x1e0, 0x1e0, 
       0x4, 0x2, 0x1e0, 0x1e0, 0x2f0, 0x2f0, 0x5, 0x2, 0x166, 0x166, 0x253, 
       0x253, 0x288, 0x288, 0x6, 0x2, 0x20f, 0x20f, 0x25a, 0x25a, 0x267, 
       0x267, 0x298, 0x298, 0xf, 0x2, 0x13, 0x13, 0x3a, 0x3a, 0x87, 0x87, 
       0x93, 0x93, 0x107, 0x107, 0x10b, 0x10b, 0x11a, 0x11a, 0x151, 0x151, 
       0x1e2, 0x1e2, 0x1e9, 0x1e9, 0x20a, 0x20a, 0x290, 0x290, 0x299, 0x299, 
       0x6, 0x2, 0x12b, 0x12b, 0x158, 0x158, 0x16e, 0x16e, 0x171, 0x171, 
       0x4, 0x2, 0x2f, 0x2f, 0x55, 0x55, 0x4, 0x2, 0x1cd, 0x1cd, 0x1e9, 
       0x1e9, 0x4, 0x2, 0xf1, 0xf1, 0x1e0, 0x1e0, 0x4, 0x2, 0x8c, 0x8c, 
       0x10e, 0x10e, 0x7, 0x2, 0x52, 0x52, 0x8c, 0x8c, 0x8f, 0x8f, 0xd7, 
       0xd7, 0x10e, 0x10e, 0x5, 0x2, 0x8c, 0x8c, 0x10e, 0x10e, 0x16f, 0x16f, 
       0x6, 0x2, 0x1ad, 0x1ad, 0x1b7, 0x1b7, 0x1e0, 0x1e0, 0x244, 0x244, 
       0x4, 0x2, 0x12f, 0x12f, 0x2e7, 0x2e7, 0x5, 0x2, 0xb9, 0xb9, 0xe5, 
       0xe5, 0x149, 0x149, 0x4, 0x2, 0x1fc, 0x1fc, 0x213, 0x213, 0x4, 0x2, 
       0x49, 0x49, 0x116, 0x116, 0x5, 0x2, 0xa5, 0xa5, 0x20a, 0x20a, 0x219, 
       0x219, 0x4, 0x2, 0x85, 0x85, 0x173, 0x173, 0x4, 0x2, 0x149, 0x149, 
       0x170, 0x170, 0x8, 0x2, 0x6b, 0x6b, 0xaa, 0xaa, 0xd8, 0xd8, 0x13c, 
       0x13c, 0x153, 0x153, 0x1ad, 0x1ad, 0x4, 0x2, 0x64, 0x64, 0x10d, 0x10d, 
       0x7, 0x2, 0x77, 0x77, 0x9f, 0x9f, 0x106, 0x106, 0x149, 0x149, 0x16d, 
       0x16d, 0x7, 0x2, 0x82, 0x82, 0x84, 0x84, 0x98, 0x98, 0x139, 0x139, 
       0x1b7, 0x1b7, 0x4, 0x2, 0x16e, 0x16e, 0x2e7, 0x2e7, 0x4, 0x2, 0x7a, 
       0x7a, 0x91, 0x91, 0x3, 0x2, 0x1e3, 0x1e4, 0x5, 0x2, 0x16b, 0x16b, 
       0x1f6, 0x1f6, 0x292, 0x292, 0x4, 0x2, 0x192, 0x192, 0x1b0, 0x1b0, 
       0x4, 0x2, 0x195, 0x195, 0x24c, 0x24c, 0x4, 0x2, 0x42, 0x42, 0x1ad, 
       0x1ad, 0x4, 0x2, 0x181, 0x181, 0x183, 0x188, 0x5, 0x2, 0x18b, 0x18d, 
       0x1e7, 0x1e7, 0x239, 0x239, 0x3, 0x2, 0x189, 0x18a, 0x3, 0x2, 0x190, 
       0x191, 0x4, 0x2, 0x189, 0x18a, 0x18f, 0x18f, 0x3, 0x2, 0x1b9, 0x1bb, 
       0x6, 0x2, 0x2c7, 0x2c8, 0x2d5, 0x2d5, 0x2d7, 0x2d7, 0x2d9, 0x2d9, 
       0x4, 0x2, 0x2cd, 0x2cd, 0x2cf, 0x2cf, 0x4, 0x2, 0x2ca, 0x2ca, 0x2ce, 
       0x2ce, 0x4, 0x2, 0x96, 0x96, 0xb0, 0xb0, 0x4, 0x2, 0x209, 0x209, 
       0x2d8, 0x2d8, 0x4, 0x2, 0x3c, 0x3c, 0x14d, 0x14d, 0x3, 0x2, 0x1d7, 
       0x1d8, 0x3, 0x2, 0x160, 0x161, 0x5, 0x2, 0x71, 0x72, 0x15f, 0x15f, 
       0x162, 0x162, 0x4, 0x2, 0x17c, 0x17c, 0x23e, 0x23e, 0x4, 0x2, 0x17c, 
       0x17c, 0x18e, 0x18e, 0x7, 0x2, 0x1d9, 0x1dc, 0x205, 0x207, 0x235, 
       0x236, 0x266, 0x266, 0x2b1, 0x2b1, 0xb, 0x2, 0x73, 0x73, 0xa0, 0xa0, 
       0xdb, 0xdb, 0xdd, 0xdd, 0xe1, 0xe1, 0x10c, 0x10c, 0x133, 0x133, 0x175, 
       0x175, 0x17b, 0x17b, 0x5, 0x2, 0x1ca, 0x1ca, 0x1f3, 0x1f3, 0x293, 
       0x293, 0x4, 0x2, 0xf2, 0xf2, 0x12d, 0x12d, 0xc, 0x2, 0x50, 0x50, 
       0x56, 0x56, 0x5a, 0x5a, 0x66, 0x68, 0x6e, 0x6e, 0xda, 0xda, 0xe6, 
       0xe6, 0x132, 0x132, 0x14c, 0x14c, 0x155, 0x155, 0x4, 0x2, 0x280, 
       0x280, 0x2a7, 0x2a7, 0x5, 0x2, 0x7f, 0x7f, 0x97, 0x97, 0x1e0, 0x1e0, 
       0x5, 0x2, 0x7c, 0x7c, 0xd8, 0xd8, 0x1e0, 0x1e0, 0x5, 0x2, 0x92, 0x92, 
       0xfa, 0xfa, 0x137, 0x137, 0x5, 0x2, 0x4e, 0x4e, 0x9e, 0x9e, 0x130, 
       0x130, 0x3, 0x2, 0x2b6, 0x2b7, 0x4, 0x2, 0x164, 0x164, 0x29b, 0x29b, 
       0x7, 0x2, 0x1b6, 0x1b6, 0x212, 0x212, 0x232, 0x232, 0x270, 0x270, 
       0x28c, 0x28c, 0x6, 0x2, 0x97, 0x97, 0x1de, 0x1de, 0x1f8, 0x1f8, 0x242, 
       0x242, 0x3, 0x2, 0x4c, 0x4d, 0x4, 0x2, 0x226, 0x226, 0x231, 0x231, 
       0x6, 0x2, 0x99, 0x9a, 0xb4, 0xb4, 0xe2, 0xe4, 0x102, 0x103, 0x5, 
       0x2, 0x2e, 0x2e, 0x297, 0x297, 0x2b2, 0x2b2, 0x3, 0x2, 0x146, 0x148, 
       0x4, 0x2, 0xb, 0xb, 0x157, 0x157, 0x8, 0x2, 0x5e, 0x5e, 0x60, 0x60, 
       0x7f, 0x7f, 0x97, 0x97, 0x114, 0x114, 0x1e0, 0x1e0, 0x5, 0x2, 0x1d, 
       0x1d, 0x96, 0x96, 0xb0, 0xb0, 0x4, 0x2, 0x7c, 0x7c, 0xd8, 0xd8, 0x4, 
       0x2, 0xb5, 0xb5, 0x255, 0x255, 0x4, 0x2, 0xba, 0xba, 0xde, 0xde, 
       0x4, 0x2, 0x6f, 0x6f, 0x20a, 0x20a, 0x5, 0x2, 0x20d, 0x20d, 0x213, 
       0x213, 0x24f, 0x24f, 0x4, 0x2, 0x27b, 0x27b, 0x289, 0x289, 0x4, 0x2, 
       0x243, 0x243, 0x245, 0x245, 0x4, 0x2, 0xb6, 0xb6, 0x240, 0x240, 0x4, 
       0x2, 0x2fd, 0x2fd, 0x2ff, 0x2ff, 0x5, 0x2, 0x17e, 0x180, 0x1a7, 0x1a7, 
       0x1a9, 0x1aa, 0x4, 0x2, 0x17e, 0x180, 0x1a7, 0x1a7, 0x4, 0x2, 0x17e, 
       0x180, 0x1a9, 0x1aa, 0x3, 0x2, 0x17e, 0x180, 0x3, 0x2, 0x1a7, 0x1a8, 
       0x4, 0x2, 0x1f6, 0x1f6, 0x292, 0x292, 0x4, 0x2, 0x1a5, 0x1a5, 0x241, 
       0x241, 0x3, 0x2, 0x181, 0x182, 0x7, 0x2, 0x9d, 0x9d, 0xb6, 0xb6, 
       0x136, 0x136, 0x2b3, 0x2b3, 0x2c2, 0x2c2, 0x8, 0x2, 0x3, 0x12, 0x14, 
       0x39, 0x2b4, 0x2b4, 0x2b6, 0x2b7, 0x2c6, 0x2c6, 0x2f1, 0x2f4, 0x21, 
       0x2, 0x3b, 0x40, 0x42, 0x6b, 0x6d, 0x86, 0x88, 0x92, 0x94, 0xa3, 
       0xa5, 0xa7, 0xa9, 0xf0, 0xf2, 0x106, 0x108, 0x10a, 0x10c, 0x119, 
       0x11b, 0x11c, 0x11e, 0x12b, 0x12d, 0x12e, 0x130, 0x165, 0x167, 0x17b, 
       0x1af, 0x1af, 0x2b9, 0x2b9, 0x2be, 0x2c0, 0x2c3, 0x2c5, 0x2c9, 0x2c9, 
       0x2cb, 0x2cb, 0x2d2, 0x2d3, 0x2d6, 0x2d6, 0x2d8, 0x2d8, 0x2da, 0x2db, 
       0x2df, 0x2e5, 0x2e8, 0x2e9, 0x2ed, 0x2ee, 0x2f0, 0x2f0, 0x2f5, 0x2f6, 
       0x2f8, 0x2f9, 0x7, 0x2, 0x6c, 0x6c, 0xa4, 0xa4, 0x12c, 0x12c, 0x12f, 
       0x12f, 0x166, 0x166, 0x8, 0x2, 0x151, 0x151, 0x1f1, 0x1f1, 0x1f4, 
       0x1f4, 0x246, 0x246, 0x29f, 0x29f, 0x2ae, 0x2ae, 0x2, 0x23c7, 0x2, 
       0x498, 0x3, 0x2, 0x2, 0x2, 0x4, 0x4be, 0x3, 0x2, 0x2, 0x2, 0x6, 0x4c0, 
       0x3, 0x2, 0x2, 0x2, 0x8, 0x4dd, 0x3, 0x2, 0x2, 0x2, 0xa, 0x4ec, 0x3, 
       0x2, 0x2, 0x2, 0xc, 0x512, 0x3, 0x2, 0x2, 0x2, 0xe, 0x51b, 0x3, 0x2, 
       0x2, 0x2, 0x10, 0x528, 0x3, 0x2, 0x2, 0x2, 0x12, 0x52a, 0x3, 0x2, 
       0x2, 0x2, 0x14, 0x52f, 0x3, 0x2, 0x2, 0x2, 0x16, 0x547, 0x3, 0x2, 
       0x2, 0x2, 0x18, 0x550, 0x3, 0x2, 0x2, 0x2, 0x1a, 0x552, 0x3, 0x2, 
       0x2, 0x2, 0x1c, 0x561, 0x3, 0x2, 0x2, 0x2, 0x1e, 0x5c5, 0x3, 0x2, 
       0x2, 0x2, 0x20, 0x5c9, 0x3, 0x2, 0x2, 0x2, 0x22, 0x5db, 0x3, 0x2, 
       0x2, 0x2, 0x24, 0x655, 0x3, 0x2, 0x2, 0x2, 0x26, 0x65a, 0x3, 0x2, 
       0x2, 0x2, 0x28, 0x65c, 0x3, 0x2, 0x2, 0x2, 0x2a, 0x65e, 0x3, 0x2, 
       0x2, 0x2, 0x2c, 0x66c, 0x3, 0x2, 0x2, 0x2, 0x2e, 0x674, 0x3, 0x2, 
       0x2, 0x2, 0x30, 0x67c, 0x3, 0x2, 0x2, 0x2, 0x32, 0x687, 0x3, 0x2, 
       0x2, 0x2, 0x34, 0x68b, 0x3, 0x2, 0x2, 0x2, 0x36, 0x690, 0x3, 0x2, 
       0x2, 0x2, 0x38, 0x692, 0x3, 0x2, 0x2, 0x2, 0x3a, 0x69d, 0x3, 0x2, 
       0x2, 0x2, 0x3c, 0x6c2, 0x3, 0x2, 0x2, 0x2, 0x3e, 0x6ca, 0x3, 0x2, 
       0x2, 0x2, 0x40, 0x6d4, 0x3, 0x2, 0x2, 0x2, 0x42, 0x6d6, 0x3, 0x2, 
       0x2, 0x2, 0x44, 0x6ea, 0x3, 0x2, 0x2, 0x2, 0x46, 0x6f3, 0x3, 0x2, 
       0x2, 0x2, 0x48, 0x6f6, 0x3, 0x2, 0x2, 0x2, 0x4a, 0x703, 0x3, 0x2, 
       0x2, 0x2, 0x4c, 0x708, 0x3, 0x2, 0x2, 0x2, 0x4e, 0x70c, 0x3, 0x2, 
       0x2, 0x2, 0x50, 0x713, 0x3, 0x2, 0x2, 0x2, 0x52, 0x728, 0x3, 0x2, 
       0x2, 0x2, 0x54, 0x737, 0x3, 0x2, 0x2, 0x2, 0x56, 0x73a, 0x3, 0x2, 
       0x2, 0x2, 0x58, 0x759, 0x3, 0x2, 0x2, 0x2, 0x5a, 0x763, 0x3, 0x2, 
       0x2, 0x2, 0x5c, 0x766, 0x3, 0x2, 0x2, 0x2, 0x5e, 0x76f, 0x3, 0x2, 
       0x2, 0x2, 0x60, 0x771, 0x3, 0x2, 0x2, 0x2, 0x62, 0x77d, 0x3, 0x2, 
       0x2, 0x2, 0x64, 0x796, 0x3, 0x2, 0x2, 0x2, 0x66, 0x7b1, 0x3, 0x2, 
       0x2, 0x2, 0x68, 0x7bf, 0x3, 0x2, 0x2, 0x2, 0x6a, 0x7c2, 0x3, 0x2, 
       0x2, 0x2, 0x6c, 0x7d7, 0x3, 0x2, 0x2, 0x2, 0x6e, 0x7da, 0x3, 0x2, 
       0x2, 0x2, 0x70, 0x813, 0x3, 0x2, 0x2, 0x2, 0x72, 0x815, 0x3, 0x2, 
       0x2, 0x2, 0x74, 0x819, 0x3, 0x2, 0x2, 0x2, 0x76, 0x822, 0x3, 0x2, 
       0x2, 0x2, 0x78, 0x832, 0x3, 0x2, 0x2, 0x2, 0x7a, 0x834, 0x3, 0x2, 
       0x2, 0x2, 0x7c, 0x83c, 0x3, 0x2, 0x2, 0x2, 0x7e, 0x856, 0x3, 0x2, 
       0x2, 0x2, 0x80, 0x858, 0x3, 0x2, 0x2, 0x2, 0x82, 0x864, 0x3, 0x2, 
       0x2, 0x2, 0x84, 0x873, 0x3, 0x2, 0x2, 0x2, 0x86, 0x875, 0x3, 0x2, 
       0x2, 0x2, 0x88, 0x878, 0x3, 0x2, 0x2, 0x2, 0x8a, 0x88e, 0x3, 0x2, 
       0x2, 0x2, 0x8c, 0x890, 0x3, 0x2, 0x2, 0x2, 0x8e, 0x896, 0x3, 0x2, 
       0x2, 0x2, 0x90, 0x89c, 0x3, 0x2, 0x2, 0x2, 0x92, 0x8a2, 0x3, 0x2, 
       0x2, 0x2, 0x94, 0x8a8, 0x3, 0x2, 0x2, 0x2, 0x96, 0x8ae, 0x3, 0x2, 
       0x2, 0x2, 0x98, 0x8b5, 0x3, 0x2, 0x2, 0x2, 0x9a, 0x8bd, 0x3, 0x2, 
       0x2, 0x2, 0x9c, 0x8bf, 0x3, 0x2, 0x2, 0x2, 0x9e, 0x8c5, 0x3, 0x2, 
       0x2, 0x2, 0xa0, 0x8cb, 0x3, 0x2, 0x2, 0x2, 0xa2, 0x8d2, 0x3, 0x2, 
       0x2, 0x2, 0xa4, 0x8e4, 0x3, 0x2, 0x2, 0x2, 0xa6, 0x8e6, 0x3, 0x2, 
       0x2, 0x2, 0xa8, 0x8ea, 0x3, 0x2, 0x2, 0x2, 0xaa, 0x8ef, 0x3, 0x2, 
       0x2, 0x2, 0xac, 0x8ff, 0x3, 0x2, 0x2, 0x2, 0xae, 0x904, 0x3, 0x2, 
       0x2, 0x2, 0xb0, 0x925, 0x3, 0x2, 0x2, 0x2, 0xb2, 0x944, 0x3, 0x2, 
       0x2, 0x2, 0xb4, 0x955, 0x3, 0x2, 0x2, 0x2, 0xb6, 0x957, 0x3, 0x2, 
       0x2, 0x2, 0xb8, 0x96b, 0x3, 0x2, 0x2, 0x2, 0xba, 0x971, 0x3, 0x2, 
       0x2, 0x2, 0xbc, 0x977, 0x3, 0x2, 0x2, 0x2, 0xbe, 0x97d, 0x3, 0x2, 
       0x2, 0x2, 0xc0, 0x984, 0x3, 0x2, 0x2, 0x2, 0xc2, 0x98d, 0x3, 0x2, 
       0x2, 0x2, 0xc4, 0x99e, 0x3, 0x2, 0x2, 0x2, 0xc6, 0x9a0, 0x3, 0x2, 
       0x2, 0x2, 0xc8, 0x9a7, 0x3, 0x2, 0x2, 0x2, 0xca, 0x9b1, 0x3, 0x2, 
       0x2, 0x2, 0xcc, 0x9bf, 0x3, 0x2, 0x2, 0x2, 0xce, 0x9c5, 0x3, 0x2, 
       0x2, 0x2, 0xd0, 0x9cd, 0x3, 0x2, 0x2, 0x2, 0xd2, 0x9d3, 0x3, 0x2, 
       0x2, 0x2, 0xd4, 0x9db, 0x3, 0x2, 0x2, 0x2, 0xd6, 0x9e1, 0x3, 0x2, 
       0x2, 0x2, 0xd8, 0x9eb, 0x3, 0x2, 0x2, 0x2, 0xda, 0x9ef, 0x3, 0x2, 
       0x2, 0x2, 0xdc, 0x9f5, 0x3, 0x2, 0x2, 0x2, 0xde, 0x9fa, 0x3, 0x2, 
       0x2, 0x2, 0xe0, 0xa05, 0x3, 0x2, 0x2, 0x2, 0xe2, 0xa2c, 0x3, 0x2, 
       0x2, 0x2, 0xe4, 0xa32, 0x3, 0x2, 0x2, 0x2, 0xe6, 0xa34, 0x3, 0x2, 
       0x2, 0x2, 0xe8, 0xa3b, 0x3, 0x2, 0x2, 0x2, 0xea, 0xa59, 0x3, 0x2, 
       0x2, 0x2, 0xec, 0xa5b, 0x3, 0x2, 0x2, 0x2, 0xee, 0xa72, 0x3, 0x2, 
       0x2, 0x2, 0xf0, 0xa79, 0x3, 0x2, 0x2, 0x2, 0xf2, 0xa7d, 0x3, 0x2, 
       0x2, 0x2, 0xf4, 0xa85, 0x3, 0x2, 0x2, 0x2, 0xf6, 0xa8f, 0x3, 0x2, 
       0x2, 0x2, 0xf8, 0xa91, 0x3, 0x2, 0x2, 0x2, 0xfa, 0xaa3, 0x3, 0x2, 
       0x2, 0x2, 0xfc, 0xaaf, 0x3, 0x2, 0x2, 0x2, 0xfe, 0xab5, 0x3, 0x2, 
       0x2, 0x2, 0x100, 0xad9, 0x3, 0x2, 0x2, 0x2, 0x102, 0xadb, 0x3, 0x2, 
       0x2, 0x2, 0x104, 0xae4, 0x3, 0x2, 0x2, 0x2, 0x106, 0xaed, 0x3, 0x2, 
       0x2, 0x2, 0x108, 0xaf5, 0x3, 0x2, 0x2, 0x2, 0x10a, 0xb01, 0x3, 0x2, 
       0x2, 0x2, 0x10c, 0xb15, 0x3, 0x2, 0x2, 0x2, 0x10e, 0xb1e, 0x3, 0x2, 
       0x2, 0x2, 0x110, 0xb42, 0x3, 0x2, 0x2, 0x2, 0x112, 0xb4f, 0x3, 0x2, 
       0x2, 0x2, 0x114, 0xb5f, 0x3, 0x2, 0x2, 0x2, 0x116, 0xb66, 0x3, 0x2, 
       0x2, 0x2, 0x118, 0xb81, 0x3, 0x2, 0x2, 0x2, 0x11a, 0xb83, 0x3, 0x2, 
       0x2, 0x2, 0x11c, 0xb85, 0x3, 0x2, 0x2, 0x2, 0x11e, 0xb88, 0x3, 0x2, 
       0x2, 0x2, 0x120, 0xb8b, 0x3, 0x2, 0x2, 0x2, 0x122, 0xb92, 0x3, 0x2, 
       0x2, 0x2, 0x124, 0xb94, 0x3, 0x2, 0x2, 0x2, 0x126, 0xbb2, 0x3, 0x2, 
       0x2, 0x2, 0x128, 0xbbe, 0x3, 0x2, 0x2, 0x2, 0x12a, 0xbc1, 0x3, 0x2, 
       0x2, 0x2, 0x12c, 0xbca, 0x3, 0x2, 0x2, 0x2, 0x12e, 0xbce, 0x3, 0x2, 
       0x2, 0x2, 0x130, 0xbd3, 0x3, 0x2, 0x2, 0x2, 0x132, 0xbe0, 0x3, 0x2, 
       0x2, 0x2, 0x134, 0xbe5, 0x3, 0x2, 0x2, 0x2, 0x136, 0xbe9, 0x3, 0x2, 
       0x2, 0x2, 0x138, 0xbf9, 0x3, 0x2, 0x2, 0x2, 0x13a, 0xbfb, 0x3, 0x2, 
       0x2, 0x2, 0x13c, 0xc0d, 0x3, 0x2, 0x2, 0x2, 0x13e, 0xc0f, 0x3, 0x2, 
       0x2, 0x2, 0x140, 0xc18, 0x3, 0x2, 0x2, 0x2, 0x142, 0xc24, 0x3, 0x2, 
       0x2, 0x2, 0x144, 0xc2b, 0x3, 0x2, 0x2, 0x2, 0x146, 0xc36, 0x3, 0x2, 
       0x2, 0x2, 0x148, 0xc38, 0x3, 0x2, 0x2, 0x2, 0x14a, 0xc3c, 0x3, 0x2, 
       0x2, 0x2, 0x14c, 0xc3e, 0x3, 0x2, 0x2, 0x2, 0x14e, 0xc43, 0x3, 0x2, 
       0x2, 0x2, 0x150, 0xc53, 0x3, 0x2, 0x2, 0x2, 0x152, 0xc64, 0x3, 0x2, 
       0x2, 0x2, 0x154, 0xc69, 0x3, 0x2, 0x2, 0x2, 0x156, 0xc6e, 0x3, 0x2, 
       0x2, 0x2, 0x158, 0xc72, 0x3, 0x2, 0x2, 0x2, 0x15a, 0xc80, 0x3, 0x2, 
       0x2, 0x2, 0x15c, 0xc83, 0x3, 0x2, 0x2, 0x2, 0x15e, 0xc89, 0x3, 0x2, 
       0x2, 0x2, 0x160, 0xc92, 0x3, 0x2, 0x2, 0x2, 0x162, 0xc9a, 0x3, 0x2, 
       0x2, 0x2, 0x164, 0xcb4, 0x3, 0x2, 0x2, 0x2, 0x166, 0xcc1, 0x3, 0x2, 
       0x2, 0x2, 0x168, 0xcc8, 0x3, 0x2, 0x2, 0x2, 0x16a, 0xcca, 0x3, 0x2, 
       0x2, 0x2, 0x16c, 0xcd6, 0x3, 0x2, 0x2, 0x2, 0x16e, 0xcd8, 0x3, 0x2, 
       0x2, 0x2, 0x170, 0xce2, 0x3, 0x2, 0x2, 0x2, 0x172, 0xcfa, 0x3, 0x2, 
       0x2, 0x2, 0x174, 0xcfc, 0x3, 0x2, 0x2, 0x2, 0x176, 0xd03, 0x3, 0x2, 
       0x2, 0x2, 0x178, 0xd0d, 0x3, 0x2, 0x2, 0x2, 0x17a, 0xd30, 0x3, 0x2, 
       0x2, 0x2, 0x17c, 0xd3a, 0x3, 0x2, 0x2, 0x2, 0x17e, 0xd3c, 0x3, 0x2, 
       0x2, 0x2, 0x180, 0xd40, 0x3, 0x2, 0x2, 0x2, 0x182, 0xd48, 0x3, 0x2, 
       0x2, 0x2, 0x184, 0xd4a, 0x3, 0x2, 0x2, 0x2, 0x186, 0xd4d, 0x3, 0x2, 
       0x2, 0x2, 0x188, 0xd51, 0x3, 0x2, 0x2, 0x2, 0x18a, 0xd6d, 0x3, 0x2, 
       0x2, 0x2, 0x18c, 0xd6f, 0x3, 0x2, 0x2, 0x2, 0x18e, 0xd71, 0x3, 0x2, 
       0x2, 0x2, 0x190, 0xd79, 0x3, 0x2, 0x2, 0x2, 0x192, 0xd7b, 0x3, 0x2, 
       0x2, 0x2, 0x194, 0xd83, 0x3, 0x2, 0x2, 0x2, 0x196, 0xd8d, 0x3, 0x2, 
       0x2, 0x2, 0x198, 0xd91, 0x3, 0x2, 0x2, 0x2, 0x19a, 0xdaa, 0x3, 0x2, 
       0x2, 0x2, 0x19c, 0xdc5, 0x3, 0x2, 0x2, 0x2, 0x19e, 0xdc7, 0x3, 0x2, 
       0x2, 0x2, 0x1a0, 0xdd1, 0x3, 0x2, 0x2, 0x2, 0x1a2, 0xdd9, 0x3, 0x2, 
       0x2, 0x2, 0x1a4, 0xde0, 0x3, 0x2, 0x2, 0x2, 0x1a6, 0xdff, 0x3, 0x2, 
       0x2, 0x2, 0x1a8, 0xe17, 0x3, 0x2, 0x2, 0x2, 0x1aa, 0xe19, 0x3, 0x2, 
       0x2, 0x2, 0x1ac, 0xe27, 0x3, 0x2, 0x2, 0x2, 0x1ae, 0xe29, 0x3, 0x2, 
       0x2, 0x2, 0x1b0, 0xe4c, 0x3, 0x2, 0x2, 0x2, 0x1b2, 0xe4e, 0x3, 0x2, 
       0x2, 0x2, 0x1b4, 0xe79, 0x3, 0x2, 0x2, 0x2, 0x1b6, 0xe89, 0x3, 0x2, 
       0x2, 0x2, 0x1b8, 0xe8b, 0x3, 0x2, 0x2, 0x2, 0x1ba, 0xe8f, 0x3, 0x2, 
       0x2, 0x2, 0x1bc, 0xe98, 0x3, 0x2, 0x2, 0x2, 0x1be, 0xe9f, 0x3, 0x2, 
       0x2, 0x2, 0x1c0, 0xeed, 0x3, 0x2, 0x2, 0x2, 0x1c2, 0xefb, 0x3, 0x2, 
       0x2, 0x2, 0x1c4, 0xefd, 0x3, 0x2, 0x2, 0x2, 0x1c6, 0xf0a, 0x3, 0x2, 
       0x2, 0x2, 0x1c8, 0xf4a, 0x3, 0x2, 0x2, 0x2, 0x1ca, 0xf4c, 0x3, 0x2, 
       0x2, 0x2, 0x1cc, 0xf54, 0x3, 0x2, 0x2, 0x2, 0x1ce, 0xf5c, 0x3, 0x2, 
       0x2, 0x2, 0x1d0, 0xf64, 0x3, 0x2, 0x2, 0x2, 0x1d2, 0xf66, 0x3, 0x2, 
       0x2, 0x2, 0x1d4, 0xf83, 0x3, 0x2, 0x2, 0x2, 0x1d6, 0xf8c, 0x3, 0x2, 
       0x2, 0x2, 0x1d8, 0xfab, 0x3, 0x2, 0x2, 0x2, 0x1da, 0xfad, 0x3, 0x2, 
       0x2, 0x2, 0x1dc, 0xfb5, 0x3, 0x2, 0x2, 0x2, 0x1de, 0xfb7, 0x3, 0x2, 
       0x2, 0x2, 0x1e0, 0xfc5, 0x3, 0x2, 0x2, 0x2, 0x1e2, 0xfc7, 0x3, 0x2, 
       0x2, 0x2, 0x1e4, 0xfcd, 0x3, 0x2, 0x2, 0x2, 0x1e6, 0xfd5, 0x3, 0x2, 
       0x2, 0x2, 0x1e8, 0xffa, 0x3, 0x2, 0x2, 0x2, 0x1ea, 0xffc, 0x3, 0x2, 
       0x2, 0x2, 0x1ec, 0x100c, 0x3, 0x2, 0x2, 0x2, 0x1ee, 0x100e, 0x3, 
       0x2, 0x2, 0x2, 0x1f0, 0x103a, 0x3, 0x2, 0x2, 0x2, 0x1f2, 0x103c, 
       0x3, 0x2, 0x2, 0x2, 0x1f4, 0x1052, 0x3, 0x2, 0x2, 0x2, 0x1f6, 0x105b, 
       0x3, 0x2, 0x2, 0x2, 0x1f8, 0x105d, 0x3, 0x2, 0x2, 0x2, 0x1fa, 0x1062, 
       0x3, 0x2, 0x2, 0x2, 0x1fc, 0x108f, 0x3, 0x2, 0x2, 0x2, 0x1fe, 0x1091, 
       0x3, 0x2, 0x2, 0x2, 0x200, 0x1099, 0x3, 0x2, 0x2, 0x2, 0x202, 0x10c8, 
       0x3, 0x2, 0x2, 0x2, 0x204, 0x10d5, 0x3, 0x2, 0x2, 0x2, 0x206, 0x10d7, 
       0x3, 0x2, 0x2, 0x2, 0x208, 0x10da, 0x3, 0x2, 0x2, 0x2, 0x20a, 0x10e9, 
       0x3, 0x2, 0x2, 0x2, 0x20c, 0x111c, 0x3, 0x2, 0x2, 0x2, 0x20e, 0x111e, 
       0x3, 0x2, 0x2, 0x2, 0x210, 0x1120, 0x3, 0x2, 0x2, 0x2, 0x212, 0x113d, 
       0x3, 0x2, 0x2, 0x2, 0x214, 0x116e, 0x3, 0x2, 0x2, 0x2, 0x216, 0x117b, 
       0x3, 0x2, 0x2, 0x2, 0x218, 0x117d, 0x3, 0x2, 0x2, 0x2, 0x21a, 0x118d, 
       0x3, 0x2, 0x2, 0x2, 0x21c, 0x1199, 0x3, 0x2, 0x2, 0x2, 0x21e, 0x11b2, 
       0x3, 0x2, 0x2, 0x2, 0x220, 0x11b4, 0x3, 0x2, 0x2, 0x2, 0x222, 0x11bc, 
       0x3, 0x2, 0x2, 0x2, 0x224, 0x11ec, 0x3, 0x2, 0x2, 0x2, 0x226, 0x11fb, 
       0x3, 0x2, 0x2, 0x2, 0x228, 0x1200, 0x3, 0x2, 0x2, 0x2, 0x22a, 0x1202, 
       0x3, 0x2, 0x2, 0x2, 0x22c, 0x121a, 0x3, 0x2, 0x2, 0x2, 0x22e, 0x121c, 
       0x3, 0x2, 0x2, 0x2, 0x230, 0x124c, 0x3, 0x2, 0x2, 0x2, 0x232, 0x124e, 
       0x3, 0x2, 0x2, 0x2, 0x234, 0x1254, 0x3, 0x2, 0x2, 0x2, 0x236, 0x125c, 
       0x3, 0x2, 0x2, 0x2, 0x238, 0x125e, 0x3, 0x2, 0x2, 0x2, 0x23a, 0x126c, 
       0x3, 0x2, 0x2, 0x2, 0x23c, 0x126e, 0x3, 0x2, 0x2, 0x2, 0x23e, 0x1354, 
       0x3, 0x2, 0x2, 0x2, 0x240, 0x135b, 0x3, 0x2, 0x2, 0x2, 0x242, 0x135d, 
       0x3, 0x2, 0x2, 0x2, 0x244, 0x135f, 0x3, 0x2, 0x2, 0x2, 0x246, 0x1369, 
       0x3, 0x2, 0x2, 0x2, 0x248, 0x1390, 0x3, 0x2, 0x2, 0x2, 0x24a, 0x1394, 
       0x3, 0x2, 0x2, 0x2, 0x24c, 0x1396, 0x3, 0x2, 0x2, 0x2, 0x24e, 0x139e, 
       0x3, 0x2, 0x2, 0x2, 0x250, 0x13a2, 0x3, 0x2, 0x2, 0x2, 0x252, 0x13aa, 
       0x3, 0x2, 0x2, 0x2, 0x254, 0x13b3, 0x3, 0x2, 0x2, 0x2, 0x256, 0x13b5, 
       0x3, 0x2, 0x2, 0x2, 0x258, 0x13cc, 0x3, 0x2, 0x2, 0x2, 0x25a, 0x13ce, 
       0x3, 0x2, 0x2, 0x2, 0x25c, 0x13d0, 0x3, 0x2, 0x2, 0x2, 0x25e, 0x13e0, 
       0x3, 0x2, 0x2, 0x2, 0x260, 0x13ec, 0x3, 0x2, 0x2, 0x2, 0x262, 0x13ee, 
       0x3, 0x2, 0x2, 0x2, 0x264, 0x13f6, 0x3, 0x2, 0x2, 0x2, 0x266, 0x13fe, 
       0x3, 0x2, 0x2, 0x2, 0x268, 0x1408, 0x3, 0x2, 0x2, 0x2, 0x26a, 0x140a, 
       0x3, 0x2, 0x2, 0x2, 0x26c, 0x141c, 0x3, 0x2, 0x2, 0x2, 0x26e, 0x142a, 
       0x3, 0x2, 0x2, 0x2, 0x270, 0x142f, 0x3, 0x2, 0x2, 0x2, 0x272, 0x1435, 
       0x3, 0x2, 0x2, 0x2, 0x274, 0x1437, 0x3, 0x2, 0x2, 0x2, 0x276, 0x1447, 
       0x3, 0x2, 0x2, 0x2, 0x278, 0x144f, 0x3, 0x2, 0x2, 0x2, 0x27a, 0x1459, 
       0x3, 0x2, 0x2, 0x2, 0x27c, 0x1466, 0x3, 0x2, 0x2, 0x2, 0x27e, 0x1468, 
       0x3, 0x2, 0x2, 0x2, 0x280, 0x146e, 0x3, 0x2, 0x2, 0x2, 0x282, 0x1487, 
       0x3, 0x2, 0x2, 0x2, 0x284, 0x1489, 0x3, 0x2, 0x2, 0x2, 0x286, 0x148c, 
       0x3, 0x2, 0x2, 0x2, 0x288, 0x148f, 0x3, 0x2, 0x2, 0x2, 0x28a, 0x149c, 
       0x3, 0x2, 0x2, 0x2, 0x28c, 0x14ac, 0x3, 0x2, 0x2, 0x2, 0x28e, 0x14c3, 
       0x3, 0x2, 0x2, 0x2, 0x290, 0x14c5, 0x3, 0x2, 0x2, 0x2, 0x292, 0x14e4, 
       0x3, 0x2, 0x2, 0x2, 0x294, 0x14e6, 0x3, 0x2, 0x2, 0x2, 0x296, 0x156b, 
       0x3, 0x2, 0x2, 0x2, 0x298, 0x157e, 0x3, 0x2, 0x2, 0x2, 0x29a, 0x1603, 
       0x3, 0x2, 0x2, 0x2, 0x29c, 0x1605, 0x3, 0x2, 0x2, 0x2, 0x29e, 0x1636, 
       0x3, 0x2, 0x2, 0x2, 0x2a0, 0x1638, 0x3, 0x2, 0x2, 0x2, 0x2a2, 0x163d, 
       0x3, 0x2, 0x2, 0x2, 0x2a4, 0x1646, 0x3, 0x2, 0x2, 0x2, 0x2a6, 0x1659, 
       0x3, 0x2, 0x2, 0x2, 0x2a8, 0x165c, 0x3, 0x2, 0x2, 0x2, 0x2aa, 0x1665, 
       0x3, 0x2, 0x2, 0x2, 0x2ac, 0x1667, 0x3, 0x2, 0x2, 0x2, 0x2ae, 0x167e, 
       0x3, 0x2, 0x2, 0x2, 0x2b0, 0x1792, 0x3, 0x2, 0x2, 0x2, 0x2b2, 0x17b3, 
       0x3, 0x2, 0x2, 0x2, 0x2b4, 0x17b5, 0x3, 0x2, 0x2, 0x2, 0x2b6, 0x17bb, 
       0x3, 0x2, 0x2, 0x2, 0x2b8, 0x17be, 0x3, 0x2, 0x2, 0x2, 0x2ba, 0x17cd, 
       0x3, 0x2, 0x2, 0x2, 0x2bc, 0x17d5, 0x3, 0x2, 0x2, 0x2, 0x2be, 0x17d7, 
       0x3, 0x2, 0x2, 0x2, 0x2c0, 0x17f4, 0x3, 0x2, 0x2, 0x2, 0x2c2, 0x1815, 
       0x3, 0x2, 0x2, 0x2, 0x2c4, 0x1817, 0x3, 0x2, 0x2, 0x2, 0x2c6, 0x181f, 
       0x3, 0x2, 0x2, 0x2, 0x2c8, 0x1829, 0x3, 0x2, 0x2, 0x2, 0x2ca, 0x182e, 
       0x3, 0x2, 0x2, 0x2, 0x2cc, 0x1830, 0x3, 0x2, 0x2, 0x2, 0x2ce, 0x183e, 
       0x3, 0x2, 0x2, 0x2, 0x2d0, 0x1840, 0x3, 0x2, 0x2, 0x2, 0x2d2, 0x1843, 
       0x3, 0x2, 0x2, 0x2, 0x2d4, 0x1846, 0x3, 0x2, 0x2, 0x2, 0x2d6, 0x186f, 
       0x3, 0x2, 0x2, 0x2, 0x2d8, 0x1871, 0x3, 0x2, 0x2, 0x2, 0x2da, 0x187c, 
       0x3, 0x2, 0x2, 0x2, 0x2dc, 0x187e, 0x3, 0x2, 0x2, 0x2, 0x2de, 0x1880, 
       0x3, 0x2, 0x2, 0x2, 0x2e0, 0x1884, 0x3, 0x2, 0x2, 0x2, 0x2e2, 0x1886, 
       0x3, 0x2, 0x2, 0x2, 0x2e4, 0x1888, 0x3, 0x2, 0x2, 0x2, 0x2e6, 0x188c, 
       0x3, 0x2, 0x2, 0x2, 0x2e8, 0x1890, 0x3, 0x2, 0x2, 0x2, 0x2ea, 0x1898, 
       0x3, 0x2, 0x2, 0x2, 0x2ec, 0x189c, 0x3, 0x2, 0x2, 0x2, 0x2ee, 0x18a4, 
       0x3, 0x2, 0x2, 0x2, 0x2f0, 0x18a6, 0x3, 0x2, 0x2, 0x2, 0x2f2, 0x18b8, 
       0x3, 0x2, 0x2, 0x2, 0x2f4, 0x18ba, 0x3, 0x2, 0x2, 0x2, 0x2f6, 0x18bd, 
       0x3, 0x2, 0x2, 0x2, 0x2f8, 0x18c2, 0x3, 0x2, 0x2, 0x2, 0x2fa, 0x18ca, 
       0x3, 0x2, 0x2, 0x2, 0x2fc, 0x18d0, 0x3, 0x2, 0x2, 0x2, 0x2fe, 0x18d4, 
       0x3, 0x2, 0x2, 0x2, 0x300, 0x18e5, 0x3, 0x2, 0x2, 0x2, 0x302, 0x18e8, 
       0x3, 0x2, 0x2, 0x2, 0x304, 0x18ed, 0x3, 0x2, 0x2, 0x2, 0x306, 0x18ef, 
       0x3, 0x2, 0x2, 0x2, 0x308, 0x18f2, 0x3, 0x2, 0x2, 0x2, 0x30a, 0x18fb, 
       0x3, 0x2, 0x2, 0x2, 0x30c, 0x1903, 0x3, 0x2, 0x2, 0x2, 0x30e, 0x1905, 
       0x3, 0x2, 0x2, 0x2, 0x310, 0x190a, 0x3, 0x2, 0x2, 0x2, 0x312, 0x1911, 
       0x3, 0x2, 0x2, 0x2, 0x314, 0x191b, 0x3, 0x2, 0x2, 0x2, 0x316, 0x1923, 
       0x3, 0x2, 0x2, 0x2, 0x318, 0x1925, 0x3, 0x2, 0x2, 0x2, 0x31a, 0x192f, 
       0x3, 0x2, 0x2, 0x2, 0x31c, 0x1937, 0x3, 0x2, 0x2, 0x2, 0x31e, 0x1939, 
       0x3, 0x2, 0x2, 0x2, 0x320, 0x193f, 0x3, 0x2, 0x2, 0x2, 0x322, 0x1954, 
       0x3, 0x2, 0x2, 0x2, 0x324, 0x1956, 0x3, 0x2, 0x2, 0x2, 0x326, 0x195c, 
       0x3, 0x2, 0x2, 0x2, 0x328, 0x195f, 0x3, 0x2, 0x2, 0x2, 0x32a, 0x1962, 
       0x3, 0x2, 0x2, 0x2, 0x32c, 0x1980, 0x3, 0x2, 0x2, 0x2, 0x32e, 0x1984, 
       0x3, 0x2, 0x2, 0x2, 0x330, 0x198b, 0x3, 0x2, 0x2, 0x2, 0x332, 0x1992, 
       0x3, 0x2, 0x2, 0x2, 0x334, 0x1994, 0x3, 0x2, 0x2, 0x2, 0x336, 0x19a4, 
       0x3, 0x2, 0x2, 0x2, 0x338, 0x19b7, 0x3, 0x2, 0x2, 0x2, 0x33a, 0x19bb, 
       0x3, 0x2, 0x2, 0x2, 0x33c, 0x19be, 0x3, 0x2, 0x2, 0x2, 0x33e, 0x19c1, 
       0x3, 0x2, 0x2, 0x2, 0x340, 0x19d9, 0x3, 0x2, 0x2, 0x2, 0x342, 0x19db, 
       0x3, 0x2, 0x2, 0x2, 0x344, 0x19e2, 0x3, 0x2, 0x2, 0x2, 0x346, 0x19e4, 
       0x3, 0x2, 0x2, 0x2, 0x348, 0x1a31, 0x3, 0x2, 0x2, 0x2, 0x34a, 0x1a33, 
       0x3, 0x2, 0x2, 0x2, 0x34c, 0x1a86, 0x3, 0x2, 0x2, 0x2, 0x34e, 0x1a96, 
       0x3, 0x2, 0x2, 0x2, 0x350, 0x1a98, 0x3, 0x2, 0x2, 0x2, 0x352, 0x1ab8, 
       0x3, 0x2, 0x2, 0x2, 0x354, 0x1aba, 0x3, 0x2, 0x2, 0x2, 0x356, 0x1ac5, 
       0x3, 0x2, 0x2, 0x2, 0x358, 0x1acc, 0x3, 0x2, 0x2, 0x2, 0x35a, 0x1adc, 
       0x3, 0x2, 0x2, 0x2, 0x35c, 0x1ae2, 0x3, 0x2, 0x2, 0x2, 0x35e, 0x1ae4, 
       0x3, 0x2, 0x2, 0x2, 0x360, 0x1ae8, 0x3, 0x2, 0x2, 0x2, 0x362, 0x1af4, 
       0x3, 0x2, 0x2, 0x2, 0x364, 0x1af6, 0x3, 0x2, 0x2, 0x2, 0x366, 0x1af8, 
       0x3, 0x2, 0x2, 0x2, 0x368, 0x1aff, 0x3, 0x2, 0x2, 0x2, 0x36a, 0x1b01, 
       0x3, 0x2, 0x2, 0x2, 0x36c, 0x1b03, 0x3, 0x2, 0x2, 0x2, 0x36e, 0x1b99, 
       0x3, 0x2, 0x2, 0x2, 0x370, 0x1b9e, 0x3, 0x2, 0x2, 0x2, 0x372, 0x1ba3, 
       0x3, 0x2, 0x2, 0x2, 0x374, 0x1baf, 0x3, 0x2, 0x2, 0x2, 0x376, 0x1bb1, 
       0x3, 0x2, 0x2, 0x2, 0x378, 0x1bb9, 0x3, 0x2, 0x2, 0x2, 0x37a, 0x1bcb, 
       0x3, 0x2, 0x2, 0x2, 0x37c, 0x1bd3, 0x3, 0x2, 0x2, 0x2, 0x37e, 0x1bdb, 
       0x3, 0x2, 0x2, 0x2, 0x380, 0x1bdd, 0x3, 0x2, 0x2, 0x2, 0x382, 0x1be1, 
       0x3, 0x2, 0x2, 0x2, 0x384, 0x1bea, 0x3, 0x2, 0x2, 0x2, 0x386, 0x1bef, 
       0x3, 0x2, 0x2, 0x2, 0x388, 0x1bf1, 0x3, 0x2, 0x2, 0x2, 0x38a, 0x1bfc, 
       0x3, 0x2, 0x2, 0x2, 0x38c, 0x1c82, 0x3, 0x2, 0x2, 0x2, 0x38e, 0x1c86, 
       0x3, 0x2, 0x2, 0x2, 0x390, 0x1c89, 0x3, 0x2, 0x2, 0x2, 0x392, 0x1c92, 
       0x3, 0x2, 0x2, 0x2, 0x394, 0x1c9b, 0x3, 0x2, 0x2, 0x2, 0x396, 0x1ca3, 
       0x3, 0x2, 0x2, 0x2, 0x398, 0x1cd1, 0x3, 0x2, 0x2, 0x2, 0x39a, 0x1cd3, 
       0x3, 0x2, 0x2, 
  };
  static uint16_t serializedATNSegment1[] = {
    0x2, 0x39c, 0x1ce8, 0x3, 0x2, 0x2, 0x2, 0x39e, 0x1ced, 0x3, 0x2, 0x2, 
       0x2, 0x3a0, 0x1cf8, 0x3, 0x2, 0x2, 0x2, 0x3a2, 0x1d25, 0x3, 0x2, 
       0x2, 0x2, 0x3a4, 0x1d49, 0x3, 0x2, 0x2, 0x2, 0x3a6, 0x1d4b, 0x3, 
       0x2, 0x2, 0x2, 0x3a8, 0x1d53, 0x3, 0x2, 0x2, 0x2, 0x3aa, 0x1d60, 
       0x3, 0x2, 0x2, 0x2, 0x3ac, 0x1d62, 0x3, 0x2, 0x2, 0x2, 0x3ae, 0x1d66, 
       0x3, 0x2, 0x2, 0x2, 0x3b0, 0x1d69, 0x3, 0x2, 0x2, 0x2, 0x3b2, 0x1d6e, 
       0x3, 0x2, 0x2, 0x2, 0x3b4, 0x1d72, 0x3, 0x2, 0x2, 0x2, 0x3b6, 0x1d75, 
       0x3, 0x2, 0x2, 0x2, 0x3b8, 0x1d78, 0x3, 0x2, 0x2, 0x2, 0x3ba, 0x1d7c, 
       0x3, 0x2, 0x2, 0x2, 0x3bc, 0x1d82, 0x3, 0x2, 0x2, 0x2, 0x3be, 0x1d8a, 
       0x3, 0x2, 0x2, 0x2, 0x3c0, 0x1d92, 0x3, 0x2, 0x2, 0x2, 0x3c2, 0x1d98, 
       0x3, 0x2, 0x2, 0x2, 0x3c4, 0x1d9b, 0x3, 0x2, 0x2, 0x2, 0x3c6, 0x1dad, 
       0x3, 0x2, 0x2, 0x2, 0x3c8, 0x1daf, 0x3, 0x2, 0x2, 0x2, 0x3ca, 0x1db5, 
       0x3, 0x2, 0x2, 0x2, 0x3cc, 0x1db9, 0x3, 0x2, 0x2, 0x2, 0x3ce, 0x1dc1, 
       0x3, 0x2, 0x2, 0x2, 0x3d0, 0x1dc9, 0x3, 0x2, 0x2, 0x2, 0x3d2, 0x1dd1, 
       0x3, 0x2, 0x2, 0x2, 0x3d4, 0x1de9, 0x3, 0x2, 0x2, 0x2, 0x3d6, 0x1e06, 
       0x3, 0x2, 0x2, 0x2, 0x3d8, 0x1e0a, 0x3, 0x2, 0x2, 0x2, 0x3da, 0x1e0e, 
       0x3, 0x2, 0x2, 0x2, 0x3dc, 0x1e1b, 0x3, 0x2, 0x2, 0x2, 0x3de, 0x1e1d, 
       0x3, 0x2, 0x2, 0x2, 0x3e0, 0x1e22, 0x3, 0x2, 0x2, 0x2, 0x3e2, 0x1e24, 
       0x3, 0x2, 0x2, 0x2, 0x3e4, 0x1e27, 0x3, 0x2, 0x2, 0x2, 0x3e6, 0x1e29, 
       0x3, 0x2, 0x2, 0x2, 0x3e8, 0x1e32, 0x3, 0x2, 0x2, 0x2, 0x3ea, 0x1e38, 
       0x3, 0x2, 0x2, 0x2, 0x3ec, 0x1e3a, 0x3, 0x2, 0x2, 0x2, 0x3ee, 0x1e3c, 
       0x3, 0x2, 0x2, 0x2, 0x3f0, 0x1e47, 0x3, 0x2, 0x2, 0x2, 0x3f2, 0x1e4b, 
       0x3, 0x2, 0x2, 0x2, 0x3f4, 0x1e4d, 0x3, 0x2, 0x2, 0x2, 0x3f6, 0x1e4f, 
       0x3, 0x2, 0x2, 0x2, 0x3f8, 0x1e51, 0x3, 0x2, 0x2, 0x2, 0x3fa, 0x1e5a, 
       0x3, 0x2, 0x2, 0x2, 0x3fc, 0x1e5c, 0x3, 0x2, 0x2, 0x2, 0x3fe, 0x1e5e, 
       0x3, 0x2, 0x2, 0x2, 0x400, 0x1e60, 0x3, 0x2, 0x2, 0x2, 0x402, 0x1e62, 
       0x3, 0x2, 0x2, 0x2, 0x404, 0x1e64, 0x3, 0x2, 0x2, 0x2, 0x406, 0x1e66, 
       0x3, 0x2, 0x2, 0x2, 0x408, 0x1e68, 0x3, 0x2, 0x2, 0x2, 0x40a, 0x1e6c, 
       0x3, 0x2, 0x2, 0x2, 0x40c, 0x1e70, 0x3, 0x2, 0x2, 0x2, 0x40e, 0x1e72, 
       0x3, 0x2, 0x2, 0x2, 0x410, 0x1e74, 0x3, 0x2, 0x2, 0x2, 0x412, 0x1e76, 
       0x3, 0x2, 0x2, 0x2, 0x414, 0x1e78, 0x3, 0x2, 0x2, 0x2, 0x416, 0x1e7a, 
       0x3, 0x2, 0x2, 0x2, 0x418, 0x1e7c, 0x3, 0x2, 0x2, 0x2, 0x41a, 0x1e7e, 
       0x3, 0x2, 0x2, 0x2, 0x41c, 0x1e80, 0x3, 0x2, 0x2, 0x2, 0x41e, 0x1e82, 
       0x3, 0x2, 0x2, 0x2, 0x420, 0x1e84, 0x3, 0x2, 0x2, 0x2, 0x422, 0x1e88, 
       0x3, 0x2, 0x2, 0x2, 0x424, 0x1e8a, 0x3, 0x2, 0x2, 0x2, 0x426, 0x1e8d, 
       0x3, 0x2, 0x2, 0x2, 0x428, 0x1e99, 0x3, 0x2, 0x2, 0x2, 0x42a, 0x1e9b, 
       0x3, 0x2, 0x2, 0x2, 0x42c, 0x1ea3, 0x3, 0x2, 0x2, 0x2, 0x42e, 0x1eab, 
       0x3, 0x2, 0x2, 0x2, 0x430, 0x1eaf, 0x3, 0x2, 0x2, 0x2, 0x432, 0x1eb1, 
       0x3, 0x2, 0x2, 0x2, 0x434, 0x1eb5, 0x3, 0x2, 0x2, 0x2, 0x436, 0x1eb7, 
       0x3, 0x2, 0x2, 0x2, 0x438, 0x1eb9, 0x3, 0x2, 0x2, 0x2, 0x43a, 0x1ebb, 
       0x3, 0x2, 0x2, 0x2, 0x43c, 0x1ebd, 0x3, 0x2, 0x2, 0x2, 0x43e, 0x1ebf, 
       0x3, 0x2, 0x2, 0x2, 0x440, 0x1ec4, 0x3, 0x2, 0x2, 0x2, 0x442, 0x1ec8, 
       0x3, 0x2, 0x2, 0x2, 0x444, 0x1eca, 0x3, 0x2, 0x2, 0x2, 0x446, 0x1ed2, 
       0x3, 0x2, 0x2, 0x2, 0x448, 0x1ed6, 0x3, 0x2, 0x2, 0x2, 0x44a, 0x1ee5, 
       0x3, 0x2, 0x2, 0x2, 0x44c, 0x1ee7, 0x3, 0x2, 0x2, 0x2, 0x44e, 0x1eea, 
       0x3, 0x2, 0x2, 0x2, 0x450, 0x1eec, 0x3, 0x2, 0x2, 0x2, 0x452, 0x1eee, 
       0x3, 0x2, 0x2, 0x2, 0x454, 0x1ef0, 0x3, 0x2, 0x2, 0x2, 0x456, 0x1efb, 
       0x3, 0x2, 0x2, 0x2, 0x458, 0x1f02, 0x3, 0x2, 0x2, 0x2, 0x45a, 0x1f04, 
       0x3, 0x2, 0x2, 0x2, 0x45c, 0x1f12, 0x3, 0x2, 0x2, 0x2, 0x45e, 0x1f17, 
       0x3, 0x2, 0x2, 0x2, 0x460, 0x1f1e, 0x3, 0x2, 0x2, 0x2, 0x462, 0x1f26, 
       0x3, 0x2, 0x2, 0x2, 0x464, 0x1f28, 0x3, 0x2, 0x2, 0x2, 0x466, 0x1f30, 
       0x3, 0x2, 0x2, 0x2, 0x468, 0x1f32, 0x3, 0x2, 0x2, 0x2, 0x46a, 0x1f34, 
       0x3, 0x2, 0x2, 0x2, 0x46c, 0x1f3c, 0x3, 0x2, 0x2, 0x2, 0x46e, 0x1f40, 
       0x3, 0x2, 0x2, 0x2, 0x470, 0x1f42, 0x3, 0x2, 0x2, 0x2, 0x472, 0x1f4a, 
       0x3, 0x2, 0x2, 0x2, 0x474, 0x1f4e, 0x3, 0x2, 0x2, 0x2, 0x476, 0x1f52, 
       0x3, 0x2, 0x2, 0x2, 0x478, 0x1f54, 0x3, 0x2, 0x2, 0x2, 0x47a, 0x1f57, 
       0x3, 0x2, 0x2, 0x2, 0x47c, 0x1f59, 0x3, 0x2, 0x2, 0x2, 0x47e, 0x1f61, 
       0x3, 0x2, 0x2, 0x2, 0x480, 0x1f6d, 0x3, 0x2, 0x2, 0x2, 0x482, 0x1f76, 
       0x3, 0x2, 0x2, 0x2, 0x484, 0x1f82, 0x3, 0x2, 0x2, 0x2, 0x486, 0x1f89, 
       0x3, 0x2, 0x2, 0x2, 0x488, 0x1f94, 0x3, 0x2, 0x2, 0x2, 0x48a, 0x1f98, 
       0x3, 0x2, 0x2, 0x2, 0x48c, 0x499, 0x7, 0x2, 0x2, 0x3, 0x48d, 0x490, 
       0x5, 0x4, 0x3, 0x2, 0x48e, 0x490, 0x5, 0x19e, 0xd0, 0x2, 0x48f, 0x48d, 
       0x3, 0x2, 0x2, 0x2, 0x48f, 0x48e, 0x3, 0x2, 0x2, 0x2, 0x490, 0x496, 
       0x3, 0x2, 0x2, 0x2, 0x491, 0x493, 0x7, 0x199, 0x2, 0x2, 0x492, 0x494, 
       0x7, 0x2, 0x2, 0x3, 0x493, 0x492, 0x3, 0x2, 0x2, 0x2, 0x493, 0x494, 
       0x3, 0x2, 0x2, 0x2, 0x494, 0x497, 0x3, 0x2, 0x2, 0x2, 0x495, 0x497, 
       0x7, 0x2, 0x2, 0x3, 0x496, 0x491, 0x3, 0x2, 0x2, 0x2, 0x496, 0x495, 
       0x3, 0x2, 0x2, 0x2, 0x497, 0x499, 0x3, 0x2, 0x2, 0x2, 0x498, 0x48c, 
       0x3, 0x2, 0x2, 0x2, 0x498, 0x48f, 0x3, 0x2, 0x2, 0x2, 0x499, 0x3, 
       0x3, 0x2, 0x2, 0x2, 0x49a, 0x4bf, 0x5, 0x6, 0x4, 0x2, 0x49b, 0x4bf, 
       0x5, 0x50, 0x29, 0x2, 0x49c, 0x4bf, 0x5, 0xb6, 0x5c, 0x2, 0x49d, 
       0x4bf, 0x5, 0xd6, 0x6c, 0x2, 0x49e, 0x4bf, 0x5, 0xda, 0x6e, 0x2, 
       0x49f, 0x4a0, 0x6, 0x3, 0x2, 0x2, 0x4a0, 0x4bf, 0x5, 0xdc, 0x6f, 
       0x2, 0x4a1, 0x4bf, 0x5, 0xde, 0x70, 0x2, 0x4a2, 0x4bf, 0x5, 0xe0, 
       0x71, 0x2, 0x4a3, 0x4bf, 0x5, 0xe6, 0x74, 0x2, 0x4a4, 0x4bf, 0x5, 
       0xe8, 0x75, 0x2, 0x4a5, 0x4bf, 0x5, 0xec, 0x77, 0x2, 0x4a6, 0x4bf, 
       0x5, 0xfe, 0x80, 0x2, 0x4a7, 0x4bf, 0x5, 0x10a, 0x86, 0x2, 0x4a8, 
       0x4bf, 0x5, 0x10c, 0x87, 0x2, 0x4a9, 0x4bf, 0x5, 0x198, 0xcd, 0x2, 
       0x4aa, 0x4bf, 0x5, 0x19a, 0xce, 0x2, 0x4ab, 0x4bf, 0x5, 0x1b4, 0xdb, 
       0x2, 0x4ac, 0x4bf, 0x5, 0x1e0, 0xf1, 0x2, 0x4ad, 0x4ae, 0x6, 0x3, 
       0x3, 0x2, 0x4ae, 0x4bf, 0x5, 0x1e6, 0xf4, 0x2, 0x4af, 0x4bf, 0x5, 
       0x1ec, 0xf7, 0x2, 0x4b0, 0x4bf, 0x5, 0x224, 0x113, 0x2, 0x4b1, 0x4bf, 
       0x5, 0x22c, 0x117, 0x2, 0x4b2, 0x4bf, 0x5, 0x22e, 0x118, 0x2, 0x4b3, 
       0x4bf, 0x5, 0x23c, 0x11f, 0x2, 0x4b4, 0x4b5, 0x6, 0x3, 0x4, 0x2, 
       0x4b5, 0x4bf, 0x5, 0x268, 0x135, 0x2, 0x4b6, 0x4bf, 0x5, 0x248, 0x125, 
       0x2, 0x4b7, 0x4bf, 0x5, 0x27c, 0x13f, 0x2, 0x4b8, 0x4b9, 0x6, 0x3, 
       0x5, 0x2, 0x4b9, 0x4bf, 0x5, 0x32a, 0x196, 0x2, 0x4ba, 0x4bb, 0x6, 
       0x3, 0x6, 0x2, 0x4bb, 0x4bf, 0x5, 0x334, 0x19b, 0x2, 0x4bc, 0x4bd, 
       0x6, 0x3, 0x7, 0x2, 0x4bd, 0x4bf, 0x5, 0x336, 0x19c, 0x2, 0x4be, 
       0x49a, 0x3, 0x2, 0x2, 0x2, 0x4be, 0x49b, 0x3, 0x2, 0x2, 0x2, 0x4be, 
       0x49c, 0x3, 0x2, 0x2, 0x2, 0x4be, 0x49d, 0x3, 0x2, 0x2, 0x2, 0x4be, 
       0x49e, 0x3, 0x2, 0x2, 0x2, 0x4be, 0x49f, 0x3, 0x2, 0x2, 0x2, 0x4be, 
       0x4a1, 0x3, 0x2, 0x2, 0x2, 0x4be, 0x4a2, 0x3, 0x2, 0x2, 0x2, 0x4be, 
       0x4a3, 0x3, 0x2, 0x2, 0x2, 0x4be, 0x4a4, 0x3, 0x2, 0x2, 0x2, 0x4be, 
       0x4a5, 0x3, 0x2, 0x2, 0x2, 0x4be, 0x4a6, 0x3, 0x2, 0x2, 0x2, 0x4be, 
       0x4a7, 0x3, 0x2, 0x2, 0x2, 0x4be, 0x4a8, 0x3, 0x2, 0x2, 0x2, 0x4be, 
       0x4a9, 0x3, 0x2, 0x2, 0x2, 0x4be, 0x4aa, 0x3, 0x2, 0x2, 0x2, 0x4be, 
       0x4ab, 0x3, 0x2, 0x2, 0x2, 0x4be, 0x4ac, 0x3, 0x2, 0x2, 0x2, 0x4be, 
       0x4ad, 0x3, 0x2, 0x2, 0x2, 0x4be, 0x4af, 0x3, 0x2, 0x2, 0x2, 0x4be, 
       0x4b0, 0x3, 0x2, 0x2, 0x2, 0x4be, 0x4b1, 0x3, 0x2, 0x2, 0x2, 0x4be, 
       0x4b2, 0x3, 0x2, 0x2, 0x2, 0x4be, 0x4b3, 0x3, 0x2, 0x2, 0x2, 0x4be, 
       0x4b4, 0x3, 0x2, 0x2, 0x2, 0x4be, 0x4b6, 0x3, 0x2, 0x2, 0x2, 0x4be, 
       0x4b7, 0x3, 0x2, 0x2, 0x2, 0x4be, 0x4b8, 0x3, 0x2, 0x2, 0x2, 0x4be, 
       0x4ba, 0x3, 0x2, 0x2, 0x2, 0x4be, 0x4bc, 0x3, 0x2, 0x2, 0x2, 0x4bf, 
       0x5, 0x3, 0x2, 0x2, 0x2, 0x4c0, 0x4db, 0x7, 0x1ae, 0x2, 0x2, 0x4c1, 
       0x4dc, 0x5, 0x14, 0xb, 0x2, 0x4c2, 0x4dc, 0x5, 0x8, 0x5, 0x2, 0x4c3, 
       0x4c4, 0x7, 0x253, 0x2, 0x2, 0x4c4, 0x4c6, 0x5, 0x400, 0x201, 0x2, 
       0x4c5, 0x4c7, 0x5, 0x6a, 0x36, 0x2, 0x4c6, 0x4c5, 0x3, 0x2, 0x2, 
       0x2, 0x4c6, 0x4c7, 0x3, 0x2, 0x2, 0x2, 0x4c7, 0x4dc, 0x3, 0x2, 0x2, 
       0x2, 0x4c8, 0x4c9, 0x7, 0x166, 0x2, 0x2, 0x4c9, 0x4cb, 0x5, 0x404, 
       0x203, 0x2, 0x4ca, 0x4cc, 0x5, 0x6a, 0x36, 0x2, 0x4cb, 0x4ca, 0x3, 
       0x2, 0x2, 0x2, 0x4cb, 0x4cc, 0x3, 0x2, 0x2, 0x2, 0x4cc, 0x4dc, 0x3, 
       0x2, 0x2, 0x2, 0x4cd, 0x4dc, 0x5, 0x48, 0x25, 0x2, 0x4ce, 0x4dc, 
       0x5, 0xa, 0x6, 0x2, 0x4cf, 0x4dc, 0x5, 0x3a, 0x1e, 0x2, 0x4d0, 0x4d1, 
       0x6, 0x4, 0x8, 0x2, 0x4d1, 0x4dc, 0x5, 0x3c, 0x1f, 0x2, 0x4d2, 0x4dc, 
       0x5, 0xc, 0x7, 0x2, 0x4d3, 0x4dc, 0x5, 0x12, 0xa, 0x2, 0x4d4, 0x4d5, 
       0x6, 0x4, 0x9, 0x2, 0x4d5, 0x4d6, 0x7, 0xa7, 0x2, 0x2, 0x4d6, 0x4d7, 
       0x7, 0x12a, 0x2, 0x2, 0x4d7, 0x4d8, 0x5, 0x472, 0x23a, 0x2, 0x4d8, 
       0x4d9, 0x7, 0xbb, 0x2, 0x2, 0x4d9, 0x4da, 0x7, 0x21a, 0x2, 0x2, 0x4da, 
       0x4dc, 0x3, 0x2, 0x2, 0x2, 0x4db, 0x4c1, 0x3, 0x2, 0x2, 0x2, 0x4db, 
       0x4c2, 0x3, 0x2, 0x2, 0x2, 0x4db, 0x4c3, 0x3, 0x2, 0x2, 0x2, 0x4db, 
       0x4c8, 0x3, 0x2, 0x2, 0x2, 0x4db, 0x4cd, 0x3, 0x2, 0x2, 0x2, 0x4db, 
       0x4ce, 0x3, 0x2, 0x2, 0x2, 0x4db, 0x4cf, 0x3, 0x2, 0x2, 0x2, 0x4db, 
       0x4d0, 0x3, 0x2, 0x2, 0x2, 0x4db, 0x4d2, 0x3, 0x2, 0x2, 0x2, 0x4db, 
       0x4d3, 0x3, 0x2, 0x2, 0x2, 0x4db, 0x4d4, 0x3, 0x2, 0x2, 0x2, 0x4dc, 
       0x7, 0x3, 0x2, 0x2, 0x2, 0x4dd, 0x4de, 0x7, 0x1d5, 0x2, 0x2, 0x4de, 
       0x4e9, 0x5, 0x3fc, 0x1ff, 0x2, 0x4df, 0x4e1, 0x5, 0x54, 0x2b, 0x2, 
       0x4e0, 0x4df, 0x3, 0x2, 0x2, 0x2, 0x4e1, 0x4e2, 0x3, 0x2, 0x2, 0x2, 
       0x4e2, 0x4e0, 0x3, 0x2, 0x2, 0x2, 0x4e2, 0x4e3, 0x3, 0x2, 0x2, 0x2, 
       0x4e3, 0x4ea, 0x3, 0x2, 0x2, 0x2, 0x4e4, 0x4e5, 0x6, 0x5, 0xa, 0x2, 
       0x4e5, 0x4e6, 0x7, 0x37, 0x2, 0x2, 0x4e6, 0x4e7, 0x7, 0x6f, 0x2, 
       0x2, 0x4e7, 0x4e8, 0x7, 0x79, 0x2, 0x2, 0x4e8, 0x4ea, 0x7, 0xe7, 
       0x2, 0x2, 0x4e9, 0x4e0, 0x3, 0x2, 0x2, 0x2, 0x4e9, 0x4e4, 0x3, 0x2, 
       0x2, 0x2, 0x4ea, 0x9, 0x3, 0x2, 0x2, 0x2, 0x4eb, 0x4ed, 0x5, 0x3ac, 
       0x1d7, 0x2, 0x4ec, 0x4eb, 0x3, 0x2, 0x2, 0x2, 0x4ec, 0x4ed, 0x3, 
       0x2, 0x2, 0x2, 0x4ed, 0x4ee, 0x3, 0x2, 0x2, 0x2, 0x4ee, 0x4ef, 0x7, 
       0x87, 0x2, 0x2, 0x4ef, 0x4f3, 0x5, 0x418, 0x20d, 0x2, 0x4f0, 0x4f1, 
       0x7, 0x244, 0x2, 0x2, 0x4f1, 0x4f2, 0x7, 0x131, 0x2, 0x2, 0x4f2, 
       0x4f4, 0x5, 0x340, 0x1a1, 0x2, 0x4f3, 0x4f0, 0x3, 0x2, 0x2, 0x2, 
       0x4f3, 0x4f4, 0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4fb, 0x3, 0x2, 0x2, 0x2, 
       0x4f5, 0x4f6, 0x7, 0x244, 0x2, 0x2, 0x4f6, 0x4f8, 0x7, 0x5f, 0x2, 
       0x2, 0x4f7, 0x4f9, 0x7, 0x23e, 0x2, 0x2, 0x4f8, 0x4f7, 0x3, 0x2, 
       0x2, 0x2, 0x4f8, 0x4f9, 0x3, 0x2, 0x2, 0x2, 0x4f9, 0x4fa, 0x3, 0x2, 
       0x2, 0x2, 0x4fa, 0x4fc, 0x7, 0x104, 0x2, 0x2, 0x4fb, 0x4f5, 0x3, 
       0x2, 0x2, 0x2, 0x4fb, 0x4fc, 0x3, 0x2, 0x2, 0x2, 0x4fc, 0x500, 0x3, 
       0x2, 0x2, 0x2, 0x4fd, 0x4fe, 0x7, 0x25d, 0x2, 0x2, 0x4fe, 0x4ff, 
       0x7, 0x28e, 0x2, 0x2, 0x4ff, 0x501, 0x5, 0x442, 0x222, 0x2, 0x500, 
       0x4fd, 0x3, 0x2, 0x2, 0x2, 0x500, 0x501, 0x3, 0x2, 0x2, 0x2, 0x501, 
       0x508, 0x3, 0x2, 0x2, 0x2, 0x502, 0x509, 0x7, 0x91, 0x2, 0x2, 0x503, 
       0x506, 0x7, 0x7a, 0x2, 0x2, 0x504, 0x505, 0x7, 0x244, 0x2, 0x2, 0x505, 
       0x507, 0x7, 0x2f, 0x2, 0x2, 0x506, 0x504, 0x3, 0x2, 0x2, 0x2, 0x506, 
       0x507, 0x3, 0x2, 0x2, 0x2, 0x507, 0x509, 0x3, 0x2, 0x2, 0x2, 0x508, 
       0x502, 0x3, 0x2, 0x2, 0x2, 0x508, 0x503, 0x3, 0x2, 0x2, 0x2, 0x508, 
       0x509, 0x3, 0x2, 0x2, 0x2, 0x509, 0x50c, 0x3, 0x2, 0x2, 0x2, 0x50a, 
       0x50b, 0x7, 0xd, 0x2, 0x2, 0x50b, 0x50d, 0x5, 0x460, 0x231, 0x2, 
       0x50c, 0x50a, 0x3, 0x2, 0x2, 0x2, 0x50c, 0x50d, 0x3, 0x2, 0x2, 0x2, 
       0x50d, 0x510, 0x3, 0x2, 0x2, 0x2, 0x50e, 0x50f, 0x7, 0x11, 0x2, 0x2, 
       0x50f, 0x511, 0x5, 0x2f2, 0x17a, 0x2, 0x510, 0x50e, 0x3, 0x2, 0x2, 
       0x2, 0x510, 0x511, 0x3, 0x2, 0x2, 0x2, 0x511, 0xb, 0x3, 0x2, 0x2, 
       0x2, 0x512, 0x513, 0x7, 0xb8, 0x2, 0x2, 0x513, 0x514, 0x7, 0x201, 
       0x2, 0x2, 0x514, 0x515, 0x5, 0x414, 0x20b, 0x2, 0x515, 0x516, 0x7, 
       0x1ac, 0x2, 0x2, 0x516, 0x517, 0x7, 0x16a, 0x2, 0x2, 0x517, 0x519, 
       0x5, 0x460, 0x231, 0x2, 0x518, 0x51a, 0x5, 0xe, 0x8, 0x2, 0x519, 
       0x518, 0x3, 0x2, 0x2, 0x2, 0x519, 0x51a, 0x3, 0x2, 0x2, 0x2, 0x51a, 
       0xd, 0x3, 0x2, 0x2, 0x2, 0x51b, 0x522, 0x5, 0x10, 0x9, 0x2, 0x51c, 
       0x51e, 0x7, 0x198, 0x2, 0x2, 0x51d, 0x51c, 0x3, 0x2, 0x2, 0x2, 0x51d, 
       0x51e, 0x3, 0x2, 0x2, 0x2, 0x51e, 0x51f, 0x3, 0x2, 0x2, 0x2, 0x51f, 
       0x521, 0x5, 0x10, 0x9, 0x2, 0x520, 0x51d, 0x3, 0x2, 0x2, 0x2, 0x521, 
       0x524, 0x3, 0x2, 0x2, 0x2, 0x522, 0x520, 0x3, 0x2, 0x2, 0x2, 0x522, 
       0x523, 0x3, 0x2, 0x2, 0x2, 0x523, 0xf, 0x3, 0x2, 0x2, 0x2, 0x524, 
       0x522, 0x3, 0x2, 0x2, 0x2, 0x525, 0x529, 0x5, 0x8c, 0x47, 0x2, 0x526, 
       0x529, 0x5, 0x98, 0x4d, 0x2, 0x527, 0x529, 0x5, 0x9a, 0x4e, 0x2, 
       0x528, 0x525, 0x3, 0x2, 0x2, 0x2, 0x528, 0x526, 0x3, 0x2, 0x2, 0x2, 
       0x528, 0x527, 0x3, 0x2, 0x2, 0x2, 0x529, 0x11, 0x3, 0x2, 0x2, 0x2, 
       0x52a, 0x52b, 0x7, 0x2d, 0x2, 0x2, 0x52b, 0x52c, 0x5, 0x41e, 0x210, 
       0x2, 0x52c, 0x52d, 0x5, 0x7c, 0x3f, 0x2, 0x52d, 0x13, 0x3, 0x2, 0x2, 
       0x2, 0x52e, 0x530, 0x5, 0x3e2, 0x1f2, 0x2, 0x52f, 0x52e, 0x3, 0x2, 
       0x2, 0x2, 0x52f, 0x530, 0x3, 0x2, 0x2, 0x2, 0x530, 0x533, 0x3, 0x2, 
       0x2, 0x2, 0x531, 0x532, 0x6, 0xb, 0xb, 0x2, 0x532, 0x534, 0x7, 0x209, 
       0x2, 0x2, 0x533, 0x531, 0x3, 0x2, 0x2, 0x2, 0x533, 0x534, 0x3, 0x2, 
       0x2, 0x2, 0x534, 0x535, 0x3, 0x2, 0x2, 0x2, 0x535, 0x536, 0x7, 0x288, 
       0x2, 0x2, 0x536, 0x538, 0x5, 0x428, 0x215, 0x2, 0x537, 0x539, 0x5, 
       0x16, 0xc, 0x2, 0x538, 0x537, 0x3, 0x2, 0x2, 0x2, 0x538, 0x539, 0x3, 
       0x2, 0x2, 0x2, 0x539, 0x15, 0x3, 0x2, 0x2, 0x2, 0x53a, 0x53d, 0x5, 
       0x18, 0xd, 0x2, 0x53b, 0x53e, 0x5, 0x396, 0x1cc, 0x2, 0x53c, 0x53e, 
       0x5, 0x34, 0x1b, 0x2, 0x53d, 0x53b, 0x3, 0x2, 0x2, 0x2, 0x53d, 0x53c, 
       0x3, 0x2, 0x2, 0x2, 0x53d, 0x53e, 0x3, 0x2, 0x2, 0x2, 0x53e, 0x548, 
       0x3, 0x2, 0x2, 0x2, 0x53f, 0x548, 0x5, 0x396, 0x1cc, 0x2, 0x540, 
       0x548, 0x5, 0x34, 0x1b, 0x2, 0x541, 0x542, 0x5, 0x1a, 0xe, 0x2, 0x542, 
       0x543, 0x7, 0x198, 0x2, 0x2, 0x543, 0x545, 0x3, 0x2, 0x2, 0x2, 0x544, 
       0x541, 0x3, 0x2, 0x2, 0x2, 0x544, 0x545, 0x3, 0x2, 0x2, 0x2, 0x545, 
       0x546, 0x3, 0x2, 0x2, 0x2, 0x546, 0x548, 0x5, 0x1c, 0xf, 0x2, 0x547, 
       0x53a, 0x3, 0x2, 0x2, 0x2, 0x547, 0x53f, 0x3, 0x2, 0x2, 0x2, 0x547, 
       0x540, 0x3, 0x2, 0x2, 0x2, 0x547, 0x544, 0x3, 0x2, 0x2, 0x2, 0x548, 
       0x17, 0x3, 0x2, 0x2, 0x2, 0x549, 0x551, 0x5, 0x1a, 0xe, 0x2, 0x54a, 
       0x54b, 0x5, 0x1a, 0xe, 0x2, 0x54b, 0x54c, 0x7, 0x198, 0x2, 0x2, 0x54c, 
       0x54e, 0x3, 0x2, 0x2, 0x2, 0x54d, 0x54a, 0x3, 0x2, 0x2, 0x2, 0x54d, 
       0x54e, 0x3, 0x2, 0x2, 0x2, 0x54e, 0x54f, 0x3, 0x2, 0x2, 0x2, 0x54f, 
       0x551, 0x5, 0x20, 0x11, 0x2, 0x550, 0x549, 0x3, 0x2, 0x2, 0x2, 0x550, 
       0x54d, 0x3, 0x2, 0x2, 0x2, 0x551, 0x19, 0x3, 0x2, 0x2, 0x2, 0x552, 
       0x557, 0x5, 0x22, 0x12, 0x2, 0x553, 0x554, 0x7, 0x198, 0x2, 0x2, 
       0x554, 0x556, 0x5, 0x22, 0x12, 0x2, 0x555, 0x553, 0x3, 0x2, 0x2, 
       0x2, 0x556, 0x559, 0x3, 0x2, 0x2, 0x2, 0x557, 0x555, 0x3, 0x2, 0x2, 
       0x2, 0x557, 0x558, 0x3, 0x2, 0x2, 0x2, 0x558, 0x1b, 0x3, 0x2, 0x2, 
       0x2, 0x559, 0x557, 0x3, 0x2, 0x2, 0x2, 0x55a, 0x55b, 0x7, 0x7b, 0x2, 
       0x2, 0x55b, 0x562, 0x7, 0x158, 0x2, 0x2, 0x55c, 0x55d, 0x7, 0xa4, 
       0x2, 0x2, 0x55d, 0x562, 0x7, 0x158, 0x2, 0x2, 0x55e, 0x562, 0x5, 
       0x1e, 0x10, 0x2, 0x55f, 0x560, 0x6, 0xf, 0xc, 0x2, 0x560, 0x562, 
       0x9, 0x2, 0x2, 0x2, 0x561, 0x55a, 0x3, 0x2, 0x2, 0x2, 0x561, 0x55c, 
       0x3, 0x2, 0x2, 0x2, 0x561, 0x55e, 0x3, 0x2, 0x2, 0x2, 0x561, 0x55f, 
       0x3, 0x2, 0x2, 0x2, 0x562, 0x1d, 0x3, 0x2, 0x2, 0x2, 0x563, 0x564, 
       0x7, 0x1ac, 0x2, 0x2, 0x564, 0x566, 0x7, 0x22, 0x2, 0x2, 0x565, 0x567, 
       0x5, 0x3e4, 0x1f3, 0x2, 0x566, 0x565, 0x3, 0x2, 0x2, 0x2, 0x566, 
       0x567, 0x3, 0x2, 0x2, 0x2, 0x567, 0x56b, 0x3, 0x2, 0x2, 0x2, 0x568, 
       0x56c, 0x5, 0x39e, 0x1d0, 0x2, 0x569, 0x56a, 0x7, 0xfc, 0x2, 0x2, 
       0x56a, 0x56c, 0x5, 0x450, 0x229, 0x2, 0x56b, 0x568, 0x3, 0x2, 0x2, 
       0x2, 0x56b, 0x569, 0x3, 0x2, 0x2, 0x2, 0x56c, 0x5c6, 0x3, 0x2, 0x2, 
       0x2, 0x56d, 0x56e, 0x7, 0x1e9, 0x2, 0x2, 0x56e, 0x56f, 0x7, 0x22, 
       0x2, 0x2, 0x56f, 0x5c6, 0x5, 0x444, 0x223, 0x2, 0x570, 0x571, 0x7, 
       0x110, 0x2, 0x2, 0x571, 0x573, 0x7, 0x22, 0x2, 0x2, 0x572, 0x574, 
       0x5, 0x3e4, 0x1f3, 0x2, 0x573, 0x572, 0x3, 0x2, 0x2, 0x2, 0x573, 
       0x574, 0x3, 0x2, 0x2, 0x2, 0x574, 0x575, 0x3, 0x2, 0x2, 0x2, 0x575, 
       0x5c6, 0x5, 0x36, 0x1c, 0x2, 0x576, 0x577, 0x7, 0x247, 0x2, 0x2, 
       0x577, 0x579, 0x7, 0x22, 0x2, 0x2, 0x578, 0x57a, 0x5, 0x3e4, 0x1f3, 
       0x2, 0x579, 0x578, 0x3, 0x2, 0x2, 0x2, 0x579, 0x57a, 0x3, 0x2, 0x2, 
       0x2, 0x57a, 0x57b, 0x3, 0x2, 0x2, 0x2, 0x57b, 0x57d, 0x5, 0x36, 0x1c, 
       0x2, 0x57c, 0x57e, 0x5, 0x3e4, 0x1f3, 0x2, 0x57d, 0x57c, 0x3, 0x2, 
       0x2, 0x2, 0x57d, 0x57e, 0x3, 0x2, 0x2, 0x2, 0x57e, 0x5c6, 0x3, 0x2, 
       0x2, 0x2, 0x57f, 0x580, 0x7, 0x41, 0x2, 0x2, 0x580, 0x582, 0x7, 0x22, 
       0x2, 0x2, 0x581, 0x583, 0x5, 0x3e4, 0x1f3, 0x2, 0x582, 0x581, 0x3, 
       0x2, 0x2, 0x2, 0x582, 0x583, 0x3, 0x2, 0x2, 0x2, 0x583, 0x584, 0x3, 
       0x2, 0x2, 0x2, 0x584, 0x5c6, 0x5, 0x36, 0x1c, 0x2, 0x585, 0x586, 
       0x7, 0x1c5, 0x2, 0x2, 0x586, 0x587, 0x7, 0x22, 0x2, 0x2, 0x587, 0x58b, 
       0x5, 0x36, 0x1c, 0x2, 0x588, 0x58a, 0x5, 0x228, 0x115, 0x2, 0x589, 
       0x588, 0x3, 0x2, 0x2, 0x2, 0x58a, 0x58d, 0x3, 0x2, 0x2, 0x2, 0x58b, 
       0x589, 0x3, 0x2, 0x2, 0x2, 0x58b, 0x58c, 0x3, 0x2, 0x2, 0x2, 0x58c, 
       0x5c6, 0x3, 0x2, 0x2, 0x2, 0x58d, 0x58b, 0x3, 0x2, 0x2, 0x2, 0x58e, 
       0x58f, 0x7, 0x27, 0x2, 0x2, 0x58f, 0x591, 0x7, 0x22, 0x2, 0x2, 0x590, 
       0x592, 0x5, 0x3e4, 0x1f3, 0x2, 0x591, 0x590, 0x3, 0x2, 0x2, 0x2, 
       0x591, 0x592, 0x3, 0x2, 0x2, 0x2, 0x592, 0x593, 0x3, 0x2, 0x2, 0x2, 
       0x593, 0x597, 0x5, 0x36, 0x1c, 0x2, 0x594, 0x596, 0x5, 0x22a, 0x116, 
       0x2, 0x595, 0x594, 0x3, 0x2, 0x2, 0x2, 0x596, 0x599, 0x3, 0x2, 0x2, 
       0x2, 0x597, 0x595, 0x3, 0x2, 0x2, 0x2, 0x597, 0x598, 0x3, 0x2, 0x2, 
       0x2, 0x598, 0x5c6, 0x3, 0x2, 0x2, 0x2, 0x599, 0x597, 0x3, 0x2, 0x2, 
       0x2, 0x59a, 0x59b, 0x7, 0x57, 0x2, 0x2, 0x59b, 0x59d, 0x7, 0x22, 
       0x2, 0x2, 0x59c, 0x59e, 0x5, 0x3e4, 0x1f3, 0x2, 0x59d, 0x59c, 0x3, 
       0x2, 0x2, 0x2, 0x59d, 0x59e, 0x3, 0x2, 0x2, 0x2, 0x59e, 0x59f, 0x3, 
       0x2, 0x2, 0x2, 0x59f, 0x5c6, 0x5, 0x450, 0x229, 0x2, 0x5a0, 0x5a1, 
       0x6, 0x10, 0xd, 0x2, 0x5a1, 0x5a2, 0x7, 0x34, 0x2, 0x2, 0x5a2, 0x5a3, 
       0x7, 0x22, 0x2, 0x2, 0x5a3, 0x5c6, 0x5, 0x36, 0x1c, 0x2, 0x5a4, 0x5c6, 
       0x5, 0x38, 0x1d, 0x2, 0x5a5, 0x5a6, 0x7, 0x11b, 0x2, 0x2, 0x5a6, 
       0x5a8, 0x7, 0x22, 0x2, 0x2, 0x5a7, 0x5a9, 0x5, 0x3e4, 0x1f3, 0x2, 
       0x5a8, 0x5a7, 0x3, 0x2, 0x2, 0x2, 0x5a8, 0x5a9, 0x3, 0x2, 0x2, 0x2, 
       0x5a9, 0x5ae, 0x3, 0x2, 0x2, 0x2, 0x5aa, 0x5ab, 0x5, 0x444, 0x223, 
       0x2, 0x5ab, 0x5ac, 0x7, 0x211, 0x2, 0x2, 0x5ac, 0x5ad, 0x5, 0x39e, 
       0x1d0, 0x2, 0x5ad, 0x5af, 0x3, 0x2, 0x2, 0x2, 0x5ae, 0x5aa, 0x3, 
       0x2, 0x2, 0x2, 0x5ae, 0x5af, 0x3, 0x2, 0x2, 0x2, 0x5af, 0x5c6, 0x3, 
       0x2, 0x2, 0x2, 0x5b0, 0x5b1, 0x7, 0x1f1, 0x2, 0x2, 0x5b1, 0x5b2, 
       0x7, 0x22, 0x2, 0x2, 0x5b2, 0x5b3, 0x5, 0x442, 0x222, 0x2, 0x5b3, 
       0x5b4, 0x7, 0x2ab, 0x2, 0x2, 0x5b4, 0x5b5, 0x7, 0x288, 0x2, 0x2, 
       0x5b5, 0x5b7, 0x5, 0x428, 0x215, 0x2, 0x5b6, 0x5b8, 0x5, 0x32, 0x1a, 
       0x2, 0x5b7, 0x5b6, 0x3, 0x2, 0x2, 0x2, 0x5b7, 0x5b8, 0x3, 0x2, 0x2, 
       0x2, 0x5b8, 0x5c6, 0x3, 0x2, 0x2, 0x2, 0x5b9, 0x5ba, 0x6, 0x10, 0xe, 
       0x2, 0x5ba, 0x5bb, 0x7, 0x7b, 0x2, 0x2, 0x5bb, 0x5bc, 0x7, 0x22, 
       0x2, 0x2, 0x5bc, 0x5bd, 0x5, 0x36, 0x1c, 0x2, 0x5bd, 0x5be, 0x7, 
       0x158, 0x2, 0x2, 0x5be, 0x5c6, 0x3, 0x2, 0x2, 0x2, 0x5bf, 0x5c0, 
       0x6, 0x10, 0xf, 0x2, 0x5c0, 0x5c1, 0x7, 0xa4, 0x2, 0x2, 0x5c1, 0x5c2, 
       0x7, 0x22, 0x2, 0x2, 0x5c2, 0x5c3, 0x5, 0x36, 0x1c, 0x2, 0x5c3, 0x5c4, 
       0x7, 0x158, 0x2, 0x2, 0x5c4, 0x5c6, 0x3, 0x2, 0x2, 0x2, 0x5c5, 0x563, 
       0x3, 0x2, 0x2, 0x2, 0x5c5, 0x56d, 0x3, 0x2, 0x2, 0x2, 0x5c5, 0x570, 
       0x3, 0x2, 0x2, 0x2, 0x5c5, 0x576, 0x3, 0x2, 0x2, 0x2, 0x5c5, 0x57f, 
       0x3, 0x2, 0x2, 0x2, 0x5c5, 0x585, 0x3, 0x2, 0x2, 0x2, 0x5c5, 0x58e, 
       0x3, 0x2, 0x2, 0x2, 0x5c5, 0x59a, 0x3, 0x2, 0x2, 0x2, 0x5c5, 0x5a0, 
       0x3, 0x2, 0x2, 0x2, 0x5c5, 0x5a4, 0x3, 0x2, 0x2, 0x2, 0x5c5, 0x5a5, 
       0x3, 0x2, 0x2, 0x2, 0x5c5, 0x5b0, 0x3, 0x2, 0x2, 0x2, 0x5c5, 0x5b9, 
       0x3, 0x2, 0x2, 0x2, 0x5c5, 0x5bf, 0x3, 0x2, 0x2, 0x2, 0x5c6, 0x1f, 
       0x3, 0x2, 0x2, 0x2, 0x5c7, 0x5ca, 0x5, 0x24, 0x13, 0x2, 0x5c8, 0x5ca, 
       0x5, 0x38a, 0x1c6, 0x2, 0x5c9, 0x5c7, 0x3, 0x2, 0x2, 0x2, 0x5c9, 
       0x5c8, 0x3, 0x2, 0x2, 0x2, 0x5ca, 0x5d3, 0x3, 0x2, 0x2, 0x2, 0x5cb, 
       0x5cf, 0x7, 0x198, 0x2, 0x2, 0x5cc, 0x5d0, 0x5, 0x24, 0x13, 0x2, 
       0x5cd, 0x5d0, 0x5, 0x22, 0x12, 0x2, 0x5ce, 0x5d0, 0x5, 0x38a, 0x1c6, 
       0x2, 0x5cf, 0x5cc, 0x3, 0x2, 0x2, 0x2, 0x5cf, 0x5cd, 0x3, 0x2, 0x2, 
       0x2, 0x5cf, 0x5ce, 0x3, 0x2, 0x2, 0x2, 0x5d0, 0x5d2, 0x3, 0x2, 0x2, 
       0x2, 0x5d1, 0x5cb, 0x3, 0x2, 0x2, 0x2, 0x5d2, 0x5d5, 0x3, 0x2, 0x2, 
       0x2, 0x5d3, 0x5d1, 0x3, 0x2, 0x2, 0x2, 0x5d3, 0x5d4, 0x3, 0x2, 0x2, 
       0x2, 0x5d4, 0x21, 0x3, 0x2, 0x2, 0x2, 0x5d5, 0x5d3, 0x3, 0x2, 0x2, 
       0x2, 0x5d6, 0x5d7, 0x6, 0x12, 0x10, 0x2, 0x5d7, 0x5dc, 0x5, 0x2c, 
       0x17, 0x2, 0x5d8, 0x5d9, 0x6, 0x12, 0x11, 0x2, 0x5d9, 0x5dc, 0x5, 
       0x2e, 0x18, 0x2, 0x5da, 0x5dc, 0x5, 0x32, 0x1a, 0x2, 0x5db, 0x5d6, 
       0x3, 0x2, 0x2, 0x2, 0x5db, 0x5d8, 0x3, 0x2, 0x2, 0x2, 0x5db, 0x5da, 
       0x3, 0x2, 0x2, 0x2, 0x5dc, 0x23, 0x3, 0x2, 0x2, 0x2, 0x5dd, 0x5df, 
       0x7, 0x1ac, 0x2, 0x2, 0x5de, 0x5e0, 0x7, 0x1c7, 0x2, 0x2, 0x5df, 
       0x5de, 0x3, 0x2, 0x2, 0x2, 0x5df, 0x5e0, 0x3, 0x2, 0x2, 0x2, 0x5e0, 
       0x5ed, 0x3, 0x2, 0x2, 0x2, 0x5e1, 0x5e2, 0x5, 0x442, 0x222, 0x2, 
       0x5e2, 0x5e4, 0x5, 0x34a, 0x1a6, 0x2, 0x5e3, 0x5e5, 0x5, 0x344, 0x1a3, 
       0x2, 0x5e4, 0x5e3, 0x3, 0x2, 0x2, 0x2, 0x5e4, 0x5e5, 0x3, 0x2, 0x2, 
       0x2, 0x5e5, 0x5e7, 0x3, 0x2, 0x2, 0x2, 0x5e6, 0x5e8, 0x5, 0x26, 0x14, 
       0x2, 0x5e7, 0x5e6, 0x3, 0x2, 0x2, 0x2, 0x5e7, 0x5e8, 0x3, 0x2, 0x2, 
       0x2, 0x5e8, 0x5ee, 0x3, 0x2, 0x2, 0x2, 0x5e9, 0x5ea, 0x7, 0x19b, 
       0x2, 0x2, 0x5ea, 0x5eb, 0x5, 0x58, 0x2d, 0x2, 0x5eb, 0x5ec, 0x7, 
       0x19c, 0x2, 0x2, 0x5ec, 0x5ee, 0x3, 0x2, 0x2, 0x2, 0x5ed, 0x5e1, 
       0x3, 0x2, 0x2, 0x2, 0x5ed, 0x5e9, 0x3, 0x2, 0x2, 0x2, 0x5ee, 0x656, 
       0x3, 0x2, 0x2, 0x2, 0x5ef, 0x5f0, 0x7, 0x1ac, 0x2, 0x2, 0x5f0, 0x656, 
       0x5, 0x348, 0x1a5, 0x2, 0x5f1, 0x5f3, 0x7, 0x1c3, 0x2, 0x2, 0x5f2, 
       0x5f4, 0x7, 0x1c7, 0x2, 0x2, 0x5f3, 0x5f2, 0x3, 0x2, 0x2, 0x2, 0x5f3, 
       0x5f4, 0x3, 0x2, 0x2, 0x2, 0x5f4, 0x5f5, 0x3, 0x2, 0x2, 0x2, 0x5f5, 
       0x5f6, 0x5, 0x3ec, 0x1f7, 0x2, 0x5f6, 0x5f7, 0x5, 0x442, 0x222, 0x2, 
       0x5f7, 0x5f9, 0x5, 0x34a, 0x1a6, 0x2, 0x5f8, 0x5fa, 0x5, 0x26, 0x14, 
       0x2, 0x5f9, 0x5f8, 0x3, 0x2, 0x2, 0x2, 0x5f9, 0x5fa, 0x3, 0x2, 0x2, 
       0x2, 0x5fa, 0x656, 0x3, 0x2, 0x2, 0x2, 0x5fb, 0x5fd, 0x7, 0xdf, 0x2, 
       0x2, 0x5fc, 0x5fe, 0x7, 0x1c7, 0x2, 0x2, 0x5fd, 0x5fc, 0x3, 0x2, 
       0x2, 0x2, 0x5fd, 0x5fe, 0x3, 0x2, 0x2, 0x2, 0x5fe, 0x5ff, 0x3, 0x2, 
       0x2, 0x2, 0x5ff, 0x600, 0x5, 0x3ec, 0x1f7, 0x2, 0x600, 0x602, 0x5, 
       0x34a, 0x1a6, 0x2, 0x601, 0x603, 0x5, 0x26, 0x14, 0x2, 0x602, 0x601, 
       0x3, 0x2, 0x2, 0x2, 0x602, 0x603, 0x3, 0x2, 0x2, 0x2, 0x603, 0x656, 
       0x3, 0x2, 0x2, 0x2, 0x604, 0x61b, 0x7, 0x1e9, 0x2, 0x2, 0x605, 0x607, 
       0x7, 0x1c7, 0x2, 0x2, 0x606, 0x605, 0x3, 0x2, 0x2, 0x2, 0x606, 0x607, 
       0x3, 0x2, 0x2, 0x2, 0x607, 0x608, 0x3, 0x2, 0x2, 0x2, 0x608, 0x60a, 
       0x5, 0x3ec, 0x1f7, 0x2, 0x609, 0x60b, 0x5, 0x28, 0x15, 0x2, 0x60a, 
       0x609, 0x3, 0x2, 0x2, 0x2, 0x60a, 0x60b, 0x3, 0x2, 0x2, 0x2, 0x60b, 
       0x61c, 0x3, 0x2, 0x2, 0x2, 0x60c, 0x60d, 0x7, 0x1fa, 0x2, 0x2, 0x60d, 
       0x614, 0x7, 0x21a, 0x2, 0x2, 0x60e, 0x60f, 0x6, 0x13, 0x12, 0x2, 
       0x60f, 0x615, 0x5, 0x3ec, 0x1f7, 0x2, 0x610, 0x612, 0x6, 0x13, 0x13, 
       0x2, 0x611, 0x613, 0x5, 0x3ec, 0x1f7, 0x2, 0x612, 0x611, 0x3, 0x2, 
       0x2, 0x2, 0x612, 0x613, 0x3, 0x2, 0x2, 0x2, 0x613, 0x615, 0x3, 0x2, 
       0x2, 0x2, 0x614, 0x60e, 0x3, 0x2, 0x2, 0x2, 0x614, 0x610, 0x3, 0x2, 
       0x2, 0x2, 0x615, 0x61c, 0x3, 0x2, 0x2, 0x2, 0x616, 0x617, 0x7, 0x252, 
       0x2, 0x2, 0x617, 0x61c, 0x7, 0x21a, 0x2, 0x2, 0x618, 0x619, 0x5, 
       0x18e, 0xc8, 0x2, 0x619, 0x61a, 0x5, 0x3f6, 0x1fc, 0x2, 0x61a, 0x61c, 
       0x3, 0x2, 0x2, 0x2, 0x61b, 0x606, 0x3, 0x2, 0x2, 0x2, 0x61b, 0x60c, 
       0x3, 0x2, 0x2, 0x2, 0x61b, 0x616, 0x3, 0x2, 0x2, 0x2, 0x61b, 0x618, 
       0x3, 0x2, 0x2, 0x2, 0x61c, 0x656, 0x3, 0x2, 0x2, 0x2, 0x61d, 0x61e, 
       0x7, 0x7a, 0x2, 0x2, 0x61e, 0x656, 0x7, 0x219, 0x2, 0x2, 0x61f, 0x620, 
       0x7, 0x91, 0x2, 0x2, 0x620, 0x656, 0x7, 0x219, 0x2, 0x2, 0x621, 0x623, 
       0x7, 0x1ae, 0x2, 0x2, 0x622, 0x624, 0x7, 0x1c7, 0x2, 0x2, 0x623, 
       0x622, 0x3, 0x2, 0x2, 0x2, 0x623, 0x624, 0x3, 0x2, 0x2, 0x2, 0x624, 
       0x625, 0x3, 0x2, 0x2, 0x2, 0x625, 0x62f, 0x5, 0x3ec, 0x1f7, 0x2, 
       0x626, 0x627, 0x7, 0x26c, 0x2, 0x2, 0x627, 0x62b, 0x7, 0x1e0, 0x2, 
       0x2, 0x628, 0x629, 0x6, 0x13, 0x14, 0x2, 0x629, 0x62c, 0x5, 0x2e6, 
       0x174, 0x2, 0x62a, 0x62c, 0x5, 0x458, 0x22d, 0x2, 0x62b, 0x628, 0x3, 
       0x2, 0x2, 0x2, 0x62b, 0x62a, 0x3, 0x2, 0x2, 0x2, 0x62c, 0x630, 0x3, 
       0x2, 0x2, 0x2, 0x62d, 0x62e, 0x7, 0x1e9, 0x2, 0x2, 0x62e, 0x630, 
       0x7, 0x1e0, 0x2, 0x2, 0x62f, 0x626, 0x3, 0x2, 0x2, 0x2, 0x62f, 0x62d, 
       0x3, 0x2, 0x2, 0x2, 0x630, 0x656, 0x3, 0x2, 0x2, 0x2, 0x631, 0x632, 
       0x6, 0x13, 0x15, 0x2, 0x632, 0x633, 0x7, 0x1ae, 0x2, 0x2, 0x633, 
       0x634, 0x7, 0x20a, 0x2, 0x2, 0x634, 0x635, 0x5, 0x3f6, 0x1fc, 0x2, 
       0x635, 0x636, 0x5, 0x364, 0x1b3, 0x2, 0x636, 0x656, 0x3, 0x2, 0x2, 
       0x2, 0x637, 0x639, 0x7, 0x25d, 0x2, 0x2, 0x638, 0x63a, 0x9, 0x3, 
       0x2, 0x2, 0x639, 0x638, 0x3, 0x2, 0x2, 0x2, 0x639, 0x63a, 0x3, 0x2, 
       0x2, 0x2, 0x63a, 0x63b, 0x3, 0x2, 0x2, 0x2, 0x63b, 0x656, 0x5, 0x422, 
       0x212, 0x2, 0x63c, 0x63d, 0x6, 0x13, 0x16, 0x2, 0x63d, 0x63e, 0x7, 
       0x25d, 0x2, 0x2, 0x63e, 0x63f, 0x5, 0x18e, 0xc8, 0x2, 0x63f, 0x640, 
       0x5, 0x3f6, 0x1fc, 0x2, 0x640, 0x641, 0x7, 0x28e, 0x2, 0x2, 0x641, 
       0x642, 0x5, 0x3f4, 0x1fb, 0x2, 0x642, 0x656, 0x3, 0x2, 0x2, 0x2, 
       0x643, 0x644, 0x7, 0x1cb, 0x2, 0x2, 0x644, 0x645, 0x7, 0x28e, 0x2, 
       0x2, 0x645, 0x649, 0x5, 0x2da, 0x16e, 0x2, 0x646, 0x647, 0x6, 0x13, 
       0x17, 0x2, 0x647, 0x64a, 0x7, 0x1e0, 0x2, 0x2, 0x648, 0x64a, 0x5, 
       0x384, 0x1c3, 0x2, 0x649, 0x646, 0x3, 0x2, 0x2, 0x2, 0x649, 0x648, 
       0x3, 0x2, 0x2, 0x2, 0x64a, 0x64c, 0x3, 0x2, 0x2, 0x2, 0x64b, 0x64d, 
       0x5, 0x3b6, 0x1dc, 0x2, 0x64c, 0x64b, 0x3, 0x2, 0x2, 0x2, 0x64c, 
       0x64d, 0x3, 0x2, 0x2, 0x2, 0x64d, 0x656, 0x3, 0x2, 0x2, 0x2, 0x64e, 
       0x656, 0x7, 0x1f9, 0x2, 0x2, 0x64f, 0x650, 0x7, 0x24b, 0x2, 0x2, 
       0x650, 0x651, 0x7, 0x1be, 0x2, 0x2, 0x651, 0x656, 0x5, 0x2a, 0x16, 
       0x2, 0x652, 0x653, 0x6, 0x13, 0x18, 0x2, 0x653, 0x654, 0x7, 0x37, 
       0x2, 0x2, 0x654, 0x656, 0x7, 0xfb, 0x2, 0x2, 0x655, 0x5dd, 0x3, 0x2, 
       0x2, 0x2, 0x655, 0x5ef, 0x3, 0x2, 0x2, 0x2, 0x655, 0x5f1, 0x3, 0x2, 
       0x2, 0x2, 0x655, 0x5fb, 0x3, 0x2, 0x2, 0x2, 0x655, 0x604, 0x3, 0x2, 
       0x2, 0x2, 0x655, 0x61d, 0x3, 0x2, 0x2, 0x2, 0x655, 0x61f, 0x3, 0x2, 
       0x2, 0x2, 0x655, 0x621, 0x3, 0x2, 0x2, 0x2, 0x655, 0x631, 0x3, 0x2, 
       0x2, 0x2, 0x655, 0x637, 0x3, 0x2, 0x2, 0x2, 0x655, 0x63c, 0x3, 0x2, 
       0x2, 0x2, 0x655, 0x643, 0x3, 0x2, 0x2, 0x2, 0x655, 0x64e, 0x3, 0x2, 
       0x2, 0x2, 0x655, 0x64f, 0x3, 0x2, 0x2, 0x2, 0x655, 0x652, 0x3, 0x2, 
       0x2, 0x2, 0x656, 0x25, 0x3, 0x2, 0x2, 0x2, 0x657, 0x658, 0x7, 0x3d, 
       0x2, 0x2, 0x658, 0x65b, 0x5, 0x442, 0x222, 0x2, 0x659, 0x65b, 0x7, 
       0x96, 0x2, 0x2, 0x65a, 0x657, 0x3, 0x2, 0x2, 0x2, 0x65a, 0x659, 0x3, 
       0x2, 0x2, 0x2, 0x65b, 0x27, 0x3, 0x2, 0x2, 0x2, 0x65c, 0x65d, 0x9, 
       0x4, 0x2, 0x2, 0x65d, 0x29, 0x3, 0x2, 0x2, 0x2, 0x65e, 0x660, 0x5, 
       0x442, 0x222, 0x2, 0x65f, 0x661, 0x5, 0x14a, 0xa6, 0x2, 0x660, 0x65f, 
       0x3, 0x2, 0x2, 0x2, 0x660, 0x661, 0x3, 0x2, 0x2, 0x2, 0x661, 0x669, 
       0x3, 0x2, 0x2, 0x2, 0x662, 0x663, 0x7, 0x198, 0x2, 0x2, 0x663, 0x665, 
       0x5, 0x442, 0x222, 0x2, 0x664, 0x666, 0x5, 0x14a, 0xa6, 0x2, 0x665, 
       0x664, 0x3, 0x2, 0x2, 0x2, 0x665, 0x666, 0x3, 0x2, 0x2, 0x2, 0x666, 
       0x668, 0x3, 0x2, 0x2, 0x2, 0x667, 0x662, 0x3, 0x2, 0x2, 0x2, 0x668, 
       0x66b, 0x3, 0x2, 0x2, 0x2, 0x669, 0x667, 0x3, 0x2, 0x2, 0x2, 0x669, 
       0x66a, 0x3, 0x2, 0x2, 0x2, 0x66a, 0x2b, 0x3, 0x2, 0x2, 0x2, 0x66b, 
       0x669, 0x3, 0x2, 0x2, 0x2, 0x66c, 0x66e, 0x7, 0x40, 0x2, 0x2, 0x66d, 
       0x66f, 0x7, 0x181, 0x2, 0x2, 0x66e, 0x66d, 0x3, 0x2, 0x2, 0x2, 0x66e, 
       0x66f, 0x3, 0x2, 0x2, 0x2, 0x66f, 0x672, 0x3, 0x2, 0x2, 0x2, 0x670, 
       0x673, 0x7, 0x1e0, 0x2, 0x2, 0x671, 0x673, 0x5, 0x442, 0x222, 0x2, 
       0x672, 0x670, 0x3, 0x2, 0x2, 0x2, 0x672, 0x671, 0x3, 0x2, 0x2, 0x2, 
       0x673, 0x2d, 0x3, 0x2, 0x2, 0x2, 0x674, 0x676, 0x7, 0x225, 0x2, 0x2, 
       0x675, 0x677, 0x7, 0x181, 0x2, 0x2, 0x676, 0x675, 0x3, 0x2, 0x2, 
       0x2, 0x676, 0x677, 0x3, 0x2, 0x2, 0x2, 0x677, 0x67a, 0x3, 0x2, 0x2, 
       0x2, 0x678, 0x67b, 0x7, 0x1e0, 0x2, 0x2, 0x679, 0x67b, 0x5, 0x442, 
       0x222, 0x2, 0x67a, 0x678, 0x3, 0x2, 0x2, 0x2, 0x67a, 0x679, 0x3, 
       0x2, 0x2, 0x2, 0x67b, 0x2f, 0x3, 0x2, 0x2, 0x2, 0x67c, 0x685, 0x6, 
       0x19, 0x19, 0x2, 0x67d, 0x67f, 0x5, 0x2c, 0x17, 0x2, 0x67e, 0x680, 
       0x5, 0x2e, 0x18, 0x2, 0x67f, 0x67e, 0x3, 0x2, 0x2, 0x2, 0x67f, 0x680, 
       0x3, 0x2, 0x2, 0x2, 0x680, 0x686, 0x3, 0x2, 0x2, 0x2, 0x681, 0x683, 
       0x5, 0x2e, 0x18, 0x2, 0x682, 0x684, 0x5, 0x2c, 0x17, 0x2, 0x683, 
       0x682, 0x3, 0x2, 0x2, 0x2, 0x683, 0x684, 0x3, 0x2, 0x2, 0x2, 0x684, 
       0x686, 0x3, 0x2, 0x2, 0x2, 0x685, 0x67d, 0x3, 0x2, 0x2, 0x2, 0x685, 
       0x681, 0x3, 0x2, 0x2, 0x2, 0x686, 0x31, 0x3, 0x2, 0x2, 0x2, 0x687, 
       0x688, 0x6, 0x1a, 0x1a, 0x2, 0x688, 0x689, 0x9, 0x5, 0x2, 0x2, 0x689, 
       0x68a, 0x7, 0x29f, 0x2, 0x2, 0x68a, 0x33, 0x3, 0x2, 0x2, 0x2, 0x68b, 
       0x68c, 0x7, 0x26, 0x2, 0x2, 0x68c, 0x68d, 0x7, 0xfb, 0x2, 0x2, 0x68d, 
       0x35, 0x3, 0x2, 0x2, 0x2, 0x68e, 0x691, 0x7, 0x1ad, 0x2, 0x2, 0x68f, 
       0x691, 0x5, 0x444, 0x223, 0x2, 0x690, 0x68e, 0x3, 0x2, 0x2, 0x2, 
       0x690, 0x68f, 0x3, 0x2, 0x2, 0x2, 0x691, 0x37, 0x3, 0x2, 0x2, 0x2, 
       0x692, 0x693, 0x7, 0x11b, 0x2, 0x2, 0x693, 0x695, 0x7, 0x22, 0x2, 
       0x2, 0x694, 0x696, 0x5, 0x3e4, 0x1f3, 0x2, 0x695, 0x694, 0x3, 0x2, 
       0x2, 0x2, 0x695, 0x696, 0x3, 0x2, 0x2, 0x2, 0x696, 0x69b, 0x3, 0x2, 
       0x2, 0x2, 0x697, 0x698, 0x5, 0x444, 0x223, 0x2, 0x698, 0x699, 0x7, 
       0x211, 0x2, 0x2, 0x699, 0x69a, 0x5, 0x39e, 0x1d0, 0x2, 0x69a, 0x69c, 
       0x3, 0x2, 0x2, 0x2, 0x69b, 0x697, 0x3, 0x2, 0x2, 0x2, 0x69b, 0x69c, 
       0x3, 0x2, 0x2, 0x2, 0x69c, 0x39, 0x3, 0x2, 0x2, 0x2, 0x69d, 0x69e, 
       0x7, 0x158, 0x2, 0x2, 0x69e, 0x6c0, 0x5, 0x410, 0x209, 0x2, 0x69f, 
       0x6a0, 0x9, 0x6, 0x2, 0x2, 0x6a0, 0x6a1, 0x7, 0x70, 0x2, 0x2, 0x6a1, 
       0x6a3, 0x5, 0x460, 0x231, 0x2, 0x6a2, 0x6a4, 0x5, 0x42, 0x22, 0x2, 
       0x6a3, 0x6a2, 0x3, 0x2, 0x2, 0x2, 0x6a3, 0x6a4, 0x3, 0x2, 0x2, 0x2, 
       0x6a4, 0x6c1, 0x3, 0x2, 0x2, 0x2, 0x6a5, 0x6b9, 0x6, 0x1e, 0x1b, 
       0x2, 0x6a6, 0x6ba, 0x3, 0x2, 0x2, 0x2, 0x6a7, 0x6a8, 0x7, 0x1c3, 
       0x2, 0x2, 0x6a8, 0x6a9, 0x7, 0x70, 0x2, 0x2, 0x6a9, 0x6b4, 0x5, 0x460, 
       0x231, 0x2, 0x6aa, 0x6b1, 0x5, 0x46, 0x24, 0x2, 0x6ab, 0x6ad, 0x7, 
       0x198, 0x2, 0x2, 0x6ac, 0x6ab, 0x3, 0x2, 0x2, 0x2, 0x6ac, 0x6ad, 
       0x3, 0x2, 0x2, 0x2, 0x6ad, 0x6ae, 0x3, 0x2, 0x2, 0x2, 0x6ae, 0x6b0, 
       0x5, 0x46, 0x24, 0x2, 0x6af, 0x6ac, 0x3, 0x2, 0x2, 0x2, 0x6b0, 0x6b3, 
       0x3, 0x2, 0x2, 0x2, 0x6b1, 0x6af, 0x3, 0x2, 0x2, 0x2, 0x6b1, 0x6b2, 
       0x3, 0x2, 0x2, 0x2, 0x6b2, 0x6b5, 0x3, 0x2, 0x2, 0x2, 0x6b3, 0x6b1, 
       0x3, 0x2, 0x2, 0x2, 0x6b4, 0x6aa, 0x3, 0x2, 0x2, 0x2, 0x6b4, 0x6b5, 
       0x3, 0x2, 0x2, 0x2, 0x6b5, 0x6ba, 0x3, 0x2, 0x2, 0x2, 0x6b6, 0x6ba, 
       0x9, 0x7, 0x2, 0x2, 0x6b7, 0x6b8, 0x7, 0x23e, 0x2, 0x2, 0x6b8, 0x6ba, 
       0x7, 0x1ab, 0x2, 0x2, 0x6b9, 0x6a6, 0x3, 0x2, 0x2, 0x2, 0x6b9, 0x6a7, 
       0x3, 0x2, 0x2, 0x2, 0x6b9, 0x6b6, 0x3, 0x2, 0x2, 0x2, 0x6b9, 0x6b7, 
       0x3, 0x2, 0x2, 0x2, 0x6ba, 0x6c1, 0x3, 0x2, 0x2, 0x2, 0x6bb, 0x6bc, 
       0x7, 0x25d, 0x2, 0x2, 0x6bc, 0x6bd, 0x7, 0x28e, 0x2, 0x2, 0x6bd, 
       0x6c1, 0x5, 0x442, 0x222, 0x2, 0x6be, 0x6bf, 0x6, 0x1e, 0x1c, 0x2, 
       0x6bf, 0x6c1, 0x5, 0x42, 0x22, 0x2, 0x6c0, 0x69f, 0x3, 0x2, 0x2, 
       0x2, 0x6c0, 0x6a5, 0x3, 0x2, 0x2, 0x2, 0x6c0, 0x6bb, 0x3, 0x2, 0x2, 
       0x2, 0x6c0, 0x6be, 0x3, 0x2, 0x2, 0x2, 0x6c1, 0x3b, 0x3, 0x2, 0x2, 
       0x2, 0x6c2, 0x6c3, 0x7, 0x293, 0x2, 0x2, 0x6c3, 0x6c4, 0x7, 0x158, 
       0x2, 0x2, 0x6c4, 0x6c5, 0x5, 0x410, 0x209, 0x2, 0x6c5, 0x6c6, 0x7, 
       0x26c, 0x2, 0x2, 0x6c6, 0x6c8, 0x9, 0x8, 0x2, 0x2, 0x6c7, 0x6c9, 
       0x5, 0x3e, 0x20, 0x2, 0x6c8, 0x6c7, 0x3, 0x2, 0x2, 0x2, 0x6c8, 0x6c9, 
       0x3, 0x2, 0x2, 0x2, 0x6c9, 0x3d, 0x3, 0x2, 0x2, 0x2, 0x6ca, 0x6d1, 
       0x5, 0x40, 0x21, 0x2, 0x6cb, 0x6cd, 0x7, 0x198, 0x2, 0x2, 0x6cc, 
       0x6cb, 0x3, 0x2, 0x2, 0x2, 0x6cc, 0x6cd, 0x3, 0x2, 0x2, 0x2, 0x6cd, 
       0x6ce, 0x3, 0x2, 0x2, 0x2, 0x6ce, 0x6d0, 0x5, 0x40, 0x21, 0x2, 0x6cf, 
       0x6cc, 0x3, 0x2, 0x2, 0x2, 0x6d0, 0x6d3, 0x3, 0x2, 0x2, 0x2, 0x6d1, 
       0x6cf, 0x3, 0x2, 0x2, 0x2, 0x6d1, 0x6d2, 0x3, 0x2, 0x2, 0x2, 0x6d2, 
       0x3f, 0x3, 0x2, 0x2, 0x2, 0x6d3, 0x6d1, 0x3, 0x2, 0x2, 0x2, 0x6d4, 
       0x6d5, 0x5, 0x98, 0x4d, 0x2, 0x6d5, 0x41, 0x3, 0x2, 0x2, 0x2, 0x6d6, 
       0x6dd, 0x5, 0x44, 0x23, 0x2, 0x6d7, 0x6d9, 0x7, 0x198, 0x2, 0x2, 
       0x6d8, 0x6d7, 0x3, 0x2, 0x2, 0x2, 0x6d8, 0x6d9, 0x3, 0x2, 0x2, 0x2, 
       0x6d9, 0x6da, 0x3, 0x2, 0x2, 0x2, 0x6da, 0x6dc, 0x5, 0x44, 0x23, 
       0x2, 0x6db, 0x6d8, 0x3, 0x2, 0x2, 0x2, 0x6dc, 0x6df, 0x3, 0x2, 0x2, 
       0x2, 0x6dd, 0x6db, 0x3, 0x2, 0x2, 0x2, 0x6dd, 0x6de, 0x3, 0x2, 0x2, 
       0x2, 0x6de, 0x43, 0x3, 0x2, 0x2, 0x2, 0x6df, 0x6dd, 0x3, 0x2, 0x2, 
       0x2, 0x6e0, 0x6e2, 0x7, 0xa6, 0x2, 0x2, 0x6e1, 0x6e3, 0x7, 0x181, 
       0x2, 0x2, 0x6e2, 0x6e1, 0x3, 0x2, 0x2, 0x2, 0x6e2, 0x6e3, 0x3, 0x2, 
       0x2, 0x2, 0x6e3, 0x6e4, 0x3, 0x2, 0x2, 0x2, 0x6e4, 0x6eb, 0x5, 0x476, 
       0x23c, 0x2, 0x6e5, 0x6eb, 0x5, 0x90, 0x49, 0x2, 0x6e6, 0x6eb, 0x5, 
       0x92, 0x4a, 0x2, 0x6e7, 0x6eb, 0x5, 0x98, 0x4d, 0x2, 0x6e8, 0x6eb, 
       0x5, 0x9a, 0x4e, 0x2, 0x6e9, 0x6eb, 0x5, 0xa0, 0x51, 0x2, 0x6ea, 
       0x6e0, 0x3, 0x2, 0x2, 0x2, 0x6ea, 0x6e5, 0x3, 0x2, 0x2, 0x2, 0x6ea, 
       0x6e6, 0x3, 0x2, 0x2, 0x2, 0x6ea, 0x6e7, 0x3, 0x2, 0x2, 0x2, 0x6ea, 
       0x6e8, 0x3, 0x2, 0x2, 0x2, 0x6ea, 0x6e9, 0x3, 0x2, 0x2, 0x2, 0x6eb, 
       0x45, 0x3, 0x2, 0x2, 0x2, 0x6ec, 0x6ee, 0x7, 0xa6, 0x2, 0x2, 0x6ed, 
       0x6ef, 0x7, 0x181, 0x2, 0x2, 0x6ee, 0x6ed, 0x3, 0x2, 0x2, 0x2, 0x6ee, 
       0x6ef, 0x3, 0x2, 0x2, 0x2, 0x6ef, 0x6f0, 0x3, 0x2, 0x2, 0x2, 0x6f0, 
       0x6f4, 0x5, 0x476, 0x23c, 0x2, 0x6f1, 0x6f4, 0x5, 0x90, 0x49, 0x2, 
       0x6f2, 0x6f4, 0x5, 0x92, 0x4a, 0x2, 0x6f3, 0x6ec, 0x3, 0x2, 0x2, 
       0x2, 0x6f3, 0x6f1, 0x3, 0x2, 0x2, 0x2, 0x6f3, 0x6f2, 0x3, 0x2, 0x2, 
       0x2, 0x6f4, 0x47, 0x3, 0x2, 0x2, 0x2, 0x6f5, 0x6f7, 0x5, 0xa6, 0x54, 
       0x2, 0x6f6, 0x6f5, 0x3, 0x2, 0x2, 0x2, 0x6f6, 0x6f7, 0x3, 0x2, 0x2, 
       0x2, 0x6f7, 0x6f9, 0x3, 0x2, 0x2, 0x2, 0x6f8, 0x6fa, 0x5, 0x3ac, 
       0x1d7, 0x2, 0x6f9, 0x6f8, 0x3, 0x2, 0x2, 0x2, 0x6f9, 0x6fa, 0x3, 
       0x2, 0x2, 0x2, 0x6fa, 0x6fc, 0x3, 0x2, 0x2, 0x2, 0x6fb, 0x6fd, 0x5, 
       0xa8, 0x55, 0x2, 0x6fc, 0x6fb, 0x3, 0x2, 0x2, 0x2, 0x6fc, 0x6fd, 
       0x3, 0x2, 0x2, 0x2, 0x6fd, 0x6fe, 0x3, 0x2, 0x2, 0x2, 0x6fe, 0x6ff, 
       0x7, 0x171, 0x2, 0x2, 0x6ff, 0x700, 0x5, 0x40c, 0x207, 0x2, 0x700, 
       0x701, 0x5, 0x4a, 0x26, 0x2, 0x701, 0x49, 0x3, 0x2, 0x2, 0x2, 0x702, 
       0x704, 0x5, 0x3ee, 0x1f8, 0x2, 0x703, 0x702, 0x3, 0x2, 0x2, 0x2, 
       0x703, 0x704, 0x3, 0x2, 0x2, 0x2, 0x704, 0x705, 0x3, 0x2, 0x2, 0x2, 
       0x705, 0x706, 0x7, 0x1b1, 0x2, 0x2, 0x706, 0x707, 0x5, 0x4c, 0x27, 
       0x2, 0x707, 0x4b, 0x3, 0x2, 0x2, 0x2, 0x708, 0x70a, 0x5, 0x5e, 0x30, 
       0x2, 0x709, 0x70b, 0x5, 0x4e, 0x28, 0x2, 0x70a, 0x709, 0x3, 0x2, 
       0x2, 0x2, 0x70a, 0x70b, 0x3, 0x2, 0x2, 0x2, 0x70b, 0x4d, 0x3, 0x2, 
       0x2, 0x2, 0x70c, 0x70e, 0x7, 0x2ab, 0x2, 0x2, 0x70d, 0x70f, 0x9, 
       0x9, 0x2, 0x2, 0x70e, 0x70d, 0x3, 0x2, 0x2, 0x2, 0x70e, 0x70f, 0x3, 
       0x2, 0x2, 0x2, 0x70f, 0x710, 0x3, 0x2, 0x2, 0x2, 0x710, 0x711, 0x7, 
       0x1c5, 0x2, 0x2, 0x711, 0x712, 0x7, 0x249, 0x2, 0x2, 0x712, 0x4f, 
       0x3, 0x2, 0x2, 0x2, 0x713, 0x726, 0x7, 0x1cd, 0x2, 0x2, 0x714, 0x727, 
       0x5, 0x52, 0x2a, 0x2, 0x715, 0x727, 0x5, 0x56, 0x2c, 0x2, 0x716, 
       0x727, 0x5, 0x64, 0x33, 0x2, 0x717, 0x727, 0x5, 0x62, 0x32, 0x2, 
       0x718, 0x727, 0x5, 0x66, 0x34, 0x2, 0x719, 0x727, 0x5, 0x74, 0x3b, 
       0x2, 0x71a, 0x727, 0x5, 0xa2, 0x52, 0x2, 0x71b, 0x727, 0x5, 0xaa, 
       0x56, 0x2, 0x71c, 0x727, 0x5, 0x6e, 0x38, 0x2, 0x71d, 0x727, 0x5, 
       0x7a, 0x3e, 0x2, 0x71e, 0x727, 0x5, 0x80, 0x41, 0x2, 0x71f, 0x727, 
       0x5, 0xae, 0x58, 0x2, 0x720, 0x721, 0x6, 0x29, 0x1d, 0x2, 0x721, 
       0x727, 0x5, 0xb0, 0x59, 0x2, 0x722, 0x723, 0x6, 0x29, 0x1e, 0x2, 
       0x723, 0x727, 0x5, 0xb2, 0x5a, 0x2, 0x724, 0x725, 0x6, 0x29, 0x1f, 
       0x2, 0x725, 0x727, 0x5, 0x82, 0x42, 0x2, 0x726, 0x714, 0x3, 0x2, 
       0x2, 0x2, 0x726, 0x715, 0x3, 0x2, 0x2, 0x2, 0x726, 0x716, 0x3, 0x2, 
       0x2, 0x2, 0x726, 0x717, 0x3, 0x2, 0x2, 0x2, 0x726, 0x718, 0x3, 0x2, 
       0x2, 0x2, 0x726, 0x719, 0x3, 0x2, 0x2, 0x2, 0x726, 0x71a, 0x3, 0x2, 
       0x2, 0x2, 0x726, 0x71b, 0x3, 0x2, 0x2, 0x2, 0x726, 0x71c, 0x3, 0x2, 
       0x2, 0x2, 0x726, 0x71d, 0x3, 0x2, 0x2, 0x2, 0x726, 0x71e, 0x3, 0x2, 
       0x2, 0x2, 0x726, 0x71f, 0x3, 0x2, 0x2, 0x2, 0x726, 0x720, 0x3, 0x2, 
       0x2, 0x2, 0x726, 0x722, 0x3, 0x2, 0x2, 0x2, 0x726, 0x724, 0x3, 0x2, 
       0x2, 0x2, 0x727, 0x51, 0x3, 0x2, 0x2, 0x2, 0x728, 0x72a, 0x7, 0x1d5, 
       0x2, 0x2, 0x729, 0x72b, 0x5, 0x3b0, 0x1d9, 0x2, 0x72a, 0x729, 0x3, 
       0x2, 0x2, 0x2, 0x72a, 0x72b, 0x3, 0x2, 0x2, 0x2, 0x72b, 0x72c, 0x3, 
       0x2, 0x2, 0x2, 0x72c, 0x730, 0x5, 0x3fa, 0x1fe, 0x2, 0x72d, 0x72f, 
       0x5, 0x54, 0x2b, 0x2, 0x72e, 0x72d, 0x3, 0x2, 0x2, 0x2, 0x72f, 0x732, 
       0x3, 0x2, 0x2, 0x2, 0x730, 0x72e, 0x3, 0x2, 0x2, 0x2, 0x730, 0x731, 
       0x3, 0x2, 0x2, 0x2, 0x731, 0x53, 0x3, 0x2, 0x2, 0x2, 0x732, 0x730, 
       0x3, 0x2, 0x2, 0x2, 0x733, 0x738, 0x5, 0x394, 0x1cb, 0x2, 0x734, 
       0x738, 0x5, 0x390, 0x1c9, 0x2, 0x735, 0x736, 0x6, 0x2b, 0x20, 0x2, 
       0x736, 0x738, 0x5, 0x392, 0x1ca, 0x2, 0x737, 0x733, 0x3, 0x2, 0x2, 
       0x2, 0x737, 0x734, 0x3, 0x2, 0x2, 0x2, 0x737, 0x735, 0x3, 0x2, 0x2, 
       0x2, 0x738, 0x55, 0x3, 0x2, 0x2, 0x2, 0x739, 0x73b, 0x7, 0x159, 0x2, 
       0x2, 0x73a, 0x739, 0x3, 0x2, 0x2, 0x2, 0x73a, 0x73b, 0x3, 0x2, 0x2, 
       0x2, 0x73b, 0x73c, 0x3, 0x2, 0x2, 0x2, 0x73c, 0x73e, 0x7, 0x288, 
       0x2, 0x2, 0x73d, 0x73f, 0x5, 0x3b0, 0x1d9, 0x2, 0x73e, 0x73d, 0x3, 
       0x2, 0x2, 0x2, 0x73e, 0x73f, 0x3, 0x2, 0x2, 0x2, 0x73f, 0x740, 0x3, 
       0x2, 0x2, 0x2, 0x740, 0x757, 0x5, 0x422, 0x212, 0x2, 0x741, 0x742, 
       0x7, 0x19b, 0x2, 0x2, 0x742, 0x743, 0x5, 0x58, 0x2d, 0x2, 0x743, 
       0x744, 0x7, 0x19c, 0x2, 0x2, 0x744, 0x746, 0x3, 0x2, 0x2, 0x2, 0x745, 
       0x741, 0x3, 0x2, 0x2, 0x2, 0x745, 0x746, 0x3, 0x2, 0x2, 0x2, 0x746, 
       0x748, 0x3, 0x2, 0x2, 0x2, 0x747, 0x749, 0x5, 0x388, 0x1c5, 0x2, 
       0x748, 0x747, 0x3, 0x2, 0x2, 0x2, 0x748, 0x749, 0x3, 0x2, 0x2, 0x2, 
       0x749, 0x74b, 0x3, 0x2, 0x2, 0x2, 0x74a, 0x74c, 0x5, 0x396, 0x1cc, 
       0x2, 0x74b, 0x74a, 0x3, 0x2, 0x2, 0x2, 0x74b, 0x74c, 0x3, 0x2, 0x2, 
       0x2, 0x74c, 0x74e, 0x3, 0x2, 0x2, 0x2, 0x74d, 0x74f, 0x5, 0x5c, 0x2f, 
       0x2, 0x74e, 0x74d, 0x3, 0x2, 0x2, 0x2, 0x74e, 0x74f, 0x3, 0x2, 0x2, 
       0x2, 0x74f, 0x758, 0x3, 0x2, 0x2, 0x2, 0x750, 0x751, 0x7, 0x21f, 
       0x2, 0x2, 0x751, 0x758, 0x5, 0x428, 0x215, 0x2, 0x752, 0x753, 0x7, 
       0x19b, 0x2, 0x2, 0x753, 0x754, 0x7, 0x21f, 0x2, 0x2, 0x754, 0x755, 
       0x5, 0x428, 0x215, 0x2, 0x755, 0x756, 0x7, 0x19c, 0x2, 0x2, 0x756, 
       0x758, 0x3, 0x2, 0x2, 0x2, 0x757, 0x745, 0x3, 0x2, 0x2, 0x2, 0x757, 
       0x750, 0x3, 0x2, 0x2, 0x2, 0x757, 0x752, 0x3, 0x2, 0x2, 0x2, 0x758, 
       0x57, 0x3, 0x2, 0x2, 0x2, 0x759, 0x75e, 0x5, 0x5a, 0x2e, 0x2, 0x75a, 
       0x75b, 0x7, 0x198, 0x2, 0x2, 0x75b, 0x75d, 0x5, 0x5a, 0x2e, 0x2, 
       0x75c, 0x75a, 0x3, 0x2, 0x2, 0x2, 0x75d, 0x760, 0x3, 0x2, 0x2, 0x2, 
       0x75e, 0x75c, 0x3, 0x2, 0x2, 0x2, 0x75e, 0x75f, 0x3, 0x2, 0x2, 0x2, 
       0x75f, 0x59, 0x3, 0x2, 0x2, 0x2, 0x760, 0x75e, 0x3, 0x2, 0x2, 0x2, 
       0x761, 0x764, 0x5, 0x342, 0x1a2, 0x2, 0x762, 0x764, 0x5, 0x348, 0x1a5, 
       0x2, 0x763, 0x761, 0x3, 0x2, 0x2, 0x2, 0x763, 0x762, 0x3, 0x2, 0x2, 
       0x2, 0x764, 0x5b, 0x3, 0x2, 0x2, 0x2, 0x765, 0x767, 0x9, 0xa, 0x2, 
       0x2, 0x766, 0x765, 0x3, 0x2, 0x2, 0x2, 0x766, 0x767, 0x3, 0x2, 0x2, 
       0x2, 0x767, 0x769, 0x3, 0x2, 0x2, 0x2, 0x768, 0x76a, 0x7, 0x1b1, 
       0x2, 0x2, 0x769, 0x768, 0x3, 0x2, 0x2, 0x2, 0x769, 0x76a, 0x3, 0x2, 
       0x2, 0x2, 0x76a, 0x76b, 0x3, 0x2, 0x2, 0x2, 0x76b, 0x76c, 0x5, 0x5e, 
       0x30, 0x2, 0x76c, 0x5d, 0x3, 0x2, 0x2, 0x2, 0x76d, 0x770, 0x5, 0x110, 
       0x89, 0x2, 0x76e, 0x770, 0x5, 0x114, 0x8b, 0x2, 0x76f, 0x76d, 0x3, 
       0x2, 0x2, 0x2, 0x76f, 0x76e, 0x3, 0x2, 0x2, 0x2, 0x770, 0x5f, 0x3, 
       0x2, 0x2, 0x2, 0x771, 0x775, 0x7, 0x1cd, 0x2, 0x2, 0x772, 0x776, 
       0x5, 0x62, 0x32, 0x2, 0x773, 0x776, 0x5, 0x64, 0x33, 0x2, 0x774, 
       0x776, 0x5, 0x66, 0x34, 0x2, 0x775, 0x772, 0x3, 0x2, 0x2, 0x2, 0x775, 
       0x773, 0x3, 0x2, 0x2, 0x2, 0x775, 0x774, 0x3, 0x2, 0x2, 0x2, 0x776, 
       0x778, 0x3, 0x2, 0x2, 0x2, 0x777, 0x779, 0x7, 0x199, 0x2, 0x2, 0x778, 
       0x777, 0x3, 0x2, 0x2, 0x2, 0x778, 0x779, 0x3, 0x2, 0x2, 0x2, 0x779, 
       0x77a, 0x3, 0x2, 0x2, 0x2, 0x77a, 0x77b, 0x7, 0x2, 0x2, 0x3, 0x77b, 
       0x61, 0x3, 0x2, 0x2, 0x2, 0x77c, 0x77e, 0x5, 0x3ac, 0x1d7, 0x2, 0x77d, 
       0x77c, 0x3, 0x2, 0x2, 0x2, 0x77d, 0x77e, 0x3, 0x2, 0x2, 0x2, 0x77e, 
       0x77f, 0x3, 0x2, 0x2, 0x2, 0x77f, 0x780, 0x7, 0x253, 0x2, 0x2, 0x780, 
       0x781, 0x5, 0x3fe, 0x200, 0x2, 0x781, 0x78a, 0x7, 0x19b, 0x2, 0x2, 
       0x782, 0x787, 0x5, 0x3b2, 0x1da, 0x2, 0x783, 0x784, 0x7, 0x198, 0x2, 
       0x2, 0x784, 0x786, 0x5, 0x3b2, 0x1da, 0x2, 0x785, 0x783, 0x3, 0x2, 
       0x2, 0x2, 0x786, 0x789, 0x3, 0x2, 0x2, 0x2, 0x787, 0x785, 0x3, 0x2, 
       0x2, 0x2, 0x787, 0x788, 0x3, 0x2, 0x2, 0x2, 0x788, 0x78b, 0x3, 0x2, 
       0x2, 0x2, 0x789, 0x787, 0x3, 0x2, 0x2, 0x2, 0x78a, 0x782, 0x3, 0x2, 
       0x2, 0x2, 0x78a, 0x78b, 0x3, 0x2, 0x2, 0x2, 0x78b, 0x78c, 0x3, 0x2, 
       0x2, 0x2, 0x78c, 0x790, 0x7, 0x19c, 0x2, 0x2, 0x78d, 0x78f, 0x5, 
       0x68, 0x35, 0x2, 0x78e, 0x78d, 0x3, 0x2, 0x2, 0x2, 0x78f, 0x792, 
       0x3, 0x2, 0x2, 0x2, 0x790, 0x78e, 0x3, 0x2, 0x2, 0x2, 0x790, 0x791, 
       0x3, 0x2, 0x2, 0x2, 0x791, 0x793, 0x3, 0x2, 0x2, 0x2, 0x792, 0x790, 
       0x3, 0x2, 0x2, 0x2, 0x793, 0x794, 0x5, 0x2f2, 0x17a, 0x2, 0x794, 
       0x63, 0x3, 0x2, 0x2, 0x2, 0x795, 0x797, 0x5, 0x3ac, 0x1d7, 0x2, 0x796, 
       0x795, 0x3, 0x2, 0x2, 0x2, 0x796, 0x797, 0x3, 0x2, 0x2, 0x2, 0x797, 
       0x798, 0x3, 0x2, 0x2, 0x2, 0x798, 0x799, 0x7, 0x166, 0x2, 0x2, 0x799, 
       0x79a, 0x5, 0x402, 0x202, 0x2, 0x79a, 0x7a3, 0x7, 0x19b, 0x2, 0x2, 
       0x79b, 0x7a0, 0x5, 0x3b4, 0x1db, 0x2, 0x79c, 0x79d, 0x7, 0x198, 0x2, 
       0x2, 0x79d, 0x79f, 0x5, 0x3b4, 0x1db, 0x2, 0x79e, 0x79c, 0x3, 0x2, 
       0x2, 0x2, 0x79f, 0x7a2, 0x3, 0x2, 0x2, 0x2, 0x7a0, 0x79e, 0x3, 0x2, 
       0x2, 0x2, 0x7a0, 0x7a1, 0x3, 0x2, 0x2, 0x2, 0x7a1, 0x7a4, 0x3, 0x2, 
       0x2, 0x2, 0x7a2, 0x7a0, 0x3, 0x2, 0x2, 0x2, 0x7a3, 0x79b, 0x3, 0x2, 
       0x2, 0x2, 0x7a3, 0x7a4, 0x3, 0x2, 0x2, 0x2, 0x7a4, 0x7a5, 0x3, 0x2, 
       0x2, 0x2, 0x7a5, 0x7a6, 0x7, 0x19c, 0x2, 0x2, 0x7a6, 0x7a7, 0x7, 
       0x127, 0x2, 0x2, 0x7a7, 0x7ab, 0x5, 0x3b8, 0x1dd, 0x2, 0x7a8, 0x7aa, 
       0x5, 0x68, 0x35, 0x2, 0x7a9, 0x7a8, 0x3, 0x2, 0x2, 0x2, 0x7aa, 0x7ad, 
       0x3, 0x2, 0x2, 0x2, 0x7ab, 0x7a9, 0x3, 0x2, 0x2, 0x2, 0x7ab, 0x7ac, 
       0x3, 0x2, 0x2, 0x2, 0x7ac, 0x7ae, 0x3, 0x2, 0x2, 0x2, 0x7ad, 0x7ab, 
       0x3, 0x2, 0x2, 0x2, 0x7ae, 0x7af, 0x5, 0x2f2, 0x17a, 0x2, 0x7af, 
       0x65, 0x3, 0x2, 0x2, 0x2, 0x7b0, 0x7b2, 0x7, 0x3f, 0x2, 0x2, 0x7b1, 
       0x7b0, 0x3, 0x2, 0x2, 0x2, 0x7b1, 0x7b2, 0x3, 0x2, 0x2, 0x2, 0x7b2, 
       0x7b3, 0x3, 0x2, 0x2, 0x2, 0x7b3, 0x7b4, 0x7, 0x166, 0x2, 0x2, 0x7b4, 
       0x7b5, 0x5, 0x41a, 0x20e, 0x2, 0x7b5, 0x7b6, 0x7, 0x127, 0x2, 0x2, 
       0x7b6, 0x7b7, 0x9, 0xb, 0x2, 0x2, 0x7b7, 0x7b8, 0x7, 0x31, 0x2, 0x2, 
       0x7b8, 0x7b9, 0x5, 0x460, 0x231, 0x2, 0x7b9, 0x67, 0x3, 0x2, 0x2, 
       0x2, 0x7ba, 0x7c0, 0x5, 0x6c, 0x37, 0x2, 0x7bb, 0x7bd, 0x7, 0x23e, 
       0x2, 0x2, 0x7bc, 0x7bb, 0x3, 0x2, 0x2, 0x2, 0x7bc, 0x7bd, 0x3, 0x2, 
       0x2, 0x2, 0x7bd, 0x7be, 0x3, 0x2, 0x2, 0x2, 0x7be, 0x7c0, 0x7, 0x1e5, 
       0x2, 0x2, 0x7bf, 0x7ba, 0x3, 0x2, 0x2, 0x2, 0x7bf, 0x7bc, 0x3, 0x2, 
       0x2, 0x2, 0x7c0, 0x69, 0x3, 0x2, 0x2, 0x2, 0x7c1, 0x7c3, 0x5, 0x68, 
       0x35, 0x2, 0x7c2, 0x7c1, 0x3, 0x2, 0x2, 0x2, 0x7c3, 0x7c4, 0x3, 0x2, 
       0x2, 0x2, 0x7c4, 0x7c2, 0x3, 0x2, 0x2, 0x2, 0x7c4, 0x7c5, 0x3, 0x2, 
       0x2, 0x2, 0x7c5, 0x6b, 0x3, 0x2, 0x2, 0x2, 0x7c6, 0x7c7, 0x7, 0xd, 
       0x2, 0x2, 0x7c7, 0x7d8, 0x5, 0x460, 0x231, 0x2, 0x7c8, 0x7c9, 0x7, 
       0x1c, 0x2, 0x2, 0x7c9, 0x7d8, 0x7, 0x279, 0x2, 0x2, 0x7ca, 0x7cb, 
       0x7, 0x1d, 0x2, 0x2, 0x7cb, 0x7d8, 0x7, 0x279, 0x2, 0x2, 0x7cc, 0x7cd, 
       0x7, 0xf, 0x2, 0x2, 0x7cd, 0x7d8, 0x7, 0x279, 0x2, 0x2, 0x7ce, 0x7cf, 
       0x7, 0x256, 0x2, 0x2, 0x7cf, 0x7d0, 0x7, 0x279, 0x2, 0x2, 0x7d0, 
       0x7d8, 0x7, 0x6f, 0x2, 0x2, 0x7d1, 0x7d2, 0x7, 0x238, 0x2, 0x2, 0x7d2, 
       0x7d3, 0x7, 0x279, 0x2, 0x2, 0x7d3, 0x7d8, 0x7, 0x6f, 0x2, 0x2, 0x7d4, 
       0x7d5, 0x7, 0x279, 0x2, 0x2, 0x7d5, 0x7d6, 0x7, 0x2c, 0x2, 0x2, 0x7d6, 
       0x7d8, 0x9, 0xc, 0x2, 0x2, 0x7d7, 0x7c6, 0x3, 0x2, 0x2, 0x2, 0x7d7, 
       0x7c8, 0x3, 0x2, 0x2, 0x2, 0x7d7, 0x7ca, 0x3, 0x2, 0x2, 0x2, 0x7d7, 
       0x7cc, 0x3, 0x2, 0x2, 0x2, 0x7d7, 0x7ce, 0x3, 0x2, 0x2, 0x2, 0x7d7, 
       0x7d1, 0x3, 0x2, 0x2, 0x2, 0x7d7, 0x7d4, 0x3, 0x2, 0x2, 0x2, 0x7d8, 
       0x6d, 0x3, 0x2, 0x2, 0x2, 0x7d9, 0x7db, 0x5, 0x3e2, 0x1f2, 0x2, 0x7da, 
       0x7d9, 0x3, 0x2, 0x2, 0x2, 0x7da, 0x7db, 0x3, 0x2, 0x2, 0x2, 0x7db, 
       0x805, 0x3, 0x2, 0x2, 0x2, 0x7dc, 0x7de, 0x7, 0x295, 0x2, 0x2, 0x7dd, 
       0x7dc, 0x3, 0x2, 0x2, 0x2, 0x7dd, 0x7de, 0x3, 0x2, 0x2, 0x2, 0x7de, 
       0x7df, 0x3, 0x2, 0x2, 0x2, 0x7df, 0x7e8, 0x7, 0x20a, 0x2, 0x2, 0x7e0, 
       0x7e1, 0x6, 0x38, 0x21, 0x2, 0x7e1, 0x7e3, 0x5, 0x3f4, 0x1fb, 0x2, 
       0x7e2, 0x7e4, 0x5, 0x366, 0x1b4, 0x2, 0x7e3, 0x7e2, 0x3, 0x2, 0x2, 
       0x2, 0x7e3, 0x7e4, 0x3, 0x2, 0x2, 0x2, 0x7e4, 0x7e9, 0x3, 0x2, 0x2, 
       0x2, 0x7e5, 0x7e7, 0x5, 0x70, 0x39, 0x2, 0x7e6, 0x7e5, 0x3, 0x2, 
       0x2, 0x2, 0x7e6, 0x7e7, 0x3, 0x2, 0x2, 0x2, 0x7e7, 0x7e9, 0x3, 0x2, 
       0x2, 0x2, 0x7e8, 0x7e0, 0x3, 0x2, 0x2, 0x2, 0x7e8, 0x7e6, 0x3, 0x2, 
       0x2, 0x2, 0x7e9, 0x7ea, 0x3, 0x2, 0x2, 0x2, 0x7ea, 0x7ee, 0x5, 0x72, 
       0x3a, 0x2, 0x7eb, 0x7ed, 0x5, 0x360, 0x1b1, 0x2, 0x7ec, 0x7eb, 0x3, 
       0x2, 0x2, 0x2, 0x7ed, 0x7f0, 0x3, 0x2, 0x2, 0x2, 0x7ee, 0x7ec, 0x3, 
       0x2, 0x2, 0x2, 0x7ee, 0x7ef, 0x3, 0x2, 0x2, 0x2, 0x7ef, 0x806, 0x3, 
       0x2, 0x2, 0x2, 0x7f0, 0x7ee, 0x3, 0x2, 0x2, 0x2, 0x7f1, 0x7f2, 0x7, 
       0x1fd, 0x2, 0x2, 0x7f2, 0x7f3, 0x7, 0x20a, 0x2, 0x2, 0x7f3, 0x7f4, 
       0x5, 0x3f4, 0x1fb, 0x2, 0x7f4, 0x7f8, 0x5, 0x72, 0x3a, 0x2, 0x7f5, 
       0x7f7, 0x5, 0x368, 0x1b5, 0x2, 0x7f6, 0x7f5, 0x3, 0x2, 0x2, 0x2, 
       0x7f7, 0x7fa, 0x3, 0x2, 0x2, 0x2, 0x7f8, 0x7f6, 0x3, 0x2, 0x2, 0x2, 
       0x7f8, 0x7f9, 0x3, 0x2, 0x2, 0x2, 0x7f9, 0x806, 0x3, 0x2, 0x2, 0x2, 
       0x7fa, 0x7f8, 0x3, 0x2, 0x2, 0x2, 0x7fb, 0x7fc, 0x7, 0x271, 0x2, 
       0x2, 0x7fc, 0x7fd, 0x7, 0x20a, 0x2, 0x2, 0x7fd, 0x7fe, 0x5, 0x3f4, 
       0x1fb, 0x2, 0x7fe, 0x802, 0x5, 0x72, 0x3a, 0x2, 0x7ff, 0x801, 0x5, 
       0x36a, 0x1b6, 0x2, 0x800, 0x7ff, 0x3, 0x2, 0x2, 0x2, 0x801, 0x804, 
       0x3, 0x2, 0x2, 0x2, 0x802, 0x800, 0x3, 0x2, 0x2, 0x2, 0x802, 0x803, 
       0x3, 0x2, 0x2, 0x2, 0x803, 0x806, 0x3, 0x2, 0x2, 0x2, 0x804, 0x802, 
       0x3, 0x2, 0x2, 0x2, 0x805, 0x7dd, 0x3, 0x2, 0x2, 0x2, 0x805, 0x7f1, 
       0x3, 0x2, 0x2, 0x2, 0x805, 0x7fb, 0x3, 0x2, 0x2, 0x2, 0x806, 0x808, 
       0x3, 0x2, 0x2, 0x2, 0x807, 0x809, 0x5, 0x30, 0x19, 0x2, 0x808, 0x807, 
       0x3, 0x2, 0x2, 0x2, 0x808, 0x809, 0x3, 0x2, 0x2, 0x2, 0x809, 0x6f, 
       0x3, 0x2, 0x2, 0x2, 0x80a, 0x80d, 0x5, 0x3f4, 0x1fb, 0x2, 0x80b, 
       0x80c, 0x7, 0x29b, 0x2, 0x2, 0x80c, 0x80e, 0x5, 0x35e, 0x1b0, 0x2, 
       0x80d, 0x80b, 0x3, 0x2, 0x2, 0x2, 0x80d, 0x80e, 0x3, 0x2, 0x2, 0x2, 
       0x80e, 0x814, 0x3, 0x2, 0x2, 0x2, 0x80f, 0x810, 0x5, 0x3f4, 0x1fb, 
       0x2, 0x810, 0x811, 0x7, 0x164, 0x2, 0x2, 0x811, 0x812, 0x5, 0x35e, 
       0x1b0, 0x2, 0x812, 0x814, 0x3, 0x2, 0x2, 0x2, 0x813, 0x80a, 0x3, 
       0x2, 0x2, 0x2, 0x813, 0x80f, 0x3, 0x2, 0x2, 0x2, 0x814, 0x71, 0x3, 
       0x2, 0x2, 0x2, 0x815, 0x816, 0x7, 0x244, 0x2, 0x2, 0x816, 0x817, 
       0x5, 0x428, 0x215, 0x2, 0x817, 0x818, 0x5, 0x35c, 0x1af, 0x2, 0x818, 
       0x73, 0x3, 0x2, 0x2, 0x2, 0x819, 0x81a, 0x7, 0xb8, 0x2, 0x2, 0x81a, 
       0x81b, 0x7, 0x201, 0x2, 0x2, 0x81b, 0x81c, 0x5, 0x412, 0x20a, 0x2, 
       0x81c, 0x81d, 0x7, 0x1ac, 0x2, 0x2, 0x81d, 0x81e, 0x9, 0xd, 0x2, 
       0x2, 0x81e, 0x820, 0x5, 0x460, 0x231, 0x2, 0x81f, 0x821, 0x5, 0x76, 
       0x3c, 0x2, 0x820, 0x81f, 0x3, 0x2, 0x2, 0x2, 0x820, 0x821, 0x3, 0x2, 
       0x2, 0x2, 0x821, 0x75, 0x3, 0x2, 0x2, 0x2, 0x822, 0x829, 0x5, 0x78, 
       0x3d, 0x2, 0x823, 0x825, 0x7, 0x198, 0x2, 0x2, 0x824, 0x823, 0x3, 
       0x2, 0x2, 0x2, 0x824, 0x825, 0x3, 0x2, 0x2, 0x2, 0x825, 0x826, 0x3, 
       0x2, 0x2, 0x2, 0x826, 0x828, 0x5, 0x78, 0x3d, 0x2, 0x827, 0x824, 
       0x3, 0x2, 0x2, 0x2, 0x828, 0x82b, 0x3, 0x2, 0x2, 0x2, 0x829, 0x827, 
       0x3, 0x2, 0x2, 0x2, 0x829, 0x82a, 0x3, 0x2, 0x2, 0x2, 0x82a, 0x77, 
       0x3, 0x2, 0x2, 0x2, 0x82b, 0x829, 0x3, 0x2, 0x2, 0x2, 0x82c, 0x833, 
       0x5, 0x8c, 0x47, 0x2, 0x82d, 0x833, 0x5, 0x8e, 0x48, 0x2, 0x82e, 
       0x833, 0x5, 0x96, 0x4c, 0x2, 0x82f, 0x833, 0x5, 0x98, 0x4d, 0x2, 
       0x830, 0x833, 0x5, 0x9a, 0x4e, 0x2, 0x831, 0x833, 0x5, 0x9c, 0x4f, 
       0x2, 0x832, 0x82c, 0x3, 0x2, 0x2, 0x2, 0x832, 0x82d, 0x3, 0x2, 0x2, 
       0x2, 0x832, 0x82e, 0x3, 0x2, 0x2, 0x2, 0x832, 0x82f, 0x3, 0x2, 0x2, 
       0x2, 0x832, 0x830, 0x3, 0x2, 0x2, 0x2, 0x832, 0x831, 0x3, 0x2, 0x2, 
       0x2, 0x833, 0x79, 0x3, 0x2, 0x2, 0x2, 0x834, 0x835, 0x7, 0x2d, 0x2, 
       0x2, 0x835, 0x836, 0x5, 0x41c, 0x20f, 0x2, 0x836, 0x837, 0x7, 0x1fa, 
       0x2, 0x2, 0x837, 0x838, 0x7, 0x6f, 0x2, 0x2, 0x838, 0x839, 0x7, 0x38, 
       0x2, 0x2, 0x839, 0x83a, 0x5, 0x472, 0x23a, 0x2, 0x83a, 0x83b, 0x5, 
       0x7c, 0x3f, 0x2, 0x83b, 0x7b, 0x3, 0x2, 0x2, 0x2, 0x83c, 0x83d, 0x7, 
       0x1f, 0x2, 0x2, 0x83d, 0x83e, 0x7, 0x19b, 0x2, 0x2, 0x83e, 0x843, 
       0x5, 0x7e, 0x40, 0x2, 0x83f, 0x840, 0x7, 0x198, 0x2, 0x2, 0x840, 
       0x842, 0x5, 0x7e, 0x40, 0x2, 0x841, 0x83f, 0x3, 0x2, 0x2, 0x2, 0x842, 
       0x845, 0x3, 0x2, 0x2, 0x2, 0x843, 0x841, 0x3, 0x2, 0x2, 0x2, 0x843, 
       0x844, 0x3, 0x2, 0x2, 0x2, 0x844, 0x846, 0x3, 0x2, 0x2, 0x2, 0x845, 
       0x843, 0x3, 0x2, 0x2, 0x2, 0x846, 0x847, 0x7, 0x19c, 0x2, 0x2, 0x847, 
       0x7d, 0x3, 0x2, 0x2, 0x2, 0x848, 0x849, 0x7, 0x1a, 0x2, 0x2, 0x849, 
       0x857, 0x5, 0x460, 0x231, 0x2, 0x84a, 0x84b, 0x7, 0x1d5, 0x2, 0x2, 
       0x84b, 0x857, 0x5, 0x460, 0x231, 0x2, 0x84c, 0x84d, 0x7, 0x16e, 0x2, 
       0x2, 0x84d, 0x857, 0x5, 0x460, 0x231, 0x2, 0x84e, 0x84f, 0x7, 0xfd, 
       0x2, 0x2, 0x84f, 0x857, 0x5, 0x460, 0x231, 0x2, 0x850, 0x851, 0x7, 
       0x30, 0x2, 0x2, 0x851, 0x857, 0x5, 0x460, 0x231, 0x2, 0x852, 0x853, 
       0x7, 0x20, 0x2, 0x2, 0x853, 0x857, 0x5, 0x460, 0x231, 0x2, 0x854, 
       0x855, 0x7, 0x23, 0x2, 0x2, 0x855, 0x857, 0x5, 0x44e, 0x228, 0x2, 
       0x856, 0x848, 0x3, 0x2, 0x2, 0x2, 0x856, 0x84a, 0x3, 0x2, 0x2, 0x2, 
       0x856, 0x84c, 0x3, 0x2, 0x2, 0x2, 0x856, 0x84e, 0x3, 0x2, 0x2, 0x2, 
       0x856, 0x850, 0x3, 0x2, 0x2, 0x2, 0x856, 0x852, 0x3, 0x2, 0x2, 0x2, 
       0x856, 0x854, 0x3, 0x2, 0x2, 0x2, 0x857, 0x7f, 0x3, 0x2, 0x2, 0x2, 
       0x858, 0x859, 0x7, 0x158, 0x2, 0x2, 0x859, 0x85a, 0x5, 0x40e, 0x208, 
       0x2, 0x85a, 0x85f, 0x5, 0x84, 0x43, 0x2, 0x85b, 0x85c, 0x7, 0x29a, 
       0x2, 0x2, 0x85c, 0x85d, 0x7, 0xb8, 0x2, 0x2, 0x85d, 0x85e, 0x7, 0x201, 
       0x2, 0x2, 0x85e, 0x860, 0x5, 0x414, 0x20b, 0x2, 0x85f, 0x85b, 0x3, 
       0x2, 0x2, 0x2, 0x85f, 0x860, 0x3, 0x2, 0x2, 0x2, 0x860, 0x862, 0x3, 
       0x2, 0x2, 0x2, 0x861, 0x863, 0x5, 0x88, 0x45, 0x2, 0x862, 0x861, 
       0x3, 0x2, 0x2, 0x2, 0x862, 0x863, 0x3, 0x2, 0x2, 0x2, 0x863, 0x81, 
       0x3, 0x2, 0x2, 0x2, 0x864, 0x865, 0x7, 0x293, 0x2, 0x2, 0x865, 0x866, 
       0x7, 0x158, 0x2, 0x2, 0x866, 0x867, 0x5, 0x40e, 0x208, 0x2, 0x867, 
       0x868, 0x7, 0x1ac, 0x2, 0x2, 0x868, 0x86a, 0x5, 0x86, 0x44, 0x2, 
       0x869, 0x86b, 0x5, 0x3e, 0x20, 0x2, 0x86a, 0x869, 0x3, 0x2, 0x2, 
       0x2, 0x86a, 0x86b, 0x3, 0x2, 0x2, 0x2, 0x86b, 0x83, 0x3, 0x2, 0x2, 
       0x2, 0x86c, 0x86f, 0x6, 0x43, 0x22, 0x2, 0x86d, 0x86e, 0x7, 0x1ac, 
       0x2, 0x2, 0x86e, 0x870, 0x5, 0x86, 0x44, 0x2, 0x86f, 0x86d, 0x3, 
       0x2, 0x2, 0x2, 0x86f, 0x870, 0x3, 0x2, 0x2, 0x2, 0x870, 0x874, 0x3, 
       0x2, 0x2, 0x2, 0x871, 0x872, 0x7, 0x1ac, 0x2, 0x2, 0x872, 0x874, 
       0x5, 0x86, 0x44, 0x2, 0x873, 0x86c, 0x3, 0x2, 0x2, 0x2, 0x873, 0x871, 
       0x3, 0x2, 0x2, 0x2, 0x874, 0x85, 0x3, 0x2, 0x2, 0x2, 0x875, 0x876, 
       0x7, 0x70, 0x2, 0x2, 0x876, 0x877, 0x5, 0x460, 0x231, 0x2, 0x877, 
       0x87, 0x3, 0x2, 0x2, 0x2, 0x878, 0x87f, 0x5, 0x8a, 0x46, 0x2, 0x879, 
       0x87b, 0x7, 0x198, 0x2, 0x2, 0x87a, 0x879, 0x3, 0x2, 0x2, 0x2, 0x87a, 
       0x87b, 0x3, 0x2, 0x2, 0x2, 0x87b, 0x87c, 0x3, 0x2, 0x2, 0x2, 0x87c, 
       0x87e, 0x5, 0x8a, 0x46, 0x2, 0x87d, 0x87a, 0x3, 0x2, 0x2, 0x2, 0x87e, 
       0x881, 0x3, 0x2, 0x2, 0x2, 0x87f, 0x87d, 0x3, 0x2, 0x2, 0x2, 0x87f, 
       0x880, 0x3, 0x2, 0x2, 0x2, 0x880, 0x89, 0x3, 0x2, 0x2, 0x2, 0x881, 
       0x87f, 0x3, 0x2, 0x2, 0x2, 0x882, 0x88f, 0x5, 0x8c, 0x47, 0x2, 0x883, 
       0x88f, 0x5, 0x90, 0x49, 0x2, 0x884, 0x88f, 0x5, 0x92, 0x4a, 0x2, 
       0x885, 0x88f, 0x5, 0x94, 0x4b, 0x2, 0x886, 0x88f, 0x5, 0x96, 0x4c, 
       0x2, 0x887, 0x88f, 0x5, 0x98, 0x4d, 0x2, 0x888, 0x88f, 0x5, 0x9a, 
       0x4e, 0x2, 0x889, 0x88f, 0x5, 0x9c, 0x4f, 0x2, 0x88a, 0x88b, 0x6, 
       0x46, 0x23, 0x2, 0x88b, 0x88f, 0x5, 0x9e, 0x50, 0x2, 0x88c, 0x88d, 
       0x6, 0x46, 0x24, 0x2, 0x88d, 0x88f, 0x5, 0xa0, 0x51, 0x2, 0x88e, 
       0x882, 0x3, 0x2, 0x2, 0x2, 0x88e, 0x883, 0x3, 0x2, 0x2, 0x2, 0x88e, 
       0x884, 0x3, 0x2, 0x2, 0x2, 0x88e, 0x885, 0x3, 0x2, 0x2, 0x2, 0x88e, 
       0x886, 0x3, 0x2, 0x2, 0x2, 0x88e, 0x887, 0x3, 0x2, 0x2, 0x2, 0x88e, 
       0x888, 0x3, 0x2, 0x2, 0x2, 0x88e, 0x889, 0x3, 0x2, 0x2, 0x2, 0x88e, 
       0x88a, 0x3, 0x2, 0x2, 0x2, 0x88e, 0x88c, 0x3, 0x2, 0x2, 0x2, 0x88f, 
       0x8b, 0x3, 0x2, 0x2, 0x2, 0x890, 0x892, 0x7, 0xa6, 0x2, 0x2, 0x891, 
       0x893, 0x7, 0x181, 0x2, 0x2, 0x892, 0x891, 0x3, 0x2, 0x2, 0x2, 0x892, 
       0x893, 0x3, 0x2, 0x2, 0x2, 0x893, 0x894, 0x3, 0x2, 0x2, 0x2, 0x894, 
       0x895, 0x5, 0x476, 0x23c, 0x2, 0x895, 0x8d, 0x3, 0x2, 0x2, 0x2, 0x896, 
       0x898, 0x9, 0xe, 0x2, 0x2, 0x897, 0x899, 0x7, 0x181, 0x2, 0x2, 0x898, 
       0x897, 0x3, 0x2, 0x2, 0x2, 0x898, 0x899, 0x3, 0x2, 0x2, 0x2, 0x899, 
       0x89a, 0x3, 0x2, 0x2, 0x2, 0x89a, 0x89b, 0x5, 0x476, 0x23c, 0x2, 
       0x89b, 0x8f, 0x3, 0x2, 0x2, 0x2, 0x89c, 0x89e, 0x7, 0x46, 0x2, 0x2, 
       0x89d, 0x89f, 0x7, 0x181, 0x2, 0x2, 0x89e, 0x89d, 0x3, 0x2, 0x2, 
       0x2, 0x89e, 0x89f, 0x3, 0x2, 0x2, 0x2, 0x89f, 0x8a0, 0x3, 0x2, 0x2, 
       0x2, 0x8a0, 0x8a1, 0x5, 0x476, 0x23c, 0x2, 0x8a1, 0x91, 0x3, 0x2, 
       0x2, 0x2, 0x8a2, 0x8a4, 0x7, 0xd4, 0x2, 0x2, 0x8a3, 0x8a5, 0x7, 0x181, 
       0x2, 0x2, 0x8a4, 0x8a3, 0x3, 0x2, 0x2, 0x2, 0x8a4, 0x8a5, 0x3, 0x2, 
       0x2, 0x2, 0x8a5, 0x8a6, 0x3, 0x2, 0x2, 0x2, 0x8a6, 0x8a7, 0x5, 0x476, 
       0x23c, 0x2, 0x8a7, 0x93, 0x3, 0x2, 0x2, 0x2, 0x8a8, 0x8aa, 0x7, 0x8d, 
       0x2, 0x2, 0x8a9, 0x8ab, 0x7, 0x181, 0x2, 0x2, 0x8aa, 0x8a9, 0x3, 
       0x2, 0x2, 0x2, 0x8aa, 0x8ab, 0x3, 0x2, 0x2, 0x2, 0x8ab, 0x8ac, 0x3, 
       0x2, 0x2, 0x2, 0x8ac, 0x8ad, 0x5, 0x476, 0x23c, 0x2, 0x8ad, 0x95, 
       0x3, 0x2, 0x2, 0x2, 0x8ae, 0x8b0, 0x7, 0xf0, 0x2, 0x2, 0x8af, 0x8b1, 
       0x7, 0x181, 0x2, 0x2, 0x8b0, 0x8af, 0x3, 0x2, 0x2, 0x2, 0x8b0, 0x8b1, 
       0x3, 0x2, 0x2, 0x2, 0x8b1, 0x8b2, 0x3, 0x2, 0x2, 0x2, 0x8b2, 0x8b3, 
       0x5, 0x450, 0x229, 0x2, 0x8b3, 0x97, 0x3, 0x2, 0x2, 0x2, 0x8b4, 0x8b6, 
       0x7, 0x14a, 0x2, 0x2, 0x8b5, 0x8b4, 0x3, 0x2, 0x2, 0x2, 0x8b5, 0x8b6, 
       0x3, 0x2, 0x2, 0x2, 0x8b6, 0x8b7, 0x3, 0x2, 0x2, 0x2, 0x8b7, 0x8b9, 
       0x7, 0x82, 0x2, 0x2, 0x8b8, 0x8ba, 0x7, 0x181, 0x2, 0x2, 0x8b9, 0x8b8, 
       0x3, 0x2, 0x2, 0x2, 0x8b9, 0x8ba, 0x3, 0x2, 0x2, 0x2, 0x8ba, 0x8bb, 
       0x3, 0x2, 0x2, 0x2, 0x8bb, 0x8bc, 0x5, 0x420, 0x211, 0x2, 0x8bc, 
       0x99, 0x3, 0x2, 0x2, 0x2, 0x8bd, 0x8be, 0x9, 0xf, 0x2, 0x2, 0x8be, 
       0x9b, 0x3, 0x2, 0x2, 0x2, 0x8bf, 0x8c1, 0x7, 0xd, 0x2, 0x2, 0x8c0, 
       0x8c2, 0x7, 0x181, 0x2, 0x2, 0x8c1, 0x8c0, 0x3, 0x2, 0x2, 0x2, 0x8c1, 
       0x8c2, 0x3, 0x2, 0x2, 0x2, 0x8c2, 0x8c3, 0x3, 0x2, 0x2, 0x2, 0x8c3, 
       0x8c4, 0x5, 0x460, 0x231, 0x2, 0x8c4, 0x9d, 0x3, 0x2, 0x2, 0x2, 0x8c5, 
       0x8c7, 0x7, 0x94, 0x2, 0x2, 0x8c6, 0x8c8, 0x7, 0x181, 0x2, 0x2, 0x8c7, 
       0x8c6, 0x3, 0x2, 0x2, 0x2, 0x8c7, 0x8c8, 0x3, 0x2, 0x2, 0x2, 0x8c8, 
       0x8c9, 0x3, 0x2, 0x2, 0x2, 0x8c9, 0x8ca, 0x5, 0x476, 0x23c, 0x2, 
       0x8ca, 0x9f, 0x3, 0x2, 0x2, 0x2, 0x8cb, 0x8cd, 0x7, 0x62, 0x2, 0x2, 
       0x8cc, 0x8ce, 0x7, 0x181, 0x2, 0x2, 0x8cd, 0x8cc, 0x3, 0x2, 0x2, 
       0x2, 0x8cd, 0x8ce, 0x3, 0x2, 0x2, 0x2, 0x8ce, 0x8cf, 0x3, 0x2, 0x2, 
       0x2, 0x8cf, 0x8d0, 0x5, 0x45c, 0x22f, 0x2, 0x8d0, 0xa1, 0x3, 0x2, 
       0x2, 0x2, 0x8d1, 0x8d3, 0x5, 0xa4, 0x53, 0x2, 0x8d2, 0x8d1, 0x3, 
       0x2, 0x2, 0x2, 0x8d2, 0x8d3, 0x3, 0x2, 0x2, 0x2, 0x8d3, 0x8d5, 0x3, 
       0x2, 0x2, 0x2, 0x8d4, 0x8d6, 0x5, 0x3ac, 0x1d7, 0x2, 0x8d5, 0x8d4, 
       0x3, 0x2, 0x2, 0x2, 0x8d5, 0x8d6, 0x3, 0x2, 0x2, 0x2, 0x8d6, 0x8d8, 
       0x3, 0x2, 0x2, 0x2, 0x8d7, 0x8d9, 0x5, 0xa8, 0x55, 0x2, 0x8d8, 0x8d7, 
       0x3, 0x2, 0x2, 0x2, 0x8d8, 0x8d9, 0x3, 0x2, 0x2, 0x2, 0x8d9, 0x8da, 
       0x3, 0x2, 0x2, 0x2, 0x8da, 0x8db, 0x7, 0x171, 0x2, 0x2, 0x8db, 0x8dc, 
       0x5, 0x40a, 0x206, 0x2, 0x8dc, 0x8dd, 0x5, 0x4a, 0x26, 0x2, 0x8dd, 
       0xa3, 0x3, 0x2, 0x2, 0x2, 0x8de, 0x8df, 0x7, 0x24c, 0x2, 0x2, 0x8df, 
       0x8e1, 0x7, 0x25f, 0x2, 0x2, 0x8e0, 0x8e2, 0x5, 0xa6, 0x54, 0x2, 
       0x8e1, 0x8e0, 0x3, 0x2, 0x2, 0x2, 0x8e1, 0x8e2, 0x3, 0x2, 0x2, 0x2, 
       0x8e2, 0x8e5, 0x3, 0x2, 0x2, 0x2, 0x8e3, 0x8e5, 0x5, 0xa6, 0x54, 
       0x2, 0x8e4, 0x8de, 0x3, 0x2, 0x2, 0x2, 0x8e4, 0x8e3, 0x3, 0x2, 0x2, 
       0x2, 0x8e5, 0xa5, 0x3, 0x2, 0x2, 0x2, 0x8e6, 0x8e7, 0x7, 0x40, 0x2, 
       0x2, 0x8e7, 0x8e8, 0x7, 0x181, 0x2, 0x2, 0x8e8, 0x8e9, 0x9, 0x10, 
       0x2, 0x2, 0x8e9, 0xa7, 0x3, 0x2, 0x2, 0x2, 0x8ea, 0x8eb, 0x7, 0x279, 
       0x2, 0x2, 0x8eb, 0x8ec, 0x7, 0x2c, 0x2, 0x2, 0x8ec, 0x8ed, 0x9, 0xc, 
       0x2, 0x2, 0x8ed, 0xa9, 0x3, 0x2, 0x2, 0x2, 0x8ee, 0x8f0, 0x5, 0x3ac, 
       0x1d7, 0x2, 0x8ef, 0x8ee, 0x3, 0x2, 0x2, 0x2, 0x8ef, 0x8f0, 0x3, 
       0x2, 0x2, 0x2, 0x8f0, 0x8f1, 0x3, 0x2, 0x2, 0x2, 0x8f1, 0x8f2, 0x7, 
       0x290, 0x2, 0x2, 0x8f2, 0x8f3, 0x5, 0x406, 0x204, 0x2, 0x8f3, 0x8f4, 
       0x9, 0x11, 0x2, 0x2, 0x8f4, 0x8f5, 0x9, 0x12, 0x2, 0x2, 0x8f5, 0x8f6, 
       0x7, 0x244, 0x2, 0x2, 0x8f6, 0x8f7, 0x5, 0x428, 0x215, 0x2, 0x8f7, 
       0x8f8, 0x7, 0x1fb, 0x2, 0x2, 0x8f8, 0x8f9, 0x7, 0x1eb, 0x2, 0x2, 
       0x8f9, 0x8fb, 0x7, 0x12f, 0x2, 0x2, 0x8fa, 0x8fc, 0x5, 0xac, 0x57, 
       0x2, 0x8fb, 0x8fa, 0x3, 0x2, 0x2, 0x2, 0x8fb, 0x8fc, 0x3, 0x2, 0x2, 
       0x2, 0x8fc, 0x8fd, 0x3, 0x2, 0x2, 0x2, 0x8fd, 0x8fe, 0x5, 0x2f2, 
       0x17a, 0x2, 0x8fe, 0xab, 0x3, 0x2, 0x2, 0x2, 0x8ff, 0x900, 0x6, 0x57, 
       0x25, 0x2, 0x900, 0x901, 0x9, 0x13, 0x2, 0x2, 0x901, 0x902, 0x5, 
       0x472, 0x23a, 0x2, 0x902, 0xad, 0x3, 0x2, 0x2, 0x2, 0x903, 0x905, 
       0x5, 0x3ac, 0x1d7, 0x2, 0x904, 0x903, 0x3, 0x2, 0x2, 0x2, 0x904, 
       0x905, 0x3, 0x2, 0x2, 0x2, 0x905, 0x906, 0x3, 0x2, 0x2, 0x2, 0x906, 
       0x908, 0x7, 0x87, 0x2, 0x2, 0x907, 0x909, 0x5, 0x3b0, 0x1d9, 0x2, 
       0x908, 0x907, 0x3, 0x2, 0x2, 0x2, 0x908, 0x909, 0x3, 0x2, 0x2, 0x2, 
       0x909, 0x90a, 0x3, 0x2, 0x2, 0x2, 0x90a, 0x90b, 0x5, 0x416, 0x20c, 
       0x2, 0x90b, 0x90c, 0x7, 0x244, 0x2, 0x2, 0x90c, 0x90d, 0x7, 0x131, 
       0x2, 0x2, 0x90d, 0x914, 0x5, 0x340, 0x1a1, 0x2, 0x90e, 0x90f, 0x7, 
       0x244, 0x2, 0x2, 0x90f, 0x911, 0x7, 0x5f, 0x2, 0x2, 0x910, 0x912, 
       0x7, 0x23e, 0x2, 0x2, 0x911, 0x910, 0x3, 0x2, 0x2, 0x2, 0x911, 0x912, 
       0x3, 0x2, 0x2, 0x2, 0x912, 0x913, 0x3, 0x2, 0x2, 0x2, 0x913, 0x915, 
       0x7, 0x104, 0x2, 0x2, 0x914, 0x90e, 0x3, 0x2, 0x2, 0x2, 0x914, 0x915, 
       0x3, 0x2, 0x2, 0x2, 0x915, 0x91c, 0x3, 0x2, 0x2, 0x2, 0x916, 0x91d, 
       0x7, 0x91, 0x2, 0x2, 0x917, 0x91a, 0x7, 0x7a, 0x2, 0x2, 0x918, 0x919, 
       0x7, 0x244, 0x2, 0x2, 0x919, 0x91b, 0x7, 0x2f, 0x2, 0x2, 0x91a, 0x918, 
       0x3, 0x2, 0x2, 0x2, 0x91a, 0x91b, 0x3, 0x2, 0x2, 0x2, 0x91b, 0x91d, 
       0x3, 0x2, 0x2, 0x2, 0x91c, 0x916, 0x3, 0x2, 0x2, 0x2, 0x91c, 0x917, 
       0x3, 0x2, 0x2, 0x2, 0x91c, 0x91d, 0x3, 0x2, 0x2, 0x2, 0x91d, 0x920, 
       0x3, 0x2, 0x2, 0x2, 0x91e, 0x91f, 0x7, 0xd, 0x2, 0x2, 0x91f, 0x921, 
       0x5, 0x460, 0x231, 0x2, 0x920, 0x91e, 0x3, 0x2, 0x2, 0x2, 0x920, 
       0x921, 0x3, 0x2, 0x2, 0x2, 0x921, 0x922, 0x3, 0x2, 0x2, 0x2, 0x922, 
       0x923, 0x7, 0x11, 0x2, 0x2, 0x923, 0x924, 0x5, 0x2f2, 0x17a, 0x2, 
       0x924, 0xaf, 0x3, 0x2, 0x2, 0x2, 0x925, 0x927, 0x7, 0x2b4, 0x2, 0x2, 
       0x926, 0x928, 0x5, 0x3b0, 0x1d9, 0x2, 0x927, 0x926, 0x3, 0x2, 0x2, 
       0x2, 0x927, 0x928, 0x3, 0x2, 0x2, 0x2, 0x928, 0x929, 0x3, 0x2, 0x2, 
       0x2, 0x929, 0x92a, 0x5, 0x220, 0x111, 0x2, 0x92a, 0xb1, 0x3, 0x2, 
       0x2, 0x2, 0x92b, 0x92c, 0x7, 0x24c, 0x2, 0x2, 0x92c, 0x92d, 0x7, 
       0x25f, 0x2, 0x2, 0x92d, 0x92e, 0x7, 0x271, 0x2, 0x2, 0x92e, 0x92f, 
       0x7, 0x2ef, 0x2, 0x2, 0x92f, 0x930, 0x7, 0x2e7, 0x2, 0x2, 0x930, 
       0x934, 0x5, 0x454, 0x22b, 0x2, 0x931, 0x933, 0x5, 0xb4, 0x5b, 0x2, 
       0x932, 0x931, 0x3, 0x2, 0x2, 0x2, 0x933, 0x936, 0x3, 0x2, 0x2, 0x2, 
       0x934, 0x932, 0x3, 0x2, 0x2, 0x2, 0x934, 0x935, 0x3, 0x2, 0x2, 0x2, 
       0x935, 0x945, 0x3, 0x2, 0x2, 0x2, 0x936, 0x934, 0x3, 0x2, 0x2, 0x2, 
       0x937, 0x938, 0x7, 0x271, 0x2, 0x2, 0x938, 0x939, 0x7, 0x2ef, 0x2, 
       0x2, 0x939, 0x93b, 0x7, 0x2e7, 0x2, 0x2, 0x93a, 0x93c, 0x5, 0x3b0, 
       0x1d9, 0x2, 0x93b, 0x93a, 0x3, 0x2, 0x2, 0x2, 0x93b, 0x93c, 0x3, 
       0x2, 0x2, 0x2, 0x93c, 0x93d, 0x3, 0x2, 0x2, 0x2, 0x93d, 0x941, 0x5, 
       0x454, 0x22b, 0x2, 0x93e, 0x940, 0x5, 0xb4, 0x5b, 0x2, 0x93f, 0x93e, 
       0x3, 0x2, 0x2, 0x2, 0x940, 0x943, 0x3, 0x2, 0x2, 0x2, 0x941, 0x93f, 
       0x3, 0x2, 0x2, 0x2, 0x941, 0x942, 0x3, 0x2, 0x2, 0x2, 0x942, 0x945, 
       0x3, 0x2, 0x2, 0x2, 0x943, 0x941, 0x3, 0x2, 0x2, 0x2, 0x944, 0x92b, 
       0x3, 0x2, 0x2, 0x2, 0x944, 0x937, 0x3, 0x2, 0x2, 0x2, 0x945, 0xb3, 
       0x3, 0x2, 0x2, 0x2, 0x946, 0x947, 0x7, 0xe7, 0x2, 0x2, 0x947, 0x948, 
       0x7, 0x15b, 0x2, 0x2, 0x948, 0x956, 0x5, 0x462, 0x232, 0x2, 0x949, 
       0x94a, 0x7, 0x2ec, 0x2, 0x2, 0x94a, 0x94b, 0x7, 0x15b, 0x2, 0x2, 
       0x94b, 0x956, 0x5, 0x462, 0x232, 0x2, 0x94c, 0x94d, 0x7, 0x2ee, 0x2, 
       0x2, 0x94d, 0x94e, 0x5, 0x462, 0x232, 0x2, 0x94e, 0x94f, 0x7, 0xa1, 
       0x2, 0x2, 0x94f, 0x950, 0x7, 0x1be, 0x2, 0x2, 0x950, 0x951, 0x5, 
       0x454, 0x22b, 0x2, 0x951, 0x956, 0x3, 0x2, 0x2, 0x2, 0x952, 0x953, 
       0x7, 0x2ed, 0x2, 0x2, 0x953, 0x954, 0x7, 0x15b, 0x2, 0x2, 0x954, 
       0x956, 0x5, 0x462, 0x232, 0x2, 0x955, 0x946, 0x3, 0x2, 0x2, 0x2, 
       0x955, 0x949, 0x3, 0x2, 0x2, 0x2, 0x955, 0x94c, 0x3, 0x2, 0x2, 0x2, 
       0x955, 0x952, 0x3, 0x2, 0x2, 0x2, 0x956, 0xb5, 0x3, 0x2, 0x2, 0x2, 
       0x957, 0x969, 0x7, 0x1e9, 0x2, 0x2, 0x958, 0x96a, 0x5, 0xb8, 0x5d, 
       0x2, 0x959, 0x96a, 0x5, 0xba, 0x5e, 0x2, 0x95a, 0x96a, 0x5, 0xbc, 
       0x5f, 0x2, 0x95b, 0x96a, 0x5, 0xbe, 0x60, 0x2, 0x95c, 0x96a, 0x5, 
       0xc0, 0x61, 0x2, 0x95d, 0x96a, 0x5, 0xc2, 0x62, 0x2, 0x95e, 0x96a, 
       0x5, 0xc6, 0x64, 0x2, 0x95f, 0x96a, 0x5, 0xc8, 0x65, 0x2, 0x960, 
       0x96a, 0x5, 0xca, 0x66, 0x2, 0x961, 0x96a, 0x5, 0xcc, 0x67, 0x2, 
       0x962, 0x96a, 0x5, 0xce, 0x68, 0x2, 0x963, 0x964, 0x6, 0x5c, 0x26, 
       0x2, 0x964, 0x96a, 0x5, 0xd0, 0x69, 0x2, 0x965, 0x966, 0x6, 0x5c, 
       0x27, 0x2, 0x966, 0x96a, 0x5, 0xd2, 0x6a, 0x2, 0x967, 0x968, 0x6, 
       0x5c, 0x28, 0x2, 0x968, 0x96a, 0x5, 0xd4, 0x6b, 0x2, 0x969, 0x958, 
       0x3, 0x2, 0x2, 0x2, 0x969, 0x959, 0x3, 0x2, 0x2, 0x2, 0x969, 0x95a, 
       0x3, 0x2, 0x2, 0x2, 0x969, 0x95b, 0x3, 0x2, 0x2, 0x2, 0x969, 0x95c, 
       0x3, 0x2, 0x2, 0x2, 0x969, 0x95d, 0x3, 0x2, 0x2, 0x2, 0x969, 0x95e, 
       0x3, 0x2, 0x2, 0x2, 0x969, 0x95f, 0x3, 0x2, 0x2, 0x2, 0x969, 0x960, 
       0x3, 0x2, 0x2, 0x2, 0x969, 0x961, 0x3, 0x2, 0x2, 0x2, 0x969, 0x962, 
       0x3, 0x2, 0x2, 0x2, 0x969, 0x963, 0x3, 0x2, 0x2, 0x2, 0x969, 0x965, 
       0x3, 0x2, 0x2, 0x2, 0x969, 0x967, 0x3, 0x2, 0x2, 0x2, 0x96a, 0xb7, 
       0x3, 0x2, 0x2, 0x2, 0x96b, 0x96d, 0x7, 0x1d5, 0x2, 0x2, 0x96c, 0x96e, 
       0x5, 0x3ae, 0x1d8, 0x2, 0x96d, 0x96c, 0x3, 0x2, 0x2, 0x2, 0x96d, 
       0x96e, 0x3, 0x2, 0x2, 0x2, 0x96e, 0x96f, 0x3, 0x2, 0x2, 0x2, 0x96f, 
       0x970, 0x5, 0x3fc, 0x1ff, 0x2, 0x970, 0xb9, 0x3, 0x2, 0x2, 0x2, 0x971, 
       0x973, 0x7, 0x87, 0x2, 0x2, 0x972, 0x974, 0x5, 0x3ae, 0x1d8, 0x2, 
       0x973, 0x972, 0x3, 0x2, 0x2, 0x2, 0x973, 0x974, 0x3, 0x2, 0x2, 0x2, 
       0x974, 0x975, 0x3, 0x2, 0x2, 0x2, 0x975, 0x976, 0x5, 0x418, 0x20d, 
       0x2, 0x976, 0xbb, 0x3, 0x2, 0x2, 0x2, 0x977, 0x979, 0x7, 0x166, 0x2, 
       0x2, 0x978, 0x97a, 0x5, 0x3ae, 0x1d8, 0x2, 0x979, 0x978, 0x3, 0x2, 
       0x2, 0x2, 0x979, 0x97a, 0x3, 0x2, 0x2, 0x2, 0x97a, 0x97b, 0x3, 0x2, 
       0x2, 0x2, 0x97b, 0x97c, 0x5, 0x404, 0x203, 0x2, 0x97c, 0xbd, 0x3, 
       0x2, 0x2, 0x2, 0x97d, 0x97f, 0x7, 0x253, 0x2, 0x2, 0x97e, 0x980, 
       0x5, 0x3ae, 0x1d8, 0x2, 0x97f, 0x97e, 0x3, 0x2, 0x2, 0x2, 0x97f, 
       0x980, 0x3, 0x2, 0x2, 0x2, 0x980, 0x981, 0x3, 0x2, 0x2, 0x2, 0x981, 
       0x982, 0x5, 0x400, 0x201, 0x2, 0x982, 0xbf, 0x3, 0x2, 0x2, 0x2, 0x983, 
       0x985, 0x5, 0x3e2, 0x1f2, 0x2, 0x984, 0x983, 0x3, 0x2, 0x2, 0x2, 
       0x984, 0x985, 0x3, 0x2, 0x2, 0x2, 0x985, 0x986, 0x3, 0x2, 0x2, 0x2, 
       0x986, 0x987, 0x7, 0x20a, 0x2, 0x2, 0x987, 0x988, 0x5, 0x3f6, 0x1fc, 
       0x2, 0x988, 0x989, 0x7, 0x244, 0x2, 0x2, 0x989, 0x98b, 0x5, 0x428, 
       0x215, 0x2, 0x98a, 0x98c, 0x5, 0x30, 0x19, 0x2, 0x98b, 0x98a, 0x3, 
       0x2, 0x2, 0x2, 0x98b, 0x98c, 0x3, 0x2, 0x2, 0x2, 0x98c, 0xc1, 0x3, 
       0x2, 0x2, 0x2, 0x98d, 0x98e, 0x7, 0xb8, 0x2, 0x2, 0x98e, 0x98f, 0x7, 
       0x201, 0x2, 0x2, 0x98f, 0x99a, 0x5, 0x414, 0x20b, 0x2, 0x990, 0x997, 
       0x5, 0xc4, 0x63, 0x2, 0x991, 0x993, 0x7, 0x198, 0x2, 0x2, 0x992, 
       0x991, 0x3, 0x2, 0x2, 0x2, 0x992, 0x993, 0x3, 0x2, 0x2, 0x2, 0x993, 
       0x994, 0x3, 0x2, 0x2, 0x2, 0x994, 0x996, 0x5, 0xc4, 0x63, 0x2, 0x995, 
       0x992, 0x3, 0x2, 0x2, 0x2, 0x996, 0x999, 0x3, 0x2, 0x2, 0x2, 0x997, 
       0x995, 0x3, 0x2, 0x2, 0x2, 0x997, 0x998, 0x3, 0x2, 0x2, 0x2, 0x998, 
       0x99b, 0x3, 0x2, 0x2, 0x2, 0x999, 0x997, 0x3, 0x2, 0x2, 0x2, 0x99a, 
       0x990, 0x3, 0x2, 0x2, 0x2, 0x99a, 0x99b, 0x3, 0x2, 0x2, 0x2, 0x99b, 
       0xc3, 0x3, 0x2, 0x2, 0x2, 0x99c, 0x99f, 0x5, 0x9a, 0x4e, 0x2, 0x99d, 
       0x99f, 0x5, 0x98, 0x4d, 0x2, 0x99e, 0x99c, 0x3, 0x2, 0x2, 0x2, 0x99e, 
       0x99d, 0x3, 0x2, 0x2, 0x2, 0x99f, 0xc5, 0x3, 0x2, 0x2, 0x2, 0x9a0, 
       0x9a2, 0x7, 0x2d, 0x2, 0x2, 0x9a1, 0x9a3, 0x5, 0x3ae, 0x1d8, 0x2, 
       0x9a2, 0x9a1, 0x3, 0x2, 0x2, 0x2, 0x9a2, 0x9a3, 0x3, 0x2, 0x2, 0x2, 
       0x9a3, 0x9a4, 0x3, 0x2, 0x2, 0x2, 0x9a4, 0x9a5, 0x5, 0x41e, 0x210, 
       0x2, 0x9a5, 0xc7, 0x3, 0x2, 0x2, 0x2, 0x9a6, 0x9a8, 0x7, 0x159, 0x2, 
       0x2, 0x9a7, 0x9a6, 0x3, 0x2, 0x2, 0x2, 0x9a7, 0x9a8, 0x3, 0x2, 0x2, 
       0x2, 0x9a8, 0x9a9, 0x3, 0x2, 0x2, 0x2, 0x9a9, 0x9ab, 0x9, 0x14, 0x2, 
       0x2, 0x9aa, 0x9ac, 0x5, 0x3ae, 0x1d8, 0x2, 0x9ab, 0x9aa, 0x3, 0x2, 
       0x2, 0x2, 0x9ab, 0x9ac, 0x3, 0x2, 0x2, 0x2, 0x9ac, 0x9ad, 0x3, 0x2, 
       0x2, 0x2, 0x9ad, 0x9af, 0x5, 0x42a, 0x216, 0x2, 0x9ae, 0x9b0, 0x9, 
       0x4, 0x2, 0x2, 0x9af, 0x9ae, 0x3, 0x2, 0x2, 0x2, 0x9af, 0x9b0, 0x3, 
       0x2, 0x2, 0x2, 0x9b0, 0xc9, 0x3, 0x2, 0x2, 0x2, 0x9b1, 0x9b2, 0x7, 
       0x158, 0x2, 0x2, 0x9b2, 0x9bd, 0x5, 0x410, 0x209, 0x2, 0x9b3, 0x9ba, 
       0x5, 0xc4, 0x63, 0x2, 0x9b4, 0x9b6, 0x7, 0x198, 0x2, 0x2, 0x9b5, 
       0x9b4, 0x3, 0x2, 0x2, 0x2, 0x9b5, 0x9b6, 0x3, 0x2, 0x2, 0x2, 0x9b6, 
       0x9b7, 0x3, 0x2, 0x2, 0x2, 0x9b7, 0x9b9, 0x5, 0xc4, 0x63, 0x2, 0x9b8, 
       0x9b5, 0x3, 0x2, 0x2, 0x2, 0x9b9, 0x9bc, 0x3, 0x2, 0x2, 0x2, 0x9ba, 
       0x9b8, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0x9bb, 0x3, 0x2, 0x2, 0x2, 0x9bb, 
       0x9be, 0x3, 0x2, 0x2, 0x2, 0x9bc, 0x9ba, 0x3, 0x2, 0x2, 0x2, 0x9bd, 
       0x9b3, 0x3, 0x2, 0x2, 0x2, 0x9bd, 0x9be, 0x3, 0x2, 0x2, 0x2, 0x9be, 
       0xcb, 0x3, 0x2, 0x2, 0x2, 0x9bf, 0x9c1, 0x7, 0x290, 0x2, 0x2, 0x9c0, 
       0x9c2, 0x5, 0x3ae, 0x1d8, 0x2, 0x9c1, 0x9c0, 0x3, 0x2, 0x2, 0x2, 
       0x9c1, 0x9c2, 0x3, 0x2, 0x2, 0x2, 0x9c2, 0x9c3, 0x3, 0x2, 0x2, 0x2, 
       0x9c3, 0x9c4, 0x5, 0x408, 0x205, 0x2, 0x9c4, 0xcd, 0x3, 0x2, 0x2, 
       0x2, 0x9c5, 0x9c7, 0x7, 0x171, 0x2, 0x2, 0x9c6, 0x9c8, 0x5, 0x3ae, 
       0x1d8, 0x2, 0x9c7, 0x9c6, 0x3, 0x2, 0x2, 0x2, 0x9c7, 0x9c8, 0x3, 
       0x2, 0x2, 0x2, 0x9c8, 0x9c9, 0x3, 0x2, 0x2, 0x2, 0x9c9, 0x9cb, 0x5, 
       0x3bc, 0x1df, 0x2, 0x9ca, 0x9cc, 0x9, 0x4, 0x2, 0x2, 0x9cb, 0x9ca, 
       0x3, 0x2, 0x2, 0x2, 0x9cb, 0x9cc, 0x3, 0x2, 0x2, 0x2, 0x9cc, 0xcf, 
       0x3, 0x2, 0x2, 0x2, 0x9cd, 0x9cf, 0x7, 0x2b4, 0x2, 0x2, 0x9ce, 0x9d0, 
       0x5, 0x3ae, 0x1d8, 0x2, 0x9cf, 0x9ce, 0x3, 0x2, 0x2, 0x2, 0x9cf, 
       0x9d0, 0x3, 0x2, 0x2, 0x2, 0x9d0, 0x9d1, 0x3, 0x2, 0x2, 0x2, 0x9d1, 
       0x9d2, 0x5, 0x220, 0x111, 0x2, 0x9d2, 0xd1, 0x3, 0x2, 0x2, 0x2, 0x9d3, 
       0x9d4, 0x7, 0x271, 0x2, 0x2, 0x9d4, 0x9d5, 0x7, 0x2ef, 0x2, 0x2, 
       0x9d5, 0x9d7, 0x7, 0x2e7, 0x2, 0x2, 0x9d6, 0x9d8, 0x5, 0x3ae, 0x1d8, 
       0x2, 0x9d7, 0x9d6, 0x3, 0x2, 0x2, 0x2, 0x9d7, 0x9d8, 0x3, 0x2, 0x2, 
       0x2, 0x9d8, 0x9d9, 0x3, 0x2, 0x2, 0x2, 0x9d9, 0x9da, 0x5, 0x454, 
       0x22b, 0x2, 0x9da, 0xd3, 0x3, 0x2, 0x2, 0x2, 0x9db, 0x9dc, 0x7, 0x293, 
       0x2, 0x2, 0x9dc, 0x9dd, 0x7, 0x158, 0x2, 0x2, 0x9dd, 0x9df, 0x5, 
       0x410, 0x209, 0x2, 0x9de, 0x9e0, 0x5, 0x3e, 0x20, 0x2, 0x9df, 0x9de, 
       0x3, 0x2, 0x2, 0x2, 0x9df, 0x9e0, 0x3, 0x2, 0x2, 0x2, 0x9e0, 0xd5, 
       0x3, 0x2, 0x2, 0x2, 0x9e1, 0x9e2, 0x7, 0x25d, 0x2, 0x2, 0x9e2, 0x9e3, 
       0x9, 0x14, 0x2, 0x2, 0x9e3, 0x9e8, 0x5, 0xd8, 0x6d, 0x2, 0x9e4, 0x9e5, 
       0x7, 0x198, 0x2, 0x2, 0x9e5, 0x9e7, 0x5, 0xd8, 0x6d, 0x2, 0x9e6, 
       0x9e4, 0x3, 0x2, 0x2, 0x2, 0x9e7, 0x9ea, 0x3, 0x2, 0x2, 0x2, 0x9e8, 
       0x9e6, 0x3, 0x2, 0x2, 0x2, 0x9e8, 0x9e9, 0x3, 0x2, 0x2, 0x2, 0x9e9, 
       0xd7, 0x3, 0x2, 0x2, 0x2, 0x9ea, 0x9e8, 0x3, 0x2, 0x2, 0x2, 0x9eb, 
       0x9ec, 0x5, 0x428, 0x215, 0x2, 0x9ec, 0x9ed, 0x7, 0x28e, 0x2, 0x2, 
       0x9ed, 0x9ee, 0x5, 0x422, 0x212, 0x2, 0x9ee, 0xd9, 0x3, 0x2, 0x2, 
       0x2, 0x9ef, 0x9f1, 0x7, 0x34, 0x2, 0x2, 0x9f0, 0x9f2, 0x7, 0x288, 
       0x2, 0x2, 0x9f1, 0x9f0, 0x3, 0x2, 0x2, 0x2, 0x9f1, 0x9f2, 0x3, 0x2, 
       0x2, 0x2, 0x9f2, 0x9f3, 0x3, 0x2, 0x2, 0x2, 0x9f3, 0x9f4, 0x5, 0x428, 
       0x215, 0x2, 0x9f4, 0xdb, 0x3, 0x2, 0x2, 0x2, 0x9f5, 0x9f6, 0x7, 0xa4, 
       0x2, 0x2, 0x9f6, 0x9f7, 0x7, 0x288, 0x2, 0x2, 0x9f7, 0x9f8, 0x7, 
       0x1fc, 0x2, 0x2, 0x9f8, 0x9f9, 0x5, 0x464, 0x233, 0x2, 0x9f9, 0xdd, 
       0x3, 0x2, 0x2, 0x2, 0x9fa, 0x9fb, 0x7, 0x1bf, 0x2, 0x2, 0x9fb, 0xa01, 
       0x5, 0x400, 0x201, 0x2, 0x9fc, 0x9fe, 0x7, 0x19b, 0x2, 0x2, 0x9fd, 
       0x9ff, 0x5, 0x2d8, 0x16d, 0x2, 0x9fe, 0x9fd, 0x3, 0x2, 0x2, 0x2, 
       0x9fe, 0x9ff, 0x3, 0x2, 0x2, 0x2, 0x9ff, 0xa00, 0x3, 0x2, 0x2, 0x2, 
       0xa00, 0xa02, 0x7, 0x19c, 0x2, 0x2, 0xa01, 0x9fc, 0x3, 0x2, 0x2, 
       0x2, 0xa01, 0xa02, 0x3, 0x2, 0x2, 0x2, 0xa02, 0xdf, 0x3, 0x2, 0x2, 
       0x2, 0xa03, 0xa04, 0x6, 0x71, 0x29, 0x2, 0xa04, 0xa06, 0x5, 0x140, 
       0xa1, 0x2, 0xa05, 0xa03, 0x3, 0x2, 0x2, 0x2, 0xa05, 0xa06, 0x3, 0x2, 
       0x2, 0x2, 0xa06, 0xa07, 0x3, 0x2, 0x2, 0x2, 0xa07, 0xa0b, 0x7, 0x1e2, 
       0x2, 0x2, 0xa08, 0xa0a, 0x5, 0xe4, 0x73, 0x2, 0xa09, 0xa08, 0x3, 
       0x2, 0x2, 0x2, 0xa0a, 0xa0d, 0x3, 0x2, 0x2, 0x2, 0xa0b, 0xa09, 0x3, 
       0x2, 0x2, 0x2, 0xa0b, 0xa0c, 0x3, 0x2, 0x2, 0x2, 0xa0c, 0xa2a, 0x3, 
       0x2, 0x2, 0x2, 0xa0d, 0xa0b, 0x3, 0x2, 0x2, 0x2, 0xa0e, 0xa22, 0x7, 
       0x1fc, 0x2, 0x2, 0xa0f, 0xa10, 0x5, 0x42c, 0x217, 0x2, 0xa10, 0xa11, 
       0x7, 0x29b, 0x2, 0x2, 0xa11, 0xa13, 0x5, 0x14e, 0xa8, 0x2, 0xa12, 
       0xa14, 0x5, 0x15e, 0xb0, 0x2, 0xa13, 0xa12, 0x3, 0x2, 0x2, 0x2, 0xa13, 
       0xa14, 0x3, 0x2, 0x2, 0x2, 0xa14, 0xa23, 0x3, 0x2, 0x2, 0x2, 0xa15, 
       0xa17, 0x5, 0x428, 0x215, 0x2, 0xa16, 0xa18, 0x5, 0xe2, 0x72, 0x2, 
       0xa17, 0xa16, 0x3, 0x2, 0x2, 0x2, 0xa17, 0xa18, 0x3, 0x2, 0x2, 0x2, 
       0xa18, 0xa1a, 0x3, 0x2, 0x2, 0x2, 0xa19, 0xa1b, 0x5, 0x15e, 0xb0, 
       0x2, 0xa1a, 0xa19, 0x3, 0x2, 0x2, 0x2, 0xa1a, 0xa1b, 0x3, 0x2, 0x2, 
       0x2, 0xa1b, 0xa1d, 0x3, 0x2, 0x2, 0x2, 0xa1c, 0xa1e, 0x5, 0x148, 
       0xa5, 0x2, 0xa1d, 0xa1c, 0x3, 0x2, 0x2, 0x2, 0xa1d, 0xa1e, 0x3, 0x2, 
       0x2, 0x2, 0xa1e, 0xa20, 0x3, 0x2, 0x2, 0x2, 0xa1f, 0xa21, 0x5, 0x11e, 
       0x90, 0x2, 0xa20, 0xa1f, 0x3, 0x2, 0x2, 0x2, 0xa20, 0xa21, 0x3, 0x2, 
       0x2, 0x2, 0xa21, 0xa23, 0x3, 0x2, 0x2, 0x2, 0xa22, 0xa0f, 0x3, 0x2, 
       0x2, 0x2, 0xa22, 0xa15, 0x3, 0x2, 0x2, 0x2, 0xa23, 0xa2b, 0x3, 0x2, 
       0x2, 0x2, 0xa24, 0xa25, 0x5, 0x42c, 0x217, 0x2, 0xa25, 0xa26, 0x7, 
       0x1fc, 0x2, 0x2, 0xa26, 0xa28, 0x5, 0x14e, 0xa8, 0x2, 0xa27, 0xa29, 
       0x5, 0x15e, 0xb0, 0x2, 0xa28, 0xa27, 0x3, 0x2, 0x2, 0x2, 0xa28, 0xa29, 
       0x3, 0x2, 0x2, 0x2, 0xa29, 0xa2b, 0x3, 0x2, 0x2, 0x2, 0xa2a, 0xa0e, 
       0x3, 0x2, 0x2, 0x2, 0xa2a, 0xa24, 0x3, 0x2, 0x2, 0x2, 0xa2b, 0xe1, 
       0x3, 0x2, 0x2, 0x2, 0xa2c, 0xa2d, 0x6, 0x72, 0x2a, 0x2, 0xa2d, 0xa2e, 
       0x7, 0x22, 0x2, 0x2, 0xa2e, 0xa2f, 0x7, 0x19b, 0x2, 0x2, 0xa2f, 0xa30, 
       0x5, 0x444, 0x223, 0x2, 0xa30, 0xa31, 0x7, 0x19c, 0x2, 0x2, 0xa31, 
       0xe3, 0x3, 0x2, 0x2, 0x2, 0xa32, 0xa33, 0x9, 0x15, 0x2, 0x2, 0xa33, 
       0xe5, 0x3, 0x2, 0x2, 0x2, 0xa34, 0xa39, 0x7, 0x11, 0x2, 0x2, 0xa35, 
       0xa36, 0x6, 0x74, 0x2b, 0x2, 0xa36, 0xa3a, 0x5, 0x2d8, 0x16d, 0x2, 
       0xa37, 0xa38, 0x6, 0x74, 0x2c, 0x2, 0xa38, 0xa3a, 0x5, 0x158, 0xad, 
       0x2, 0xa39, 0xa35, 0x3, 0x2, 0x2, 0x2, 0xa39, 0xa37, 0x3, 0x2, 0x2, 
       0x2, 0xa3a, 0xe7, 0x3, 0x2, 0x2, 0x2, 0xa3b, 0xa4d, 0x7, 0x18, 0x2, 
       0x2, 0xa3c, 0xa3d, 0x5, 0x428, 0x215, 0x2, 0xa3d, 0xa3f, 0x7, 0x1e, 
       0x2, 0x2, 0xa3e, 0xa40, 0x5, 0x186, 0xc4, 0x2, 0xa3f, 0xa3e, 0x3, 
       0x2, 0x2, 0x2, 0xa3f, 0xa40, 0x3, 0x2, 0x2, 0x2, 0xa40, 0xa4e, 0x3, 
       0x2, 0x2, 0x2, 0xa41, 0xa4b, 0x5, 0x442, 0x222, 0x2, 0xa42, 0xa4c, 
       0x7, 0xc, 0x2, 0x2, 0xa43, 0xa44, 0x7, 0x257, 0x2, 0x2, 0xa44, 0xa46, 
       0x5, 0xea, 0x76, 0x2, 0xa45, 0xa47, 0x5, 0x15e, 0xb0, 0x2, 0xa46, 
       0xa45, 0x3, 0x2, 0x2, 0x2, 0xa46, 0xa47, 0x3, 0x2, 0x2, 0x2, 0xa47, 
       0xa49, 0x3, 0x2, 0x2, 0x2, 0xa48, 0xa4a, 0x5, 0x11c, 0x8f, 0x2, 0xa49, 
       0xa48, 0x3, 0x2, 0x2, 0x2, 0xa49, 0xa4a, 0x3, 0x2, 0x2, 0x2, 0xa4a, 
       0xa4c, 0x3, 0x2, 0x2, 0x2, 0xa4b, 0xa42, 0x3, 0x2, 0x2, 0x2, 0xa4b, 
       0xa43, 0x3, 0x2, 0x2, 0x2, 0xa4c, 0xa4e, 0x3, 0x2, 0x2, 0x2, 0xa4d, 
       0xa3c, 0x3, 0x2, 0x2, 0x2, 0xa4d, 0xa41, 0x3, 0x2, 0x2, 0x2, 0xa4e, 
       0xe9, 0x3, 0x2, 0x2, 0x2, 0xa4f, 0xa5a, 0x9, 0x16, 0x2, 0x2, 0xa50, 
       0xa57, 0x5, 0x442, 0x222, 0x2, 0xa51, 0xa58, 0x9, 0x17, 0x2, 0x2, 
       0xa52, 0xa53, 0x9, 0x18, 0x2, 0x2, 0xa53, 0xa54, 0x7, 0x19b, 0x2, 
       0x2, 0xa54, 0xa55, 0x5, 0xfa, 0x7e, 0x2, 0xa55, 0xa56, 0x7, 0x19c, 
       0x2, 0x2, 0xa56, 0xa58, 0x3, 0x2, 0x2, 0x2, 0xa57, 0xa51, 0x3, 0x2, 
       0x2, 0x2, 0xa57, 0xa52, 0x3, 0x2, 0x2, 0x2, 0xa58, 0xa5a, 0x3, 0x2, 
       0x2, 0x2, 0xa59, 0xa4f, 0x3, 0x2, 0x2, 0x2, 0xa59, 0xa50, 0x3, 0x2, 
       0x2, 0x2, 0xa5a, 0xeb, 0x3, 0x2, 0x2, 0x2, 0xa5b, 0xa5d, 0x7, 0x20f, 
       0x2, 0x2, 0xa5c, 0xa5e, 0x5, 0xee, 0x78, 0x2, 0xa5d, 0xa5c, 0x3, 
       0x2, 0x2, 0x2, 0xa5d, 0xa5e, 0x3, 0x2, 0x2, 0x2, 0xa5e, 0xa60, 0x3, 
       0x2, 0x2, 0x2, 0xa5f, 0xa61, 0x7, 0x209, 0x2, 0x2, 0xa60, 0xa5f, 
       0x3, 0x2, 0x2, 0x2, 0xa60, 0xa61, 0x3, 0x2, 0x2, 0x2, 0xa61, 0xa63, 
       0x3, 0x2, 0x2, 0x2, 0xa62, 0xa64, 0x7, 0x211, 0x2, 0x2, 0xa63, 0xa62, 
       0x3, 0x2, 0x2, 0x2, 0xa63, 0xa64, 0x3, 0x2, 0x2, 0x2, 0xa64, 0xa65, 
       0x3, 0x2, 0x2, 0x2, 0xa65, 0xa67, 0x5, 0x428, 0x215, 0x2, 0xa66, 
       0xa68, 0x5, 0x3e6, 0x1f4, 0x2, 0xa67, 0xa66, 0x3, 0x2, 0x2, 0x2, 
       0xa67, 0xa68, 0x3, 0x2, 0x2, 0x2, 0xa68, 0xa6d, 0x3, 0x2, 0x2, 0x2, 
       0xa69, 0xa6e, 0x5, 0xf0, 0x79, 0x2, 0xa6a, 0xa6b, 0x7, 0x26c, 0x2, 
       0x2, 0xa6b, 0xa6e, 0x5, 0x3be, 0x1e0, 0x2, 0xa6c, 0xa6e, 0x5, 0xf6, 
       0x7c, 0x2, 0xa6d, 0xa69, 0x3, 0x2, 0x2, 0x2, 0xa6d, 0xa6a, 0x3, 0x2, 
       0x2, 0x2, 0xa6d, 0xa6c, 0x3, 0x2, 0x2, 0x2, 0xa6e, 0xa70, 0x3, 0x2, 
       0x2, 0x2, 0xa6f, 0xa71, 0x5, 0xfc, 0x7f, 0x2, 0xa70, 0xa6f, 0x3, 
       0x2, 0x2, 0x2, 0xa70, 0xa71, 0x3, 0x2, 0x2, 0x2, 0xa71, 0xed, 0x3, 
       0x2, 0x2, 0x2, 0xa72, 0xa73, 0x9, 0x19, 0x2, 0x2, 0xa73, 0xef, 0x3, 
       0x2, 0x2, 0x2, 0xa74, 0xa76, 0x7, 0x19b, 0x2, 0x2, 0xa75, 0xa77, 
       0x5, 0xf2, 0x7a, 0x2, 0xa76, 0xa75, 0x3, 0x2, 0x2, 0x2, 0xa76, 0xa77, 
       0x3, 0x2, 0x2, 0x2, 0xa77, 0xa78, 0x3, 0x2, 0x2, 0x2, 0xa78, 0xa7a, 
       0x7, 0x19c, 0x2, 0x2, 0xa79, 0xa74, 0x3, 0x2, 0x2, 0x2, 0xa79, 0xa7a, 
       0x3, 0x2, 0x2, 0x2, 0xa7a, 0xa7b, 0x3, 0x2, 0x2, 0x2, 0xa7b, 0xa7c, 
       0x5, 0xf4, 0x7b, 0x2, 0xa7c, 0xf1, 0x3, 0x2, 0x2, 0x2, 0xa7d, 0xa82, 
       0x5, 0x3f2, 0x1fa, 0x2, 0xa7e, 0xa7f, 0x7, 0x198, 0x2, 0x2, 0xa7f, 
       0xa81, 0x5, 0x3f2, 0x1fa, 0x2, 0xa80, 0xa7e, 0x3, 0x2, 0x2, 0x2, 
       0xa81, 0xa84, 0x3, 0x2, 0x2, 0x2, 0xa82, 0xa80, 0x3, 0x2, 0x2, 0x2, 
       0xa82, 0xa83, 0x3, 0x2, 0x2, 0x2, 0xa83, 0xf3, 0x3, 0x2, 0x2, 0x2, 
       0xa84, 0xa82, 0x3, 0x2, 0x2, 0x2, 0xa85, 0xa86, 0x9, 0x1a, 0x2, 0x2, 
       0xa86, 0xa87, 0x5, 0xf8, 0x7d, 0x2, 0xa87, 0xf5, 0x3, 0x2, 0x2, 0x2, 
       0xa88, 0xa90, 0x5, 0x5e, 0x30, 0x2, 0xa89, 0xa8b, 0x7, 0x19b, 0x2, 
       0x2, 0xa8a, 0xa8c, 0x5, 0xf2, 0x7a, 0x2, 0xa8b, 0xa8a, 0x3, 0x2, 
       0x2, 0x2, 0xa8b, 0xa8c, 0x3, 0x2, 0x2, 0x2, 0xa8c, 0xa8d, 0x3, 0x2, 
       0x2, 0x2, 0xa8d, 0xa8e, 0x7, 0x19c, 0x2, 0x2, 0xa8e, 0xa90, 0x5, 
       0x5e, 0x30, 0x2, 0xa8f, 0xa88, 0x3, 0x2, 0x2, 0x2, 0xa8f, 0xa89, 
       0x3, 0x2, 0x2, 0x2, 0xa90, 0xf7, 0x3, 0x2, 0x2, 0x2, 0xa91, 0xa93, 
       0x7, 0x19b, 0x2, 0x2, 0xa92, 0xa94, 0x5, 0xfa, 0x7e, 0x2, 0xa93, 
       0xa92, 0x3, 0x2, 0x2, 0x2, 0xa93, 0xa94, 0x3, 0x2, 0x2, 0x2, 0xa94, 
       0xa95, 0x3, 0x2, 0x2, 0x2, 0xa95, 0xa9e, 0x7, 0x19c, 0x2, 0x2, 0xa96, 
       0xa97, 0x7, 0x198, 0x2, 0x2, 0xa97, 0xa99, 0x7, 0x19b, 0x2, 0x2, 
       0xa98, 0xa9a, 0x5, 0xfa, 0x7e, 0x2, 0xa99, 0xa98, 0x3, 0x2, 0x2, 
       0x2, 0xa99, 0xa9a, 0x3, 0x2, 0x2, 0x2, 0xa9a, 0xa9b, 0x3, 0x2, 0x2, 
       0x2, 0xa9b, 0xa9d, 0x7, 0x19c, 0x2, 0x2, 0xa9c, 0xa96, 0x3, 0x2, 
       0x2, 0x2, 0xa9d, 0xaa0, 0x3, 0x2, 0x2, 0x2, 0xa9e, 0xa9c, 0x3, 0x2, 
       0x2, 0x2, 0xa9e, 0xa9f, 0x3, 0x2, 0x2, 0x2, 0xa9f, 0xf9, 0x3, 0x2, 
       0x2, 0x2, 0xaa0, 0xa9e, 0x3, 0x2, 0x2, 0x2, 0xaa1, 0xaa4, 0x5, 0x28a, 
       0x146, 0x2, 0xaa2, 0xaa4, 0x7, 0x1e0, 0x2, 0x2, 0xaa3, 0xaa1, 0x3, 
       0x2, 0x2, 0x2, 0xaa3, 0xaa2, 0x3, 0x2, 0x2, 0x2, 0xaa4, 0xaac, 0x3, 
       0x2, 0x2, 0x2, 0xaa5, 0xaa8, 0x7, 0x198, 0x2, 0x2, 0xaa6, 0xaa9, 
       0x5, 0x28a, 0x146, 0x2, 0xaa7, 0xaa9, 0x7, 0x1e0, 0x2, 0x2, 0xaa8, 
       0xaa6, 0x3, 0x2, 0x2, 0x2, 0xaa8, 0xaa7, 0x3, 0x2, 0x2, 0x2, 0xaa9, 
       0xaab, 0x3, 0x2, 0x2, 0x2, 0xaaa, 0xaa5, 0x3, 0x2, 0x2, 0x2, 0xaab, 
       0xaae, 0x3, 0x2, 0x2, 0x2, 0xaac, 0xaaa, 0x3, 0x2, 0x2, 0x2, 0xaac, 
       0xaad, 0x3, 0x2, 0x2, 0x2, 0xaad, 0xfb, 0x3, 0x2, 0x2, 0x2, 0xaae, 
       0xaac, 0x3, 0x2, 0x2, 0x2, 0xaaf, 0xab0, 0x7, 0x244, 0x2, 0x2, 0xab0, 
       0xab1, 0x7, 0x7e, 0x2, 0x2, 0xab1, 0xab2, 0x7, 0x21a, 0x2, 0x2, 0xab2, 
       0xab3, 0x7, 0x298, 0x2, 0x2, 0xab3, 0xab4, 0x5, 0x3be, 0x1e0, 0x2, 
       0xab4, 0xfd, 0x3, 0x2, 0x2, 0x2, 0xab5, 0xab6, 0x7, 0x223, 0x2, 0x2, 
       0xab6, 0xab8, 0x5, 0x100, 0x81, 0x2, 0xab7, 0xab9, 0x9, 0x1b, 0x2, 
       0x2, 0xab8, 0xab7, 0x3, 0x2, 0x2, 0x2, 0xab8, 0xab9, 0x3, 0x2, 0x2, 
       0x2, 0xab9, 0xabb, 0x3, 0x2, 0x2, 0x2, 0xaba, 0xabc, 0x7, 0xb6, 0x2, 
       0x2, 0xabb, 0xaba, 0x3, 0x2, 0x2, 0x2, 0xabb, 0xabc, 0x3, 0x2, 0x2, 
       0x2, 0xabc, 0xabd, 0x3, 0x2, 0x2, 0x2, 0xabd, 0xabe, 0x7, 0x20b, 
       0x2, 0x2, 0xabe, 0xac0, 0x5, 0x460, 0x231, 0x2, 0xabf, 0xac1, 0x9, 
       0xa, 0x2, 0x2, 0xac0, 0xabf, 0x3, 0x2, 0x2, 0x2, 0xac0, 0xac1, 0x3, 
       0x2, 0x2, 0x2, 0xac1, 0xac2, 0x3, 0x2, 0x2, 0x2, 0xac2, 0xac3, 0x7, 
       0x211, 0x2, 0x2, 0xac3, 0xac4, 0x7, 0x288, 0x2, 0x2, 0xac4, 0xac6, 
       0x5, 0x428, 0x215, 0x2, 0xac5, 0xac7, 0x5, 0x3e6, 0x1f4, 0x2, 0xac6, 
       0xac5, 0x3, 0x2, 0x2, 0x2, 0xac6, 0xac7, 0x3, 0x2, 0x2, 0x2, 0xac7, 
       0xac9, 0x3, 0x2, 0x2, 0x2, 0xac8, 0xaca, 0x5, 0x3c2, 0x1e2, 0x2, 
       0xac9, 0xac8, 0x3, 0x2, 0x2, 0x2, 0xac9, 0xaca, 0x3, 0x2, 0x2, 0x2, 
       0xaca, 0xacc, 0x3, 0x2, 0x2, 0x2, 0xacb, 0xacd, 0x5, 0x102, 0x82, 
       0x2, 0xacc, 0xacb, 0x3, 0x2, 0x2, 0x2, 0xacc, 0xacd, 0x3, 0x2, 0x2, 
       0x2, 0xacd, 0xacf, 0x3, 0x2, 0x2, 0x2, 0xace, 0xad0, 0x5, 0x3c4, 
       0x1e3, 0x2, 0xacf, 0xace, 0x3, 0x2, 0x2, 0x2, 0xacf, 0xad0, 0x3, 
       0x2, 0x2, 0x2, 0xad0, 0xad2, 0x3, 0x2, 0x2, 0x2, 0xad1, 0xad3, 0x5, 
       0x3c8, 0x1e5, 0x2, 0xad2, 0xad1, 0x3, 0x2, 0x2, 0x2, 0xad2, 0xad3, 
       0x3, 0x2, 0x2, 0x2, 0xad3, 0xad4, 0x3, 0x2, 0x2, 0x2, 0xad4, 0xad5, 
       0x5, 0x104, 0x83, 0x2, 0xad5, 0xff, 0x3, 0x2, 0x2, 0x2, 0xad6, 0xada, 
       0x7, 0x6f, 0x2, 0x2, 0xad7, 0xad8, 0x6, 0x81, 0x2d, 0x2, 0xad8, 0xada, 
       0x7, 0x17a, 0x2, 0x2, 0xad9, 0xad6, 0x3, 0x2, 0x2, 0x2, 0xad9, 0xad7, 
       0x3, 0x2, 0x2, 0x2, 0xada, 0x101, 0x3, 0x2, 0x2, 0x2, 0xadb, 0xadc, 
       0x6, 0x82, 0x2e, 0x2, 0xadc, 0xadd, 0x7, 0x12c, 0x2, 0x2, 0xadd, 
       0xade, 0x7, 0xa1, 0x2, 0x2, 0xade, 0xadf, 0x7, 0x1be, 0x2, 0x2, 0xadf, 
       0xae0, 0x5, 0x45e, 0x230, 0x2, 0xae0, 0x103, 0x3, 0x2, 0x2, 0x2, 
       0xae1, 0xae2, 0x7, 0x209, 0x2, 0x2, 0xae2, 0xae3, 0x7, 0x17e, 0x2, 
       0x2, 0xae3, 0xae5, 0x9, 0x1c, 0x2, 0x2, 0xae4, 0xae1, 0x3, 0x2, 0x2, 
       0x2, 0xae4, 0xae5, 0x3, 0x2, 0x2, 0x2, 0xae5, 0xae7, 0x3, 0x2, 0x2, 
       0x2, 0xae6, 0xae8, 0x5, 0x106, 0x84, 0x2, 0xae7, 0xae6, 0x3, 0x2, 
       0x2, 0x2, 0xae7, 0xae8, 0x3, 0x2, 0x2, 0x2, 0xae8, 0xaeb, 0x3, 0x2, 
       0x2, 0x2, 0xae9, 0xaea, 0x7, 0x26c, 0x2, 0x2, 0xaea, 0xaec, 0x5, 
       0x3be, 0x1e0, 0x2, 0xaeb, 0xae9, 0x3, 0x2, 0x2, 0x2, 0xaeb, 0xaec, 
       0x3, 0x2, 0x2, 0x2, 0xaec, 0x105, 0x3, 0x2, 0x2, 0x2, 0xaed, 0xaef, 
       0x7, 0x19b, 0x2, 0x2, 0xaee, 0xaf0, 0x5, 0x108, 0x85, 0x2, 0xaef, 
       0xaee, 0x3, 0x2, 0x2, 0x2, 0xaef, 0xaf0, 0x3, 0x2, 0x2, 0x2, 0xaf0, 
       0xaf1, 0x3, 0x2, 0x2, 0x2, 0xaf1, 0xaf2, 0x7, 0x19c, 0x2, 0x2, 0xaf2, 
       0x107, 0x3, 0x2, 0x2, 0x2, 0xaf3, 0xaf6, 0x5, 0x3f0, 0x1f9, 0x2, 
       0xaf4, 0xaf6, 0x5, 0x2ca, 0x166, 0x2, 0xaf5, 0xaf3, 0x3, 0x2, 0x2, 
       0x2, 0xaf5, 0xaf4, 0x3, 0x2, 0x2, 0x2, 0xaf6, 0xafe, 0x3, 0x2, 0x2, 
       0x2, 0xaf7, 0xafa, 0x7, 0x198, 0x2, 0x2, 0xaf8, 0xafb, 0x5, 0x3f0, 
       0x1f9, 0x2, 0xaf9, 0xafb, 0x5, 0x2ca, 0x166, 0x2, 0xafa, 0xaf8, 0x3, 
       0x2, 0x2, 0x2, 0xafa, 0xaf9, 0x3, 0x2, 0x2, 0x2, 0xafb, 0xafd, 0x3, 
       0x2, 0x2, 0x2, 0xafc, 0xaf7, 0x3, 0x2, 0x2, 0x2, 0xafd, 0xb00, 0x3, 
       0x2, 0x2, 0x2, 0xafe, 0xafc, 0x3, 0x2, 0x2, 0x2, 0xafe, 0xaff, 0x3, 
       0x2, 0x2, 0x2, 0xaff, 0x109, 0x3, 0x2, 0x2, 0x2, 0xb00, 0xafe, 0x3, 
       0x2, 0x2, 0x2, 0xb01, 0xb03, 0x7, 0x25f, 0x2, 0x2, 0xb02, 0xb04, 
       0x9, 0x1d, 0x2, 0x2, 0xb03, 0xb02, 0x3, 0x2, 0x2, 0x2, 0xb03, 0xb04, 
       0x3, 0x2, 0x2, 0x2, 0xb04, 0xb06, 0x3, 0x2, 0x2, 0x2, 0xb05, 0xb07, 
       0x7, 0x211, 0x2, 0x2, 0xb06, 0xb05, 0x3, 0x2, 0x2, 0x2, 0xb06, 0xb07, 
       0x3, 0x2, 0x2, 0x2, 0xb07, 0xb08, 0x3, 0x2, 0x2, 0x2, 0xb08, 0xb0a, 
       0x5, 0x428, 0x215, 0x2, 0xb09, 0xb0b, 0x5, 0x3e6, 0x1f4, 0x2, 0xb0a, 
       0xb09, 0x3, 0x2, 0x2, 0x2, 0xb0a, 0xb0b, 0x3, 0x2, 0x2, 0x2, 0xb0b, 
       0xb10, 0x3, 0x2, 0x2, 0x2, 0xb0c, 0xb11, 0x5, 0xf0, 0x79, 0x2, 0xb0d, 
       0xb0e, 0x7, 0x26c, 0x2, 0x2, 0xb0e, 0xb11, 0x5, 0x3be, 0x1e0, 0x2, 
       0xb0f, 0xb11, 0x5, 0xf6, 0x7c, 0x2, 0xb10, 0xb0c, 0x3, 0x2, 0x2, 
       0x2, 0xb10, 0xb0d, 0x3, 0x2, 0x2, 0x2, 0xb10, 0xb0f, 0x3, 0x2, 0x2, 
       0x2, 0xb11, 0x10b, 0x3, 0x2, 0x2, 0x2, 0xb12, 0xb16, 0x5, 0x110, 
       0x89, 0x2, 0xb13, 0xb16, 0x5, 0x114, 0x8b, 0x2, 0xb14, 0xb16, 0x5, 
       0x10e, 0x88, 0x2, 0xb15, 0xb12, 0x3, 0x2, 0x2, 0x2, 0xb15, 0xb13, 
       0x3, 0x2, 0x2, 0x2, 0xb15, 0xb14, 0x3, 0x2, 0x2, 0x2, 0xb16, 0x10d, 
       0x3, 0x2, 0x2, 0x2, 0xb17, 0xb18, 0x7, 0x19b, 0x2, 0x2, 0xb18, 0xb19, 
       0x5, 0x10e, 0x88, 0x2, 0xb19, 0xb1a, 0x7, 0x19c, 0x2, 0x2, 0xb1a, 
       0xb1f, 0x3, 0x2, 0x2, 0x2, 0xb1b, 0xb1c, 0x5, 0x110, 0x89, 0x2, 0xb1c, 
       0xb1d, 0x5, 0x124, 0x93, 0x2, 0xb1d, 0xb1f, 0x3, 0x2, 0x2, 0x2, 0xb1e, 
       0xb17, 0x3, 0x2, 0x2, 0x2, 0xb1e, 0xb1b, 0x3, 0x2, 0x2, 0x2, 0xb1f, 
       0x10f, 0x3, 0x2, 0x2, 0x2, 0xb20, 0xb21, 0x6, 0x89, 0x2f, 0x2, 0xb21, 
       0xb23, 0x5, 0x140, 0xa1, 0x2, 0xb22, 0xb20, 0x3, 0x2, 0x2, 0x2, 0xb22, 
       0xb23, 0x3, 0x2, 0x2, 0x2, 0xb23, 0xb33, 0x3, 0x2, 0x2, 0x2, 0xb24, 
       0xb26, 0x5, 0x112, 0x8a, 0x2, 0xb25, 0xb27, 0x5, 0x148, 0xa5, 0x2, 
       0xb26, 0xb25, 0x3, 0x2, 0x2, 0x2, 0xb26, 0xb27, 0x3, 0x2, 0x2, 0x2, 
       0xb27, 0xb29, 0x3, 0x2, 0x2, 0x2, 0xb28, 0xb2a, 0x5, 0x11c, 0x8f, 
       0x2, 0xb29, 0xb28, 0x3, 0x2, 0x2, 0x2, 0xb29, 0xb2a, 0x3, 0x2, 0x2, 
       0x2, 0xb2a, 0xb34, 0x3, 0x2, 0x2, 0x2, 0xb2b, 0xb31, 0x5, 0x114, 
       0x8b, 0x2, 0xb2c, 0xb2e, 0x5, 0x148, 0xa5, 0x2, 0xb2d, 0xb2f, 0x5, 
       0x11c, 0x8f, 0x2, 0xb2e, 0xb2d, 0x3, 0x2, 0x2, 0x2, 0xb2e, 0xb2f, 
       0x3, 0x2, 0x2, 0x2, 0xb2f, 0xb32, 0x3, 0x2, 0x2, 0x2, 0xb30, 0xb32, 
       0x5, 0x11c, 0x8f, 0x2, 0xb31, 0xb2c, 0x3, 0x2, 0x2, 0x2, 0xb31, 0xb30, 
       0x3, 0x2, 0x2, 0x2, 0xb32, 0xb34, 0x3, 0x2, 0x2, 0x2, 0xb33, 0xb24, 
       0x3, 0x2, 0x2, 0x2, 0xb33, 0xb2b, 0x3, 0x2, 0x2, 0x2, 0xb34, 0xb37, 
       0x3, 0x2, 0x2, 0x2, 0xb35, 0xb36, 0x6, 0x89, 0x30, 0x2, 0xb36, 0xb38, 
       0x5, 0x126, 0x94, 0x2, 0xb37, 0xb35, 0x3, 0x2, 0x2, 0x2, 0xb37, 0xb38, 
       0x3, 0x2, 0x2, 0x2, 0xb38, 0xb3a, 0x3, 0x2, 0x2, 0x2, 0xb39, 0xb3b, 
       0x5, 0x152, 0xaa, 0x2, 0xb3a, 0xb39, 0x3, 0x2, 0x2, 0x2, 0xb3a, 0xb3b, 
       0x3, 0x2, 0x2, 0x2, 0xb3b, 0xb43, 0x3, 0x2, 0x2, 0x2, 0xb3c, 0xb3d, 
       0x6, 0x89, 0x31, 0x2, 0xb3d, 0xb3e, 0x5, 0x140, 0xa1, 0x2, 0xb3e, 
       0xb40, 0x5, 0x114, 0x8b, 0x2, 0xb3f, 0xb41, 0x5, 0x152, 0xaa, 0x2, 
       0xb40, 0xb3f, 0x3, 0x2, 0x2, 0x2, 0xb40, 0xb41, 0x3, 0x2, 0x2, 0x2, 
       0xb41, 0xb43, 0x3, 0x2, 0x2, 0x2, 0xb42, 0xb22, 0x3, 0x2, 0x2, 0x2, 
       0xb42, 0xb3c, 0x3, 0x2, 0x2, 0x2, 0xb43, 0x111, 0x3, 0x2, 0x2, 0x2, 
       0xb44, 0xb45, 0x8, 0x8a, 0x1, 0x2, 0xb45, 0xb50, 0x5, 0x116, 0x8c, 
       0x2, 0xb46, 0xb47, 0x5, 0x114, 0x8b, 0x2, 0xb47, 0xb49, 0x7, 0x294, 
       0x2, 0x2, 0xb48, 0xb4a, 0x5, 0x184, 0xc3, 0x2, 0xb49, 0xb48, 0x3, 
       0x2, 0x2, 0x2, 0xb49, 0xb4a, 0x3, 0x2, 0x2, 0x2, 0xb4a, 0xb4d, 0x3, 
       0x2, 0x2, 0x2, 0xb4b, 0xb4e, 0x5, 0x116, 0x8c, 0x2, 0xb4c, 0xb4e, 
       0x5, 0x114, 0x8b, 0x2, 0xb4d, 0xb4b, 0x3, 0x2, 0x2, 0x2, 0xb4d, 0xb4c, 
       0x3, 0x2, 0x2, 0x2, 0xb4e, 0xb50, 0x3, 0x2, 0x2, 0x2, 0xb4f, 0xb44, 
       0x3, 0x2, 0x2, 0x2, 0xb4f, 0xb46, 0x3, 0x2, 0x2, 0x2, 0xb50, 0xb5c, 
       0x3, 0x2, 0x2, 0x2, 0xb51, 0xb52, 0xc, 0x4, 0x2, 0x2, 0xb52, 0xb54, 
       0x7, 0x294, 0x2, 0x2, 0xb53, 0xb55, 0x5, 0x184, 0xc3, 0x2, 0xb54, 
       0xb53, 0x3, 0x2, 0x2, 0x2, 0xb54, 0xb55, 0x3, 0x2, 0x2, 0x2, 0xb55, 
       0xb58, 0x3, 0x2, 0x2, 0x2, 0xb56, 0xb59, 0x5, 0x116, 0x8c, 0x2, 0xb57, 
       0xb59, 0x5, 0x114, 0x8b, 0x2, 0xb58, 0xb56, 0x3, 0x2, 0x2, 0x2, 0xb58, 
       0xb57, 0x3, 0x2, 0x2, 0x2, 0xb59, 0xb5b, 0x3, 0x2, 0x2, 0x2, 0xb5a, 
       0xb51, 0x3, 0x2, 0x2, 0x2, 0xb5b, 0xb5e, 0x3, 0x2, 0x2, 0x2, 0xb5c, 
       0xb5a, 0x3, 0x2, 0x2, 0x2, 0xb5c, 0xb5d, 0x3, 0x2, 0x2, 0x2, 0xb5d, 
       0x113, 0x3, 0x2, 0x2, 0x2, 0xb5e, 0xb5c, 0x3, 0x2, 0x2, 0x2, 0xb5f, 
       0xb62, 0x7, 0x19b, 0x2, 0x2, 0xb60, 0xb63, 0x5, 0x114, 0x8b, 0x2, 
       0xb61, 0xb63, 0x5, 0x110, 0x89, 0x2, 0xb62, 0xb60, 0x3, 0x2, 0x2, 
       0x2, 0xb62, 0xb61, 0x3, 0x2, 0x2, 0x2, 0xb63, 0xb64, 0x3, 0x2, 0x2, 
       0x2, 0xb64, 0xb65, 0x7, 0x19c, 0x2, 0x2, 0xb65, 0x115, 0x3, 0x2, 
       0x2, 0x2, 0xb66, 0xb6a, 0x7, 0x267, 0x2, 0x2, 0xb67, 0xb69, 0x5, 
       0x150, 0xa9, 0x2, 0xb68, 0xb67, 0x3, 0x2, 0x2, 0x2, 0xb69, 0xb6c, 
       0x3, 0x2, 0x2, 0x2, 0xb6a, 0xb68, 0x3, 0x2, 0x2, 0x2, 0xb6a, 0xb6b, 
       0x3, 0x2, 0x2, 0x2, 0xb6b, 0xb6d, 0x3, 0x2, 0x2, 0x2, 0xb6c, 0xb6a, 
       0x3, 0x2, 0x2, 0x2, 0xb6d, 0xb6f, 0x5, 0x158, 0xad, 0x2, 0xb6e, 0xb70, 
       0x5, 0x124, 0x93, 0x2, 0xb6f, 0xb6e, 0x3, 0x2, 0x2, 0x2, 0xb6f, 0xb70, 
       0x3, 0x2, 0x2, 0x2, 0xb70, 0xb72, 0x3, 0x2, 0x2, 0x2, 0xb71, 0xb73, 
       0x5, 0x14c, 0xa7, 0x2, 0xb72, 0xb71, 0x3, 0x2, 0x2, 0x2, 0xb72, 0xb73, 
       0x3, 0x2, 0x2, 0x2, 0xb73, 0xb75, 0x3, 0x2, 0x2, 0x2, 0xb74, 0xb76, 
       0x5, 0x15e, 0xb0, 0x2, 0xb75, 0xb74, 0x3, 0x2, 0x2, 0x2, 0xb75, 0xb76, 
       0x3, 0x2, 0x2, 0x2, 0xb76, 0xb78, 0x3, 0x2, 0x2, 0x2, 0xb77, 0xb79, 
       0x5, 0x144, 0xa3, 0x2, 0xb78, 0xb77, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb79, 
       0x3, 0x2, 0x2, 0x2, 0xb79, 0xb7b, 0x3, 0x2, 0x2, 0x2, 0xb7a, 0xb7c, 
       0x5, 0x128, 0x95, 0x2, 0xb7b, 0xb7a, 0x3, 0x2, 0x2, 0x2, 0xb7b, 0xb7c, 
       0x3, 0x2, 0x2, 0x2, 0xb7c, 0xb7f, 0x3, 0x2, 0x2, 0x2, 0xb7d, 0xb7e, 
       0x6, 0x8c, 0x33, 0x2, 0xb7e, 0xb80, 0x5, 0x12a, 0x96, 0x2, 0xb7f, 
       0xb7d, 0x3, 0x2, 0x2, 0x2, 0xb7f, 0xb80, 0x3, 0x2, 0x2, 0x2, 0xb80, 
       0x117, 0x3, 0x2, 0x2, 0x2, 0xb81, 0xb82, 0x5, 0x114, 0x8b, 0x2, 0xb82, 
       0x119, 0x3, 0x2, 0x2, 0x2, 0xb83, 0xb84, 0x9, 0x1e, 0x2, 0x2, 0xb84, 
       0x11b, 0x3, 0x2, 0x2, 0x2, 0xb85, 0xb86, 0x7, 0x220, 0x2, 0x2, 0xb86, 
       0xb87, 0x5, 0x120, 0x91, 0x2, 0xb87, 0x11d, 0x3, 0x2, 0x2, 0x2, 0xb88, 
       0xb89, 0x7, 0x220, 0x2, 0x2, 0xb89, 0xb8a, 0x5, 0x122, 0x92, 0x2, 
       0xb8a, 0x11f, 0x3, 0x2, 0x2, 0x2, 0xb8b, 0xb8e, 0x5, 0x122, 0x92, 
       0x2, 0xb8c, 0xb8d, 0x9, 0x1f, 0x2, 0x2, 0xb8d, 0xb8f, 0x5, 0x122, 
       0x92, 0x2, 0xb8e, 0xb8c, 0x3, 0x2, 0x2, 0x2, 0xb8e, 0xb8f, 0x3, 0x2, 
       0x2, 0x2, 0xb8f, 0x121, 0x3, 0x2, 0x2, 0x2, 0xb90, 0xb93, 0x5, 0x442, 
       0x222, 0x2, 0xb91, 0xb93, 0x9, 0x20, 0x2, 0x2, 0xb92, 0xb90, 0x3, 
       0x2, 0x2, 0x2, 0xb92, 0xb91, 0x3, 0x2, 0x2, 0x2, 0xb93, 0x123, 0x3, 
       0x2, 0x2, 0x2, 0xb94, 0xbb0, 0x7, 0x211, 0x2, 0x2, 0xb95, 0xb96, 
       0x7, 0x24e, 0x2, 0x2, 0xb96, 0xb98, 0x5, 0x45c, 0x22f, 0x2, 0xb97, 
       0xb99, 0x5, 0x3c2, 0x1e2, 0x2, 0xb98, 0xb97, 0x3, 0x2, 0x2, 0x2, 
       0xb98, 0xb99, 0x3, 0x2, 0x2, 0x2, 0xb99, 0xb9b, 0x3, 0x2, 0x2, 0x2, 
       0xb9a, 0xb9c, 0x5, 0x3c4, 0x1e3, 0x2, 0xb9b, 0xb9a, 0x3, 0x2, 0x2, 
       0x2, 0xb9b, 0xb9c, 0x3, 0x2, 0x2, 0x2, 0xb9c, 0xb9e, 0x3, 0x2, 0x2, 
       0x2, 0xb9d, 0xb9f, 0x5, 0x3c8, 0x1e5, 0x2, 0xb9e, 0xb9d, 0x3, 0x2, 
       0x2, 0x2, 0xb9e, 0xb9f, 0x3, 0x2, 0x2, 0x2, 0xb9f, 0xbb1, 0x3, 0x2, 
       0x2, 0x2, 0xba0, 0xba1, 0x7, 0x7d, 0x2, 0x2, 0xba1, 0xbb1, 0x5, 0x45c, 
       0x22f, 0x2, 0xba2, 0xba5, 0x5, 0x472, 0x23a, 0x2, 0xba3, 0xba5, 0x5, 
       0x2ca, 0x166, 0x2, 0xba4, 0xba2, 0x3, 0x2, 0x2, 0x2, 0xba4, 0xba3, 
       0x3, 0x2, 0x2, 0x2, 0xba5, 0xbad, 0x3, 0x2, 0x2, 0x2, 0xba6, 0xba9, 
       0x7, 0x198, 0x2, 0x2, 0xba7, 0xbaa, 0x5, 0x472, 0x23a, 0x2, 0xba8, 
       0xbaa, 0x5, 0x2ca, 0x166, 0x2, 0xba9, 0xba7, 0x3, 0x2, 0x2, 0x2, 
       0xba9, 0xba8, 0x3, 0x2, 0x2, 0x2, 0xbaa, 0xbac, 0x3, 0x2, 0x2, 0x2, 
       0xbab, 0xba6, 0x3, 0x2, 0x2, 0x2, 0xbac, 0xbaf, 0x3, 0x2, 0x2, 0x2, 
       0xbad, 0xbab, 0x3, 0x2, 0x2, 0x2, 0xbad, 0xbae, 0x3, 0x2, 0x2, 0x2, 
       0xbae, 0xbb1, 0x3, 0x2, 0x2, 0x2, 0xbaf, 0xbad, 0x3, 0x2, 0x2, 0x2, 
       0xbb0, 0xb95, 0x3, 0x2, 0x2, 0x2, 0xbb0, 0xba0, 0x3, 0x2, 0x2, 0x2, 
       0xbb0, 0xba4, 0x3, 0x2, 0x2, 0x2, 0xbb1, 0x125, 0x3, 0x2, 0x2, 0x2, 
       0xbb2, 0xbb3, 0x7, 0x253, 0x2, 0x2, 0xbb3, 0xbb4, 0x7, 0x1af, 0x2, 
       0x2, 0xbb4, 0xbba, 0x7, 0x19b, 0x2, 0x2, 0xbb5, 0xbb8, 0x7, 0x17e, 
       0x2, 0x2, 0xbb6, 0xbb7, 0x7, 0x198, 0x2, 0x2, 0xbb7, 0xbb9, 0x7, 
       0x17e, 0x2, 0x2, 0xbb8, 0xbb6, 0x3, 0x2, 0x2, 0x2, 0xbb8, 0xbb9, 
       0x3, 0x2, 0x2, 0x2, 0xbb9, 0xbbb, 0x3, 0x2, 0x2, 0x2, 0xbba, 0xbb5, 
       0x3, 0x2, 0x2, 0x2, 0xbba, 0xbbb, 0x3, 0x2, 0x2, 0x2, 0xbbb, 0xbbc, 
       0x3, 0x2, 0x2, 0x2, 0xbbc, 0xbbd, 0x7, 0x19c, 0x2, 0x2, 0xbbd, 0x127, 
       0x3, 0x2, 0x2, 0x2, 0xbbe, 0xbbf, 0x7, 0x203, 0x2, 0x2, 0xbbf, 0xbc0, 
       0x5, 0x28a, 0x146, 0x2, 0xbc0, 0x129, 0x3, 0x2, 0x2, 0x2, 0xbc1, 
       0xbc2, 0x7, 0x2dc, 0x2, 0x2, 0xbc2, 0xbc7, 0x5, 0x12c, 0x97, 0x2, 
       0xbc3, 0xbc4, 0x7, 0x198, 0x2, 0x2, 0xbc4, 0xbc6, 0x5, 0x12c, 0x97, 
       0x2, 0xbc5, 0xbc3, 0x3, 0x2, 0x2, 0x2, 0xbc6, 0xbc9, 0x3, 0x2, 0x2, 
       0x2, 0xbc7, 0xbc5, 0x3, 0x2, 0x2, 0x2, 0xbc7, 0xbc8, 0x3, 0x2, 0x2, 
       0x2, 0xbc8, 0x12b, 0x3, 0x2, 0x2, 0x2, 0xbc9, 0xbc7, 0x3, 0x2, 0x2, 
       0x2, 0xbca, 0xbcb, 0x5, 0x43e, 0x220, 0x2, 0xbcb, 0xbcc, 0x7, 0x1b1, 
       0x2, 0x2, 0xbcc, 0xbcd, 0x5, 0x12e, 0x98, 0x2, 0xbcd, 0x12d, 0x3, 
       0x2, 0x2, 0x2, 0xbce, 0xbcf, 0x7, 0x19b, 0x2, 0x2, 0xbcf, 0xbd0, 
       0x5, 0x130, 0x99, 0x2, 0xbd0, 0xbd1, 0x7, 0x19c, 0x2, 0x2, 0xbd1, 
       0x12f, 0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbd4, 0x5, 0x43e, 0x220, 0x2, 
       0xbd3, 0xbd2, 0x3, 0x2, 0x2, 0x2, 0xbd3, 0xbd4, 0x3, 0x2, 0x2, 0x2, 
       0xbd4, 0xbd8, 0x3, 0x2, 0x2, 0x2, 0xbd5, 0xbd6, 0x7, 0x22, 0x2, 0x2, 
       0xbd6, 0xbd7, 0x7, 0x1be, 0x2, 0x2, 0xbd7, 0xbd9, 0x5, 0x2e8, 0x175, 
       0x2, 0xbd8, 0xbd5, 0x3, 0x2, 0x2, 0x2, 0xbd8, 0xbd9, 0x3, 0x2, 0x2, 
       0x2, 0xbd9, 0xbdb, 0x3, 0x2, 0x2, 0x2, 0xbda, 0xbdc, 0x5, 0x148, 
       0xa5, 0x2, 0xbdb, 0xbda, 0x3, 0x2, 0x2, 0x2, 0xbdb, 0xbdc, 0x3, 0x2, 
       0x2, 0x2, 0xbdc, 0xbde, 0x3, 0x2, 0x2, 0x2, 0xbdd, 0xbdf, 0x5, 0x132, 
       0x9a, 0x2, 0xbde, 0xbdd, 0x3, 0x2, 0x2, 0x2, 0xbde, 0xbdf, 0x3, 0x2, 
       0x2, 0x2, 0xbdf, 0x131, 0x3, 0x2, 0x2, 0x2, 0xbe0, 0xbe1, 0x5, 0x134, 
       0x9b, 0x2, 0xbe1, 0xbe3, 0x5, 0x136, 0x9c, 0x2, 0xbe2, 0xbe4, 0x5, 
       0x13e, 0xa0, 0x2, 0xbe3, 0xbe2, 0x3, 0x2, 0x2, 0x2, 0xbe3, 0xbe4, 
       0x3, 0x2, 0x2, 0x2, 0xbe4, 0x133, 0x3, 0x2, 0x2, 0x2, 0xbe5, 0xbe6, 
       0x9, 0x21, 0x2, 0x2, 0xbe6, 0x135, 0x3, 0x2, 0x2, 0x2, 0xbe7, 0xbea, 
       0x5, 0x138, 0x9d, 0x2, 0xbe8, 0xbea, 0x5, 0x13a, 0x9e, 0x2, 0xbe9, 
       0xbe7, 0x3, 0x2, 0x2, 0x2, 0xbe9, 0xbe8, 0x3, 0x2, 0x2, 0x2, 0xbea, 
       0x137, 0x3, 0x2, 0x2, 0x2, 0xbeb, 0xbec, 0x7, 0x2db, 0x2, 0x2, 0xbec, 
       0xbfa, 0x7, 0x2d6, 0x2, 0x2, 0xbed, 0xbee, 0x5, 0x452, 0x22a, 0x2, 
       0xbee, 0xbef, 0x7, 0x2d6, 0x2, 0x2, 0xbef, 0xbfa, 0x3, 0x2, 0x2, 
       0x2, 0xbf0, 0xbf1, 0x7, 0x1a6, 0x2, 0x2, 0xbf1, 0xbfa, 0x7, 0x2d6, 
       0x2, 0x2, 0xbf2, 0xbf3, 0x7, 0x210, 0x2, 0x2, 0xbf3, 0xbf4, 0x5, 
       0x28a, 0x146, 0x2, 0xbf4, 0xbf5, 0x5, 0x2e0, 0x171, 0x2, 0xbf5, 0xbf6, 
       0x7, 0x2d6, 0x2, 0x2, 0xbf6, 0xbfa, 0x3, 0x2, 0x2, 0x2, 0xbf7, 0xbf8, 
       0x7, 0x6d, 0x2, 0x2, 0xbf8, 0xbfa, 0x7, 0x12f, 0x2, 0x2, 0xbf9, 0xbeb, 
       0x3, 0x2, 0x2, 0x2, 0xbf9, 0xbed, 0x3, 0x2, 0x2, 0x2, 0xbf9, 0xbf0, 
       0x3, 0x2, 0x2, 0x2, 0xbf9, 0xbf2, 0x3, 0x2, 0x2, 0x2, 0xbf9, 0xbf7, 
       0x3, 0x2, 0x2, 0x2, 0xbfa, 0x139, 0x3, 0x2, 0x2, 0x2, 0xbfb, 0xbfc, 
       0x7, 0x1b5, 0x2, 0x2, 0xbfc, 0xbfd, 0x5, 0x13c, 0x9f, 0x2, 0xbfd, 
       0xbfe, 0x7, 0x1b0, 0x2, 0x2, 0xbfe, 0xbff, 0x5, 0x13c, 0x9f, 0x2, 
       0xbff, 0x13b, 0x3, 0x2, 0x2, 0x2, 0xc00, 0xc0e, 0x5, 0x138, 0x9d, 
       0x2, 0xc01, 0xc02, 0x7, 0x2db, 0x2, 0x2, 0xc02, 0xc0e, 0x7, 0x2cb, 
       0x2, 0x2, 0xc03, 0xc04, 0x5, 0x452, 0x22a, 0x2, 0xc04, 0xc05, 0x7, 
       0x2cb, 0x2, 0x2, 0xc05, 0xc0e, 0x3, 0x2, 0x2, 0x2, 0xc06, 0xc07, 
       0x7, 0x1a6, 0x2, 0x2, 0xc07, 0xc0e, 0x7, 0x2cb, 0x2, 0x2, 0xc08, 
       0xc09, 0x7, 0x210, 0x2, 0x2, 0xc09, 0xc0a, 0x5, 0x28a, 0x146, 0x2, 
       0xc0a, 0xc0b, 0x5, 0x2e0, 0x171, 0x2, 0xc0b, 0xc0c, 0x7, 0x2cb, 0x2, 
       0x2, 0xc0c, 0xc0e, 0x3, 0x2, 0x2, 0x2, 0xc0d, 0xc00, 0x3, 0x2, 0x2, 
       0x2, 0xc0d, 0xc01, 0x3, 0x2, 0x2, 0x2, 0xc0d, 0xc03, 0x3, 0x2, 0x2, 
       0x2, 0xc0d, 0xc06, 0x3, 0x2, 0x2, 0x2, 0xc0d, 0xc08, 0x3, 0x2, 0x2, 
       0x2, 0xc0e, 0x13d, 0x3, 0x2, 0x2, 0x2, 0xc0f, 0xc16, 0x7, 0x2c9, 
       0x2, 0x2, 0xc10, 0xc11, 0x7, 0x6d, 0x2, 0x2, 0xc11, 0xc17, 0x7, 0x12f, 
       0x2, 0x2, 0xc12, 0xc17, 0x7, 0x201, 0x2, 0x2, 0xc13, 0xc17, 0x7, 
       0x2da, 0x2, 0x2, 0xc14, 0xc15, 0x7, 0x1d, 0x2, 0x2, 0xc15, 0xc17, 
       0x7, 0x2d3, 0x2, 0x2, 0xc16, 0xc10, 0x3, 0x2, 0x2, 0x2, 0xc16, 0xc12, 
       0x3, 0x2, 0x2, 0x2, 0xc16, 0xc13, 0x3, 0x2, 0x2, 0x2, 0xc16, 0xc14, 
       0x3, 0x2, 0x2, 0x2, 0xc17, 0x13f, 0x3, 0x2, 0x2, 0x2, 0xc18, 0xc1a, 
       0x7, 0x2ab, 0x2, 0x2, 0xc19, 0xc1b, 0x7, 0x2ba, 0x2, 0x2, 0xc1a, 
       0xc19, 0x3, 0x2, 0x2, 0x2, 0xc1a, 0xc1b, 0x3, 0x2, 0x2, 0x2, 0xc1b, 
       0xc1c, 0x3, 0x2, 0x2, 0x2, 0xc1c, 0xc21, 0x5, 0x142, 0xa2, 0x2, 0xc1d, 
       0xc1e, 0x7, 0x198, 0x2, 0x2, 0xc1e, 0xc20, 0x5, 0x142, 0xa2, 0x2, 
       0xc1f, 0xc1d, 0x3, 0x2, 0x2, 0x2, 0xc20, 0xc23, 0x3, 0x2, 0x2, 0x2, 
       0xc21, 0xc1f, 0x3, 0x2, 0x2, 0x2, 0xc21, 0xc22, 0x3, 0x2, 0x2, 0x2, 
       0xc22, 0x141, 0x3, 0x2, 0x2, 0x2, 0xc23, 0xc21, 0x3, 0x2, 0x2, 0x2, 
       0xc24, 0xc26, 0x5, 0x442, 0x222, 0x2, 0xc25, 0xc27, 0x5, 0x3ee, 0x1f8, 
       0x2, 0xc26, 0xc25, 0x3, 0x2, 0x2, 0x2, 0xc26, 0xc27, 0x3, 0x2, 0x2, 
       0x2, 0xc27, 0xc28, 0x3, 0x2, 0x2, 0x2, 0xc28, 0xc29, 0x7, 0x1b1, 
       0x2, 0x2, 0xc29, 0xc2a, 0x5, 0x118, 0x8d, 0x2, 0xc2a, 0x143, 0x3, 
       0x2, 0x2, 0x2, 0xc2b, 0xc2c, 0x7, 0x201, 0x2, 0x2, 0xc2c, 0xc2d, 
       0x7, 0x1be, 0x2, 0x2, 0xc2d, 0xc2f, 0x5, 0x2e8, 0x175, 0x2, 0xc2e, 
       0xc30, 0x5, 0x146, 0xa4, 0x2, 0xc2f, 0xc2e, 0x3, 0x2, 0x2, 0x2, 0xc2f, 
       0xc30, 0x3, 0x2, 0x2, 0x2, 0xc30, 0x145, 0x3, 0x2, 0x2, 0x2, 0xc31, 
       0xc32, 0x7, 0x2ab, 0x2, 0x2, 0xc32, 0xc37, 0x7, 0x129, 0x2, 0x2, 
       0xc33, 0xc34, 0x6, 0xa4, 0x34, 0x2, 0xc34, 0xc35, 0x7, 0x2ab, 0x2, 
       0x2, 0xc35, 0xc37, 0x7, 0x6c, 0x2, 0x2, 0xc36, 0xc31, 0x3, 0x2, 0x2, 
       0x2, 0xc36, 0xc33, 0x3, 0x2, 0x2, 0x2, 0xc37, 0x147, 0x3, 0x2, 0x2, 
       0x2, 0xc38, 0xc39, 0x7, 0x24b, 0x2, 0x2, 0xc39, 0xc3a, 0x7, 0x1be, 
       0x2, 0x2, 0xc3a, 0xc3b, 0x5, 0x2e8, 0x175, 0x2, 0xc3b, 0x149, 0x3, 
       0x2, 0x2, 0x2, 0xc3c, 0xc3d, 0x9, 0x22, 0x2, 0x2, 0xc3d, 0x14b, 0x3, 
       0x2, 0x2, 0x2, 0xc3e, 0xc41, 0x7, 0x1fc, 0x2, 0x2, 0xc3f, 0xc42, 
       0x7, 0x1ea, 0x2, 0x2, 0xc40, 0xc42, 0x5, 0x14e, 0xa8, 0x2, 0xc41, 
       0xc3f, 0x3, 0x2, 0x2, 0x2, 0xc41, 0xc40, 0x3, 0x2, 0x2, 0x2, 0xc42, 
       0x14d, 0x3, 0x2, 0x2, 0x2, 0xc43, 0xc48, 0x5, 0x160, 0xb1, 0x2, 0xc44, 
       0xc45, 0x7, 0x198, 0x2, 0x2, 0xc45, 0xc47, 0x5, 0x160, 0xb1, 0x2, 
       0xc46, 0xc44, 0x3, 0x2, 0x2, 0x2, 0xc47, 0xc4a, 0x3, 0x2, 0x2, 0x2, 
       0xc48, 0xc46, 0x3, 0x2, 0x2, 0x2, 0xc48, 0xc49, 0x3, 0x2, 0x2, 0x2, 
       0xc49, 0x14f, 0x3, 0x2, 0x2, 0x2, 0xc4a, 0xc48, 0x3, 0x2, 0x2, 0x2, 
       0xc4b, 0xc54, 0x5, 0x11a, 0x8e, 0x2, 0xc4c, 0xc54, 0x7, 0x142, 0x2, 
       0x2, 0xc4d, 0xc4e, 0x6, 0xa9, 0x35, 0x2, 0xc4e, 0xc54, 0x7, 0x140, 
       0x2, 0x2, 0xc4f, 0xc50, 0x6, 0xa9, 0x36, 0x2, 0xc50, 0xc51, 0x7, 
       0xd3, 0x2, 0x2, 0xc51, 0xc52, 0x7, 0x181, 0x2, 0x2, 0xc52, 0xc54, 
       0x5, 0x450, 0x229, 0x2, 0xc53, 0xc4b, 0x3, 0x2, 0x2, 0x2, 0xc53, 
       0xc4c, 0x3, 0x2, 0x2, 0x2, 0xc53, 0xc4d, 0x3, 0x2, 0x2, 0x2, 0xc53, 
       0xc4f, 0x3, 0x2, 0x2, 0x2, 0xc54, 0x151, 0x3, 0x2, 0x2, 0x2, 0xc55, 
       0xc56, 0x7, 0x1fb, 0x2, 0x2, 0xc56, 0xc5a, 0x5, 0x154, 0xab, 0x2, 
       0xc57, 0xc58, 0x6, 0xaa, 0x37, 0x2, 0xc58, 0xc59, 0x7, 0x2bd, 0x2, 
       0x2, 0xc59, 0xc5b, 0x5, 0x42c, 0x217, 0x2, 0xc5a, 0xc57, 0x3, 0x2, 
       0x2, 0x2, 0xc5a, 0xc5b, 0x3, 0x2, 0x2, 0x2, 0xc5b, 0xc5e, 0x3, 0x2, 
       0x2, 0x2, 0xc5c, 0xc5d, 0x6, 0xaa, 0x38, 0x2, 0xc5d, 0xc5f, 0x5, 
       0x156, 0xac, 0x2, 0xc5e, 0xc5c, 0x3, 0x2, 0x2, 0x2, 0xc5e, 0xc5f, 
       0x3, 0x2, 0x2, 0x2, 0xc5f, 0xc65, 0x3, 0x2, 0x2, 0x2, 0xc60, 0xc61, 
       0x7, 0x225, 0x2, 0x2, 0xc61, 0xc62, 0x7, 0x213, 0x2, 0x2, 0xc62, 
       0xc63, 0x7, 0x138, 0x2, 0x2, 0xc63, 0xc65, 0x7, 0xe0, 0x2, 0x2, 0xc64, 
       0xc55, 0x3, 0x2, 0x2, 0x2, 0xc64, 0xc60, 0x3, 0x2, 0x2, 0x2, 0xc65, 
       0x153, 0x3, 0x2, 0x2, 0x2, 0xc66, 0xc6a, 0x7, 0x298, 0x2, 0x2, 0xc67, 
       0xc68, 0x6, 0xab, 0x39, 0x2, 0xc68, 0xc6a, 0x7, 0x138, 0x2, 0x2, 
       0xc69, 0xc66, 0x3, 0x2, 0x2, 0x2, 0xc69, 0xc67, 0x3, 0x2, 0x2, 0x2, 
       0xc6a, 0x155, 0x3, 0x2, 0x2, 0x2, 0xc6b, 0xc6c, 0x7, 0x2be, 0x2, 
       0x2, 0xc6c, 0xc6f, 0x7, 0x2bf, 0x2, 0x2, 0xc6d, 0xc6f, 0x7, 0x2c0, 
       0x2, 0x2, 0xc6e, 0xc6b, 0x3, 0x2, 0x2, 0x2, 0xc6e, 0xc6d, 0x3, 0x2, 
       0x2, 0x2, 0xc6f, 0x157, 0x3, 0x2, 0x2, 0x2, 0xc70, 0xc73, 0x5, 0x15a, 
       0xae, 0x2, 0xc71, 0xc73, 0x7, 0x18b, 0x2, 0x2, 0xc72, 0xc70, 0x3, 
       0x2, 0x2, 0x2, 0xc72, 0xc71, 0x3, 0x2, 0x2, 0x2, 0xc73, 0xc78, 0x3, 
       0x2, 0x2, 0x2, 0xc74, 0xc75, 0x7, 0x198, 0x2, 0x2, 0xc75, 0xc77, 
       0x5, 0x15a, 0xae, 0x2, 0xc76, 0xc74, 0x3, 0x2, 0x2, 0x2, 0xc77, 0xc7a, 
       0x3, 0x2, 0x2, 0x2, 0xc78, 0xc76, 0x3, 0x2, 0x2, 0x2, 0xc78, 0xc79, 
       0x3, 0x2, 0x2, 0x2, 0xc79, 0x159, 0x3, 0x2, 0x2, 0x2, 0xc7a, 0xc78, 
       0x3, 0x2, 0x2, 0x2, 0xc7b, 0xc81, 0x5, 0x3f8, 0x1fd, 0x2, 0xc7c, 
       0xc7e, 0x5, 0x28a, 0x146, 0x2, 0xc7d, 0xc7f, 0x5, 0x15c, 0xaf, 0x2, 
       0xc7e, 0xc7d, 0x3, 0x2, 0x2, 0x2, 0xc7e, 0xc7f, 0x3, 0x2, 0x2, 0x2, 
       0xc7f, 0xc81, 0x3, 0x2, 0x2, 0x2, 0xc80, 0xc7b, 0x3, 0x2, 0x2, 0x2, 
       0xc80, 0xc7c, 0x3, 0x2, 0x2, 0x2, 0xc81, 0x15b, 0x3, 0x2, 0x2, 0x2, 
       0xc82, 0xc84, 0x7, 0x1b1, 0x2, 0x2, 0xc83, 0xc82, 0x3, 0x2, 0x2, 
       0x2, 0xc83, 0xc84, 0x3, 0x2, 0x2, 0x2, 0xc84, 0xc87, 0x3, 0x2, 0x2, 
       0x2, 0xc85, 0xc88, 0x5, 0x442, 0x222, 0x2, 0xc86, 0xc88, 0x5, 0x45c, 
       0x22f, 0x2, 0xc87, 0xc85, 0x3, 0x2, 0x2, 0x2, 0xc87, 0xc86, 0x3, 
       0x2, 0x2, 0x2, 0xc88, 0x15d, 0x3, 0x2, 0x2, 0x2, 0xc89, 0xc8a, 0x7, 
       0x2a9, 0x2, 0x2, 0xc8a, 0xc8b, 0x5, 0x28a, 0x146, 0x2, 0xc8b, 0x15f, 
       0x3, 0x2, 0x2, 0x2, 0xc8c, 0xc93, 0x5, 0x16c, 0xb7, 0x2, 0xc8d, 0xc8e, 
       0x7, 0x19d, 0x2, 0x2, 0xc8e, 0xc8f, 0x5, 0x442, 0x222, 0x2, 0xc8f, 
       0xc90, 0x5, 0x162, 0xb2, 0x2, 0xc90, 0xc91, 0x7, 0x19e, 0x2, 0x2, 
       0xc91, 0xc93, 0x3, 0x2, 0x2, 0x2, 0xc92, 0xc8c, 0x3, 0x2, 0x2, 0x2, 
       0xc92, 0xc8d, 0x3, 0x2, 0x2, 0x2, 0xc93, 0xc97, 0x3, 0x2, 0x2, 0x2, 
       0xc94, 0xc96, 0x5, 0x164, 0xb3, 0x2, 0xc95, 0xc94, 0x3, 0x2, 0x2, 
       0x2, 0xc96, 0xc99, 0x3, 0x2, 0x2, 0x2, 0xc97, 0xc95, 0x3, 0x2, 0x2, 
       0x2, 0xc97, 0xc98, 0x3, 0x2, 0x2, 0x2, 0xc98, 0x161, 0x3, 0x2, 0x2, 
       0x2, 0xc99, 0xc97, 0x3, 0x2, 0x2, 0x2, 0xc9a, 0xc9e, 0x5, 0x16c, 
       0xb7, 0x2, 0xc9b, 0xc9d, 0x5, 0x164, 0xb3, 0x2, 0xc9c, 0xc9b, 0x3, 
       0x2, 0x2, 0x2, 0xc9d, 0xca0, 0x3, 0x2, 0x2, 0x2, 0xc9e, 0xc9c, 0x3, 
       0x2, 0x2, 0x2, 0xc9e, 0xc9f, 0x3, 0x2, 0x2, 0x2, 0xc9f, 0x163, 0x3, 
       0x2, 0x2, 0x2, 0xca0, 0xc9e, 0x3, 0x2, 0x2, 0x2, 0xca1, 0xca2, 0x5, 
       0x168, 0xb5, 0x2, 0xca2, 0xca7, 0x5, 0x160, 0xb1, 0x2, 0xca3, 0xca4, 
       0x7, 0x244, 0x2, 0x2, 0xca4, 0xca8, 0x5, 0x28a, 0x146, 0x2, 0xca5, 
       0xca6, 0x7, 0x29b, 0x2, 0x2, 0xca6, 0xca8, 0x5, 0x446, 0x224, 0x2, 
       0xca7, 0xca3, 0x3, 0x2, 0x2, 0x2, 0xca7, 0xca5, 0x3, 0x2, 0x2, 0x2, 
       0xca7, 0xca8, 0x3, 0x2, 0x2, 0x2, 0xca8, 0xcb5, 0x3, 0x2, 0x2, 0x2, 
       0xca9, 0xcaa, 0x5, 0x16a, 0xb6, 0x2, 0xcaa, 0xcaf, 0x5, 0x160, 0xb1, 
       0x2, 0xcab, 0xcac, 0x7, 0x244, 0x2, 0x2, 0xcac, 0xcb0, 0x5, 0x28a, 
       0x146, 0x2, 0xcad, 0xcae, 0x7, 0x29b, 0x2, 0x2, 0xcae, 0xcb0, 0x5, 
       0x446, 0x224, 0x2, 0xcaf, 0xcab, 0x3, 0x2, 0x2, 0x2, 0xcaf, 0xcad, 
       0x3, 0x2, 0x2, 0x2, 0xcb0, 0xcb5, 0x3, 0x2, 0x2, 0x2, 0xcb1, 0xcb2, 
       0x5, 0x166, 0xb4, 0x2, 0xcb2, 0xcb3, 0x5, 0x16c, 0xb7, 0x2, 0xcb3, 
       0xcb5, 0x3, 0x2, 0x2, 0x2, 0xcb4, 0xca1, 0x3, 0x2, 0x2, 0x2, 0xcb4, 
       0xca9, 0x3, 0x2, 0x2, 0x2, 0xcb4, 0xcb1, 0x3, 0x2, 0x2, 0x2, 0xcb5, 
       0x165, 0x3, 0x2, 0x2, 0x2, 0xcb6, 0xcb8, 0x7, 0x23a, 0x2, 0x2, 0xcb7, 
       0xcb9, 0x7, 0x20c, 0x2, 0x2, 0xcb8, 0xcb7, 0x3, 0x2, 0x2, 0x2, 0xcb8, 
       0xcb9, 0x3, 0x2, 0x2, 0x2, 0xcb9, 0xcba, 0x3, 0x2, 0x2, 0x2, 0xcba, 
       0xcc2, 0x7, 0x218, 0x2, 0x2, 0xcbb, 0xcbc, 0x7, 0x23a, 0x2, 0x2, 
       0xcbc, 0xcbe, 0x9, 0x23, 0x2, 0x2, 0xcbd, 0xcbf, 0x7, 0x24d, 0x2, 
       0x2, 0xcbe, 0xcbd, 0x3, 0x2, 0x2, 0x2, 0xcbe, 0xcbf, 0x3, 0x2, 0x2, 
       0x2, 0xcbf, 0xcc0, 0x3, 0x2, 0x2, 0x2, 0xcc0, 0xcc2, 0x7, 0x218, 
       0x2, 0x2, 0xcc1, 0xcb6, 0x3, 0x2, 0x2, 0x2, 0xcc1, 0xcbb, 0x3, 0x2, 
       0x2, 0x2, 0xcc2, 0x167, 0x3, 0x2, 0x2, 0x2, 0xcc3, 0xcc5, 0x9, 0x24, 
       0x2, 0x2, 0xcc4, 0xcc3, 0x3, 0x2, 0x2, 0x2, 0xcc4, 0xcc5, 0x3, 0x2, 
       0x2, 0x2, 0xcc5, 0xcc6, 0x3, 0x2, 0x2, 0x2, 0xcc6, 0xcc9, 0x7, 0x218, 
       0x2, 0x2, 0xcc7, 0xcc9, 0x7, 0x281, 0x2, 0x2, 0xcc8, 0xcc4, 0x3, 
       0x2, 0x2, 0x2, 0xcc8, 0xcc7, 0x3, 0x2, 0x2, 0x2, 0xcc9, 0x169, 0x3, 
       0x2, 0x2, 0x2, 0xcca, 0xccc, 0x9, 0x23, 0x2, 0x2, 0xccb, 0xccd, 0x7, 
       0x24d, 0x2, 0x2, 0xccc, 0xccb, 0x3, 0x2, 0x2, 0x2, 0xccc, 0xccd, 
       0x3, 0x2, 0x2, 0x2, 0xccd, 0xcce, 0x3, 0x2, 0x2, 0x2, 0xcce, 0xccf, 
       0x7, 0x218, 0x2, 0x2, 0xccf, 0x16b, 0x3, 0x2, 0x2, 0x2, 0xcd0, 0xcd7, 
       0x5, 0x16e, 0xb8, 0x2, 0xcd1, 0xcd7, 0x5, 0x170, 0xb9, 0x2, 0xcd2, 
       0xcd7, 0x5, 0x172, 0xba, 0x2, 0xcd3, 0xcd7, 0x5, 0x174, 0xbb, 0x2, 
       0xcd4, 0xcd5, 0x6, 0xb7, 0x3a, 0x2, 0xcd5, 0xcd7, 0x5, 0x176, 0xbc, 
       0x2, 0xcd6, 0xcd0, 0x3, 0x2, 0x2, 0x2, 0xcd6, 0xcd1, 0x3, 0x2, 0x2, 
       0x2, 0xcd6, 0xcd2, 0x3, 0x2, 0x2, 0x2, 0xcd6, 0xcd3, 0x3, 0x2, 0x2, 
       0x2, 0xcd6, 0xcd4, 0x3, 0x2, 0x2, 0x2, 0xcd7, 0x16d, 0x3, 0x2, 0x2, 
       0x2, 0xcd8, 0xcda, 0x5, 0x428, 0x215, 0x2, 0xcd9, 0xcdb, 0x5, 0x3e6, 
       0x1f4, 0x2, 0xcda, 0xcd9, 0x3, 0x2, 0x2, 0x2, 0xcda, 0xcdb, 0x3, 
       0x2, 0x2, 0x2, 0xcdb, 0xcdd, 0x3, 0x2, 0x2, 0x2, 0xcdc, 0xcde, 0x5, 
       0x186, 0xc4, 0x2, 0xcdd, 0xcdc, 0x3, 0x2, 0x2, 0x2, 0xcdd, 0xcde, 
       0x3, 0x2, 0x2, 0x2, 0xcde, 0xce0, 0x3, 0x2, 0x2, 0x2, 0xcdf, 0xce1, 
       0x5, 0x188, 0xc5, 0x2, 0xce0, 0xcdf, 0x3, 0x2, 0x2, 0x2, 0xce0, 0xce1, 
       0x3, 0x2, 0x2, 0x2, 0xce1, 0x16f, 0x3, 0x2, 0x2, 0x2, 0xce2, 0xce5, 
       0x7, 0x19b, 0x2, 0x2, 0xce3, 0xce6, 0x5, 0x16e, 0xb8, 0x2, 0xce4, 
       0xce6, 0x5, 0x170, 0xb9, 0x2, 0xce5, 0xce3, 0x3, 0x2, 0x2, 0x2, 0xce5, 
       0xce4, 0x3, 0x2, 0x2, 0x2, 0xce6, 0xce7, 0x3, 0x2, 0x2, 0x2, 0xce7, 
       0xce8, 0x7, 0x19c, 0x2, 0x2, 0xce8, 0x171, 0x3, 0x2, 0x2, 0x2, 0xce9, 
       0xceb, 0x5, 0x118, 0x8d, 0x2, 0xcea, 0xcec, 0x5, 0x186, 0xc4, 0x2, 
       0xceb, 0xcea, 0x3, 0x2, 0x2, 0x2, 0xceb, 0xcec, 0x3, 0x2, 0x2, 0x2, 
       0xcec, 0xcef, 0x3, 0x2, 0x2, 0x2, 0xced, 0xcee, 0x6, 0xba, 0x3b, 
       0x2, 0xcee, 0xcf0, 0x5, 0x3ee, 0x1f8, 0x2, 0xcef, 0xced, 0x3, 0x2, 
       0x2, 0x2, 0xcef, 0xcf0, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcfb, 0x3, 0x2, 
       0x2, 0x2, 0xcf1, 0xcf2, 0x6, 0xba, 0x3c, 0x2, 0xcf2, 0xcf3, 0x7, 
       0x2f7, 0x2, 0x2, 0xcf3, 0xcf5, 0x5, 0x118, 0x8d, 0x2, 0xcf4, 0xcf6, 
       0x5, 0x186, 0xc4, 0x2, 0xcf5, 0xcf4, 0x3, 0x2, 0x2, 0x2, 0xcf5, 0xcf6, 
       0x3, 0x2, 0x2, 0x2, 0xcf6, 0xcf8, 0x3, 0x2, 0x2, 0x2, 0xcf7, 0xcf9, 
       0x5, 0x3ee, 0x1f8, 0x2, 0xcf8, 0xcf7, 0x3, 0x2, 0x2, 0x2, 0xcf8, 
       0xcf9, 0x3, 0x2, 0x2, 0x2, 0xcf9, 0xcfb, 0x3, 0x2, 0x2, 0x2, 0xcfa, 
       0xce9, 0x3, 0x2, 0x2, 0x2, 0xcfa, 0xcf1, 0x3, 0x2, 0x2, 0x2, 0xcfb, 
       0x173, 0x3, 0x2, 0x2, 0x2, 0xcfc, 0xcff, 0x7, 0x19b, 0x2, 0x2, 0xcfd, 
       0xd00, 0x5, 0x14e, 0xa8, 0x2, 0xcfe, 0xd00, 0x5, 0x174, 0xbb, 0x2, 
       0xcff, 0xcfd, 0x3, 0x2, 0x2, 0x2, 0xcff, 0xcfe, 0x3, 0x2, 0x2, 0x2, 
       0xd00, 0xd01, 0x3, 0x2, 0x2, 0x2, 0xd01, 0xd02, 0x7, 0x19c, 0x2, 
       0x2, 0xd02, 0x175, 0x3, 0x2, 0x2, 0x2, 0xd03, 0xd04, 0x7, 0x2de, 
       0x2, 0x2, 0xd04, 0xd05, 0x7, 0x19b, 0x2, 0x2, 0xd05, 0xd06, 0x5, 
       0x28a, 0x146, 0x2, 0xd06, 0xd07, 0x7, 0x198, 0x2, 0x2, 0xd07, 0xd08, 
       0x5, 0x45c, 0x22f, 0x2, 0xd08, 0xd09, 0x5, 0x178, 0xbd, 0x2, 0xd09, 
       0xd0b, 0x7, 0x19c, 0x2, 0x2, 0xd0a, 0xd0c, 0x5, 0x186, 0xc4, 0x2, 
       0xd0b, 0xd0a, 0x3, 0x2, 0x2, 0x2, 0xd0b, 0xd0c, 0x3, 0x2, 0x2, 0x2, 
       0xd0c, 0x177, 0x3, 0x2, 0x2, 0x2, 0xd0d, 0xd0e, 0x7, 0x5c, 0x2, 0x2, 
       0xd0e, 0xd0f, 0x7, 0x19b, 0x2, 0x2, 0xd0f, 0xd14, 0x5, 0x17a, 0xbe, 
       0x2, 0xd10, 0xd11, 0x7, 0x198, 0x2, 0x2, 0xd11, 0xd13, 0x5, 0x17a, 
       0xbe, 0x2, 0xd12, 0xd10, 0x3, 0x2, 0x2, 0x2, 0xd13, 0xd16, 0x3, 0x2, 
       0x2, 0x2, 0xd14, 0xd12, 0x3, 0x2, 0x2, 0x2, 0xd14, 0xd15, 0x3, 0x2, 
       0x2, 0x2, 0xd15, 0xd17, 0x3, 0x2, 0x2, 0x2, 0xd16, 0xd14, 0x3, 0x2, 
       0x2, 0x2, 0xd17, 0xd18, 0x7, 0x19c, 0x2, 0x2, 0xd18, 0x179, 0x3, 
       0x2, 0x2, 0x2, 0xd19, 0xd1a, 0x5, 0x442, 0x222, 0x2, 0xd1a, 0xd1b, 
       0x7, 0x1fb, 0x2, 0x2, 0xd1b, 0xd1c, 0x7, 0x2e0, 0x2, 0x2, 0xd1c, 
       0xd31, 0x3, 0x2, 0x2, 0x2, 0xd1d, 0xd1e, 0x5, 0x442, 0x222, 0x2, 
       0xd1e, 0xd21, 0x5, 0x36e, 0x1b8, 0x2, 0xd1f, 0xd20, 0x6, 0xbe, 0x3d, 
       0x2, 0xd20, 0xd22, 0x5, 0x3b6, 0x1dc, 0x2, 0xd21, 0xd1f, 0x3, 0x2, 
       0x2, 0x2, 0xd21, 0xd22, 0x3, 0x2, 0x2, 0x2, 0xd22, 0xd24, 0x3, 0x2, 
       0x2, 0x2, 0xd23, 0xd25, 0x7, 0x1f2, 0x2, 0x2, 0xd24, 0xd23, 0x3, 
       0x2, 0x2, 0x2, 0xd24, 0xd25, 0x3, 0x2, 0x2, 0x2, 0xd25, 0xd26, 0x3, 
       0x2, 0x2, 0x2, 0xd26, 0xd27, 0x7, 0x2e1, 0x2, 0x2, 0xd27, 0xd29, 
       0x5, 0x45c, 0x22f, 0x2, 0xd28, 0xd2a, 0x5, 0x17c, 0xbf, 0x2, 0xd29, 
       0xd28, 0x3, 0x2, 0x2, 0x2, 0xd29, 0xd2a, 0x3, 0x2, 0x2, 0x2, 0xd2a, 
       0xd31, 0x3, 0x2, 0x2, 0x2, 0xd2b, 0xd2c, 0x7, 0x2df, 0x2, 0x2, 0xd2c, 
       0xd2d, 0x7, 0x2e1, 0x2, 0x2, 0xd2d, 0xd2e, 0x5, 0x45c, 0x22f, 0x2, 
       0xd2e, 0xd2f, 0x5, 0x178, 0xbd, 0x2, 0xd2f, 0xd31, 0x3, 0x2, 0x2, 
       0x2, 0xd30, 0xd19, 0x3, 0x2, 0x2, 0x2, 0xd30, 0xd1d, 0x3, 0x2, 0x2, 
       0x2, 0xd30, 0xd2b, 0x3, 0x2, 0x2, 0x2, 0xd31, 0x17b, 0x3, 0x2, 0x2, 
       0x2, 0xd32, 0xd34, 0x5, 0x17e, 0xc0, 0x2, 0xd33, 0xd35, 0x5, 0x180, 
       0xc1, 0x2, 0xd34, 0xd33, 0x3, 0x2, 0x2, 0x2, 0xd34, 0xd35, 0x3, 0x2, 
       0x2, 0x2, 0xd35, 0xd3b, 0x3, 0x2, 0x2, 0x2, 0xd36, 0xd38, 0x5, 0x180, 
       0xc1, 0x2, 0xd37, 0xd39, 0x5, 0x17e, 0xc0, 0x2, 0xd38, 0xd37, 0x3, 
       0x2, 0x2, 0x2, 0xd38, 0xd39, 0x3, 0x2, 0x2, 0x2, 0xd39, 0xd3b, 0x3, 
       0x2, 0x2, 0x2, 0xd3a, 0xd32, 0x3, 0x2, 0x2, 0x2, 0xd3a, 0xd36, 0x3, 
       0x2, 0x2, 0x2, 0xd3b, 0x17d, 0x3, 0x2, 0x2, 0x2, 0xd3c, 0xd3d, 0x5, 
       0x182, 0xc2, 0x2, 0xd3d, 0xd3e, 0x7, 0x244, 0x2, 0x2, 0xd3e, 0xd3f, 
       0x7, 0x2dd, 0x2, 0x2, 0xd3f, 0x17f, 0x3, 0x2, 0x2, 0x2, 0xd40, 0xd41, 
       0x5, 0x182, 0xc2, 0x2, 0xd41, 0xd42, 0x7, 0x244, 0x2, 0x2, 0xd42, 
       0xd43, 0x7, 0x84, 0x2, 0x2, 0xd43, 0x181, 0x3, 0x2, 0x2, 0x2, 0xd44, 
       0xd49, 0x7, 0x84, 0x2, 0x2, 0xd45, 0xd49, 0x7, 0x241, 0x2, 0x2, 0xd46, 
       0xd47, 0x7, 0x1e0, 0x2, 0x2, 0xd47, 0xd49, 0x5, 0x45c, 0x22f, 0x2, 
       0xd48, 0xd44, 0x3, 0x2, 0x2, 0x2, 0xd48, 0xd45, 0x3, 0x2, 0x2, 0x2, 
       0xd48, 0xd46, 0x3, 0x2, 0x2, 0x2, 0xd49, 0x183, 0x3, 0x2, 0x2, 0x2, 
       0xd4a, 0xd4b, 0x9, 0x25, 0x2, 0x2, 0xd4b, 0x185, 0x3, 0x2, 0x2, 0x2, 
       0xd4c, 0xd4e, 0x9, 0x26, 0x2, 0x2, 0xd4d, 0xd4c, 0x3, 0x2, 0x2, 0x2, 
       0xd4d, 0xd4e, 0x3, 0x2, 0x2, 0x2, 0xd4e, 0xd4f, 0x3, 0x2, 0x2, 0x2, 
       0xd4f, 0xd50, 0x5, 0x442, 0x222, 0x2, 0xd50, 0x187, 0x3, 0x2, 0x2, 
       0x2, 0xd51, 0xd56, 0x5, 0x18a, 0xc6, 0x2, 0xd52, 0xd53, 0x7, 0x198, 
       0x2, 0x2, 0xd53, 0xd55, 0x5, 0x18a, 0xc6, 0x2, 0xd54, 0xd52, 0x3, 
       0x2, 0x2, 0x2, 0xd55, 0xd58, 0x3, 0x2, 0x2, 0x2, 0xd56, 0xd54, 0x3, 
       0x2, 0x2, 0x2, 0xd56, 0xd57, 0x3, 0x2, 0x2, 0x2, 0xd57, 0x189, 0x3, 
       0x2, 0x2, 0x2, 0xd58, 0xd56, 0x3, 0x2, 0x2, 0x2, 0xd59, 0xd5a, 0x5, 
       0x18c, 0xc7, 0x2, 0xd5a, 0xd5c, 0x5, 0x18e, 0xc8, 0x2, 0xd5b, 0xd5d, 
       0x5, 0x192, 0xca, 0x2, 0xd5c, 0xd5b, 0x3, 0x2, 0x2, 0x2, 0xd5c, 0xd5d, 
       0x3, 0x2, 0x2, 0x2, 0xd5d, 0xd5e, 0x3, 0x2, 0x2, 0x2, 0xd5e, 0xd5f, 
       0x7, 0x19b, 0x2, 0x2, 0xd5f, 0xd60, 0x5, 0x194, 0xcb, 0x2, 0xd60, 
       0xd61, 0x7, 0x19c, 0x2, 0x2, 0xd61, 0xd6e, 0x3, 0x2, 0x2, 0x2, 0xd62, 
       0xd63, 0x7, 0x29a, 0x2, 0x2, 0xd63, 0xd65, 0x5, 0x18e, 0xc8, 0x2, 
       0xd64, 0xd66, 0x5, 0x192, 0xca, 0x2, 0xd65, 0xd64, 0x3, 0x2, 0x2, 
       0x2, 0xd65, 0xd66, 0x3, 0x2, 0x2, 0x2, 0xd66, 0xd67, 0x3, 0x2, 0x2, 
       0x2, 0xd67, 0xd69, 0x7, 0x19b, 0x2, 0x2, 0xd68, 0xd6a, 0x5, 0x194, 
       0xcb, 0x2, 0xd69, 0xd68, 0x3, 0x2, 0x2, 0x2, 0xd69, 0xd6a, 0x3, 0x2, 
       0x2, 0x2, 0xd6a, 0xd6b, 0x3, 0x2, 0x2, 0x2, 0xd6b, 0xd6c, 0x7, 0x19c, 
       0x2, 0x2, 0xd6c, 0xd6e, 0x3, 0x2, 0x2, 0x2, 0xd6d, 0xd59, 0x3, 0x2, 
       0x2, 0x2, 0xd6d, 0xd62, 0x3, 0x2, 0x2, 0x2, 0xd6e, 0x18b, 0x3, 0x2, 
       0x2, 0x2, 0xd6f, 0xd70, 0x9, 0x27, 0x2, 0x2, 0xd70, 0x18d, 0x3, 0x2, 
       0x2, 0x2, 0xd71, 0xd72, 0x9, 0x28, 0x2, 0x2, 0xd72, 0x18f, 0x3, 0x2, 
       0x2, 0x2, 0xd73, 0xd74, 0x7, 0x252, 0x2, 0x2, 0xd74, 0xd7a, 0x7, 
       0x21a, 0x2, 0x2, 0xd75, 0xd77, 0x7, 0x295, 0x2, 0x2, 0xd76, 0xd78, 
       0x5, 0x18e, 0xc8, 0x2, 0xd77, 0xd76, 0x3, 0x2, 0x2, 0x2, 0xd77, 0xd78, 
       0x3, 0x2, 0x2, 0x2, 0xd78, 0xd7a, 0x3, 0x2, 0x2, 0x2, 0xd79, 0xd73, 
       0x3, 0x2, 0x2, 0x2, 0xd79, 0xd75, 0x3, 0x2, 0x2, 0x2, 0xd7a, 0x191, 
       0x3, 0x2, 0x2, 0x2, 0xd7b, 0xd81, 0x7, 0x1fb, 0x2, 0x2, 0xd7c, 0xd82, 
       0x7, 0x218, 0x2, 0x2, 0xd7d, 0xd7e, 0x7, 0x24b, 0x2, 0x2, 0xd7e, 
       0xd82, 0x7, 0x1be, 0x2, 0x2, 0xd7f, 0xd80, 0x7, 0x201, 0x2, 0x2, 
       0xd80, 0xd82, 0x7, 0x1be, 0x2, 0x2, 0xd81, 0xd7c, 0x3, 0x2, 0x2, 
       0x2, 0xd81, 0xd7d, 0x3, 0x2, 0x2, 0x2, 0xd81, 0xd7f, 0x3, 0x2, 0x2, 
       0x2, 0xd82, 0x193, 0x3, 0x2, 0x2, 0x2, 0xd83, 0xd88, 0x5, 0x196, 
       0xcc, 0x2, 0xd84, 0xd85, 0x7, 0x198, 0x2, 0x2, 0xd85, 0xd87, 0x5, 
       0x196, 0xcc, 0x2, 0xd86, 0xd84, 0x3, 0x2, 0x2, 0x2, 0xd87, 0xd8a, 
       0x3, 0x2, 0x2, 0x2, 0xd88, 0xd86, 0x3, 0x2, 0x2, 0x2, 0xd88, 0xd89, 
       0x3, 0x2, 0x2, 0x2, 0xd89, 0x195, 0x3, 0x2, 0x2, 0x2, 0xd8a, 0xd88, 
       0x3, 0x2, 0x2, 0x2, 0xd8b, 0xd8e, 0x5, 0x442, 0x222, 0x2, 0xd8c, 
       0xd8e, 0x7, 0x252, 0x2, 0x2, 0xd8d, 0xd8b, 0x3, 0x2, 0x2, 0x2, 0xd8d, 
       0xd8c, 0x3, 0x2, 0x2, 0x2, 0xd8e, 0x197, 0x3, 0x2, 0x2, 0x2, 0xd8f, 
       0xd90, 0x6, 0xcd, 0x3e, 0x2, 0xd90, 0xd92, 0x5, 0x140, 0xa1, 0x2, 
       0xd91, 0xd8f, 0x3, 0x2, 0x2, 0x2, 0xd91, 0xd92, 0x3, 0x2, 0x2, 0x2, 
       0xd92, 0xd93, 0x3, 0x2, 0x2, 0x2, 0xd93, 0xd95, 0x7, 0x298, 0x2, 
       0x2, 0xd94, 0xd96, 0x7, 0x22b, 0x2, 0x2, 0xd95, 0xd94, 0x3, 0x2, 
       0x2, 0x2, 0xd95, 0xd96, 0x3, 0x2, 0x2, 0x2, 0xd96, 0xd98, 0x3, 0x2, 
       0x2, 0x2, 0xd97, 0xd99, 0x7, 0x209, 0x2, 0x2, 0xd98, 0xd97, 0x3, 
       0x2, 0x2, 0x2, 0xd98, 0xd99, 0x3, 0x2, 0x2, 0x2, 0xd99, 0xd9a, 0x3, 
       0x2, 0x2, 0x2, 0xd9a, 0xd9b, 0x5, 0x14e, 0xa8, 0x2, 0xd9b, 0xd9c, 
       0x7, 0x26c, 0x2, 0x2, 0xd9c, 0xd9e, 0x5, 0x3be, 0x1e0, 0x2, 0xd9d, 
       0xd9f, 0x5, 0x15e, 0xb0, 0x2, 0xd9e, 0xd9d, 0x3, 0x2, 0x2, 0x2, 0xd9e, 
       0xd9f, 0x3, 0x2, 0x2, 0x2, 0xd9f, 0xda1, 0x3, 0x2, 0x2, 0x2, 0xda0, 
       0xda2, 0x5, 0x148, 0xa5, 0x2, 0xda1, 0xda0, 0x3, 0x2, 0x2, 0x2, 0xda1, 
       0xda2, 0x3, 0x2, 0x2, 0x2, 0xda2, 0xda4, 0x3, 0x2, 0x2, 0x2, 0xda3, 
       0xda5, 0x5, 0x11e, 0x90, 0x2, 0xda4, 0xda3, 0x3, 0x2, 0x2, 0x2, 0xda4, 
       0xda5, 0x3, 0x2, 0x2, 0x2, 0xda5, 0x199, 0x3, 0x2, 0x2, 0x2, 0xda6, 
       0xdab, 0x5, 0x19c, 0xcf, 0x2, 0xda7, 0xdab, 0x5, 0x1a6, 0xd4, 0x2, 
       0xda8, 0xdab, 0x5, 0x1a8, 0xd5, 0x2, 0xda9, 0xdab, 0x5, 0x1ae, 0xd8, 
       0x2, 0xdaa, 0xda6, 0x3, 0x2, 0x2, 0x2, 0xdaa, 0xda7, 0x3, 0x2, 0x2, 
       0x2, 0xdaa, 0xda8, 0x3, 0x2, 0x2, 0x2, 0xdaa, 0xda9, 0x3, 0x2, 0x2, 
       0x2, 0xdab, 0x19b, 0x3, 0x2, 0x2, 0x2, 0xdac, 0xdad, 0x7, 0x32, 0x2, 
       0x2, 0xdad, 0xdb1, 0x7, 0x15d, 0x2, 0x2, 0xdae, 0xdb0, 0x5, 0x1a0, 
       0xd1, 0x2, 0xdaf, 0xdae, 0x3, 0x2, 0x2, 0x2, 0xdb0, 0xdb3, 0x3, 0x2, 
       0x2, 0x2, 0xdb1, 0xdaf, 0x3, 0x2, 0x2, 0x2, 0xdb1, 0xdb2, 0x3, 0x2, 
       0x2, 0x2, 0xdb2, 0xdc6, 0x3, 0x2, 0x2, 0x2, 0xdb3, 0xdb1, 0x3, 0x2, 
       0x2, 0x2, 0xdb4, 0xdb6, 0x7, 0xe, 0x2, 0x2, 0xdb5, 0xdb7, 0x7, 0x176, 
       0x2, 0x2, 0xdb6, 0xdb5, 0x3, 0x2, 0x2, 0x2, 0xdb6, 0xdb7, 0x3, 0x2, 
       0x2, 0x2, 0xdb7, 0xdbd, 0x3, 0x2, 0x2, 0x2, 0xdb8, 0xdba, 0x7, 0x1b0, 
       0x2, 0x2, 0xdb9, 0xdbb, 0x7, 0x1d, 0x2, 0x2, 0xdba, 0xdb9, 0x3, 0x2, 
       0x2, 0x2, 0xdba, 0xdbb, 0x3, 0x2, 0x2, 0x2, 0xdbb, 0xdbc, 0x3, 0x2, 
       0x2, 0x2, 0xdbc, 0xdbe, 0x7, 0x51, 0x2, 0x2, 0xdbd, 0xdb8, 0x3, 0x2, 
       0x2, 0x2, 0xdbd, 0xdbe, 0x3, 0x2, 0x2, 0x2, 0xdbe, 0xdc3, 0x3, 0x2, 
       0x2, 0x2, 0xdbf, 0xdc1, 0x7, 0x1d, 0x2, 0x2, 0xdc0, 0xdbf, 0x3, 0x2, 
       0x2, 0x2, 0xdc0, 0xdc1, 0x3, 0x2, 0x2, 0x2, 0xdc1, 0xdc2, 0x3, 0x2, 
       0x2, 0x2, 0xdc2, 0xdc4, 0x7, 0x25c, 0x2, 0x2, 0xdc3, 0xdc0, 0x3, 
       0x2, 0x2, 0x2, 0xdc3, 0xdc4, 0x3, 0x2, 0x2, 0x2, 0xdc4, 0xdc6, 0x3, 
       0x2, 0x2, 0x2, 0xdc5, 0xdac, 0x3, 0x2, 0x2, 0x2, 0xdc5, 0xdb4, 0x3, 
       0x2, 0x2, 0x2, 0xdc6, 0x19d, 0x3, 0x2, 0x2, 0x2, 0xdc7, 0xdc9, 0x7, 
       0x7, 0x2, 0x2, 0xdc8, 0xdca, 0x7, 0x176, 0x2, 0x2, 0xdc9, 0xdc8, 
       0x3, 0x2, 0x2, 0x2, 0xdc9, 0xdca, 0x3, 0x2, 0x2, 0x2, 0xdca, 0x19f, 
       0x3, 0x2, 0x2, 0x2, 0xdcb, 0xdcc, 0x7, 0x2ab, 0x2, 0x2, 0xdcc, 0xdcd, 
       0x7, 0x65, 0x2, 0x2, 0xdcd, 0xdd2, 0x7, 0x13a, 0x2, 0x2, 0xdce, 0xdcf, 
       0x6, 0xd1, 0x3f, 0x2, 0xdcf, 0xdd0, 0x7, 0x257, 0x2, 0x2, 0xdd0, 
       0xdd2, 0x9, 0x29, 0x2, 0x2, 0xdd1, 0xdcb, 0x3, 0x2, 0x2, 0x2, 0xdd1, 
       0xdce, 0x3, 0x2, 0x2, 0x2, 0xdd2, 0x1a1, 0x3, 0x2, 0x2, 0x2, 0xdd3, 
       0xdd4, 0x7, 0xab, 0x2, 0x2, 0xdd4, 0xdd5, 0x7, 0xb3, 0x2, 0x2, 0xdd5, 
       0xdda, 0x5, 0x1a4, 0xd3, 0x2, 0xdd6, 0xdd7, 0x6, 0xd2, 0x40, 0x2, 
       0xdd7, 0xdd8, 0x7, 0x257, 0x2, 0x2, 0xdd8, 0xdda, 0x9, 0x29, 0x2, 
       0x2, 0xdd9, 0xdd3, 0x3, 0x2, 0x2, 0x2, 0xdd9, 0xdd6, 0x3, 0x2, 0x2, 
       0x2, 0xdda, 0x1a3, 0x3, 0x2, 0x2, 0x2, 0xddb, 0xddc, 0x7, 0x11c, 
       0x2, 0x2, 0xddc, 0xde1, 0x7, 0x257, 0x2, 0x2, 0xddd, 0xdde, 0x7, 
       0x257, 0x2, 0x2, 0xdde, 0xde1, 0x9, 0x2a, 0x2, 0x2, 0xddf, 0xde1, 
       0x7, 0x135, 0x2, 0x2, 0xde0, 0xddb, 0x3, 0x2, 0x2, 0x2, 0xde0, 0xddd, 
       0x3, 0x2, 0x2, 0x2, 0xde0, 0xddf, 0x3, 0x2, 0x2, 0x2, 0xde1, 0x1a5, 
       0x3, 0x2, 0x2, 0x2, 0xde2, 0xde3, 0x7, 0x2b, 0x2, 0x2, 0xde3, 0xe00, 
       0x5, 0x442, 0x222, 0x2, 0xde4, 0xde6, 0x7, 0x2a, 0x2, 0x2, 0xde5, 
       0xde7, 0x7, 0x176, 0x2, 0x2, 0xde6, 0xde5, 0x3, 0x2, 0x2, 0x2, 0xde6, 
       0xde7, 0x3, 0x2, 0x2, 0x2, 0xde7, 0xdfa, 0x3, 0x2, 0x2, 0x2, 0xde8, 
       0xdea, 0x7, 0x28e, 0x2, 0x2, 0xde9, 0xdeb, 0x7, 0x2b, 0x2, 0x2, 0xdea, 
       0xde9, 0x3, 0x2, 0x2, 0x2, 0xdea, 0xdeb, 0x3, 0x2, 0x2, 0x2, 0xdeb, 
       0xdec, 0x3, 0x2, 0x2, 0x2, 0xdec, 0xdfb, 0x5, 0x442, 0x222, 0x2, 
       0xded, 0xdef, 0x7, 0x1b0, 0x2, 0x2, 0xdee, 0xdf0, 0x7, 0x1d, 0x2, 
       0x2, 0xdef, 0xdee, 0x3, 0x2, 0x2, 0x2, 0xdef, 0xdf0, 0x3, 0x2, 0x2, 
       0x2, 0xdf0, 0xdf1, 0x3, 0x2, 0x2, 0x2, 0xdf1, 0xdf3, 0x7, 0x51, 0x2, 
       0x2, 0xdf2, 0xded, 0x3, 0x2, 0x2, 0x2, 0xdf2, 0xdf3, 0x3, 0x2, 0x2, 
       0x2, 0xdf3, 0xdf8, 0x3, 0x2, 0x2, 0x2, 0xdf4, 0xdf6, 0x7, 0x1d, 0x2, 
       0x2, 0xdf5, 0xdf4, 0x3, 0x2, 0x2, 0x2, 0xdf5, 0xdf6, 0x3, 0x2, 0x2, 
       0x2, 0xdf6, 0xdf7, 0x3, 0x2, 0x2, 0x2, 0xdf7, 0xdf9, 0x7, 0x25c, 
       0x2, 0x2, 0xdf8, 0xdf5, 0x3, 0x2, 0x2, 0x2, 0xdf8, 0xdf9, 0x3, 0x2, 
       0x2, 0x2, 0xdf9, 0xdfb, 0x3, 0x2, 0x2, 0x2, 0xdfa, 0xde8, 0x3, 0x2, 
       0x2, 0x2, 0xdfa, 0xdf2, 0x3, 0x2, 0x2, 0x2, 0xdfb, 0xe00, 0x3, 0x2, 
       0x2, 0x2, 0xdfc, 0xdfd, 0x7, 0x25c, 0x2, 0x2, 0xdfd, 0xdfe, 0x7, 
       0x2b, 0x2, 0x2, 0xdfe, 0xe00, 0x5, 0x442, 0x222, 0x2, 0xdff, 0xde2, 
       0x3, 0x2, 0x2, 0x2, 0xdff, 0xde4, 0x3, 0x2, 0x2, 0x2, 0xdff, 0xdfc, 
       0x3, 0x2, 0x2, 0x2, 0xe00, 0x1a7, 0x3, 0x2, 0x2, 0x2, 0xe01, 0xe02, 
       0x7, 0x225, 0x2, 0x2, 0xe02, 0xe03, 0x9, 0x14, 0x2, 0x2, 0xe03, 0xe08, 
       0x5, 0x1aa, 0xd6, 0x2, 0xe04, 0xe05, 0x7, 0x198, 0x2, 0x2, 0xe05, 
       0xe07, 0x5, 0x1aa, 0xd6, 0x2, 0xe06, 0xe04, 0x3, 0x2, 0x2, 0x2, 0xe07, 
       0xe0a, 0x3, 0x2, 0x2, 0x2, 0xe08, 0xe06, 0x3, 0x2, 0x2, 0x2, 0xe08, 
       0xe09, 0x3, 0x2, 0x2, 0x2, 0xe09, 0xe18, 0x3, 0x2, 0x2, 0x2, 0xe0a, 
       0xe08, 0x3, 0x2, 0x2, 0x2, 0xe0b, 0xe0c, 0x6, 0xd5, 0x41, 0x2, 0xe0c, 
       0xe0d, 0x7, 0x225, 0x2, 0x2, 0xe0d, 0xe0e, 0x7, 0xa7, 0x2, 0x2, 0xe0e, 
       0xe0f, 0x7, 0x1fb, 0x2, 0x2, 0xe0f, 0xe18, 0x7, 0x6, 0x2, 0x2, 0xe10, 
       0xe15, 0x7, 0x296, 0x2, 0x2, 0xe11, 0xe16, 0x7, 0x156, 0x2, 0x2, 
       0xe12, 0xe16, 0x7, 0x288, 0x2, 0x2, 0xe13, 0xe14, 0x6, 0xd5, 0x42, 
       0x2, 0xe14, 0xe16, 0x7, 0xa7, 0x2, 0x2, 0xe15, 0xe11, 0x3, 0x2, 0x2, 
       0x2, 0xe15, 0xe12, 0x3, 0x2, 0x2, 0x2, 0xe15, 0xe13, 0x3, 0x2, 0x2, 
       0x2, 0xe16, 0xe18, 0x3, 0x2, 0x2, 0x2, 0xe17, 0xe01, 0x3, 0x2, 0x2, 
       0x2, 0xe17, 0xe0b, 0x3, 0x2, 0x2, 0x2, 0xe17, 0xe10, 0x3, 0x2, 0x2, 
       0x2, 0xe18, 0x1a9, 0x3, 0x2, 0x2, 0x2, 0xe19, 0xe1b, 0x5, 0x428, 
       0x215, 0x2, 0xe1a, 0xe1c, 0x5, 0x186, 0xc4, 0x2, 0xe1b, 0xe1a, 0x3, 
       0x2, 0x2, 0x2, 0xe1b, 0xe1c, 0x3, 0x2, 0x2, 0x2, 0xe1c, 0xe1d, 0x3, 
       0x2, 0x2, 0x2, 0xe1d, 0xe1e, 0x5, 0x1ac, 0xd7, 0x2, 0xe1e, 0x1ab, 
       0x3, 0x2, 0x2, 0x2, 0xe1f, 0xe21, 0x7, 0x257, 0x2, 0x2, 0xe20, 0xe22, 
       0x7, 0xb6, 0x2, 0x2, 0xe21, 0xe20, 0x3, 0x2, 0x2, 0x2, 0xe21, 0xe22, 
       0x3, 0x2, 0x2, 0x2, 0xe22, 0xe28, 0x3, 0x2, 0x2, 0x2, 0xe23, 0xe25, 
       0x7, 0x22b, 0x2, 0x2, 0xe24, 0xe23, 0x3, 0x2, 0x2, 0x2, 0xe24, 0xe25, 
       0x3, 0x2, 0x2, 0x2, 0xe25, 0xe26, 0x3, 0x2, 0x2, 0x2, 0xe26, 0xe28, 
       0x7, 0x2af, 0x2, 0x2, 0xe27, 0xe1f, 0x3, 0x2, 0x2, 0x2, 0xe27, 0xe24, 
       0x3, 0x2, 0x2, 0x2, 0xe28, 0x1ad, 0x3, 0x2, 0x2, 0x2, 0xe29, 0xe44, 
       0x7, 0x39, 0x2, 0x2, 0xe2a, 0xe2b, 0x9, 0x2b, 0x2, 0x2, 0xe2b, 0xe2d, 
       0x5, 0x1b2, 0xda, 0x2, 0xe2c, 0xe2e, 0x9, 0x2c, 0x2, 0x2, 0xe2d, 
       0xe2c, 0x3, 0x2, 0x2, 0x2, 0xe2d, 0xe2e, 0x3, 0x2, 0x2, 0x2, 0xe2e, 
       0xe45, 0x3, 0x2, 0x2, 0x2, 0xe2f, 0xe30, 0x7, 0x12, 0x2, 0x2, 0xe30, 
       0xe36, 0x5, 0x1b2, 0xda, 0x2, 0xe31, 0xe34, 0x7, 0x152, 0x2, 0x2, 
       0xe32, 0xe33, 0x7, 0x1fb, 0x2, 0x2, 0xe33, 0xe35, 0x7, 0xdc, 0x2, 
       0x2, 0xe34, 0xe32, 0x3, 0x2, 0x2, 0x2, 0xe34, 0xe35, 0x3, 0x2, 0x2, 
       0x2, 0xe35, 0xe37, 0x3, 0x2, 0x2, 0x2, 0xe36, 0xe31, 0x3, 0x2, 0x2, 
       0x2, 0xe36, 0xe37, 0x3, 0x2, 0x2, 0x2, 0xe37, 0xe45, 0x3, 0x2, 0x2, 
       0x2, 0xe38, 0xe39, 0x7, 0x25, 0x2, 0x2, 0xe39, 0xe45, 0x5, 0x1b2, 
       0xda, 0x2, 0xe3a, 0xe3b, 0x7, 0xe, 0x2, 0x2, 0xe3b, 0xe3e, 0x5, 0x1b2, 
       0xda, 0x2, 0xe3c, 0xe3d, 0x7, 0xf7, 0x2, 0x2, 0xe3d, 0xe3f, 0x7, 
       0xfe, 0x2, 0x2, 0xe3e, 0xe3c, 0x3, 0x2, 0x2, 0x2, 0xe3e, 0xe3f, 0x3, 
       0x2, 0x2, 0x2, 0xe3f, 0xe45, 0x3, 0x2, 0x2, 0x2, 0xe40, 0xe41, 0x7, 
       0x2a, 0x2, 0x2, 0xe41, 0xe45, 0x5, 0x1b2, 0xda, 0x2, 0xe42, 0xe43, 
       0x7, 0x111, 0x2, 0x2, 0xe43, 0xe45, 0x5, 0x1b0, 0xd9, 0x2, 0xe44, 
       0xe2a, 0x3, 0x2, 0x2, 0x2, 0xe44, 0xe2f, 0x3, 0x2, 0x2, 0x2, 0xe44, 
       0xe38, 0x3, 0x2, 0x2, 0x2, 0xe44, 0xe3a, 0x3, 0x2, 0x2, 0x2, 0xe44, 
       0xe40, 0x3, 0x2, 0x2, 0x2, 0xe44, 0xe42, 0x3, 0x2, 0x2, 0x2, 0xe45, 
       0x1af, 0x3, 0x2, 0x2, 0x2, 0xe46, 0xe49, 0x6, 0xd9, 0x43, 0x2, 0xe47, 
       0xe48, 0x7, 0x1cb, 0x2, 0x2, 0xe48, 0xe4a, 0x7, 0x179, 0x2, 0x2, 
       0xe49, 0xe47, 0x3, 0x2, 0x2, 0x2, 0xe49, 0xe4a, 0x3, 0x2, 0x2, 0x2, 
       0xe4a, 0xe4d, 0x3, 0x2, 0x2, 0x2, 0xe4b, 0xe4d, 0x3, 0x2, 0x2, 0x2, 
       0xe4c, 0xe46, 0x3, 0x2, 0x2, 0x2, 0xe4c, 0xe4b, 0x3, 0x2, 0x2, 0x2, 
       0xe4d, 0x1b1, 0x3, 0x2, 0x2, 0x2, 0xe4e, 0xe55, 0x5, 0x45e, 0x230, 
       0x2, 0xe4f, 0xe50, 0x7, 0x198, 0x2, 0x2, 0xe50, 0xe53, 0x5, 0x45e, 
       0x230, 0x2, 0xe51, 0xe52, 0x7, 0x198, 0x2, 0x2, 0xe52, 0xe54, 0x5, 
       0x44e, 0x228, 0x2, 0xe53, 0xe51, 0x3, 0x2, 0x2, 0x2, 0xe53, 0xe54, 
       0x3, 0x2, 0x2, 0x2, 0xe54, 0xe56, 0x3, 0x2, 0x2, 0x2, 0xe55, 0xe4f, 
       0x3, 0x2, 0x2, 0x2, 0xe55, 0xe56, 0x3, 0x2, 0x2, 0x2, 0xe56, 0x1b3, 
       0x3, 0x2, 0x2, 0x2, 0xe57, 0xe58, 0x7, 0x254, 0x2, 0x2, 0xe58, 0xe59, 
       0x9, 0x2d, 0x2, 0x2, 0xe59, 0xe5e, 0x7, 0xb9, 0x2, 0x2, 0xe5a, 0xe5b, 
       0x7, 0x28e, 0x2, 0x2, 0xe5b, 0xe5f, 0x5, 0x460, 0x231, 0x2, 0xe5c, 
       0xe5d, 0x7, 0x1b4, 0x2, 0x2, 0xe5d, 0xe5f, 0x5, 0x28a, 0x146, 0x2, 
       0xe5e, 0xe5a, 0x3, 0x2, 0x2, 0x2, 0xe5e, 0xe5c, 0x3, 0x2, 0x2, 0x2, 
       0xe5f, 0xe7a, 0x3, 0x2, 0x2, 0x2, 0xe60, 0xe7a, 0x5, 0x1bc, 0xdf, 
       0x2, 0xe61, 0xe62, 0x7, 0x28, 0x2, 0x2, 0xe62, 0xe67, 0x5, 0x1b6, 
       0xdc, 0x2, 0xe63, 0xe64, 0x7, 0x198, 0x2, 0x2, 0xe64, 0xe66, 0x5, 
       0x1b6, 0xdc, 0x2, 0xe65, 0xe63, 0x3, 0x2, 0x2, 0x2, 0xe66, 0xe69, 
       0x3, 0x2, 0x2, 0x2, 0xe67, 0xe65, 0x3, 0x2, 0x2, 0x2, 0xe67, 0xe68, 
       0x3, 0x2, 0x2, 0x2, 0xe68, 0xe7a, 0x3, 0x2, 0x2, 0x2, 0xe69, 0xe67, 
       0x3, 0x2, 0x2, 0x2, 0xe6a, 0xe6b, 0x6, 0xdb, 0x44, 0x2, 0xe6b, 0xe6c, 
       0x7, 0x28, 0x2, 0x2, 0xe6c, 0xe70, 0x7, 0x2b3, 0x2, 0x2, 0xe6d, 0xe6e, 
       0x5, 0x3ae, 0x1d8, 0x2, 0xe6e, 0xe6f, 0x5, 0x442, 0x222, 0x2, 0xe6f, 
       0xe71, 0x3, 0x2, 0x2, 0x2, 0xe70, 0xe6d, 0x3, 0x2, 0x2, 0x2, 0xe70, 
       0xe71, 0x3, 0x2, 0x2, 0x2, 0xe71, 0xe7a, 0x3, 0x2, 0x2, 0x2, 0xe72, 
       0xe7a, 0x5, 0x1d4, 0xeb, 0x2, 0xe73, 0xe74, 0x6, 0xdb, 0x45, 0x2, 
       0xe74, 0xe7a, 0x5, 0x1c6, 0xe4, 0x2, 0xe75, 0xe76, 0x6, 0xdb, 0x46, 
       0x2, 0xe76, 0xe7a, 0x5, 0x1ba, 0xde, 0x2, 0xe77, 0xe78, 0x6, 0xdb, 
       0x47, 0x2, 0xe78, 0xe7a, 0x5, 0x1de, 0xf0, 0x2, 0xe79, 0xe57, 0x3, 
       0x2, 0x2, 0x2, 0xe79, 0xe60, 0x3, 0x2, 0x2, 0x2, 0xe79, 0xe61, 0x3, 
       0x2, 0x2, 0x2, 0xe79, 0xe6a, 0x3, 0x2, 0x2, 0x2, 0xe79, 0xe72, 0x3, 
       0x2, 0x2, 0x2, 0xe79, 0xe73, 0x3, 0x2, 0x2, 0x2, 0xe79, 0xe75, 0x3, 
       0x2, 0x2, 0x2, 0xe79, 0xe77, 0x3, 0x2, 0x2, 0x2, 0xe7a, 0x1b5, 0x3, 
       0x2, 0x2, 0x2, 0xe7b, 0xe7d, 0x7, 0xbb, 0x2, 0x2, 0xe7c, 0xe7e, 0x5, 
       0x1b8, 0xdd, 0x2, 0xe7d, 0xe7c, 0x3, 0x2, 0x2, 0x2, 0xe7d, 0xe7e, 
       0x3, 0x2, 0x2, 0x2, 0xe7e, 0xe8a, 0x3, 0x2, 0x2, 0x2, 0xe7f, 0xe80, 
       0x6, 0xdc, 0x48, 0x2, 0xe80, 0xe81, 0x7, 0x10d, 0x2, 0x2, 0xe81, 
       0xe8a, 0x7, 0x9, 0x2, 0x2, 0xe82, 0xe84, 0x7, 0x2f, 0x2, 0x2, 0xe83, 
       0xe85, 0x7, 0x1ad, 0x2, 0x2, 0xe84, 0xe83, 0x3, 0x2, 0x2, 0x2, 0xe84, 
       0xe85, 0x3, 0x2, 0x2, 0x2, 0xe85, 0xe87, 0x3, 0x2, 0x2, 0x2, 0xe86, 
       0xe88, 0x5, 0x2f0, 0x179, 0x2, 0xe87, 0xe86, 0x3, 0x2, 0x2, 0x2, 
       0xe87, 0xe88, 0x3, 0x2, 0x2, 0x2, 0xe88, 0xe8a, 0x3, 0x2, 0x2, 0x2, 
       0xe89, 0xe7b, 0x3, 0x2, 0x2, 0x2, 0xe89, 0xe7f, 0x3, 0x2, 0x2, 0x2, 
       0xe89, 0xe82, 0x3, 0x2, 0x2, 0x2, 0xe8a, 0x1b7, 0x3, 0x2, 0x2, 0x2, 
       0xe8b, 0xe8c, 0x6, 0xdd, 0x49, 0x2, 0xe8c, 0xe8d, 0x7, 0x28e, 0x2, 
       0x2, 0xe8d, 0xe8e, 0x5, 0x450, 0x229, 0x2, 0xe8e, 0x1b9, 0x3, 0x2, 
       0x2, 0x2, 0xe8f, 0xe93, 0x7, 0x223, 0x2, 0x2, 0xe90, 0xe94, 0x7, 
       0x6f, 0x2, 0x2, 0xe91, 0xe92, 0x7, 0x288, 0x2, 0x2, 0xe92, 0xe94, 
       0x5, 0x428, 0x215, 0x2, 0xe93, 0xe90, 0x3, 0x2, 0x2, 0x2, 0xe93, 
       0xe91, 0x3, 0x2, 0x2, 0x2, 0xe94, 0xe95, 0x3, 0x2, 0x2, 0x2, 0xe95, 
       0xe96, 0x7, 0x1fc, 0x2, 0x2, 0xe96, 0xe97, 0x7, 0xbb, 0x2, 0x2, 0xe97, 
       0x1bb, 0x3, 0x2, 0x2, 0x2, 0xe98, 0xe99, 0x7, 0x1c3, 0x2, 0x2, 0xe99, 
       0xe9a, 0x7, 0xbb, 0x2, 0x2, 0xe9a, 0xe9b, 0x7, 0x28e, 0x2, 0x2, 0xe9b, 
       0xe9d, 0x5, 0x1be, 0xe0, 0x2, 0xe9c, 0xe9e, 0x5, 0x2f0, 0x179, 0x2, 
       0xe9d, 0xe9c, 0x3, 0x2, 0x2, 0x2, 0xe9d, 0xe9e, 0x3, 0x2, 0x2, 0x2, 
       0xe9e, 0x1bd, 0x3, 0x2, 0x2, 0x2, 0xe9f, 0xea4, 0x5, 0x1c0, 0xe1, 
       0x2, 0xea0, 0xea1, 0x7, 0x198, 0x2, 0x2, 0xea1, 0xea3, 0x5, 0x1c0, 
       0xe1, 0x2, 0xea2, 0xea0, 0x3, 0x2, 0x2, 0x2, 0xea3, 0xea6, 0x3, 0x2, 
       0x2, 0x2, 0xea4, 0xea2, 0x3, 0x2, 0x2, 0x2, 0xea4, 0xea5, 0x3, 0x2, 
       0x2, 0x2, 0xea5, 0x1bf, 0x3, 0x2, 0x2, 0x2, 0xea6, 0xea4, 0x3, 0x2, 
       0x2, 0x2, 0xea7, 0xea8, 0x7, 0xbd, 0x2, 0x2, 0xea8, 0xea9, 0x7, 0x181, 
       0x2, 0x2, 0xea9, 0xeee, 0x5, 0x462, 0x232, 0x2, 0xeaa, 0xeab, 0x7, 
       0x22c, 0x2, 0x2, 0xeab, 0xeac, 0x7, 0x181, 0x2, 0x2, 0xeac, 0xeee, 
       0x5, 0x462, 0x232, 0x2, 0xead, 0xeae, 0x7, 0xc1, 0x2, 0x2, 0xeae, 
       0xeaf, 0x7, 0x181, 0x2, 0x2, 0xeaf, 0xeee, 0x5, 0x462, 0x232, 0x2, 
       0xeb0, 0xeb1, 0x7, 0xc2, 0x2, 0x2, 0xeb1, 0xeb2, 0x7, 0x181, 0x2, 
       0x2, 0xeb2, 0xeee, 0x5, 0x462, 0x232, 0x2, 0xeb3, 0xeb4, 0x7, 0xbe, 
       0x2, 0x2, 0xeb4, 0xeb5, 0x7, 0x181, 0x2, 0x2, 0xeb5, 0xeee, 0x5, 
       0x44e, 0x228, 0x2, 0xeb6, 0xeb7, 0x7, 0xc4, 0x2, 0x2, 0xeb7, 0xeb8, 
       0x7, 0x181, 0x2, 0x2, 0xeb8, 0xeee, 0x5, 0x44e, 0x228, 0x2, 0xeb9, 
       0xeba, 0x7, 0xc5, 0x2, 0x2, 0xeba, 0xebb, 0x7, 0x181, 0x2, 0x2, 0xebb, 
       0xeee, 0x5, 0x44e, 0x228, 0x2, 0xebc, 0xebd, 0x7, 0xc6, 0x2, 0x2, 
       0xebd, 0xebe, 0x7, 0x181, 0x2, 0x2, 0xebe, 0xeee, 0x5, 0x44e, 0x228, 
       0x2, 0xebf, 0xec0, 0x7, 0xc7, 0x2, 0x2, 0xec0, 0xec1, 0x7, 0x181, 
       0x2, 0x2, 0xec1, 0xeee, 0x5, 0x44e, 0x228, 0x2, 0xec2, 0xec3, 0x7, 
       0xc8, 0x2, 0x2, 0xec3, 0xec4, 0x7, 0x181, 0x2, 0x2, 0xec4, 0xeee, 
       0x5, 0x462, 0x232, 0x2, 0xec5, 0xec6, 0x7, 0xca, 0x2, 0x2, 0xec6, 
       0xec7, 0x7, 0x181, 0x2, 0x2, 0xec7, 0xeee, 0x5, 0x462, 0x232, 0x2, 
       0xec8, 0xec9, 0x7, 0xc9, 0x2, 0x2, 0xec9, 0xeca, 0x7, 0x181, 0x2, 
       0x2, 0xeca, 0xeee, 0x5, 0x462, 0x232, 0x2, 0xecb, 0xecc, 0x7, 0xcb, 
       0x2, 0x2, 0xecc, 0xecd, 0x7, 0x181, 0x2, 0x2, 0xecd, 0xeee, 0x5, 
       0x462, 0x232, 0x2, 0xece, 0xecf, 0x7, 0xcc, 0x2, 0x2, 0xecf, 0xed0, 
       0x7, 0x181, 0x2, 0x2, 0xed0, 0xeee, 0x5, 0x462, 0x232, 0x2, 0xed1, 
       0xed2, 0x7, 0xcf, 0x2, 0x2, 0xed2, 0xed3, 0x7, 0x181, 0x2, 0x2, 0xed3, 
       0xeee, 0x5, 0x462, 0x232, 0x2, 0xed4, 0xed5, 0x7, 0x22d, 0x2, 0x2, 
       0xed5, 0xed6, 0x7, 0x181, 0x2, 0x2, 0xed6, 0xeee, 0x5, 0x44e, 0x228, 
       0x2, 0xed7, 0xed8, 0x7, 0xcd, 0x2, 0x2, 0xed8, 0xed9, 0x7, 0x181, 
       0x2, 0x2, 0xed9, 0xeee, 0x5, 0x460, 0x231, 0x2, 0xeda, 0xedb, 0x7, 
       0xce, 0x2, 0x2, 0xedb, 0xedc, 0x7, 0x181, 0x2, 0x2, 0xedc, 0xeee, 
       0x5, 0x462, 0x232, 0x2, 0xedd, 0xede, 0x7, 0x2e9, 0x2, 0x2, 0xede, 
       0xedf, 0x7, 0x181, 0x2, 0x2, 0xedf, 0xeee, 0x5, 0x462, 0x232, 0x2, 
       0xee0, 0xee1, 0x7, 0x2ea, 0x2, 0x2, 0xee1, 0xee2, 0x7, 0x181, 0x2, 
       0x2, 0xee2, 0xeee, 0x5, 0x44e, 0x228, 0x2, 0xee3, 0xee4, 0x7, 0xbc, 
       0x2, 0x2, 0xee4, 0xee5, 0x7, 0x181, 0x2, 0x2, 0xee5, 0xeee, 0x5, 
       0x44e, 0x228, 0x2, 0xee6, 0xee7, 0x7, 0xa2, 0x2, 0x2, 0xee7, 0xee8, 
       0x7, 0x181, 0x2, 0x2, 0xee8, 0xeee, 0x5, 0x1c4, 0xe3, 0x2, 0xee9, 
       0xeea, 0x7, 0xd0, 0x2, 0x2, 0xeea, 0xeeb, 0x7, 0x181, 0x2, 0x2, 0xeeb, 
       0xeee, 0x5, 0x44e, 0x228, 0x2, 0xeec, 0xeee, 0x5, 0x1c2, 0xe2, 0x2, 
       0xeed, 0xea7, 0x3, 0x2, 0x2, 0x2, 0xeed, 0xeaa, 0x3, 0x2, 0x2, 0x2, 
       0xeed, 0xead, 0x3, 0x2, 0x2, 0x2, 0xeed, 0xeb0, 0x3, 0x2, 0x2, 0x2, 
       0xeed, 0xeb3, 0x3, 0x2, 0x2, 0x2, 0xeed, 0xeb6, 0x3, 0x2, 0x2, 0x2, 
       0xeed, 0xeb9, 0x3, 0x2, 0x2, 0x2, 0xeed, 0xebc, 0x3, 0x2, 0x2, 0x2, 
       0xeed, 0xebf, 0x3, 0x2, 0x2, 0x2, 0xeed, 0xec2, 0x3, 0x2, 0x2, 0x2, 
       0xeed, 0xec5, 0x3, 0x2, 0x2, 0x2, 0xeed, 0xec8, 0x3, 0x2, 0x2, 0x2, 
       0xeed, 0xecb, 0x3, 0x2, 0x2, 0x2, 0xeed, 0xece, 0x3, 0x2, 0x2, 0x2, 
       0xeed, 0xed1, 0x3, 0x2, 0x2, 0x2, 0xeed, 0xed4, 0x3, 0x2, 0x2, 0x2, 
       0xeed, 0xed7, 0x3, 0x2, 0x2, 0x2, 0xeed, 0xeda, 0x3, 0x2, 0x2, 0x2, 
       0xeed, 0xedd, 0x3, 0x2, 0x2, 0x2, 0xeed, 0xee0, 0x3, 0x2, 0x2, 0x2, 
       0xeed, 0xee3, 0x3, 0x2, 0x2, 0x2, 0xeed, 0xee6, 0x3, 0x2, 0x2, 0x2, 
       0xeed, 0xee9, 0x3, 0x2, 0x2, 0x2, 0xeed, 0xeec, 0x3, 0x2, 0x2, 0x2, 
       0xeee, 0x1c1, 0x3, 0x2, 0x2, 0x2, 0xeef, 0xef0, 0x7, 0xbf, 0x2, 0x2, 
       0xef0, 0xef1, 0x7, 0x181, 0x2, 0x2, 0xef1, 0xefc, 0x5, 0x462, 0x232, 
       0x2, 0xef2, 0xef3, 0x7, 0xc0, 0x2, 0x2, 0xef3, 0xef4, 0x7, 0x181, 
       0x2, 0x2, 0xef4, 0xefc, 0x5, 0x452, 0x22a, 0x2, 0xef5, 0xef6, 0x7, 
       0x117, 0x2, 0x2, 0xef6, 0xef7, 0x7, 0x181, 0x2, 0x2, 0xef7, 0xefc, 
       0x5, 0x462, 0x232, 0x2, 0xef8, 0xef9, 0x7, 0x118, 0x2, 0x2, 0xef9, 
       0xefa, 0x7, 0x181, 0x2, 0x2, 0xefa, 0xefc, 0x5, 0x44e, 0x228, 0x2, 
       0xefb, 0xeef, 0x3, 0x2, 0x2, 0x2, 0xefb, 0xef2, 0x3, 0x2, 0x2, 0x2, 
       0xefb, 0xef5, 0x3, 0x2, 0x2, 0x2, 0xefb, 0xef8, 0x3, 0x2, 0x2, 0x2, 
       0xefc, 0x1c3, 0x3, 0x2, 0x2, 0x2, 0xefd, 0xf06, 0x7, 0x19b, 0x2, 
       0x2, 0xefe, 0xf03, 0x5, 0x44e, 0x228, 0x2, 0xeff, 0xf00, 0x7, 0x198, 
       0x2, 0x2, 0xf00, 0xf02, 0x5, 0x44e, 0x228, 0x2, 0xf01, 0xeff, 0x3, 
       0x2, 0x2, 0x2, 0xf02, 0xf05, 0x3, 0x2, 0x2, 0x2, 0xf03, 0xf01, 0x3, 
       0x2, 0x2, 0x2, 0xf03, 0xf04, 0x3, 0x2, 0x2, 0x2, 0xf04, 0xf07, 0x3, 
       0x2, 0x2, 0x2, 0xf05, 0xf03, 0x3, 0x2, 0x2, 0x2, 0xf06, 0xefe, 0x3, 
       0x2, 0x2, 0x2, 0xf06, 0xf07, 0x3, 0x2, 0x2, 0x2, 0xf07, 0xf08, 0x3, 
       0x2, 0x2, 0x2, 0xf08, 0xf09, 0x7, 0x19c, 0x2, 0x2, 0xf09, 0x1c5, 
       0x3, 0x2, 0x2, 0x2, 0xf0a, 0xf0b, 0x7, 0x1c3, 0x2, 0x2, 0xf0b, 0xf0c, 
       0x7, 0x11d, 0x2, 0x2, 0xf0c, 0xf0d, 0x7, 0x95, 0x2, 0x2, 0xf0d, 0xf12, 
       0x5, 0x1c8, 0xe5, 0x2, 0xf0e, 0xf0f, 0x7, 0x198, 0x2, 0x2, 0xf0f, 
       0xf11, 0x5, 0x1c8, 0xe5, 0x2, 0xf10, 0xf0e, 0x3, 0x2, 0x2, 0x2, 0xf11, 
       0xf14, 0x3, 0x2, 0x2, 0x2, 0xf12, 0xf10, 0x3, 0x2, 0x2, 0x2, 0xf12, 
       0xf13, 0x3, 0x2, 0x2, 0x2, 0xf13, 0xf17, 0x3, 0x2, 0x2, 0x2, 0xf14, 
       0xf12, 0x3, 0x2, 0x2, 0x2, 0xf15, 0xf16, 0x6, 0xe4, 0x4a, 0x2, 0xf16, 
       0xf18, 0x5, 0x2f0, 0x179, 0x2, 0xf17, 0xf15, 0x3, 0x2, 0x2, 0x2, 
       0xf17, 0xf18, 0x3, 0x2, 0x2, 0x2, 0xf18, 0x1c7, 0x3, 0x2, 0x2, 0x2, 
       0xf19, 0xf1a, 0x7, 0x11e, 0x2, 0x2, 0xf1a, 0xf1b, 0x7, 0x181, 0x2, 
       0x2, 0xf1b, 0xf1d, 0x7, 0x19b, 0x2, 0x2, 0xf1c, 0xf1e, 0x5, 0x1ca, 
       0xe6, 0x2, 0xf1d, 0xf1c, 0x3, 0x2, 0x2, 0x2, 0xf1d, 0xf1e, 0x3, 0x2, 
       0x2, 0x2, 0xf1e, 0xf1f, 0x3, 0x2, 0x2, 0x2, 0xf1f, 0xf4b, 0x7, 0x19c, 
       0x2, 0x2, 0xf20, 0xf21, 0x7, 0x11f, 0x2, 0x2, 0xf21, 0xf22, 0x7, 
       0x181, 0x2, 0x2, 0xf22, 0xf24, 0x7, 0x19b, 0x2, 0x2, 0xf23, 0xf25, 
       0x5, 0x1ca, 0xe6, 0x2, 0xf24, 0xf23, 0x3, 0x2, 0x2, 0x2, 0xf24, 0xf25, 
       0x3, 0x2, 0x2, 0x2, 0xf25, 0xf26, 0x3, 0x2, 0x2, 0x2, 0xf26, 0xf4b, 
       0x7, 0x19c, 0x2, 0x2, 0xf27, 0xf28, 0x7, 0x120, 0x2, 0x2, 0xf28, 
       0xf29, 0x7, 0x181, 0x2, 0x2, 0xf29, 0xf2b, 0x7, 0x19b, 0x2, 0x2, 
       0xf2a, 0xf2c, 0x5, 0x1cc, 0xe7, 0x2, 0xf2b, 0xf2a, 0x3, 0x2, 0x2, 
       0x2, 0xf2b, 0xf2c, 0x3, 0x2, 0x2, 0x2, 0xf2c, 0xf2d, 0x3, 0x2, 0x2, 
       0x2, 0xf2d, 0xf4b, 0x7, 0x19c, 0x2, 0x2, 0xf2e, 0xf2f, 0x7, 0x121, 
       0x2, 0x2, 0xf2f, 0xf30, 0x7, 0x181, 0x2, 0x2, 0xf30, 0xf32, 0x7, 
       0x19b, 0x2, 0x2, 0xf31, 0xf33, 0x5, 0x1cc, 0xe7, 0x2, 0xf32, 0xf31, 
       0x3, 0x2, 0x2, 0x2, 0xf32, 0xf33, 0x3, 0x2, 0x2, 0x2, 0xf33, 0xf34, 
       0x3, 0x2, 0x2, 0x2, 0xf34, 0xf4b, 0x7, 0x19c, 0x2, 0x2, 0xf35, 0xf36, 
       0x7, 0x122, 0x2, 0x2, 0xf36, 0xf37, 0x7, 0x181, 0x2, 0x2, 0xf37, 
       0xf39, 0x7, 0x19b, 0x2, 0x2, 0xf38, 0xf3a, 0x5, 0x1ce, 0xe8, 0x2, 
       0xf39, 0xf38, 0x3, 0x2, 0x2, 0x2, 0xf39, 0xf3a, 0x3, 0x2, 0x2, 0x2, 
       0xf3a, 0xf3b, 0x3, 0x2, 0x2, 0x2, 0xf3b, 0xf4b, 0x7, 0x19c, 0x2, 
       0x2, 0xf3c, 0xf3d, 0x7, 0x123, 0x2, 0x2, 0xf3d, 0xf3e, 0x7, 0x181, 
       0x2, 0x2, 0xf3e, 0xf40, 0x7, 0x19b, 0x2, 0x2, 0xf3f, 0xf41, 0x5, 
       0x1ce, 0xe8, 0x2, 0xf40, 0xf3f, 0x3, 0x2, 0x2, 0x2, 0xf40, 0xf41, 
       0x3, 0x2, 0x2, 0x2, 0xf41, 0xf42, 0x3, 0x2, 0x2, 0x2, 0xf42, 0xf4b, 
       0x7, 0x19c, 0x2, 0x2, 0xf43, 0xf44, 0x7, 0x124, 0x2, 0x2, 0xf44, 
       0xf45, 0x7, 0x181, 0x2, 0x2, 0xf45, 0xf47, 0x7, 0x19b, 0x2, 0x2, 
       0xf46, 0xf48, 0x5, 0x1d2, 0xea, 0x2, 0xf47, 0xf46, 0x3, 0x2, 0x2, 
       0x2, 0xf47, 0xf48, 0x3, 0x2, 0x2, 0x2, 0xf48, 0xf49, 0x3, 0x2, 0x2, 
       0x2, 0xf49, 0xf4b, 0x7, 0x19c, 0x2, 0x2, 0xf4a, 0xf19, 0x3, 0x2, 
       0x2, 0x2, 0xf4a, 0xf20, 0x3, 0x2, 0x2, 0x2, 0xf4a, 0xf27, 0x3, 0x2, 
       0x2, 0x2, 0xf4a, 0xf2e, 0x3, 0x2, 0x2, 0x2, 0xf4a, 0xf35, 0x3, 0x2, 
       0x2, 0x2, 0xf4a, 0xf3c, 0x3, 0x2, 0x2, 0x2, 0xf4a, 0xf43, 0x3, 0x2, 
       0x2, 0x2, 0xf4b, 0x1c9, 0x3, 0x2, 0x2, 0x2, 0xf4c, 0xf51, 0x5, 0x3fc, 
       0x1ff, 0x2, 0xf4d, 0xf4e, 0x7, 0x198, 0x2, 0x2, 0xf4e, 0xf50, 0x5, 
       0x3fc, 0x1ff, 0x2, 0xf4f, 0xf4d, 0x3, 0x2, 0x2, 0x2, 0xf50, 0xf53, 
       0x3, 0x2, 0x2, 0x2, 0xf51, 0xf4f, 0x3, 0x2, 0x2, 0x2, 0xf51, 0xf52, 
       0x3, 0x2, 0x2, 0x2, 0xf52, 0x1cb, 0x3, 0x2, 0x2, 0x2, 0xf53, 0xf51, 
       0x3, 0x2, 0x2, 0x2, 0xf54, 0xf59, 0x5, 0x424, 0x213, 0x2, 0xf55, 
       0xf56, 0x7, 0x198, 0x2, 0x2, 0xf56, 0xf58, 0x5, 0x424, 0x213, 0x2, 
       0xf57, 0xf55, 0x3, 0x2, 0x2, 0x2, 0xf58, 0xf5b, 0x3, 0x2, 0x2, 0x2, 
       0xf59, 0xf57, 0x3, 0x2, 0x2, 0x2, 0xf59, 0xf5a, 0x3, 0x2, 0x2, 0x2, 
       0xf5a, 0x1cd, 0x3, 0x2, 0x2, 0x2, 0xf5b, 0xf59, 0x3, 0x2, 0x2, 0x2, 
       0xf5c, 0xf61, 0x5, 0x1d0, 0xe9, 0x2, 0xf5d, 0xf5e, 0x7, 0x198, 0x2, 
       0x2, 0xf5e, 0xf60, 0x5, 0x1d0, 0xe9, 0x2, 0xf5f, 0xf5d, 0x3, 0x2, 
       0x2, 0x2, 0xf60, 0xf63, 0x3, 0x2, 0x2, 0x2, 0xf61, 0xf5f, 0x3, 0x2, 
       0x2, 0x2, 0xf61, 0xf62, 0x3, 0x2, 0x2, 0x2, 0xf62, 0x1cf, 0x3, 0x2, 
       0x2, 0x2, 0xf63, 0xf61, 0x3, 0x2, 0x2, 0x2, 0xf64, 0xf65, 0x5, 0x462, 
       0x232, 0x2, 0xf65, 0x1d1, 0x3, 0x2, 0x2, 0x2, 0xf66, 0xf6b, 0x5, 
       0x3ba, 0x1de, 0x2, 0xf67, 0xf68, 0x7, 0x198, 0x2, 0x2, 0xf68, 0xf6a, 
       0x5, 0x3ba, 0x1de, 0x2, 0xf69, 0xf67, 0x3, 0x2, 0x2, 0x2, 0xf6a, 
       0xf6d, 0x3, 0x2, 0x2, 0x2, 0xf6b, 0xf69, 0x3, 0x2, 0x2, 0x2, 0xf6b, 
       0xf6c, 0x3, 0x2, 0x2, 0x2, 0xf6c, 0x1d3, 0x3, 0x2, 0x2, 0x2, 0xf6d, 
       0xf6b, 0x3, 0x2, 0x2, 0x2, 0xf6e, 0xf6f, 0x7, 0x32, 0x2, 0x2, 0xf6f, 
       0xf71, 0x7, 0x2f, 0x2, 0x2, 0xf70, 0xf72, 0x5, 0x1da, 0xee, 0x2, 
       0xf71, 0xf70, 0x3, 0x2, 0x2, 0x2, 0xf71, 0xf72, 0x3, 0x2, 0x2, 0x2, 
       0xf72, 0xf75, 0x3, 0x2, 0x2, 0x2, 0xf73, 0xf74, 0x7, 0x16c, 0x2, 
       0x2, 0xf74, 0xf76, 0x5, 0x1d6, 0xec, 0x2, 0xf75, 0xf73, 0x3, 0x2, 
       0x2, 0x2, 0xf75, 0xf76, 0x3, 0x2, 0x2, 0x2, 0xf76, 0xf77, 0x3, 0x2, 
       0x2, 0x2, 0xf77, 0xf79, 0x5, 0x1d8, 0xed, 0x2, 0xf78, 0xf7a, 0x5, 
       0x2f0, 0x179, 0x2, 0xf79, 0xf78, 0x3, 0x2, 0x2, 0x2, 0xf79, 0xf7a, 
       0x3, 0x2, 0x2, 0x2, 0xf7a, 0xf84, 0x3, 0x2, 0x2, 0x2, 0xf7b, 0xf7c, 
       0x7, 0x33, 0x2, 0x2, 0xf7c, 0xf7e, 0x7, 0x2f, 0x2, 0x2, 0xf7d, 0xf7f, 
       0x5, 0x1da, 0xee, 0x2, 0xf7e, 0xf7d, 0x3, 0x2, 0x2, 0x2, 0xf7e, 0xf7f, 
       0x3, 0x2, 0x2, 0x2, 0xf7f, 0xf81, 0x3, 0x2, 0x2, 0x2, 0xf80, 0xf82, 
       0x5, 0x2f0, 0x179, 0x2, 0xf81, 0xf80, 0x3, 0x2, 0x2, 0x2, 0xf81, 
       0xf82, 0x3, 0x2, 0x2, 0x2, 0xf82, 0xf84, 0x3, 0x2, 0x2, 0x2, 0xf83, 
       0xf6e, 0x3, 0x2, 0x2, 0x2, 0xf83, 0xf7b, 0x3, 0x2, 0x2, 0x2, 0xf84, 
       0x1d5, 0x3, 0x2, 0x2, 0x2, 0xf85, 0xf8d, 0x5, 0x1c2, 0xe2, 0x2, 0xf86, 
       0xf87, 0x6, 0xec, 0x4b, 0x2, 0xf87, 0xf88, 0x9, 0x2e, 0x2, 0x2, 0xf88, 
       0xf89, 0x7, 0x181, 0x2, 0x2, 0xf89, 0xf8d, 0x5, 0x45e, 0x230, 0x2, 
       0xf8a, 0xf8b, 0x6, 0xec, 0x4c, 0x2, 0xf8b, 0xf8d, 0x7, 0x13e, 0x2, 
       0x2, 0xf8c, 0xf85, 0x3, 0x2, 0x2, 0x2, 0xf8c, 0xf86, 0x3, 0x2, 0x2, 
       0x2, 0xf8c, 0xf8a, 0x3, 0x2, 0x2, 0x2, 0xf8d, 0xf92, 0x3, 0x2, 0x2, 
       0x2, 0xf8e, 0xf8f, 0x7, 0x198, 0x2, 0x2, 0xf8f, 0xf91, 0x5, 0x1c2, 
       0xe2, 0x2, 0xf90, 0xf8e, 0x3, 0x2, 0x2, 0x2, 0xf91, 0xf94, 0x3, 0x2, 
       0x2, 0x2, 0xf92, 0xf90, 0x3, 0x2, 0x2, 0x2, 0xf92, 0xf93, 0x3, 0x2, 
       0x2, 0x2, 0xf93, 0x1d7, 0x3, 0x2, 0x2, 0x2, 0xf94, 0xf92, 0x3, 0x2, 
       0x2, 0x2, 0xf95, 0xf99, 0x6, 0xed, 0x4d, 0x2, 0xf96, 0xf97, 0x7, 
       0x16e, 0x2, 0x2, 0xf97, 0xf98, 0x7, 0x181, 0x2, 0x2, 0xf98, 0xf9a, 
       0x5, 0x45e, 0x230, 0x2, 0xf99, 0xf96, 0x3, 0x2, 0x2, 0x2, 0xf99, 
       0xf9a, 0x3, 0x2, 0x2, 0x2, 0xf9a, 0xf9e, 0x3, 0x2, 0x2, 0x2, 0xf9b, 
       0xf9c, 0x7, 0xfd, 0x2, 0x2, 0xf9c, 0xf9d, 0x7, 0x181, 0x2, 0x2, 0xf9d, 
       0xf9f, 0x5, 0x45e, 0x230, 0x2, 0xf9e, 0xf9b, 0x3, 0x2, 0x2, 0x2, 
       0xf9e, 0xf9f, 0x3, 0x2, 0x2, 0x2, 0xf9f, 0xfa3, 0x3, 0x2, 0x2, 0x2, 
       0xfa0, 0xfa1, 0x7, 0x74, 0x2, 0x2, 0xfa1, 0xfa2, 0x7, 0x181, 0x2, 
       0x2, 0xfa2, 0xfa4, 0x5, 0x45e, 0x230, 0x2, 0xfa3, 0xfa0, 0x3, 0x2, 
       0x2, 0x2, 0xfa3, 0xfa4, 0x3, 0x2, 0x2, 0x2, 0xfa4, 0xfa8, 0x3, 0x2, 
       0x2, 0x2, 0xfa5, 0xfa6, 0x7, 0xff, 0x2, 0x2, 0xfa6, 0xfa7, 0x7, 0x181, 
       0x2, 0x2, 0xfa7, 0xfa9, 0x5, 0x45e, 0x230, 0x2, 0xfa8, 0xfa5, 0x3, 
       0x2, 0x2, 0x2, 0xfa8, 0xfa9, 0x3, 0x2, 0x2, 0x2, 0xfa9, 0xfac, 0x3, 
       0x2, 
  };
  static uint16_t serializedATNSegment2[] = {
    0x2, 0x2, 0xfaa, 0xfac, 0x3, 0x2, 0x2, 0x2, 0xfab, 0xf95, 0x3, 0x2, 
       0x2, 0x2, 0xfab, 0xfaa, 0x3, 0x2, 0x2, 0x2, 0xfac, 0x1d9, 0x3, 0x2, 
       0x2, 0x2, 0xfad, 0xfb2, 0x5, 0x1dc, 0xef, 0x2, 0xfae, 0xfaf, 0x7, 
       0x198, 0x2, 0x2, 0xfaf, 0xfb1, 0x5, 0x1dc, 0xef, 0x2, 0xfb0, 0xfae, 
       0x3, 0x2, 0x2, 0x2, 0xfb1, 0xfb4, 0x3, 0x2, 0x2, 0x2, 0xfb2, 0xfb0, 
       0x3, 0x2, 0x2, 0x2, 0xfb2, 0xfb3, 0x3, 0x2, 0x2, 0x2, 0xfb3, 0x1db, 
       0x3, 0x2, 0x2, 0x2, 0xfb4, 0xfb2, 0x3, 0x2, 0x2, 0x2, 0xfb5, 0xfb6, 
       0x9, 0x2f, 0x2, 0x2, 0xfb6, 0x1dd, 0x3, 0x2, 0x2, 0x2, 0xfb7, 0xfb8, 
       0x9, 0x30, 0x2, 0x2, 0xfb8, 0xfb9, 0x7, 0x17, 0x2, 0x2, 0xfb9, 0x1df, 
       0x3, 0x2, 0x2, 0x2, 0xfba, 0xfbb, 0x7, 0x25, 0x2, 0x2, 0xfbb, 0xfbc, 
       0x5, 0x442, 0x222, 0x2, 0xfbc, 0xfbf, 0x7, 0x1fc, 0x2, 0x2, 0xfbd, 
       0xfc0, 0x5, 0x460, 0x231, 0x2, 0xfbe, 0xfc0, 0x5, 0x2ca, 0x166, 0x2, 
       0xfbf, 0xfbd, 0x3, 0x2, 0x2, 0x2, 0xfbf, 0xfbe, 0x3, 0x2, 0x2, 0x2, 
       0xfc0, 0xfc6, 0x3, 0x2, 0x2, 0x2, 0xfc1, 0xfc6, 0x5, 0x1e2, 0xf2, 
       0x2, 0xfc2, 0xfc3, 0x9, 0x31, 0x2, 0x2, 0xfc3, 0xfc4, 0x7, 0x25, 
       0x2, 0x2, 0xfc4, 0xfc6, 0x5, 0x442, 0x222, 0x2, 0xfc5, 0xfba, 0x3, 
       0x2, 0x2, 0x2, 0xfc5, 0xfc1, 0x3, 0x2, 0x2, 0x2, 0xfc5, 0xfc2, 0x3, 
       0x2, 0x2, 0x2, 0xfc6, 0x1e1, 0x3, 0x2, 0x2, 0x2, 0xfc7, 0xfc8, 0x7, 
       0x13, 0x2, 0x2, 0xfc8, 0xfcb, 0x5, 0x442, 0x222, 0x2, 0xfc9, 0xfca, 
       0x7, 0x29b, 0x2, 0x2, 0xfca, 0xfcc, 0x5, 0x1e4, 0xf3, 0x2, 0xfcb, 
       0xfc9, 0x3, 0x2, 0x2, 0x2, 0xfcb, 0xfcc, 0x3, 0x2, 0x2, 0x2, 0xfcc, 
       0x1e3, 0x3, 0x2, 0x2, 0x2, 0xfcd, 0xfd2, 0x5, 0x2ca, 0x166, 0x2, 
       0xfce, 0xfcf, 0x7, 0x198, 0x2, 0x2, 0xfcf, 0xfd1, 0x5, 0x2ca, 0x166, 
       0x2, 0xfd0, 0xfce, 0x3, 0x2, 0x2, 0x2, 0xfd1, 0xfd4, 0x3, 0x2, 0x2, 
       0x2, 0xfd2, 0xfd0, 0x3, 0x2, 0x2, 0x2, 0xfd2, 0xfd3, 0x3, 0x2, 0x2, 
       0x2, 0xfd3, 0x1e5, 0x3, 0x2, 0x2, 0x2, 0xfd4, 0xfd2, 0x3, 0x2, 0x2, 
       0x2, 0xfd5, 0xfee, 0x7, 0x2c6, 0x2, 0x2, 0xfd6, 0xfd7, 0x7, 0xb6, 
       0x2, 0x2, 0xfd7, 0xfd8, 0x7, 0x6f, 0x2, 0x2, 0xfd8, 0xfda, 0x7, 0x79, 
       0x2, 0x2, 0xfd9, 0xfdb, 0x5, 0x47a, 0x23e, 0x2, 0xfda, 0xfd9, 0x3, 
       0x2, 0x2, 0x2, 0xfda, 0xfdb, 0x3, 0x2, 0x2, 0x2, 0xfdb, 0xfdc, 0x3, 
       0x2, 0x2, 0x2, 0xfdc, 0xfef, 0x5, 0x45c, 0x22f, 0x2, 0xfdd, 0xfe0, 
       0x7, 0x2c5, 0x2, 0x2, 0xfde, 0xfdf, 0x7, 0x1fb, 0x2, 0x2, 0xfdf, 
       0xfe1, 0x7, 0x11d, 0x2, 0x2, 0xfe0, 0xfde, 0x3, 0x2, 0x2, 0x2, 0xfe0, 
       0xfe1, 0x3, 0x2, 0x2, 0x2, 0xfe1, 0xfef, 0x3, 0x2, 0x2, 0x2, 0xfe2, 
       0xfe3, 0x6, 0xf4, 0x4e, 0x2, 0xfe3, 0xfe4, 0x7, 0xa7, 0x2, 0x2, 0xfe4, 
       0xfe5, 0x7, 0x1fc, 0x2, 0x2, 0xfe5, 0xfe6, 0x5, 0x3dc, 0x1ef, 0x2, 
       0xfe6, 0xfe7, 0x7, 0x19a, 0x2, 0x2, 0xfe7, 0xfe8, 0x5, 0x44e, 0x228, 
       0x2, 0xfe8, 0xfe9, 0x7, 0xa1, 0x2, 0x2, 0xfe9, 0xfea, 0x7, 0x1be, 
       0x2, 0x2, 0xfea, 0xfec, 0x5, 0x45c, 0x22f, 0x2, 0xfeb, 0xfed, 0x5, 
       0x1e8, 0xf5, 0x2, 0xfec, 0xfeb, 0x3, 0x2, 0x2, 0x2, 0xfec, 0xfed, 
       0x3, 0x2, 0x2, 0x2, 0xfed, 0xfef, 0x3, 0x2, 0x2, 0x2, 0xfee, 0xfd6, 
       0x3, 0x2, 0x2, 0x2, 0xfee, 0xfdd, 0x3, 0x2, 0x2, 0x2, 0xfee, 0xfe2, 
       0x3, 0x2, 0x2, 0x2, 0xfef, 0x1e7, 0x3, 0x2, 0x2, 0x2, 0xff0, 0xffb, 
       0x5, 0x1ea, 0xf6, 0x2, 0xff1, 0xff2, 0x7, 0x6f, 0x2, 0x2, 0xff2, 
       0xff4, 0x7, 0x79, 0x2, 0x2, 0xff3, 0xff5, 0x5, 0x47a, 0x23e, 0x2, 
       0xff4, 0xff3, 0x3, 0x2, 0x2, 0x2, 0xff4, 0xff5, 0x3, 0x2, 0x2, 0x2, 
       0xff5, 0xff6, 0x3, 0x2, 0x2, 0x2, 0xff6, 0xff8, 0x5, 0x45c, 0x22f, 
       0x2, 0xff7, 0xff9, 0x5, 0x1ea, 0xf6, 0x2, 0xff8, 0xff7, 0x3, 0x2, 
       0x2, 0x2, 0xff8, 0xff9, 0x3, 0x2, 0x2, 0x2, 0xff9, 0xffb, 0x3, 0x2, 
       0x2, 0x2, 0xffa, 0xff0, 0x3, 0x2, 0x2, 0x2, 0xffa, 0xff1, 0x3, 0x2, 
       0x2, 0x2, 0xffb, 0x1e9, 0x3, 0x2, 0x2, 0x2, 0xffc, 0xffe, 0x7, 0x260, 
       0x2, 0x2, 0xffd, 0xfff, 0x7, 0x1d, 0x2, 0x2, 0xffe, 0xffd, 0x3, 0x2, 
       0x2, 0x2, 0xffe, 0xfff, 0x3, 0x2, 0x2, 0x2, 0xfff, 0x1000, 0x3, 0x2, 
       0x2, 0x2, 0x1000, 0x1001, 0x7, 0x27a, 0x2, 0x2, 0x1001, 0x1eb, 0x3, 
       0x2, 0x2, 0x2, 0x1002, 0x1003, 0x6, 0xf7, 0x4f, 0x2, 0x1003, 0x100d, 
       0x5, 0x1ee, 0xf8, 0x2, 0x1004, 0x100d, 0x5, 0x1f2, 0xfa, 0x2, 0x1005, 
       0x100d, 0x5, 0x1fe, 0x100, 0x2, 0x1006, 0x100d, 0x5, 0x200, 0x101, 
       0x2, 0x1007, 0x100d, 0x5, 0x208, 0x105, 0x2, 0x1008, 0x100d, 0x5, 
       0x20a, 0x106, 0x2, 0x1009, 0x100d, 0x5, 0x210, 0x109, 0x2, 0x100a, 
       0x100b, 0x6, 0xf7, 0x50, 0x2, 0x100b, 0x100d, 0x5, 0x21e, 0x110, 
       0x2, 0x100c, 0x1002, 0x3, 0x2, 0x2, 0x2, 0x100c, 0x1004, 0x3, 0x2, 
       0x2, 0x2, 0x100c, 0x1005, 0x3, 0x2, 0x2, 0x2, 0x100c, 0x1006, 0x3, 
       0x2, 0x2, 0x2, 0x100c, 0x1007, 0x3, 0x2, 0x2, 0x2, 0x100c, 0x1008, 
       0x3, 0x2, 0x2, 0x2, 0x100c, 0x1009, 0x3, 0x2, 0x2, 0x2, 0x100c, 0x100a, 
       0x3, 0x2, 0x2, 0x2, 0x100d, 0x1ed, 0x3, 0x2, 0x2, 0x2, 0x100e, 0x100f, 
       0x7, 0x1ae, 0x2, 0x2, 0x100f, 0x1012, 0x7, 0x16e, 0x2, 0x2, 0x1010, 
       0x1011, 0x6, 0xf8, 0x51, 0x2, 0x1011, 0x1013, 0x5, 0x3ae, 0x1d8, 
       0x2, 0x1012, 0x1010, 0x3, 0x2, 0x2, 0x2, 0x1012, 0x1013, 0x3, 0x2, 
       0x2, 0x2, 0x1013, 0x1014, 0x3, 0x2, 0x2, 0x2, 0x1014, 0x1015, 0x5, 
       0x1f0, 0xf9, 0x2, 0x1015, 0x1ef, 0x3, 0x2, 0x2, 0x2, 0x1016, 0x1017, 
       0x6, 0xf9, 0x52, 0x2, 0x1017, 0x101b, 0x5, 0x3ce, 0x1e8, 0x2, 0x1018, 
       0x1019, 0x6, 0xf9, 0x53, 0x2, 0x1019, 0x101b, 0x5, 0x3d0, 0x1e9, 
       0x2, 0x101a, 0x1016, 0x3, 0x2, 0x2, 0x2, 0x101a, 0x1018, 0x3, 0x2, 
       0x2, 0x2, 0x101b, 0x101c, 0x3, 0x2, 0x2, 0x2, 0x101c, 0x101d, 0x5, 
       0x1f4, 0xfb, 0x2, 0x101d, 0x103b, 0x3, 0x2, 0x2, 0x2, 0x101e, 0x101f, 
       0x6, 0xf9, 0x54, 0x2, 0x101f, 0x1020, 0x7, 0x16e, 0x2, 0x2, 0x1020, 
       0x1021, 0x5, 0x478, 0x23d, 0x2, 0x1021, 0x1022, 0x7, 0xa1, 0x2, 0x2, 
       0x1022, 0x1023, 0x7, 0x1be, 0x2, 0x2, 0x1023, 0x1026, 0x5, 0x45e, 
       0x230, 0x2, 0x1024, 0x1025, 0x6, 0xf9, 0x55, 0x2, 0x1025, 0x1027, 
       0x5, 0x3da, 0x1ee, 0x2, 0x1026, 0x1024, 0x3, 0x2, 0x2, 0x2, 0x1026, 
       0x1027, 0x3, 0x2, 0x2, 0x2, 0x1027, 0x102a, 0x3, 0x2, 0x2, 0x2, 0x1028, 
       0x1029, 0x6, 0xf9, 0x56, 0x2, 0x1029, 0x102b, 0x5, 0x3d6, 0x1ec, 
       0x2, 0x102a, 0x1028, 0x3, 0x2, 0x2, 0x2, 0x102a, 0x102b, 0x3, 0x2, 
       0x2, 0x2, 0x102b, 0x103b, 0x3, 0x2, 0x2, 0x2, 0x102c, 0x102d, 0x6, 
       0xf9, 0x57, 0x2, 0x102d, 0x102e, 0x7, 0x16e, 0x2, 0x2, 0x102e, 0x102f, 
       0x5, 0x478, 0x23d, 0x2, 0x102f, 0x1030, 0x5, 0x3d8, 0x1ed, 0x2, 0x1030, 
       0x103b, 0x3, 0x2, 0x2, 0x2, 0x1031, 0x1032, 0x6, 0xf9, 0x58, 0x2, 
       0x1032, 0x1033, 0x5, 0x3dc, 0x1ef, 0x2, 0x1033, 0x1034, 0x7, 0x1e0, 
       0x2, 0x2, 0x1034, 0x1038, 0x7, 0x2b4, 0x2, 0x2, 0x1035, 0x1039, 0x7, 
       0x1ad, 0x2, 0x2, 0x1036, 0x1039, 0x7, 0xf1, 0x2, 0x2, 0x1037, 0x1039, 
       0x5, 0x220, 0x111, 0x2, 0x1038, 0x1035, 0x3, 0x2, 0x2, 0x2, 0x1038, 
       0x1036, 0x3, 0x2, 0x2, 0x2, 0x1038, 0x1037, 0x3, 0x2, 0x2, 0x2, 0x1039, 
       0x103b, 0x3, 0x2, 0x2, 0x2, 0x103a, 0x101a, 0x3, 0x2, 0x2, 0x2, 0x103a, 
       0x101e, 0x3, 0x2, 0x2, 0x2, 0x103a, 0x102c, 0x3, 0x2, 0x2, 0x2, 0x103a, 
       0x1031, 0x3, 0x2, 0x2, 0x2, 0x103b, 0x1f1, 0x3, 0x2, 0x2, 0x2, 0x103c, 
       0x103d, 0x7, 0x1cd, 0x2, 0x2, 0x103d, 0x1041, 0x7, 0x16e, 0x2, 0x2, 
       0x103e, 0x103f, 0x6, 0xfa, 0x59, 0x2, 0x103f, 0x1042, 0x5, 0x3b0, 
       0x1d9, 0x2, 0x1040, 0x1042, 0x3, 0x2, 0x2, 0x2, 0x1041, 0x103e, 0x3, 
       0x2, 0x2, 0x2, 0x1041, 0x1040, 0x3, 0x2, 0x2, 0x2, 0x1042, 0x1043, 
       0x3, 0x2, 0x2, 0x2, 0x1043, 0x1044, 0x5, 0x3ce, 0x1e8, 0x2, 0x1044, 
       0x1045, 0x5, 0x1f6, 0xfc, 0x2, 0x1045, 0x1046, 0x5, 0x1f4, 0xfb, 
       0x2, 0x1046, 0x1f3, 0x3, 0x2, 0x2, 0x2, 0x1047, 0x1049, 0x6, 0xfb, 
       0x5a, 0x2, 0x1048, 0x104a, 0x5, 0x1f8, 0xfd, 0x2, 0x1049, 0x1048, 
       0x3, 0x2, 0x2, 0x2, 0x1049, 0x104a, 0x3, 0x2, 0x2, 0x2, 0x104a, 0x104c, 
       0x3, 0x2, 0x2, 0x2, 0x104b, 0x104d, 0x5, 0x1fa, 0xfe, 0x2, 0x104c, 
       0x104b, 0x3, 0x2, 0x2, 0x2, 0x104c, 0x104d, 0x3, 0x2, 0x2, 0x2, 0x104d, 
       0x104f, 0x3, 0x2, 0x2, 0x2, 0x104e, 0x1050, 0x5, 0x1fc, 0xff, 0x2, 
       0x104f, 0x104e, 0x3, 0x2, 0x2, 0x2, 0x104f, 0x1050, 0x3, 0x2, 0x2, 
       0x2, 0x1050, 0x1053, 0x3, 0x2, 0x2, 0x2, 0x1051, 0x1053, 0x3, 0x2, 
       0x2, 0x2, 0x1052, 0x1047, 0x3, 0x2, 0x2, 0x2, 0x1052, 0x1051, 0x3, 
       0x2, 0x2, 0x2, 0x1053, 0x1f5, 0x3, 0x2, 0x2, 0x2, 0x1054, 0x1058, 
       0x6, 0xfc, 0x5b, 0x2, 0x1055, 0x1056, 0x7, 0x1e0, 0x2, 0x2, 0x1056, 
       0x1057, 0x7, 0x2b4, 0x2, 0x2, 0x1057, 0x1059, 0x5, 0x220, 0x111, 
       0x2, 0x1058, 0x1055, 0x3, 0x2, 0x2, 0x2, 0x1058, 0x1059, 0x3, 0x2, 
       0x2, 0x2, 0x1059, 0x105c, 0x3, 0x2, 0x2, 0x2, 0x105a, 0x105c, 0x3, 
       0x2, 0x2, 0x2, 0x105b, 0x1054, 0x3, 0x2, 0x2, 0x2, 0x105b, 0x105a, 
       0x3, 0x2, 0x2, 0x2, 0x105c, 0x1f7, 0x3, 0x2, 0x2, 0x2, 0x105d, 0x1060, 
       0x7, 0x260, 0x2, 0x2, 0x105e, 0x1061, 0x5, 0x218, 0x10d, 0x2, 0x105f, 
       0x1061, 0x9, 0x32, 0x2, 0x2, 0x1060, 0x105e, 0x3, 0x2, 0x2, 0x2, 
       0x1060, 0x105f, 0x3, 0x2, 0x2, 0x2, 0x1061, 0x1f9, 0x3, 0x2, 0x2, 
       0x2, 0x1062, 0x106b, 0x7, 0x2ab, 0x2, 0x2, 0x1063, 0x1064, 0x7, 0xd2, 
       0x2, 0x2, 0x1064, 0x106c, 0x5, 0x44e, 0x228, 0x2, 0x1065, 0x1066, 
       0x7, 0xd5, 0x2, 0x2, 0x1066, 0x106c, 0x5, 0x44e, 0x228, 0x2, 0x1067, 
       0x1068, 0x7, 0xd1, 0x2, 0x2, 0x1068, 0x106c, 0x5, 0x44e, 0x228, 0x2, 
       0x1069, 0x106a, 0x7, 0xd6, 0x2, 0x2, 0x106a, 0x106c, 0x5, 0x44e, 
       0x228, 0x2, 0x106b, 0x1063, 0x3, 0x2, 0x2, 0x2, 0x106b, 0x1065, 0x3, 
       0x2, 0x2, 0x2, 0x106b, 0x1067, 0x3, 0x2, 0x2, 0x2, 0x106b, 0x1069, 
       0x3, 0x2, 0x2, 0x2, 0x106c, 0x106d, 0x3, 0x2, 0x2, 0x2, 0x106d, 0x106b, 
       0x3, 0x2, 0x2, 0x2, 0x106d, 0x106e, 0x3, 0x2, 0x2, 0x2, 0x106e, 0x1fb, 
       0x3, 0x2, 0x2, 0x2, 0x106f, 0x1070, 0x7, 0x3, 0x2, 0x2, 0x1070, 0x1090, 
       0x9, 0x33, 0x2, 0x2, 0x1071, 0x108d, 0x7, 0xfd, 0x2, 0x2, 0x1072, 
       0x1078, 0x7, 0x1f4, 0x2, 0x2, 0x1073, 0x1074, 0x7, 0x210, 0x2, 0x2, 
       0x1074, 0x1075, 0x5, 0x450, 0x229, 0x2, 0x1075, 0x1076, 0x7, 0x73, 
       0x2, 0x2, 0x1076, 0x1079, 0x3, 0x2, 0x2, 0x2, 0x1077, 0x1079, 0x9, 
       0x34, 0x2, 0x2, 0x1078, 0x1073, 0x3, 0x2, 0x2, 0x2, 0x1078, 0x1077, 
       0x3, 0x2, 0x2, 0x2, 0x1078, 0x1079, 0x3, 0x2, 0x2, 0x2, 0x1079, 0x108e, 
       0x3, 0x2, 0x2, 0x2, 0x107a, 0x107d, 0x7, 0x2e2, 0x2, 0x2, 0x107b, 
       0x107e, 0x5, 0x450, 0x229, 0x2, 0x107c, 0x107e, 0x7, 0x1e0, 0x2, 
       0x2, 0x107d, 0x107b, 0x3, 0x2, 0x2, 0x2, 0x107d, 0x107c, 0x3, 0x2, 
       0x2, 0x2, 0x107e, 0x108e, 0x3, 0x2, 0x2, 0x2, 0x107f, 0x1085, 0x7, 
       0x2e3, 0x2, 0x2, 0x1080, 0x1081, 0x7, 0x210, 0x2, 0x2, 0x1081, 0x1082, 
       0x5, 0x450, 0x229, 0x2, 0x1082, 0x1083, 0x7, 0x73, 0x2, 0x2, 0x1083, 
       0x1086, 0x3, 0x2, 0x2, 0x2, 0x1084, 0x1086, 0x7, 0x1e0, 0x2, 0x2, 
       0x1085, 0x1080, 0x3, 0x2, 0x2, 0x2, 0x1085, 0x1084, 0x3, 0x2, 0x2, 
       0x2, 0x1085, 0x1086, 0x3, 0x2, 0x2, 0x2, 0x1086, 0x108e, 0x3, 0x2, 
       0x2, 0x2, 0x1087, 0x1088, 0x6, 0xff, 0x5c, 0x2, 0x1088, 0x1089, 0x7, 
       0x260, 0x2, 0x2, 0x1089, 0x108b, 0x7, 0x6d, 0x2, 0x2, 0x108a, 0x108c, 
       0x9, 0x35, 0x2, 0x2, 0x108b, 0x108a, 0x3, 0x2, 0x2, 0x2, 0x108b, 
       0x108c, 0x3, 0x2, 0x2, 0x2, 0x108c, 0x108e, 0x3, 0x2, 0x2, 0x2, 0x108d, 
       0x1072, 0x3, 0x2, 0x2, 0x2, 0x108d, 0x107a, 0x3, 0x2, 0x2, 0x2, 0x108d, 
       0x107f, 0x3, 0x2, 0x2, 0x2, 0x108d, 0x1087, 0x3, 0x2, 0x2, 0x2, 0x108e, 
       0x1090, 0x3, 0x2, 0x2, 0x2, 0x108f, 0x106f, 0x3, 0x2, 0x2, 0x2, 0x108f, 
       0x1071, 0x3, 0x2, 0x2, 0x2, 0x1090, 0x1fd, 0x3, 0x2, 0x2, 0x2, 0x1091, 
       0x1092, 0x7, 0x1e9, 0x2, 0x2, 0x1092, 0x1095, 0x7, 0x16e, 0x2, 0x2, 
       0x1093, 0x1094, 0x6, 0x100, 0x5d, 0x2, 0x1094, 0x1096, 0x5, 0x3ae, 
       0x1d8, 0x2, 0x1095, 0x1093, 0x3, 0x2, 0x2, 0x2, 0x1095, 0x1096, 0x3, 
       0x2, 0x2, 0x2, 0x1096, 0x1097, 0x3, 0x2, 0x2, 0x2, 0x1097, 0x1098, 
       0x5, 0x3cc, 0x1e7, 0x2, 0x1098, 0x1ff, 0x3, 0x2, 0x2, 0x2, 0x1099, 
       0x10c2, 0x7, 0x200, 0x2, 0x2, 0x109a, 0x109b, 0x6, 0x101, 0x5e, 0x2, 
       0x109b, 0x109c, 0x5, 0x212, 0x10a, 0x2, 0x109c, 0x109d, 0x7, 0x28e, 
       0x2, 0x2, 0x109d, 0x10a1, 0x5, 0x3cc, 0x1e7, 0x2, 0x109e, 0x109f, 
       0x7, 0x2ab, 0x2, 0x2, 0x109f, 0x10a0, 0x7, 0x2b5, 0x2, 0x2, 0x10a0, 
       0x10a2, 0x7, 0x249, 0x2, 0x2, 0x10a1, 0x109e, 0x3, 0x2, 0x2, 0x2, 
       0x10a1, 0x10a2, 0x3, 0x2, 0x2, 0x2, 0x10a2, 0x10c3, 0x3, 0x2, 0x2, 
       0x2, 0x10a3, 0x10a9, 0x5, 0x212, 0x10a, 0x2, 0x10a4, 0x10a6, 0x7, 
       0x1ad, 0x2, 0x2, 0x10a5, 0x10a7, 0x7, 0x106, 0x2, 0x2, 0x10a6, 0x10a5, 
       0x3, 0x2, 0x2, 0x2, 0x10a6, 0x10a7, 0x3, 0x2, 0x2, 0x2, 0x10a7, 0x10a9, 
       0x3, 0x2, 0x2, 0x2, 0x10a8, 0x10a3, 0x3, 0x2, 0x2, 0x2, 0x10a8, 0x10a4, 
       0x3, 0x2, 0x2, 0x2, 0x10a9, 0x10aa, 0x3, 0x2, 0x2, 0x2, 0x10aa, 0x10ac, 
       0x7, 0x244, 0x2, 0x2, 0x10ab, 0x10ad, 0x5, 0x20e, 0x108, 0x2, 0x10ac, 
       0x10ab, 0x3, 0x2, 0x2, 0x2, 0x10ac, 0x10ad, 0x3, 0x2, 0x2, 0x2, 0x10ad, 
       0x10ae, 0x3, 0x2, 0x2, 0x2, 0x10ae, 0x10af, 0x5, 0x216, 0x10c, 0x2, 
       0x10af, 0x10b0, 0x7, 0x28e, 0x2, 0x2, 0x10b0, 0x10b2, 0x5, 0x202, 
       0x102, 0x2, 0x10b1, 0x10b3, 0x5, 0x206, 0x104, 0x2, 0x10b2, 0x10b1, 
       0x3, 0x2, 0x2, 0x2, 0x10b2, 0x10b3, 0x3, 0x2, 0x2, 0x2, 0x10b3, 0x10b5, 
       0x3, 0x2, 0x2, 0x2, 0x10b4, 0x10b6, 0x5, 0x204, 0x103, 0x2, 0x10b5, 
       0x10b4, 0x3, 0x2, 0x2, 0x2, 0x10b5, 0x10b6, 0x3, 0x2, 0x2, 0x2, 0x10b6, 
       0x10c3, 0x3, 0x2, 0x2, 0x2, 0x10b7, 0x10b8, 0x6, 0x101, 0x5f, 0x2, 
       0x10b8, 0x10b9, 0x7, 0x10b, 0x2, 0x2, 0x10b9, 0x10ba, 0x7, 0x244, 
       0x2, 0x2, 0x10ba, 0x10bb, 0x5, 0x3dc, 0x1ef, 0x2, 0x10bb, 0x10bc, 
       0x7, 0x28e, 0x2, 0x2, 0x10bc, 0x10c0, 0x5, 0x202, 0x102, 0x2, 0x10bd, 
       0x10be, 0x7, 0x2ab, 0x2, 0x2, 0x10be, 0x10bf, 0x7, 0x200, 0x2, 0x2, 
       0x10bf, 0x10c1, 0x7, 0x249, 0x2, 0x2, 0x10c0, 0x10bd, 0x3, 0x2, 0x2, 
       0x2, 0x10c0, 0x10c1, 0x3, 0x2, 0x2, 0x2, 0x10c1, 0x10c3, 0x3, 0x2, 
       0x2, 0x2, 0x10c2, 0x109a, 0x3, 0x2, 0x2, 0x2, 0x10c2, 0x10a8, 0x3, 
       0x2, 0x2, 0x2, 0x10c2, 0x10b7, 0x3, 0x2, 0x2, 0x2, 0x10c3, 0x201, 
       0x3, 0x2, 0x2, 0x2, 0x10c4, 0x10c5, 0x6, 0x102, 0x60, 0x2, 0x10c5, 
       0x10c9, 0x5, 0x3ce, 0x1e8, 0x2, 0x10c6, 0x10c7, 0x6, 0x102, 0x61, 
       0x2, 0x10c7, 0x10c9, 0x5, 0x3cc, 0x1e7, 0x2, 0x10c8, 0x10c4, 0x3, 
       0x2, 0x2, 0x2, 0x10c8, 0x10c6, 0x3, 0x2, 0x2, 0x2, 0x10c9, 0x203, 
       0x3, 0x2, 0x2, 0x2, 0x10ca, 0x10cb, 0x6, 0x103, 0x62, 0x2, 0x10cb, 
       0x10cd, 0x7, 0x2ab, 0x2, 0x2, 0x10cc, 0x10ce, 0x5, 0x21c, 0x10f, 
       0x2, 0x10cd, 0x10cc, 0x3, 0x2, 0x2, 0x2, 0x10ce, 0x10cf, 0x3, 0x2, 
       0x2, 0x2, 0x10cf, 0x10cd, 0x3, 0x2, 0x2, 0x2, 0x10cf, 0x10d0, 0x3, 
       0x2, 0x2, 0x2, 0x10d0, 0x10d6, 0x3, 0x2, 0x2, 0x2, 0x10d1, 0x10d2, 
       0x6, 0x103, 0x63, 0x2, 0x10d2, 0x10d3, 0x7, 0x2ab, 0x2, 0x2, 0x10d3, 
       0x10d4, 0x7, 0x200, 0x2, 0x2, 0x10d4, 0x10d6, 0x7, 0x249, 0x2, 0x2, 
       0x10d5, 0x10ca, 0x3, 0x2, 0x2, 0x2, 0x10d5, 0x10d1, 0x3, 0x2, 0x2, 
       0x2, 0x10d6, 0x205, 0x3, 0x2, 0x2, 0x2, 0x10d7, 0x10d8, 0x6, 0x104, 
       0x64, 0x2, 0x10d8, 0x10d9, 0x5, 0x1f8, 0xfd, 0x2, 0x10d9, 0x207, 
       0x3, 0x2, 0x2, 0x2, 0x10da, 0x10db, 0x7, 0x25d, 0x2, 0x2, 0x10db, 
       0x10dc, 0x7, 0x16e, 0x2, 0x2, 0x10dc, 0x10dd, 0x5, 0x3dc, 0x1ef, 
       0x2, 0x10dd, 0x10de, 0x7, 0x28e, 0x2, 0x2, 0x10de, 0x10e6, 0x5, 0x3dc, 
       0x1ef, 0x2, 0x10df, 0x10e0, 0x7, 0x198, 0x2, 0x2, 0x10e0, 0x10e1, 
       0x5, 0x3dc, 0x1ef, 0x2, 0x10e1, 0x10e2, 0x7, 0x28e, 0x2, 0x2, 0x10e2, 
       0x10e3, 0x5, 0x3dc, 0x1ef, 0x2, 0x10e3, 0x10e5, 0x3, 0x2, 0x2, 0x2, 
       0x10e4, 0x10df, 0x3, 0x2, 0x2, 0x2, 0x10e5, 0x10e8, 0x3, 0x2, 0x2, 
       0x2, 0x10e6, 0x10e4, 0x3, 0x2, 0x2, 0x2, 0x10e6, 0x10e7, 0x3, 0x2, 
       0x2, 0x2, 0x10e7, 0x209, 0x3, 0x2, 0x2, 0x2, 0x10e8, 0x10e6, 0x3, 
       0x2, 0x2, 0x2, 0x10e9, 0x110c, 0x7, 0x264, 0x2, 0x2, 0x10ea, 0x10eb, 
       0x6, 0x106, 0x65, 0x2, 0x10eb, 0x10ec, 0x5, 0x212, 0x10a, 0x2, 0x10ec, 
       0x10ed, 0x7, 0x1fc, 0x2, 0x2, 0x10ed, 0x10ee, 0x5, 0x3cc, 0x1e7, 
       0x2, 0x10ee, 0x110d, 0x3, 0x2, 0x2, 0x2, 0x10ef, 0x10f0, 0x5, 0x212, 
       0x10a, 0x2, 0x10f0, 0x10f1, 0x5, 0x20c, 0x107, 0x2, 0x10f1, 0x10f2, 
       0x7, 0x1fc, 0x2, 0x2, 0x10f2, 0x10f3, 0x5, 0x3cc, 0x1e7, 0x2, 0x10f3, 
       0x110d, 0x3, 0x2, 0x2, 0x2, 0x10f4, 0x10f6, 0x7, 0x1ad, 0x2, 0x2, 
       0x10f5, 0x10f7, 0x7, 0x106, 0x2, 0x2, 0x10f6, 0x10f5, 0x3, 0x2, 0x2, 
       0x2, 0x10f6, 0x10f7, 0x3, 0x2, 0x2, 0x2, 0x10f7, 0x1103, 0x3, 0x2, 
       0x2, 0x2, 0x10f8, 0x10f9, 0x6, 0x106, 0x66, 0x2, 0x10f9, 0x10fb, 
       0x7, 0x244, 0x2, 0x2, 0x10fa, 0x10fc, 0x5, 0x20e, 0x108, 0x2, 0x10fb, 
       0x10fa, 0x3, 0x2, 0x2, 0x2, 0x10fb, 0x10fc, 0x3, 0x2, 0x2, 0x2, 0x10fc, 
       0x10fd, 0x3, 0x2, 0x2, 0x2, 0x10fd, 0x1104, 0x5, 0x216, 0x10c, 0x2, 
       0x10fe, 0x10ff, 0x7, 0x198, 0x2, 0x2, 0x10ff, 0x1100, 0x7, 0x200, 
       0x2, 0x2, 0x1100, 0x1101, 0x7, 0x249, 0x2, 0x2, 0x1101, 0x1102, 0x7, 
       0x1fc, 0x2, 0x2, 0x1102, 0x1104, 0x5, 0x3cc, 0x1e7, 0x2, 0x1103, 
       0x10f8, 0x3, 0x2, 0x2, 0x2, 0x1103, 0x10fe, 0x3, 0x2, 0x2, 0x2, 0x1104, 
       0x110d, 0x3, 0x2, 0x2, 0x2, 0x1105, 0x1106, 0x6, 0x106, 0x67, 0x2, 
       0x1106, 0x1107, 0x7, 0x10b, 0x2, 0x2, 0x1107, 0x1108, 0x7, 0x244, 
       0x2, 0x2, 0x1108, 0x1109, 0x5, 0x3dc, 0x1ef, 0x2, 0x1109, 0x110a, 
       0x7, 0x1fc, 0x2, 0x2, 0x110a, 0x110b, 0x5, 0x3cc, 0x1e7, 0x2, 0x110b, 
       0x110d, 0x3, 0x2, 0x2, 0x2, 0x110c, 0x10ea, 0x3, 0x2, 0x2, 0x2, 0x110c, 
       0x10ef, 0x3, 0x2, 0x2, 0x2, 0x110c, 0x10f4, 0x3, 0x2, 0x2, 0x2, 0x110c, 
       0x1105, 0x3, 0x2, 0x2, 0x2, 0x110d, 0x20b, 0x3, 0x2, 0x2, 0x2, 0x110e, 
       0x110f, 0x6, 0x107, 0x68, 0x2, 0x110f, 0x1111, 0x7, 0x244, 0x2, 0x2, 
       0x1110, 0x1112, 0x5, 0x20e, 0x108, 0x2, 0x1111, 0x1110, 0x3, 0x2, 
       0x2, 0x2, 0x1111, 0x1112, 0x3, 0x2, 0x2, 0x2, 0x1112, 0x1113, 0x3, 
       0x2, 0x2, 0x2, 0x1113, 0x111d, 0x5, 0x216, 0x10c, 0x2, 0x1114, 0x111a, 
       0x6, 0x107, 0x69, 0x2, 0x1115, 0x1117, 0x7, 0x244, 0x2, 0x2, 0x1116, 
       0x1118, 0x5, 0x20e, 0x108, 0x2, 0x1117, 0x1116, 0x3, 0x2, 0x2, 0x2, 
       0x1117, 0x1118, 0x3, 0x2, 0x2, 0x2, 0x1118, 0x1119, 0x3, 0x2, 0x2, 
       0x2, 0x1119, 0x111b, 0x5, 0x216, 0x10c, 0x2, 0x111a, 0x1115, 0x3, 
       0x2, 0x2, 0x2, 0x111a, 0x111b, 0x3, 0x2, 0x2, 0x2, 0x111b, 0x111d, 
       0x3, 0x2, 0x2, 0x2, 0x111c, 0x110e, 0x3, 0x2, 0x2, 0x2, 0x111c, 0x1114, 
       0x3, 0x2, 0x2, 0x2, 0x111d, 0x20d, 0x3, 0x2, 0x2, 0x2, 0x111e, 0x111f, 
       0x9, 0x36, 0x2, 0x2, 0x111f, 0x20f, 0x3, 0x2, 0x2, 0x2, 0x1120, 0x1121, 
       0x7, 0x26c, 0x2, 0x2, 0x1121, 0x1124, 0x7, 0xfd, 0x2, 0x2, 0x1122, 
       0x1123, 0x7, 0x1fb, 0x2, 0x2, 0x1123, 0x1125, 0x5, 0x3dc, 0x1ef, 
       0x2, 0x1124, 0x1122, 0x3, 0x2, 0x2, 0x2, 0x1124, 0x1125, 0x3, 0x2, 
       0x2, 0x2, 0x1125, 0x1126, 0x3, 0x2, 0x2, 0x2, 0x1126, 0x1133, 0x5, 
       0x47a, 0x23e, 0x2, 0x1127, 0x1128, 0x7, 0xfd, 0x2, 0x2, 0x1128, 0x1129, 
       0x7, 0x19b, 0x2, 0x2, 0x1129, 0x112a, 0x5, 0x45e, 0x230, 0x2, 0x112a, 
       0x112b, 0x7, 0x19c, 0x2, 0x2, 0x112b, 0x1134, 0x3, 0x2, 0x2, 0x2, 
       0x112c, 0x112d, 0x6, 0x109, 0x6a, 0x2, 0x112d, 0x112e, 0x7, 0xf5, 
       0x2, 0x2, 0x112e, 0x112f, 0x7, 0x19b, 0x2, 0x2, 0x112f, 0x1130, 0x5, 
       0x45e, 0x230, 0x2, 0x1130, 0x1131, 0x7, 0x19c, 0x2, 0x2, 0x1131, 
       0x1134, 0x3, 0x2, 0x2, 0x2, 0x1132, 0x1134, 0x5, 0x45e, 0x230, 0x2, 
       0x1133, 0x1127, 0x3, 0x2, 0x2, 0x2, 0x1133, 0x112c, 0x3, 0x2, 0x2, 
       0x2, 0x1133, 0x1132, 0x3, 0x2, 0x2, 0x2, 0x1134, 0x1137, 0x3, 0x2, 
       0x2, 0x2, 0x1135, 0x1136, 0x6, 0x109, 0x6b, 0x2, 0x1136, 0x1138, 
       0x5, 0x3da, 0x1ee, 0x2, 0x1137, 0x1135, 0x3, 0x2, 0x2, 0x2, 0x1137, 
       0x1138, 0x3, 0x2, 0x2, 0x2, 0x1138, 0x113b, 0x3, 0x2, 0x2, 0x2, 0x1139, 
       0x113a, 0x6, 0x109, 0x6c, 0x2, 0x113a, 0x113c, 0x5, 0x3d6, 0x1ec, 
       0x2, 0x113b, 0x1139, 0x3, 0x2, 0x2, 0x2, 0x113b, 0x113c, 0x3, 0x2, 
       0x2, 0x2, 0x113c, 0x211, 0x3, 0x2, 0x2, 0x2, 0x113d, 0x1142, 0x5, 
       0x214, 0x10b, 0x2, 0x113e, 0x113f, 0x7, 0x198, 0x2, 0x2, 0x113f, 
       0x1141, 0x5, 0x214, 0x10b, 0x2, 0x1140, 0x113e, 0x3, 0x2, 0x2, 0x2, 
       0x1141, 0x1144, 0x3, 0x2, 0x2, 0x2, 0x1142, 0x1140, 0x3, 0x2, 0x2, 
       0x2, 0x1142, 0x1143, 0x3, 0x2, 0x2, 0x2, 0x1143, 0x213, 0x3, 0x2, 
       0x2, 0x2, 0x1144, 0x1142, 0x3, 0x2, 0x2, 0x2, 0x1145, 0x1150, 0x6, 
       0x10b, 0x6d, 0x2, 0x1146, 0x1148, 0x5, 0x474, 0x23b, 0x2, 0x1147, 
       0x1149, 0x5, 0x3ee, 0x1f8, 0x2, 0x1148, 0x1147, 0x3, 0x2, 0x2, 0x2, 
       0x1148, 0x1149, 0x3, 0x2, 0x2, 0x2, 0x1149, 0x1151, 0x3, 0x2, 0x2, 
       0x2, 0x114a, 0x114e, 0x5, 0x474, 0x23b, 0x2, 0x114b, 0x114f, 0x7, 
       0x1a3, 0x2, 0x2, 0x114c, 0x114d, 0x7, 0x1a2, 0x2, 0x2, 0x114d, 0x114f, 
       0x5, 0x472, 0x23a, 0x2, 0x114e, 0x114b, 0x3, 0x2, 0x2, 0x2, 0x114e, 
       0x114c, 0x3, 0x2, 0x2, 0x2, 0x114f, 0x1151, 0x3, 0x2, 0x2, 0x2, 0x1150, 
       0x1146, 0x3, 0x2, 0x2, 0x2, 0x1150, 0x114a, 0x3, 0x2, 0x2, 0x2, 0x1151, 
       0x116f, 0x3, 0x2, 0x2, 0x2, 0x1152, 0x1154, 0x9, 0x37, 0x2, 0x2, 
       0x1153, 0x1155, 0x5, 0x3ee, 0x1f8, 0x2, 0x1154, 0x1153, 0x3, 0x2, 
       0x2, 0x2, 0x1154, 0x1155, 0x3, 0x2, 0x2, 0x2, 0x1155, 0x116f, 0x3, 
       0x2, 0x2, 0x2, 0x1156, 0x116f, 0x9, 0x38, 0x2, 0x2, 0x1157, 0x1158, 
       0x7, 0x200, 0x2, 0x2, 0x1158, 0x116f, 0x7, 0x249, 0x2, 0x2, 0x1159, 
       0x115a, 0x7, 0x26e, 0x2, 0x2, 0x115a, 0x116f, 0x7, 0x1d6, 0x2, 0x2, 
       0x115b, 0x115f, 0x7, 0x1cd, 0x2, 0x2, 0x115c, 0x115d, 0x7, 0x159, 
       0x2, 0x2, 0x115d, 0x1160, 0x7, 0x156, 0x2, 0x2, 0x115e, 0x1160, 0x9, 
       0x39, 0x2, 0x2, 0x115f, 0x115c, 0x3, 0x2, 0x2, 0x2, 0x115f, 0x115e, 
       0x3, 0x2, 0x2, 0x2, 0x115f, 0x1160, 0x3, 0x2, 0x2, 0x2, 0x1160, 0x116f, 
       0x3, 0x2, 0x2, 0x2, 0x1161, 0x1162, 0x7, 0x225, 0x2, 0x2, 0x1162, 
       0x116f, 0x7, 0x156, 0x2, 0x2, 0x1163, 0x1164, 0x7, 0x11d, 0x2, 0x2, 
       0x1164, 0x116f, 0x9, 0x3a, 0x2, 0x2, 0x1165, 0x1166, 0x7, 0x26e, 
       0x2, 0x2, 0x1166, 0x116f, 0x7, 0x171, 0x2, 0x2, 0x1167, 0x1169, 0x7, 
       0x1ae, 0x2, 0x2, 0x1168, 0x116a, 0x7, 0x12b, 0x2, 0x2, 0x1169, 0x1168, 
       0x3, 0x2, 0x2, 0x2, 0x1169, 0x116a, 0x3, 0x2, 0x2, 0x2, 0x116a, 0x116f, 
       0x3, 0x2, 0x2, 0x2, 0x116b, 0x116c, 0x6, 0x10b, 0x6e, 0x2, 0x116c, 
       0x116d, 0x9, 0x3b, 0x2, 0x2, 0x116d, 0x116f, 0x7, 0x2b4, 0x2, 0x2, 
       0x116e, 0x1145, 0x3, 0x2, 0x2, 0x2, 0x116e, 0x1152, 0x3, 0x2, 0x2, 
       0x2, 0x116e, 0x1156, 0x3, 0x2, 0x2, 0x2, 0x116e, 0x1157, 0x3, 0x2, 
       0x2, 0x2, 0x116e, 0x1159, 0x3, 0x2, 0x2, 0x2, 0x116e, 0x115b, 0x3, 
       0x2, 0x2, 0x2, 0x116e, 0x1161, 0x3, 0x2, 0x2, 0x2, 0x116e, 0x1163, 
       0x3, 0x2, 0x2, 0x2, 0x116e, 0x1165, 0x3, 0x2, 0x2, 0x2, 0x116e, 0x1167, 
       0x3, 0x2, 0x2, 0x2, 0x116e, 0x116b, 0x3, 0x2, 0x2, 0x2, 0x116f, 0x215, 
       0x3, 0x2, 0x2, 0x2, 0x1170, 0x1173, 0x7, 0x18b, 0x2, 0x2, 0x1171, 
       0x1172, 0x7, 0x197, 0x2, 0x2, 0x1172, 0x1174, 0x7, 0x18b, 0x2, 0x2, 
       0x1173, 0x1171, 0x3, 0x2, 0x2, 0x2, 0x1173, 0x1174, 0x3, 0x2, 0x2, 
       0x2, 0x1174, 0x117c, 0x3, 0x2, 0x2, 0x2, 0x1175, 0x1178, 0x5, 0x442, 
       0x222, 0x2, 0x1176, 0x1177, 0x7, 0x197, 0x2, 0x2, 0x1177, 0x1179, 
       0x7, 0x18b, 0x2, 0x2, 0x1178, 0x1176, 0x3, 0x2, 0x2, 0x2, 0x1178, 
       0x1179, 0x3, 0x2, 0x2, 0x2, 0x1179, 0x117c, 0x3, 0x2, 0x2, 0x2, 0x117a, 
       0x117c, 0x5, 0x428, 0x215, 0x2, 0x117b, 0x1170, 0x3, 0x2, 0x2, 0x2, 
       0x117b, 0x1175, 0x3, 0x2, 0x2, 0x2, 0x117b, 0x117a, 0x3, 0x2, 0x2, 
       0x2, 0x117c, 0x217, 0x3, 0x2, 0x2, 0x2, 0x117d, 0x1184, 0x5, 0x21a, 
       0x10e, 0x2, 0x117e, 0x1180, 0x7, 0x1b0, 0x2, 0x2, 0x117f, 0x117e, 
       0x3, 0x2, 0x2, 0x2, 0x117f, 0x1180, 0x3, 0x2, 0x2, 0x2, 0x1180, 0x1181, 
       0x3, 0x2, 0x2, 0x2, 0x1181, 0x1183, 0x5, 0x21a, 0x10e, 0x2, 0x1182, 
       0x117f, 0x3, 0x2, 0x2, 0x2, 0x1183, 0x1186, 0x3, 0x2, 0x2, 0x2, 0x1184, 
       0x1182, 0x3, 0x2, 0x2, 0x2, 0x1184, 0x1185, 0x3, 0x2, 0x2, 0x2, 0x1185, 
       0x219, 0x3, 0x2, 0x2, 0x2, 0x1186, 0x1184, 0x3, 0x2, 0x2, 0x2, 0x1187, 
       0x1188, 0x7, 0x54, 0x2, 0x2, 0x1188, 0x118e, 0x5, 0x45e, 0x230, 0x2, 
       0x1189, 0x118a, 0x7, 0xac, 0x2, 0x2, 0x118a, 0x118e, 0x5, 0x45e, 
       0x230, 0x2, 0x118b, 0x118c, 0x7, 0x14e, 0x2, 0x2, 0x118c, 0x118e, 
       0x5, 0x45e, 0x230, 0x2, 0x118d, 0x1187, 0x3, 0x2, 0x2, 0x2, 0x118d, 
       0x1189, 0x3, 0x2, 0x2, 0x2, 0x118d, 0x118b, 0x3, 0x2, 0x2, 0x2, 0x118e, 
       0x21b, 0x3, 0x2, 0x2, 0x2, 0x118f, 0x1190, 0x7, 0x200, 0x2, 0x2, 
       0x1190, 0x119a, 0x7, 0x249, 0x2, 0x2, 0x1191, 0x1192, 0x7, 0xd2, 
       0x2, 0x2, 0x1192, 0x119a, 0x5, 0x44e, 0x228, 0x2, 0x1193, 0x1194, 
       0x7, 0xd5, 0x2, 0x2, 0x1194, 0x119a, 0x5, 0x44e, 0x228, 0x2, 0x1195, 
       0x1196, 0x7, 0xd1, 0x2, 0x2, 0x1196, 0x119a, 0x5, 0x44e, 0x228, 0x2, 
       0x1197, 0x1198, 0x7, 0xd6, 0x2, 0x2, 0x1198, 0x119a, 0x5, 0x44e, 
       0x228, 0x2, 0x1199, 0x118f, 0x3, 0x2, 0x2, 0x2, 0x1199, 0x1191, 0x3, 
       0x2, 0x2, 0x2, 0x1199, 0x1193, 0x3, 0x2, 0x2, 0x2, 0x1199, 0x1195, 
       0x3, 0x2, 0x2, 0x2, 0x1199, 0x1197, 0x3, 0x2, 0x2, 0x2, 0x119a, 0x21d, 
       0x3, 0x2, 0x2, 0x2, 0x119b, 0x119c, 0x7, 0x26c, 0x2, 0x2, 0x119c, 
       0x119d, 0x7, 0x2b4, 0x2, 0x2, 0x119d, 0x11b3, 0x5, 0x220, 0x111, 
       0x2, 0x119e, 0x119f, 0x7, 0x26c, 0x2, 0x2, 0x119f, 0x11a0, 0x7, 0x2b4, 
       0x2, 0x2, 0x11a0, 0x11b3, 0x9, 0x3c, 0x2, 0x2, 0x11a1, 0x11a2, 0x7, 
       0x26c, 0x2, 0x2, 0x11a2, 0x11a3, 0x7, 0x1e0, 0x2, 0x2, 0x11a3, 0x11a7, 
       0x7, 0x2b4, 0x2, 0x2, 0x11a4, 0x11a8, 0x5, 0x220, 0x111, 0x2, 0x11a5, 
       0x11a8, 0x7, 0xf1, 0x2, 0x2, 0x11a6, 0x11a8, 0x7, 0x1ad, 0x2, 0x2, 
       0x11a7, 0x11a4, 0x3, 0x2, 0x2, 0x2, 0x11a7, 0x11a5, 0x3, 0x2, 0x2, 
       0x2, 0x11a7, 0x11a6, 0x3, 0x2, 0x2, 0x2, 0x11a8, 0x11a9, 0x3, 0x2, 
       0x2, 0x2, 0x11a9, 0x11aa, 0x7, 0x28e, 0x2, 0x2, 0x11aa, 0x11b3, 0x5, 
       0x220, 0x111, 0x2, 0x11ab, 0x11ac, 0x7, 0x26c, 0x2, 0x2, 0x11ac, 
       0x11ad, 0x7, 0x2b4, 0x2, 0x2, 0x11ad, 0x11b0, 0x7, 0x1ad, 0x2, 0x2, 
       0x11ae, 0x11af, 0x7, 0x2b8, 0x2, 0x2, 0x11af, 0x11b1, 0x5, 0x220, 
       0x111, 0x2, 0x11b0, 0x11ae, 0x3, 0x2, 0x2, 0x2, 0x11b0, 0x11b1, 0x3, 
       0x2, 0x2, 0x2, 0x11b1, 0x11b3, 0x3, 0x2, 0x2, 0x2, 0x11b2, 0x119b, 
       0x3, 0x2, 0x2, 0x2, 0x11b2, 0x119e, 0x3, 0x2, 0x2, 0x2, 0x11b2, 0x11a1, 
       0x3, 0x2, 0x2, 0x2, 0x11b2, 0x11ab, 0x3, 0x2, 0x2, 0x2, 0x11b3, 0x21f, 
       0x3, 0x2, 0x2, 0x2, 0x11b4, 0x11b9, 0x5, 0x222, 0x112, 0x2, 0x11b5, 
       0x11b6, 0x7, 0x198, 0x2, 0x2, 0x11b6, 0x11b8, 0x5, 0x222, 0x112, 
       0x2, 0x11b7, 0x11b5, 0x3, 0x2, 0x2, 0x2, 0x11b8, 0x11bb, 0x3, 0x2, 
       0x2, 0x2, 0x11b9, 0x11b7, 0x3, 0x2, 0x2, 0x2, 0x11b9, 0x11ba, 0x3, 
       0x2, 0x2, 0x2, 0x11ba, 0x221, 0x3, 0x2, 0x2, 0x2, 0x11bb, 0x11b9, 
       0x3, 0x2, 0x2, 0x2, 0x11bc, 0x11bf, 0x5, 0x474, 0x23b, 0x2, 0x11bd, 
       0x11be, 0x7, 0x1a2, 0x2, 0x2, 0x11be, 0x11c0, 0x5, 0x472, 0x23a, 
       0x2, 0x11bf, 0x11bd, 0x3, 0x2, 0x2, 0x2, 0x11bf, 0x11c0, 0x3, 0x2, 
       0x2, 0x2, 0x11c0, 0x223, 0x3, 0x2, 0x2, 0x2, 0x11c1, 0x11c3, 0x7, 
       0x41, 0x2, 0x2, 0x11c2, 0x11c4, 0x5, 0x3e4, 0x1f3, 0x2, 0x11c3, 0x11c2, 
       0x3, 0x2, 0x2, 0x2, 0x11c3, 0x11c4, 0x3, 0x2, 0x2, 0x2, 0x11c4, 0x11c5, 
       0x3, 0x2, 0x2, 0x2, 0x11c5, 0x11c6, 0x7, 0x288, 0x2, 0x2, 0x11c6, 
       0x11ed, 0x5, 0x42a, 0x216, 0x2, 0x11c7, 0x11c8, 0x7, 0x1c5, 0x2, 
       0x2, 0x11c8, 0x11c9, 0x7, 0x288, 0x2, 0x2, 0x11c9, 0x11cd, 0x5, 0x42a, 
       0x216, 0x2, 0x11ca, 0x11cc, 0x5, 0x228, 0x115, 0x2, 0x11cb, 0x11ca, 
       0x3, 0x2, 0x2, 0x2, 0x11cc, 0x11cf, 0x3, 0x2, 0x2, 0x2, 0x11cd, 0x11cb, 
       0x3, 0x2, 0x2, 0x2, 0x11cd, 0x11ce, 0x3, 0x2, 0x2, 0x2, 0x11ce, 0x11ed, 
       0x3, 0x2, 0x2, 0x2, 0x11cf, 0x11cd, 0x3, 0x2, 0x2, 0x2, 0x11d0, 0x11d1, 
       0x7, 0xb, 0x2, 0x2, 0x11d1, 0x11d2, 0x7, 0x288, 0x2, 0x2, 0x11d2, 
       0x11d4, 0x5, 0x42a, 0x216, 0x2, 0x11d3, 0x11d5, 0x9, 0x3d, 0x2, 0x2, 
       0x11d4, 0x11d3, 0x3, 0x2, 0x2, 0x2, 0x11d4, 0x11d5, 0x3, 0x2, 0x2, 
       0x2, 0x11d5, 0x11ed, 0x3, 0x2, 0x2, 0x2, 0x11d6, 0x11d8, 0x7, 0x247, 
       0x2, 0x2, 0x11d7, 0x11d9, 0x5, 0x3e4, 0x1f3, 0x2, 0x11d8, 0x11d7, 
       0x3, 0x2, 0x2, 0x2, 0x11d8, 0x11d9, 0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11da, 
       0x3, 0x2, 0x2, 0x2, 0x11da, 0x11db, 0x7, 0x288, 0x2, 0x2, 0x11db, 
       0x11de, 0x5, 0x42a, 0x216, 0x2, 0x11dc, 0x11dd, 0x6, 0x113, 0x6f, 
       0x2, 0x11dd, 0x11df, 0x5, 0x226, 0x114, 0x2, 0x11de, 0x11dc, 0x3, 
       0x2, 0x2, 0x2, 0x11de, 0x11df, 0x3, 0x2, 0x2, 0x2, 0x11df, 0x11ed, 
       0x3, 0x2, 0x2, 0x2, 0x11e0, 0x11e2, 0x7, 0x27, 0x2, 0x2, 0x11e1, 
       0x11e3, 0x5, 0x3e4, 0x1f3, 0x2, 0x11e2, 0x11e1, 0x3, 0x2, 0x2, 0x2, 
       0x11e2, 0x11e3, 0x3, 0x2, 0x2, 0x2, 0x11e3, 0x11e4, 0x3, 0x2, 0x2, 
       0x2, 0x11e4, 0x11e5, 0x7, 0x288, 0x2, 0x2, 0x11e5, 0x11e9, 0x5, 0x42a, 
       0x216, 0x2, 0x11e6, 0x11e8, 0x5, 0x22a, 0x116, 0x2, 0x11e7, 0x11e6, 
       0x3, 0x2, 0x2, 0x2, 0x11e8, 0x11eb, 0x3, 0x2, 0x2, 0x2, 0x11e9, 0x11e7, 
       0x3, 0x2, 0x2, 0x2, 0x11e9, 0x11ea, 0x3, 0x2, 0x2, 0x2, 0x11ea, 0x11ed, 
       0x3, 0x2, 0x2, 0x2, 0x11eb, 0x11e9, 0x3, 0x2, 0x2, 0x2, 0x11ec, 0x11c1, 
       0x3, 0x2, 0x2, 0x2, 0x11ec, 0x11c7, 0x3, 0x2, 0x2, 0x2, 0x11ec, 0x11d0, 
       0x3, 0x2, 0x2, 0x2, 0x11ec, 0x11d6, 0x3, 0x2, 0x2, 0x2, 0x11ec, 0x11e0, 
       0x3, 0x2, 0x2, 0x2, 0x11ed, 0x225, 0x3, 0x2, 0x2, 0x2, 0x11ee, 0x11ef, 
       0x7, 0x298, 0x2, 0x2, 0x11ef, 0x11f0, 0x7, 0x2c3, 0x2, 0x2, 0x11f0, 
       0x11f1, 0x7, 0x244, 0x2, 0x2, 0x11f1, 0x11f5, 0x5, 0x444, 0x223, 
       0x2, 0x11f2, 0x11f3, 0x7, 0x2ab, 0x2, 0x2, 0x11f3, 0x11f4, 0x7, 0x17e, 
       0x2, 0x2, 0x11f4, 0x11f6, 0x7, 0x2c4, 0x2, 0x2, 0x11f5, 0x11f2, 0x3, 
       0x2, 0x2, 0x2, 0x11f5, 0x11f6, 0x3, 0x2, 0x2, 0x2, 0x11f6, 0x11fc, 
       0x3, 0x2, 0x2, 0x2, 0x11f7, 0x11f8, 0x7, 0x1e9, 0x2, 0x2, 0x11f8, 
       0x11f9, 0x7, 0x2c3, 0x2, 0x2, 0x11f9, 0x11fa, 0x7, 0x244, 0x2, 0x2, 
       0x11fa, 0x11fc, 0x5, 0x444, 0x223, 0x2, 0x11fb, 0x11ee, 0x3, 0x2, 
       0x2, 0x2, 0x11fb, 0x11f7, 0x3, 0x2, 0x2, 0x2, 0x11fc, 0x227, 0x3, 
       0x2, 0x2, 0x2, 0x11fd, 0x11fe, 0x7, 0x1fb, 0x2, 0x2, 0x11fe, 0x1201, 
       0x7, 0x37, 0x2, 0x2, 0x11ff, 0x1201, 0x9, 0x3e, 0x2, 0x2, 0x1200, 
       0x11fd, 0x3, 0x2, 0x2, 0x2, 0x1200, 0x11ff, 0x3, 0x2, 0x2, 0x2, 0x1201, 
       0x229, 0x3, 0x2, 0x2, 0x2, 0x1202, 0x1203, 0x9, 0x3f, 0x2, 0x2, 0x1203, 
       0x22b, 0x3, 0x2, 0x2, 0x2, 0x1204, 0x1205, 0x7, 0x1b, 0x2, 0x2, 0x1205, 
       0x1206, 0x7, 0x100, 0x2, 0x2, 0x1206, 0x1207, 0x5, 0x442, 0x222, 
       0x2, 0x1207, 0x1208, 0x7, 0x31, 0x2, 0x2, 0x1208, 0x1209, 0x5, 0x45c, 
       0x22f, 0x2, 0x1209, 0x121b, 0x3, 0x2, 0x2, 0x2, 0x120a, 0x120b, 0x7, 
       0x1b, 0x2, 0x2, 0x120b, 0x120c, 0x7, 0x2b9, 0x2, 0x2, 0x120c, 0x121b, 
       0x5, 0x464, 0x233, 0x2, 0x120d, 0x120e, 0x7, 0x36, 0x2, 0x2, 0x120e, 
       0x120f, 0x7, 0x100, 0x2, 0x2, 0x120f, 0x121b, 0x5, 0x438, 0x21d, 
       0x2, 0x1210, 0x1211, 0x7, 0x36, 0x2, 0x2, 0x1211, 0x1212, 0x7, 0x2b9, 
       0x2, 0x2, 0x1212, 0x1217, 0x5, 0x43a, 0x21e, 0x2, 0x1213, 0x1214, 
       0x7, 0x198, 0x2, 0x2, 0x1214, 0x1216, 0x5, 0x43a, 0x21e, 0x2, 0x1215, 
       0x1213, 0x3, 0x2, 0x2, 0x2, 0x1216, 0x1219, 0x3, 0x2, 0x2, 0x2, 0x1217, 
       0x1215, 0x3, 0x2, 0x2, 0x2, 0x1217, 0x1218, 0x3, 0x2, 0x2, 0x2, 0x1218, 
       0x121b, 0x3, 0x2, 0x2, 0x2, 0x1219, 0x1217, 0x3, 0x2, 0x2, 0x2, 0x121a, 
       0x1204, 0x3, 0x2, 0x2, 0x2, 0x121a, 0x120a, 0x3, 0x2, 0x2, 0x2, 0x121a, 
       0x120d, 0x3, 0x2, 0x2, 0x2, 0x121a, 0x1210, 0x3, 0x2, 0x2, 0x2, 0x121b, 
       0x22d, 0x3, 0x2, 0x2, 0x2, 0x121c, 0x1231, 0x7, 0x26c, 0x2, 0x2, 
       0x121d, 0x121f, 0x5, 0x47c, 0x23f, 0x2, 0x121e, 0x121d, 0x3, 0x2, 
       0x2, 0x2, 0x121e, 0x121f, 0x3, 0x2, 0x2, 0x2, 0x121f, 0x1227, 0x3, 
       0x2, 0x2, 0x2, 0x1220, 0x1221, 0x7, 0x15d, 0x2, 0x2, 0x1221, 0x1228, 
       0x5, 0x1a2, 0xd2, 0x2, 0x1222, 0x1225, 0x5, 0x234, 0x11b, 0x2, 0x1223, 
       0x1224, 0x7, 0x198, 0x2, 0x2, 0x1224, 0x1226, 0x5, 0x238, 0x11d, 
       0x2, 0x1225, 0x1223, 0x3, 0x2, 0x2, 0x2, 0x1225, 0x1226, 0x3, 0x2, 
       0x2, 0x2, 0x1226, 0x1228, 0x3, 0x2, 0x2, 0x2, 0x1227, 0x1220, 0x3, 
       0x2, 0x2, 0x2, 0x1227, 0x1222, 0x3, 0x2, 0x2, 0x2, 0x1228, 0x1232, 
       0x3, 0x2, 0x2, 0x2, 0x1229, 0x122b, 0x7, 0xf6, 0x2, 0x2, 0x122a, 
       0x1229, 0x3, 0x2, 0x2, 0x2, 0x122a, 0x122b, 0x3, 0x2, 0x2, 0x2, 0x122b, 
       0x122c, 0x3, 0x2, 0x2, 0x2, 0x122c, 0x122f, 0x5, 0x230, 0x119, 0x2, 
       0x122d, 0x122e, 0x7, 0x198, 0x2, 0x2, 0x122e, 0x1230, 0x5, 0x238, 
       0x11d, 0x2, 0x122f, 0x122d, 0x3, 0x2, 0x2, 0x2, 0x122f, 0x1230, 0x3, 
       0x2, 0x2, 0x2, 0x1230, 0x1232, 0x3, 0x2, 0x2, 0x2, 0x1231, 0x121e, 
       0x3, 0x2, 0x2, 0x2, 0x1231, 0x122a, 0x3, 0x2, 0x2, 0x2, 0x1232, 0x22f, 
       0x3, 0x2, 0x2, 0x2, 0x1233, 0x1234, 0x5, 0x2ce, 0x168, 0x2, 0x1234, 
       0x1235, 0x5, 0x47a, 0x23e, 0x2, 0x1235, 0x1236, 0x5, 0x236, 0x11c, 
       0x2, 0x1236, 0x124d, 0x3, 0x2, 0x2, 0x2, 0x1237, 0x124d, 0x5, 0x3c2, 
       0x1e2, 0x2, 0x1238, 0x1239, 0x5, 0x2ca, 0x166, 0x2, 0x1239, 0x123a, 
       0x5, 0x47a, 0x23e, 0x2, 0x123a, 0x123b, 0x5, 0x28a, 0x146, 0x2, 0x123b, 
       0x124d, 0x3, 0x2, 0x2, 0x2, 0x123c, 0x123d, 0x5, 0x232, 0x11a, 0x2, 
       0x123d, 0x123e, 0x5, 0x47a, 0x23e, 0x2, 0x123e, 0x123f, 0x5, 0x236, 
       0x11c, 0x2, 0x123f, 0x124d, 0x3, 0x2, 0x2, 0x2, 0x1240, 0x124a, 0x7, 
       0xe8, 0x2, 0x2, 0x1241, 0x1242, 0x5, 0x47a, 0x23e, 0x2, 0x1242, 0x1243, 
       0x5, 0x28a, 0x146, 0x2, 0x1243, 0x124b, 0x3, 0x2, 0x2, 0x2, 0x1244, 
       0x1246, 0x5, 0x384, 0x1c3, 0x2, 0x1245, 0x1247, 0x5, 0x3b6, 0x1dc, 
       0x2, 0x1246, 0x1245, 0x3, 0x2, 0x2, 0x2, 0x1246, 0x1247, 0x3, 0x2, 
       0x2, 0x2, 0x1247, 0x124b, 0x3, 0x2, 0x2, 0x2, 0x1248, 0x1249, 0x6, 
       0x119, 0x70, 0x2, 0x1249, 0x124b, 0x7, 0x1e0, 0x2, 0x2, 0x124a, 0x1241, 
       0x3, 0x2, 0x2, 0x2, 0x124a, 0x1244, 0x3, 0x2, 0x2, 0x2, 0x124a, 0x1248, 
       0x3, 0x2, 0x2, 0x2, 0x124b, 0x124d, 0x3, 0x2, 0x2, 0x2, 0x124c, 0x1233, 
       0x3, 0x2, 0x2, 0x2, 0x124c, 0x1237, 0x3, 0x2, 0x2, 0x2, 0x124c, 0x1238, 
       0x3, 0x2, 0x2, 0x2, 0x124c, 0x123c, 0x3, 0x2, 0x2, 0x2, 0x124c, 0x1240, 
       0x3, 0x2, 0x2, 0x2, 0x124d, 0x231, 0x3, 0x2, 0x2, 0x2, 0x124e, 0x1250, 
       0x7, 0x1a4, 0x2, 0x2, 0x124f, 0x1251, 0x5, 0x480, 0x241, 0x2, 0x1250, 
       0x124f, 0x3, 0x2, 0x2, 0x2, 0x1250, 0x1251, 0x3, 0x2, 0x2, 0x2, 0x1251, 
       0x1252, 0x3, 0x2, 0x2, 0x2, 0x1252, 0x1253, 0x5, 0x2ce, 0x168, 0x2, 
       0x1253, 0x233, 0x3, 0x2, 0x2, 0x2, 0x1254, 0x1255, 0x5, 0x2ce, 0x168, 
       0x2, 0x1255, 0x1256, 0x5, 0x47a, 0x23e, 0x2, 0x1256, 0x1257, 0x5, 
       0x236, 0x11c, 0x2, 0x1257, 0x235, 0x3, 0x2, 0x2, 0x2, 0x1258, 0x125d, 
       0x5, 0x28a, 0x146, 0x2, 0x1259, 0x125d, 0x9, 0x40, 0x2, 0x2, 0x125a, 
       0x125b, 0x6, 0x11c, 0x71, 0x2, 0x125b, 0x125d, 0x9, 0x41, 0x2, 0x2, 
       0x125c, 0x1258, 0x3, 0x2, 0x2, 0x2, 0x125c, 0x1259, 0x3, 0x2, 0x2, 
       0x2, 0x125c, 0x125a, 0x3, 0x2, 0x2, 0x2, 0x125d, 0x237, 0x3, 0x2, 
       0x2, 0x2, 0x125e, 0x1263, 0x5, 0x23a, 0x11e, 0x2, 0x125f, 0x1260, 
       0x7, 0x198, 0x2, 0x2, 0x1260, 0x1262, 0x5, 0x23a, 0x11e, 0x2, 0x1261, 
       0x125f, 0x3, 0x2, 0x2, 0x2, 0x1262, 0x1265, 0x3, 0x2, 0x2, 0x2, 0x1263, 
       0x1261, 0x3, 0x2, 0x2, 0x2, 0x1263, 0x1264, 0x3, 0x2, 0x2, 0x2, 0x1264, 
       0x239, 0x3, 0x2, 0x2, 0x2, 0x1265, 0x1263, 0x3, 0x2, 0x2, 0x2, 0x1266, 
       0x1267, 0x5, 0x47c, 0x23f, 0x2, 0x1267, 0x1268, 0x5, 0x2ce, 0x168, 
       0x2, 0x1268, 0x1269, 0x5, 0x47a, 0x23e, 0x2, 0x1269, 0x126a, 0x5, 
       0x236, 0x11c, 0x2, 0x126a, 0x126d, 0x3, 0x2, 0x2, 0x2, 0x126b, 0x126d, 
       0x5, 0x230, 0x119, 0x2, 0x126c, 0x1266, 0x3, 0x2, 0x2, 0x2, 0x126c, 
       0x126b, 0x3, 0x2, 0x2, 0x2, 0x126d, 0x23b, 0x3, 0x2, 0x2, 0x2, 0x126e, 
       0x134c, 0x7, 0x26e, 0x2, 0x2, 0x126f, 0x1270, 0x6, 0x11f, 0x72, 0x2, 
       0x1270, 0x134d, 0x7, 0x44, 0x2, 0x2, 0x1271, 0x1273, 0x7, 0x1d6, 
       0x2, 0x2, 0x1272, 0x1274, 0x5, 0x3e0, 0x1f1, 0x2, 0x1273, 0x1272, 
       0x3, 0x2, 0x2, 0x2, 0x1273, 0x1274, 0x3, 0x2, 0x2, 0x2, 0x1274, 0x134d, 
       0x3, 0x2, 0x2, 0x2, 0x1275, 0x1277, 0x5, 0x23e, 0x120, 0x2, 0x1276, 
       0x1275, 0x3, 0x2, 0x2, 0x2, 0x1276, 0x1277, 0x3, 0x2, 0x2, 0x2, 0x1277, 
       0x1278, 0x3, 0x2, 0x2, 0x2, 0x1278, 0x127a, 0x7, 0x156, 0x2, 0x2, 
       0x1279, 0x127b, 0x5, 0x244, 0x123, 0x2, 0x127a, 0x1279, 0x3, 0x2, 
       0x2, 0x2, 0x127a, 0x127b, 0x3, 0x2, 0x2, 0x2, 0x127b, 0x127d, 0x3, 
       0x2, 0x2, 0x2, 0x127c, 0x127e, 0x5, 0x3e0, 0x1f1, 0x2, 0x127d, 0x127c, 
       0x3, 0x2, 0x2, 0x2, 0x127d, 0x127e, 0x3, 0x2, 0x2, 0x2, 0x127e, 0x134d, 
       0x3, 0x2, 0x2, 0x2, 0x127f, 0x1281, 0x7, 0x92, 0x2, 0x2, 0x1280, 
       0x127f, 0x3, 0x2, 0x2, 0x2, 0x1280, 0x1281, 0x3, 0x2, 0x2, 0x2, 0x1281, 
       0x1282, 0x3, 0x2, 0x2, 0x2, 0x1282, 0x1284, 0x7, 0x15e, 0x2, 0x2, 
       0x1283, 0x1285, 0x5, 0x244, 0x123, 0x2, 0x1284, 0x1283, 0x3, 0x2, 
       0x2, 0x2, 0x1284, 0x1285, 0x3, 0x2, 0x2, 0x2, 0x1285, 0x1287, 0x3, 
       0x2, 0x2, 0x2, 0x1286, 0x1288, 0x5, 0x3e0, 0x1f1, 0x2, 0x1287, 0x1286, 
       0x3, 0x2, 0x2, 0x2, 0x1287, 0x1288, 0x3, 0x2, 0x2, 0x2, 0x1288, 0x134d, 
       0x3, 0x2, 0x2, 0x2, 0x1289, 0x128b, 0x7, 0x88, 0x2, 0x2, 0x128a, 
       0x128c, 0x5, 0x244, 0x123, 0x2, 0x128b, 0x128a, 0x3, 0x2, 0x2, 0x2, 
       0x128b, 0x128c, 0x3, 0x2, 0x2, 0x2, 0x128c, 0x128e, 0x3, 0x2, 0x2, 
       0x2, 0x128d, 0x128f, 0x5, 0x3e0, 0x1f1, 0x2, 0x128e, 0x128d, 0x3, 
       0x2, 0x2, 0x2, 0x128e, 0x128f, 0x3, 0x2, 0x2, 0x2, 0x128f, 0x134d, 
       0x3, 0x2, 0x2, 0x2, 0x1290, 0x1291, 0x7, 0x288, 0x2, 0x2, 0x1291, 
       0x1293, 0x7, 0x149, 0x2, 0x2, 0x1292, 0x1294, 0x5, 0x244, 0x123, 
       0x2, 0x1293, 0x1292, 0x3, 0x2, 0x2, 0x2, 0x1293, 0x1294, 0x3, 0x2, 
       0x2, 0x2, 0x1294, 0x1296, 0x3, 0x2, 0x2, 0x2, 0x1295, 0x1297, 0x5, 
       0x3e0, 0x1f1, 0x2, 0x1296, 0x1295, 0x3, 0x2, 0x2, 0x2, 0x1296, 0x1297, 
       0x3, 0x2, 0x2, 0x2, 0x1297, 0x134d, 0x3, 0x2, 0x2, 0x2, 0x1298, 0x1299, 
       0x7, 0x1e, 0x2, 0x2, 0x1299, 0x129b, 0x7, 0x156, 0x2, 0x2, 0x129a, 
       0x129c, 0x5, 0x244, 0x123, 0x2, 0x129b, 0x129a, 0x3, 0x2, 0x2, 0x2, 
       0x129b, 0x129c, 0x3, 0x2, 0x2, 0x2, 0x129c, 0x129e, 0x3, 0x2, 0x2, 
       0x2, 0x129d, 0x129f, 0x5, 0x3e0, 0x1f1, 0x2, 0x129e, 0x129d, 0x3, 
       0x2, 0x2, 0x2, 0x129e, 0x129f, 0x3, 0x2, 0x2, 0x2, 0x129f, 0x134d, 
       0x3, 0x2, 0x2, 0x2, 0x12a0, 0x12a1, 0x6, 0x11f, 0x73, 0x2, 0x12a1, 
       0x134d, 0x7, 0x101, 0x2, 0x2, 0x12a2, 0x12a5, 0x7, 0x82, 0x2, 0x2, 
       0x12a3, 0x12a6, 0x5, 0x420, 0x211, 0x2, 0x12a4, 0x12a6, 0x7, 0x1ad, 
       0x2, 0x2, 0x12a5, 0x12a3, 0x3, 0x2, 0x2, 0x2, 0x12a5, 0x12a4, 0x3, 
       0x2, 0x2, 0x2, 0x12a6, 0x12a7, 0x3, 0x2, 0x2, 0x2, 0x12a7, 0x134d, 
       0x9, 0x42, 0x2, 0x2, 0x12a8, 0x12aa, 0x5, 0x23e, 0x120, 0x2, 0x12a9, 
       0x12a8, 0x3, 0x2, 0x2, 0x2, 0x12a9, 0x12aa, 0x3, 0x2, 0x2, 0x2, 0x12aa, 
       0x12ab, 0x3, 0x2, 0x2, 0x2, 0x12ab, 0x12ac, 0x7, 0x5c, 0x2, 0x2, 
       0x12ac, 0x12ad, 0x9, 0x43, 0x2, 0x2, 0x12ad, 0x12af, 0x5, 0x428, 
       0x215, 0x2, 0x12ae, 0x12b0, 0x5, 0x244, 0x123, 0x2, 0x12af, 0x12ae, 
       0x3, 0x2, 0x2, 0x2, 0x12af, 0x12b0, 0x3, 0x2, 0x2, 0x2, 0x12b0, 0x12b2, 
       0x3, 0x2, 0x2, 0x2, 0x12b1, 0x12b3, 0x5, 0x3e0, 0x1f1, 0x2, 0x12b2, 
       0x12b1, 0x3, 0x2, 0x2, 0x2, 0x12b2, 0x12b3, 0x3, 0x2, 0x2, 0x2, 0x12b3, 
       0x134d, 0x3, 0x2, 0x2, 0x2, 0x12b4, 0x12b5, 0x9, 0x2d, 0x2, 0x2, 
       0x12b5, 0x134d, 0x7, 0xb9, 0x2, 0x2, 0x12b6, 0x12bd, 0x7, 0x2f, 0x2, 
       0x2, 0x12b7, 0x12be, 0x7, 0x9f, 0x2, 0x2, 0x12b8, 0x12b9, 0x7, 0x149, 
       0x2, 0x2, 0x12b9, 0x12bb, 0x5, 0x240, 0x121, 0x2, 0x12ba, 0x12bc, 
       0x5, 0x2f0, 0x179, 0x2, 0x12bb, 0x12ba, 0x3, 0x2, 0x2, 0x2, 0x12bb, 
       0x12bc, 0x3, 0x2, 0x2, 0x2, 0x12bc, 0x12be, 0x3, 0x2, 0x2, 0x2, 0x12bd, 
       0x12b7, 0x3, 0x2, 0x2, 0x2, 0x12bd, 0x12b8, 0x3, 0x2, 0x2, 0x2, 0x12be, 
       0x134d, 0x3, 0x2, 0x2, 0x2, 0x12bf, 0x12c0, 0x9, 0x44, 0x2, 0x2, 
       0x12c0, 0x12c3, 0x7, 0x88, 0x2, 0x2, 0x12c1, 0x12c2, 0x7, 0x213, 
       0x2, 0x2, 0x12c2, 0x12c4, 0x5, 0x45e, 0x230, 0x2, 0x12c3, 0x12c1, 
       0x3, 0x2, 0x2, 0x2, 0x12c3, 0x12c4, 0x3, 0x2, 0x2, 0x2, 0x12c4, 0x12c7, 
       0x3, 0x2, 0x2, 0x2, 0x12c5, 0x12c6, 0x7, 0x1fc, 0x2, 0x2, 0x12c6, 
       0x12c8, 0x5, 0x452, 0x22a, 0x2, 0x12c7, 0x12c5, 0x3, 0x2, 0x2, 0x2, 
       0x12c7, 0x12c8, 0x3, 0x2, 0x2, 0x2, 0x12c8, 0x12ca, 0x3, 0x2, 0x2, 
       0x2, 0x12c9, 0x12cb, 0x5, 0x11c, 0x8f, 0x2, 0x12ca, 0x12c9, 0x3, 
       0x2, 0x2, 0x2, 0x12ca, 0x12cb, 0x3, 0x2, 0x2, 0x2, 0x12cb, 0x12cd, 
       0x3, 0x2, 0x2, 0x2, 0x12cc, 0x12ce, 0x5, 0x2f0, 0x179, 0x2, 0x12cd, 
       0x12cc, 0x3, 0x2, 0x2, 0x2, 0x12cd, 0x12ce, 0x3, 0x2, 0x2, 0x2, 0x12ce, 
       0x134d, 0x3, 0x2, 0x2, 0x2, 0x12cf, 0x12d0, 0x6, 0x11f, 0x74, 0x2, 
       0x12d0, 0x12d2, 0x7, 0x8c, 0x2, 0x2, 0x12d1, 0x12cf, 0x3, 0x2, 0x2, 
       0x2, 0x12d1, 0x12d2, 0x3, 0x2, 0x2, 0x2, 0x12d2, 0x12d3, 0x3, 0x2, 
       0x2, 0x2, 0x12d3, 0x12d4, 0x9, 0x45, 0x2, 0x2, 0x12d4, 0x12d5, 0x5, 
       0x242, 0x122, 0x2, 0x12d5, 0x12d7, 0x5, 0x428, 0x215, 0x2, 0x12d6, 
       0x12d8, 0x5, 0x244, 0x123, 0x2, 0x12d7, 0x12d6, 0x3, 0x2, 0x2, 0x2, 
       0x12d7, 0x12d8, 0x3, 0x2, 0x2, 0x2, 0x12d8, 0x12da, 0x3, 0x2, 0x2, 
       0x2, 0x12d9, 0x12db, 0x5, 0x15e, 0xb0, 0x2, 0x12da, 0x12d9, 0x3, 
       0x2, 0x2, 0x2, 0x12da, 0x12db, 0x3, 0x2, 0x2, 0x2, 0x12db, 0x134d, 
       0x3, 0x2, 0x2, 0x2, 0x12dc, 0x12de, 0x7, 0x14a, 0x2, 0x2, 0x12dd, 
       0x12dc, 0x3, 0x2, 0x2, 0x2, 0x12dd, 0x12de, 0x3, 0x2, 0x2, 0x2, 0x12de, 
       0x12df, 0x3, 0x2, 0x2, 0x2, 0x12df, 0x134d, 0x7, 0x83, 0x2, 0x2, 
       0x12e0, 0x12e1, 0x7, 0x1cc, 0x2, 0x2, 0x12e1, 0x12e2, 0x7, 0x19b, 
       0x2, 0x2, 0x12e2, 0x12e3, 0x7, 0x18b, 0x2, 0x2, 0x12e3, 0x12e4, 0x7, 
       0x19c, 0x2, 0x2, 0x12e4, 0x134d, 0x9, 0x46, 0x2, 0x2, 0x12e5, 0x12e7, 
       0x7, 0x173, 0x2, 0x2, 0x12e6, 0x12e8, 0x5, 0x11c, 0x8f, 0x2, 0x12e7, 
       0x12e6, 0x3, 0x2, 0x2, 0x2, 0x12e7, 0x12e8, 0x3, 0x2, 0x2, 0x2, 0x12e8, 
       0x134d, 0x3, 0x2, 0x2, 0x2, 0x12e9, 0x12eb, 0x7, 0x85, 0x2, 0x2, 
       0x12ea, 0x12ec, 0x5, 0x11c, 0x8f, 0x2, 0x12eb, 0x12ea, 0x3, 0x2, 
       0x2, 0x2, 0x12eb, 0x12ec, 0x3, 0x2, 0x2, 0x2, 0x12ec, 0x134d, 0x3, 
       0x2, 0x2, 0x2, 0x12ed, 0x134d, 0x7, 0x10a, 0x2, 0x2, 0x12ee, 0x12f7, 
       0x7, 0x109, 0x2, 0x2, 0x12ef, 0x12f4, 0x5, 0x246, 0x124, 0x2, 0x12f0, 
       0x12f1, 0x7, 0x198, 0x2, 0x2, 0x12f1, 0x12f3, 0x5, 0x246, 0x124, 
       0x2, 0x12f2, 0x12f0, 0x3, 0x2, 0x2, 0x2, 0x12f3, 0x12f6, 0x3, 0x2, 
       0x2, 0x2, 0x12f4, 0x12f2, 0x3, 0x2, 0x2, 0x2, 0x12f4, 0x12f5, 0x3, 
       0x2, 0x2, 0x2, 0x12f5, 0x12f8, 0x3, 0x2, 0x2, 0x2, 0x12f6, 0x12f4, 
       0x3, 0x2, 0x2, 0x2, 0x12f7, 0x12ef, 0x3, 0x2, 0x2, 0x2, 0x12f7, 0x12f8, 
       0x3, 0x2, 0x2, 0x2, 0x12f8, 0x12fc, 0x3, 0x2, 0x2, 0x2, 0x12f9, 0x12fa, 
       0x7, 0x1fb, 0x2, 0x2, 0x12fa, 0x12fb, 0x7, 0x10d, 0x2, 0x2, 0x12fb, 
       0x12fd, 0x7, 0x17e, 0x2, 0x2, 0x12fc, 0x12f9, 0x3, 0x2, 0x2, 0x2, 
       0x12fc, 0x12fd, 0x3, 0x2, 0x2, 0x2, 0x12fd, 0x12ff, 0x3, 0x2, 0x2, 
       0x2, 0x12fe, 0x1300, 0x5, 0x11c, 0x8f, 0x2, 0x12ff, 0x12fe, 0x3, 
       0x2, 0x2, 0x2, 0x12ff, 0x1300, 0x3, 0x2, 0x2, 0x2, 0x1300, 0x134d, 
       0x3, 0x2, 0x2, 0x2, 0x1301, 0x1303, 0x5, 0x47c, 0x23f, 0x2, 0x1302, 
       0x1301, 0x3, 0x2, 0x2, 0x2, 0x1302, 0x1303, 0x3, 0x2, 0x2, 0x2, 0x1303, 
       0x1304, 0x3, 0x2, 0x2, 0x2, 0x1304, 0x1306, 0x9, 0x47, 0x2, 0x2, 
       0x1305, 0x1307, 0x5, 0x3e0, 0x1f1, 0x2, 0x1306, 0x1305, 0x3, 0x2, 
       0x2, 0x2, 0x1306, 0x1307, 0x3, 0x2, 0x2, 0x2, 0x1307, 0x134d, 0x3, 
       0x2, 0x2, 0x2, 0x1308, 0x130a, 0x7, 0x92, 0x2, 0x2, 0x1309, 0x1308, 
       0x3, 0x2, 0x2, 0x2, 0x1309, 0x130a, 0x3, 0x2, 0x2, 0x2, 0x130a, 0x130b, 
       0x3, 0x2, 0x2, 0x2, 0x130b, 0x134d, 0x7, 0x108, 0x2, 0x2, 0x130c, 
       0x130e, 0x5, 0x2da, 0x16e, 0x2, 0x130d, 0x130f, 0x5, 0x3e0, 0x1f1, 
       0x2, 0x130e, 0x130d, 0x3, 0x2, 0x2, 0x2, 0x130e, 0x130f, 0x3, 0x2, 
       0x2, 0x2, 0x130f, 0x134d, 0x3, 0x2, 0x2, 0x2, 0x1310, 0x1312, 0x7, 
       0x59, 0x2, 0x2, 0x1311, 0x1313, 0x5, 0x3e0, 0x1f1, 0x2, 0x1312, 0x1311, 
       0x3, 0x2, 0x2, 0x2, 0x1312, 0x1313, 0x3, 0x2, 0x2, 0x2, 0x1313, 0x134d, 
       0x3, 0x2, 0x2, 0x2, 0x1314, 0x1315, 0x6, 0x11f, 0x75, 0x2, 0x1315, 
       0x134d, 0x7, 0x6a, 0x2, 0x2, 0x1316, 0x134d, 0x7, 0x106, 0x2, 0x2, 
       0x1317, 0x131a, 0x7, 0x9c, 0x2, 0x2, 0x1318, 0x1319, 0x7, 0x1fb, 
       0x2, 0x2, 0x1319, 0x131b, 0x5, 0x3dc, 0x1ef, 0x2, 0x131a, 0x1318, 
       0x3, 0x2, 0x2, 0x2, 0x131a, 0x131b, 0x3, 0x2, 0x2, 0x2, 0x131b, 0x134d, 
       0x3, 0x2, 0x2, 0x2, 0x131c, 0x131d, 0x6, 0x11f, 0x76, 0x2, 0x131d, 
       0x131e, 0x7, 0x9c, 0x2, 0x2, 0x131e, 0x131f, 0x7, 0x1fb, 0x2, 0x2, 
       0x131f, 0x1320, 0x5, 0x3dc, 0x1ef, 0x2, 0x1320, 0x1321, 0x7, 0x29b, 
       0x2, 0x2, 0x1321, 0x1322, 0x5, 0x3cc, 0x1e7, 0x2, 0x1322, 0x134d, 
       0x3, 0x2, 0x2, 0x2, 0x1323, 0x1324, 0x7, 0xbb, 0x2, 0x2, 0x1324, 
       0x134d, 0x7, 0x149, 0x2, 0x2, 0x1325, 0x133a, 0x7, 0x1cd, 0x2, 0x2, 
       0x1326, 0x1328, 0x7, 0x1d5, 0x2, 0x2, 0x1327, 0x1329, 0x5, 0x3b0, 
       0x1d9, 0x2, 0x1328, 0x1327, 0x3, 0x2, 0x2, 0x2, 0x1328, 0x1329, 0x3, 
       0x2, 0x2, 0x2, 0x1329, 0x132a, 0x3, 0x2, 0x2, 0x2, 0x132a, 0x133b, 
       0x5, 0x3fc, 0x1ff, 0x2, 0x132b, 0x132c, 0x7, 0x87, 0x2, 0x2, 0x132c, 
       0x133b, 0x5, 0x418, 0x20d, 0x2, 0x132d, 0x132e, 0x7, 0x166, 0x2, 
       0x2, 0x132e, 0x133b, 0x5, 0x404, 0x203, 0x2, 0x132f, 0x1330, 0x7, 
       0x253, 0x2, 0x2, 0x1330, 0x133b, 0x5, 0x400, 0x201, 0x2, 0x1331, 
       0x1332, 0x7, 0x288, 0x2, 0x2, 0x1332, 0x133b, 0x5, 0x428, 0x215, 
       0x2, 0x1333, 0x1334, 0x7, 0x290, 0x2, 0x2, 0x1334, 0x133b, 0x5, 0x408, 
       0x205, 0x2, 0x1335, 0x1336, 0x7, 0x171, 0x2, 0x2, 0x1336, 0x133b, 
       0x5, 0x40c, 0x207, 0x2, 0x1337, 0x1338, 0x6, 0x11f, 0x77, 0x2, 0x1338, 
       0x1339, 0x7, 0x16e, 0x2, 0x2, 0x1339, 0x133b, 0x5, 0x3dc, 0x1ef, 
       0x2, 0x133a, 0x1326, 0x3, 0x2, 0x2, 0x2, 0x133a, 0x132b, 0x3, 0x2, 
       0x2, 0x2, 0x133a, 0x132d, 0x3, 0x2, 0x2, 0x2, 0x133a, 0x132f, 0x3, 
       0x2, 0x2, 0x2, 0x133a, 0x1331, 0x3, 0x2, 0x2, 0x2, 0x133a, 0x1333, 
       0x3, 0x2, 0x2, 0x2, 0x133a, 0x1335, 0x3, 0x2, 0x2, 0x2, 0x133a, 0x1337, 
       0x3, 0x2, 0x2, 0x2, 0x133b, 0x134d, 0x3, 0x2, 0x2, 0x2, 0x133c, 0x133d, 
       0x7, 0x253, 0x2, 0x2, 0x133d, 0x133f, 0x7, 0x149, 0x2, 0x2, 0x133e, 
       0x1340, 0x5, 0x3e0, 0x1f1, 0x2, 0x133f, 0x133e, 0x3, 0x2, 0x2, 0x2, 
       0x133f, 0x1340, 0x3, 0x2, 0x2, 0x2, 0x1340, 0x134d, 0x3, 0x2, 0x2, 
       0x2, 0x1341, 0x1342, 0x7, 0x166, 0x2, 0x2, 0x1342, 0x1344, 0x7, 0x149, 
       0x2, 0x2, 0x1343, 0x1345, 0x5, 0x3e0, 0x1f1, 0x2, 0x1344, 0x1343, 
       0x3, 0x2, 0x2, 0x2, 0x1344, 0x1345, 0x3, 0x2, 0x2, 0x2, 0x1345, 0x134d, 
       0x3, 0x2, 0x2, 0x2, 0x1346, 0x1347, 0x7, 0x253, 0x2, 0x2, 0x1347, 
       0x1348, 0x7, 0x58, 0x2, 0x2, 0x1348, 0x134d, 0x5, 0x400, 0x201, 0x2, 
       0x1349, 0x134a, 0x7, 0x166, 0x2, 0x2, 0x134a, 0x134b, 0x7, 0x58, 
       0x2, 0x2, 0x134b, 0x134d, 0x5, 0x404, 0x203, 0x2, 0x134c, 0x126f, 
       0x3, 0x2, 0x2, 0x2, 0x134c, 0x1271, 0x3, 0x2, 0x2, 0x2, 0x134c, 0x1276, 
       0x3, 0x2, 0x2, 0x2, 0x134c, 0x1280, 0x3, 0x2, 0x2, 0x2, 0x134c, 0x1289, 
       0x3, 0x2, 0x2, 0x2, 0x134c, 0x1290, 0x3, 0x2, 0x2, 0x2, 0x134c, 0x1298, 
       0x3, 0x2, 0x2, 0x2, 0x134c, 0x12a0, 0x3, 0x2, 0x2, 0x2, 0x134c, 0x12a2, 
       0x3, 0x2, 0x2, 0x2, 0x134c, 0x12a9, 0x3, 0x2, 0x2, 0x2, 0x134c, 0x12b4, 
       0x3, 0x2, 0x2, 0x2, 0x134c, 0x12b6, 0x3, 0x2, 0x2, 0x2, 0x134c, 0x12bf, 
       0x3, 0x2, 0x2, 0x2, 0x134c, 0x12d1, 0x3, 0x2, 0x2, 0x2, 0x134c, 0x12dd, 
       0x3, 0x2, 0x2, 0x2, 0x134c, 0x12e0, 0x3, 0x2, 0x2, 0x2, 0x134c, 0x12e5, 
       0x3, 0x2, 0x2, 0x2, 0x134c, 0x12e9, 0x3, 0x2, 0x2, 0x2, 0x134c, 0x12ed, 
       0x3, 0x2, 0x2, 0x2, 0x134c, 0x12ee, 0x3, 0x2, 0x2, 0x2, 0x134c, 0x1302, 
       0x3, 0x2, 0x2, 0x2, 0x134c, 0x1309, 0x3, 0x2, 0x2, 0x2, 0x134c, 0x130c, 
       0x3, 0x2, 0x2, 0x2, 0x134c, 0x1310, 0x3, 0x2, 0x2, 0x2, 0x134c, 0x1314, 
       0x3, 0x2, 0x2, 0x2, 0x134c, 0x1316, 0x3, 0x2, 0x2, 0x2, 0x134c, 0x1317, 
       0x3, 0x2, 0x2, 0x2, 0x134c, 0x131c, 0x3, 0x2, 0x2, 0x2, 0x134c, 0x1323, 
       0x3, 0x2, 0x2, 0x2, 0x134c, 0x1325, 0x3, 0x2, 0x2, 0x2, 0x134c, 0x133c, 
       0x3, 0x2, 0x2, 0x2, 0x134c, 0x1341, 0x3, 0x2, 0x2, 0x2, 0x134c, 0x1346, 
       0x3, 0x2, 0x2, 0x2, 0x134c, 0x1349, 0x3, 0x2, 0x2, 0x2, 0x134d, 0x23d, 
       0x3, 0x2, 0x2, 0x2, 0x134e, 0x1355, 0x7, 0x92, 0x2, 0x2, 0x134f, 
       0x1350, 0x6, 0x120, 0x78, 0x2, 0x1350, 0x1352, 0x7, 0x8c, 0x2, 0x2, 
       0x1351, 0x1353, 0x7, 0x92, 0x2, 0x2, 0x1352, 0x1351, 0x3, 0x2, 0x2, 
       0x2, 0x1352, 0x1353, 0x3, 0x2, 0x2, 0x2, 0x1353, 0x1355, 0x3, 0x2, 
       0x2, 0x2, 0x1354, 0x134e, 0x3, 0x2, 0x2, 0x2, 0x1354, 0x134f, 0x3, 
       0x2, 0x2, 0x2, 0x1355, 0x23f, 0x3, 0x2, 0x2, 0x2, 0x1356, 0x1358, 
       0x6, 0x121, 0x79, 0x2, 0x1357, 0x1359, 0x7, 0x23d, 0x2, 0x2, 0x1358, 
       0x1357, 0x3, 0x2, 0x2, 0x2, 0x1358, 0x1359, 0x3, 0x2, 0x2, 0x2, 0x1359, 
       0x135c, 0x3, 0x2, 0x2, 0x2, 0x135a, 0x135c, 0x3, 0x2, 0x2, 0x2, 0x135b, 
       0x1356, 0x3, 0x2, 0x2, 0x2, 0x135b, 0x135a, 0x3, 0x2, 0x2, 0x2, 0x135c, 
       0x241, 0x3, 0x2, 0x2, 0x2, 0x135d, 0x135e, 0x9, 0x43, 0x2, 0x2, 0x135e, 
       0x243, 0x3, 0x2, 0x2, 0x2, 0x135f, 0x1360, 0x5, 0x242, 0x122, 0x2, 
       0x1360, 0x1361, 0x5, 0x442, 0x222, 0x2, 0x1361, 0x245, 0x3, 0x2, 
       0x2, 0x2, 0x1362, 0x1363, 0x7, 0x4b, 0x2, 0x2, 0x1363, 0x136a, 0x7, 
       0xa9, 0x2, 0x2, 0x1364, 0x1365, 0x7, 0x69, 0x2, 0x2, 0x1365, 0x136a, 
       0x7, 0x154, 0x2, 0x2, 0x1366, 0x1367, 0x7, 0xf9, 0x2, 0x2, 0x1367, 
       0x136a, 0x7, 0x8e, 0x2, 0x2, 0x1368, 0x136a, 0x9, 0x48, 0x2, 0x2, 
       0x1369, 0x1362, 0x3, 0x2, 0x2, 0x2, 0x1369, 0x1364, 0x3, 0x2, 0x2, 
       0x2, 0x1369, 0x1366, 0x3, 0x2, 0x2, 0x2, 0x1369, 0x1368, 0x3, 0x2, 
       0x2, 0x2, 0x136a, 0x247, 0x3, 0x2, 0x2, 0x2, 0x136b, 0x136c, 0x7, 
       0x49, 0x2, 0x2, 0x136c, 0x1391, 0x5, 0x460, 0x231, 0x2, 0x136d, 0x136e, 
       0x7, 0x9, 0x2, 0x2, 0x136e, 0x136f, 0x7, 0x20a, 0x2, 0x2, 0x136f, 
       0x1370, 0x5, 0x24a, 0x126, 0x2, 0x1370, 0x1373, 0x7, 0x213, 0x2, 
       0x2, 0x1371, 0x1374, 0x5, 0x442, 0x222, 0x2, 0x1372, 0x1374, 0x7, 
       0x1e0, 0x2, 0x2, 0x1373, 0x1371, 0x3, 0x2, 0x2, 0x2, 0x1373, 0x1372, 
       0x3, 0x2, 0x2, 0x2, 0x1374, 0x1391, 0x3, 0x2, 0x2, 0x2, 0x1375, 0x1377, 
       0x7, 0x14, 0x2, 0x2, 0x1376, 0x1378, 0x5, 0x3e4, 0x1f3, 0x2, 0x1377, 
       0x1376, 0x3, 0x2, 0x2, 0x2, 0x1377, 0x1378, 0x3, 0x2, 0x2, 0x2, 0x1378, 
       0x1382, 0x3, 0x2, 0x2, 0x2, 0x1379, 0x1383, 0x5, 0x25c, 0x12f, 0x2, 
       0x137a, 0x137f, 0x5, 0x258, 0x12d, 0x2, 0x137b, 0x137c, 0x7, 0x198, 
       0x2, 0x2, 0x137c, 0x137e, 0x5, 0x258, 0x12d, 0x2, 0x137d, 0x137b, 
       0x3, 0x2, 0x2, 0x2, 0x137e, 0x1381, 0x3, 0x2, 0x2, 0x2, 0x137f, 0x137d, 
       0x3, 0x2, 0x2, 0x2, 0x137f, 0x1380, 0x3, 0x2, 0x2, 0x2, 0x1380, 0x1383, 
       0x3, 0x2, 0x2, 0x2, 0x1381, 0x137f, 0x3, 0x2, 0x2, 0x2, 0x1382, 0x1379, 
       0x3, 0x2, 0x2, 0x2, 0x1382, 0x137a, 0x3, 0x2, 0x2, 0x2, 0x1383, 0x1391, 
       0x3, 0x2, 0x2, 0x2, 0x1384, 0x1386, 0x7, 0x21b, 0x2, 0x2, 0x1385, 
       0x1387, 0x9, 0x49, 0x2, 0x2, 0x1386, 0x1385, 0x3, 0x2, 0x2, 0x2, 
       0x1386, 0x1387, 0x3, 0x2, 0x2, 0x2, 0x1387, 0x1388, 0x3, 0x2, 0x2, 
       0x2, 0x1388, 0x1391, 0x5, 0x28a, 0x146, 0x2, 0x1389, 0x138a, 0x7, 
       0x223, 0x2, 0x2, 0x138a, 0x138b, 0x7, 0x20a, 0x2, 0x2, 0x138b, 0x138c, 
       0x7, 0x211, 0x2, 0x2, 0x138c, 0x138d, 0x7, 0x9, 0x2, 0x2, 0x138d, 
       0x1391, 0x5, 0x260, 0x131, 0x2, 0x138e, 0x138f, 0x6, 0x125, 0x7a, 
       0x2, 0x138f, 0x1391, 0x7, 0x3a, 0x2, 0x2, 0x1390, 0x136b, 0x3, 0x2, 
       0x2, 0x2, 0x1390, 0x136d, 0x3, 0x2, 0x2, 0x2, 0x1390, 0x1375, 0x3, 
       0x2, 0x2, 0x2, 0x1390, 0x1384, 0x3, 0x2, 0x2, 0x2, 0x1390, 0x1389, 
       0x3, 0x2, 0x2, 0x2, 0x1390, 0x138e, 0x3, 0x2, 0x2, 0x2, 0x1391, 0x249, 
       0x3, 0x2, 0x2, 0x2, 0x1392, 0x1395, 0x5, 0x24c, 0x127, 0x2, 0x1393, 
       0x1395, 0x5, 0x250, 0x129, 0x2, 0x1394, 0x1392, 0x3, 0x2, 0x2, 0x2, 
       0x1394, 0x1393, 0x3, 0x2, 0x2, 0x2, 0x1395, 0x24b, 0x3, 0x2, 0x2, 
       0x2, 0x1396, 0x139b, 0x5, 0x24e, 0x128, 0x2, 0x1397, 0x1398, 0x7, 
       0x198, 0x2, 0x2, 0x1398, 0x139a, 0x5, 0x24e, 0x128, 0x2, 0x1399, 
       0x1397, 0x3, 0x2, 0x2, 0x2, 0x139a, 0x139d, 0x3, 0x2, 0x2, 0x2, 0x139b, 
       0x1399, 0x3, 0x2, 0x2, 0x2, 0x139b, 0x139c, 0x3, 0x2, 0x2, 0x2, 0x139c, 
       0x24d, 0x3, 0x2, 0x2, 0x2, 0x139d, 0x139b, 0x3, 0x2, 0x2, 0x2, 0x139e, 
       0x13a0, 0x5, 0x428, 0x215, 0x2, 0x139f, 0x13a1, 0x5, 0x252, 0x12a, 
       0x2, 0x13a0, 0x139f, 0x3, 0x2, 0x2, 0x2, 0x13a0, 0x13a1, 0x3, 0x2, 
       0x2, 0x2, 0x13a1, 0x24f, 0x3, 0x2, 0x2, 0x2, 0x13a2, 0x13a3, 0x5, 
       0x428, 0x215, 0x2, 0x13a3, 0x13a4, 0x7, 0x22, 0x2, 0x2, 0x13a4, 0x13a5, 
       0x7, 0x19b, 0x2, 0x2, 0x13a5, 0x13a6, 0x5, 0x36, 0x1c, 0x2, 0x13a6, 
       0x13a8, 0x7, 0x19c, 0x2, 0x2, 0x13a7, 0x13a9, 0x5, 0x252, 0x12a, 
       0x2, 0x13a8, 0x13a7, 0x3, 0x2, 0x2, 0x2, 0x13a8, 0x13a9, 0x3, 0x2, 
       0x2, 0x2, 0x13a9, 0x251, 0x3, 0x2, 0x2, 0x2, 0x13aa, 0x13ab, 0x5, 
       0x18e, 0xc8, 0x2, 0x13ab, 0x13ad, 0x7, 0x19b, 0x2, 0x2, 0x13ac, 0x13ae, 
       0x5, 0x256, 0x12c, 0x2, 0x13ad, 0x13ac, 0x3, 0x2, 0x2, 0x2, 0x13ad, 
       0x13ae, 0x3, 0x2, 0x2, 0x2, 0x13ae, 0x13af, 0x3, 0x2, 0x2, 0x2, 0x13af, 
       0x13b0, 0x7, 0x19c, 0x2, 0x2, 0x13b0, 0x253, 0x3, 0x2, 0x2, 0x2, 
       0x13b1, 0x13b4, 0x5, 0x442, 0x222, 0x2, 0x13b2, 0x13b4, 0x7, 0x252, 
       0x2, 0x2, 0x13b3, 0x13b1, 0x3, 0x2, 0x2, 0x2, 0x13b3, 0x13b2, 0x3, 
       0x2, 0x2, 0x2, 0x13b4, 0x255, 0x3, 0x2, 0x2, 0x2, 0x13b5, 0x13ba, 
       0x5, 0x254, 0x12b, 0x2, 0x13b6, 0x13b7, 0x7, 0x198, 0x2, 0x2, 0x13b7, 
       0x13b9, 0x5, 0x254, 0x12b, 0x2, 0x13b8, 0x13b6, 0x3, 0x2, 0x2, 0x2, 
       0x13b9, 0x13bc, 0x3, 0x2, 0x2, 0x2, 0x13ba, 0x13b8, 0x3, 0x2, 0x2, 
       0x2, 0x13ba, 0x13bb, 0x3, 0x2, 0x2, 0x2, 0x13bb, 0x257, 0x3, 0x2, 
       0x2, 0x2, 0x13bc, 0x13ba, 0x3, 0x2, 0x2, 0x2, 0x13bd, 0x13cd, 0x9, 
       0x4a, 0x2, 0x2, 0x13be, 0x13c0, 0x5, 0x25a, 0x12e, 0x2, 0x13bf, 0x13be, 
       0x3, 0x2, 0x2, 0x2, 0x13bf, 0x13c0, 0x3, 0x2, 0x2, 0x2, 0x13c0, 0x13c1, 
       0x3, 0x2, 0x2, 0x2, 0x13c1, 0x13cd, 0x7, 0xb9, 0x2, 0x2, 0x13c2, 
       0x13c3, 0x7, 0x115, 0x2, 0x2, 0x13c3, 0x13c5, 0x7, 0xb9, 0x2, 0x2, 
       0x13c4, 0x13c6, 0x5, 0x2f0, 0x179, 0x2, 0x13c5, 0x13c4, 0x3, 0x2, 
       0x2, 0x2, 0x13c5, 0x13c6, 0x3, 0x2, 0x2, 0x2, 0x13c6, 0x13cd, 0x3, 
       0x2, 0x2, 0x2, 0x13c7, 0x13c8, 0x6, 0x12d, 0x7b, 0x2, 0x13c8, 0x13c9, 
       0x7, 0x10d, 0x2, 0x2, 0x13c9, 0x13cd, 0x7, 0x9, 0x2, 0x2, 0x13ca, 
       0x13cb, 0x6, 0x12d, 0x7c, 0x2, 0x13cb, 0x13cd, 0x7, 0x248, 0x2, 0x2, 
       0x13cc, 0x13bd, 0x3, 0x2, 0x2, 0x2, 0x13cc, 0x13bf, 0x3, 0x2, 0x2, 
       0x2, 0x13cc, 0x13c2, 0x3, 0x2, 0x2, 0x2, 0x13cc, 0x13c7, 0x3, 0x2, 
       0x2, 0x2, 0x13cc, 0x13ca, 0x3, 0x2, 0x2, 0x2, 0x13cd, 0x259, 0x3, 
       0x2, 0x2, 0x2, 0x13ce, 0x13cf, 0x9, 0x4b, 0x2, 0x2, 0x13cf, 0x25b, 
       0x3, 0x2, 0x2, 0x2, 0x13d0, 0x13d8, 0x9, 0x14, 0x2, 0x2, 0x13d1, 
       0x13d2, 0x7, 0x2ab, 0x2, 0x2, 0x13d2, 0x13d3, 0x7, 0x257, 0x2, 0x2, 
       0x13d3, 0x13d9, 0x7, 0x225, 0x2, 0x2, 0x13d4, 0x13d6, 0x5, 0x444, 
       0x223, 0x2, 0x13d5, 0x13d7, 0x5, 0x25e, 0x130, 0x2, 0x13d6, 0x13d5, 
       0x3, 0x2, 0x2, 0x2, 0x13d6, 0x13d7, 0x3, 0x2, 0x2, 0x2, 0x13d7, 0x13d9, 
       0x3, 0x2, 0x2, 0x2, 0x13d8, 0x13d1, 0x3, 0x2, 0x2, 0x2, 0x13d8, 0x13d4, 
       0x3, 0x2, 0x2, 0x2, 0x13d8, 0x13d9, 0x3, 0x2, 0x2, 0x2, 0x13d9, 0x25d, 
       0x3, 0x2, 0x2, 0x2, 0x13da, 0x13db, 0x6, 0x130, 0x7d, 0x2, 0x13db, 
       0x13dc, 0x7, 0x1fb, 0x2, 0x2, 0x13dc, 0x13e1, 0x7, 0x8b, 0x2, 0x2, 
       0x13dd, 0x13de, 0x7, 0x2ab, 0x2, 0x2, 0x13de, 0x13df, 0x7, 0x257, 
       0x2, 0x2, 0x13df, 0x13e1, 0x7, 0x225, 0x2, 0x2, 0x13e0, 0x13da, 0x3, 
       0x2, 0x2, 0x2, 0x13e0, 0x13dd, 0x3, 0x2, 0x2, 0x2, 0x13e1, 0x25f, 
       0x3, 0x2, 0x2, 0x2, 0x13e2, 0x13e3, 0x5, 0x428, 0x215, 0x2, 0x13e3, 
       0x13e5, 0x5, 0x266, 0x134, 0x2, 0x13e4, 0x13e6, 0x5, 0x252, 0x12a, 
       0x2, 0x13e5, 0x13e4, 0x3, 0x2, 0x2, 0x2, 0x13e5, 0x13e6, 0x3, 0x2, 
       0x2, 0x2, 0x13e6, 0x13e9, 0x3, 0x2, 0x2, 0x2, 0x13e7, 0x13e8, 0x7, 
       0x209, 0x2, 0x2, 0x13e8, 0x13ea, 0x7, 0xb1, 0x2, 0x2, 0x13e9, 0x13e7, 
       0x3, 0x2, 0x2, 0x2, 0x13e9, 0x13ea, 0x3, 0x2, 0x2, 0x2, 0x13ea, 0x13ed, 
       0x3, 0x2, 0x2, 0x2, 0x13eb, 0x13ed, 0x5, 0x262, 0x132, 0x2, 0x13ec, 
       0x13e2, 0x3, 0x2, 0x2, 0x2, 0x13ec, 0x13eb, 0x3, 0x2, 0x2, 0x2, 0x13ed, 
       0x261, 0x3, 0x2, 0x2, 0x2, 0x13ee, 0x13f3, 0x5, 0x264, 0x133, 0x2, 
       0x13ef, 0x13f0, 0x7, 0x198, 0x2, 0x2, 0x13f0, 0x13f2, 0x5, 0x264, 
       0x133, 0x2, 0x13f1, 0x13ef, 0x3, 0x2, 0x2, 0x2, 0x13f2, 0x13f5, 0x3, 
       0x2, 0x2, 0x2, 0x13f3, 0x13f1, 0x3, 0x2, 0x2, 0x2, 0x13f3, 0x13f4, 
       0x3, 0x2, 0x2, 0x2, 0x13f4, 0x263, 0x3, 0x2, 0x2, 0x2, 0x13f5, 0x13f3, 
       0x3, 0x2, 0x2, 0x2, 0x13f6, 0x13f8, 0x5, 0x428, 0x215, 0x2, 0x13f7, 
       0x13f9, 0x5, 0x252, 0x12a, 0x2, 0x13f8, 0x13f7, 0x3, 0x2, 0x2, 0x2, 
       0x13f8, 0x13f9, 0x3, 0x2, 0x2, 0x2, 0x13f9, 0x13fc, 0x3, 0x2, 0x2, 
       0x2, 0x13fa, 0x13fb, 0x7, 0x209, 0x2, 0x2, 0x13fb, 0x13fd, 0x7, 0xb1, 
       0x2, 0x2, 0x13fc, 0x13fa, 0x3, 0x2, 0x2, 0x2, 0x13fc, 0x13fd, 0x3, 
       0x2, 0x2, 0x2, 0x13fd, 0x265, 0x3, 0x2, 0x2, 0x2, 0x13fe, 0x13ff, 
       0x6, 0x134, 0x7e, 0x2, 0x13ff, 0x1400, 0x7, 0x22, 0x2, 0x2, 0x1400, 
       0x1401, 0x7, 0x19b, 0x2, 0x2, 0x1401, 0x1402, 0x5, 0x36, 0x1c, 0x2, 
       0x1402, 0x1403, 0x7, 0x19c, 0x2, 0x2, 0x1403, 0x267, 0x3, 0x2, 0x2, 
       0x2, 0x1404, 0x1409, 0x5, 0x26a, 0x136, 0x2, 0x1405, 0x1409, 0x5, 
       0x274, 0x13b, 0x2, 0x1406, 0x1409, 0x5, 0x276, 0x13c, 0x2, 0x1407, 
       0x1409, 0x5, 0x27a, 0x13e, 0x2, 0x1408, 0x1404, 0x3, 0x2, 0x2, 0x2, 
       0x1408, 0x1405, 0x3, 0x2, 0x2, 0x2, 0x1408, 0x1406, 0x3, 0x2, 0x2, 
       0x2, 0x1408, 0x1407, 0x3, 0x2, 0x2, 0x2, 0x1409, 0x269, 0x3, 0x2, 
       0x2, 0x2, 0x140a, 0x140b, 0x7, 0x1cd, 0x2, 0x2, 0x140b, 0x140c, 0x7, 
       0x2e6, 0x2, 0x2, 0x140c, 0x140d, 0x7, 0x201, 0x2, 0x2, 0x140d, 0x140e, 
       0x5, 0x442, 0x222, 0x2, 0x140e, 0x1410, 0x7, 0x164, 0x2, 0x2, 0x140f, 
       0x1411, 0x5, 0x47a, 0x23e, 0x2, 0x1410, 0x140f, 0x3, 0x2, 0x2, 0x2, 
       0x1410, 0x1411, 0x3, 0x2, 0x2, 0x2, 0x1411, 0x1412, 0x3, 0x2, 0x2, 
       0x2, 0x1412, 0x1414, 0x9, 0x4c, 0x2, 0x2, 0x1413, 0x1415, 0x5, 0x26c, 
       0x137, 0x2, 0x1414, 0x1413, 0x3, 0x2, 0x2, 0x2, 0x1414, 0x1415, 0x3, 
       0x2, 0x2, 0x2, 0x1415, 0x1417, 0x3, 0x2, 0x2, 0x2, 0x1416, 0x1418, 
       0x5, 0x270, 0x139, 0x2, 0x1417, 0x1416, 0x3, 0x2, 0x2, 0x2, 0x1417, 
       0x1418, 0x3, 0x2, 0x2, 0x2, 0x1418, 0x141a, 0x3, 0x2, 0x2, 0x2, 0x1419, 
       0x141b, 0x5, 0x272, 0x13a, 0x2, 0x141a, 0x1419, 0x3, 0x2, 0x2, 0x2, 
       0x141a, 0x141b, 0x3, 0x2, 0x2, 0x2, 0x141b, 0x26b, 0x3, 0x2, 0x2, 
       0x2, 0x141c, 0x141e, 0x7, 0x2e8, 0x2, 0x2, 0x141d, 0x141f, 0x5, 0x47a, 
       0x23e, 0x2, 0x141e, 0x141d, 0x3, 0x2, 0x2, 0x2, 0x141e, 0x141f, 0x3, 
       0x2, 0x2, 0x2, 0x141f, 0x1420, 0x3, 0x2, 0x2, 0x2, 0x1420, 0x1427, 
       0x5, 0x26e, 0x138, 0x2, 0x1421, 0x1423, 0x7, 0x198, 0x2, 0x2, 0x1422, 
       0x1421, 0x3, 0x2, 0x2, 0x2, 0x1422, 0x1423, 0x3, 0x2, 0x2, 0x2, 0x1423, 
       0x1424, 0x3, 0x2, 0x2, 0x2, 0x1424, 0x1426, 0x5, 0x26e, 0x138, 0x2, 
       0x1425, 0x1422, 0x3, 0x2, 0x2, 0x2, 0x1426, 0x1429, 0x3, 0x2, 0x2, 
       0x2, 0x1427, 0x1425, 0x3, 0x2, 0x2, 0x2, 0x1427, 0x1428, 0x3, 0x2, 
       0x2, 0x2, 0x1428, 0x26d, 0x3, 0x2, 0x2, 0x2, 0x1429, 0x1427, 0x3, 
       0x2, 0x2, 0x2, 0x142a, 0x142d, 0x7, 0x17e, 0x2, 0x2, 0x142b, 0x142c, 
       0x7, 0x18a, 0x2, 0x2, 0x142c, 0x142e, 0x7, 0x17e, 0x2, 0x2, 0x142d, 
       0x142b, 0x3, 0x2, 0x2, 0x2, 0x142d, 0x142e, 0x3, 0x2, 0x2, 0x2, 0x142e, 
       0x26f, 0x3, 0x2, 0x2, 0x2, 0x142f, 0x1431, 0x7, 0x2e5, 0x2, 0x2, 
       0x1430, 0x1432, 0x5, 0x47a, 0x23e, 0x2, 0x1431, 0x1430, 0x3, 0x2, 
       0x2, 0x2, 0x1431, 0x1432, 0x3, 0x2, 0x2, 0x2, 0x1432, 0x1433, 0x3, 
       0x2, 0x2, 0x2, 0x1433, 0x1434, 0x7, 0x17e, 0x2, 0x2, 0x1434, 0x271, 
       0x3, 0x2, 0x2, 0x2, 0x1435, 0x1436, 0x9, 0x4d, 0x2, 0x2, 0x1436, 
       0x273, 0x3, 0x2, 0x2, 0x2, 0x1437, 0x1438, 0x7, 0x1ae, 0x2, 0x2, 
       0x1438, 0x1439, 0x7, 0x2e6, 0x2, 0x2, 0x1439, 0x143a, 0x7, 0x201, 
       0x2, 0x2, 0x143a, 0x143c, 0x5, 0x43c, 0x21f, 0x2, 0x143b, 0x143d, 
       0x5, 0x26c, 0x137, 0x2, 0x143c, 0x143b, 0x3, 0x2, 0x2, 0x2, 0x143c, 
       0x143d, 0x3, 0x2, 0x2, 0x2, 0x143d, 0x143f, 0x3, 0x2, 0x2, 0x2, 0x143e, 
       0x1440, 0x5, 0x270, 0x139, 0x2, 0x143f, 0x143e, 0x3, 0x2, 0x2, 0x2, 
       0x143f, 0x1440, 0x3, 0x2, 0x2, 0x2, 0x1440, 0x1442, 0x3, 0x2, 0x2, 
       0x2, 0x1441, 0x1443, 0x5, 0x272, 0x13a, 0x2, 0x1442, 0x1441, 0x3, 
       0x2, 0x2, 0x2, 0x1442, 0x1443, 0x3, 0x2, 0x2, 0x2, 0x1443, 0x1445, 
       0x3, 0x2, 0x2, 0x2, 0x1444, 0x1446, 0x7, 0x1f9, 0x2, 0x2, 0x1445, 
       0x1444, 0x3, 0x2, 0x2, 0x2, 0x1445, 0x1446, 0x3, 0x2, 0x2, 0x2, 0x1446, 
       0x275, 0x3, 0x2, 0x2, 0x2, 0x1447, 0x1448, 0x7, 0x26c, 0x2, 0x2, 
       0x1448, 0x1449, 0x7, 0x2e6, 0x2, 0x2, 0x1449, 0x144a, 0x7, 0x201, 
       0x2, 0x2, 0x144a, 0x144d, 0x5, 0x442, 0x222, 0x2, 0x144b, 0x144c, 
       0x7, 0x1fb, 0x2, 0x2, 0x144c, 0x144e, 0x5, 0x278, 0x13d, 0x2, 0x144d, 
       0x144b, 0x3, 0x2, 0x2, 0x2, 0x144d, 0x144e, 0x3, 0x2, 0x2, 0x2, 0x144e, 
       0x277, 0x3, 0x2, 0x2, 0x2, 0x144f, 0x1456, 0x5, 0x450, 0x229, 0x2, 
       0x1450, 0x1452, 0x7, 0x198, 0x2, 0x2, 0x1451, 0x1450, 0x3, 0x2, 0x2, 
       0x2, 0x1451, 0x1452, 0x3, 0x2, 0x2, 0x2, 0x1452, 0x1453, 0x3, 0x2, 
       0x2, 0x2, 0x1453, 0x1455, 0x5, 0x450, 0x229, 0x2, 0x1454, 0x1451, 
       0x3, 0x2, 0x2, 0x2, 0x1455, 0x1458, 0x3, 0x2, 0x2, 0x2, 0x1456, 0x1454, 
       0x3, 0x2, 0x2, 0x2, 0x1456, 0x1457, 0x3, 0x2, 0x2, 0x2, 0x1457, 0x279, 
       0x3, 0x2, 0x2, 0x2, 0x1458, 0x1456, 0x3, 0x2, 0x2, 0x2, 0x1459, 0x145a, 
       0x7, 0x1e9, 0x2, 0x2, 0x145a, 0x145b, 0x7, 0x2e6, 0x2, 0x2, 0x145b, 
       0x145c, 0x7, 0x201, 0x2, 0x2, 0x145c, 0x145e, 0x5, 0x43c, 0x21f, 
       0x2, 0x145d, 0x145f, 0x7, 0x1f9, 0x2, 0x2, 0x145e, 0x145d, 0x3, 0x2, 
       0x2, 0x2, 0x145e, 0x145f, 0x3, 0x2, 0x2, 0x2, 0x145f, 0x27b, 0x3, 
       0x2, 0x2, 0x2, 0x1460, 0x1467, 0x5, 0x27e, 0x140, 0x2, 0x1461, 0x1467, 
       0x5, 0x280, 0x141, 0x2, 0x1462, 0x1467, 0x5, 0x284, 0x143, 0x2, 0x1463, 
       0x1467, 0x5, 0x286, 0x144, 0x2, 0x1464, 0x1465, 0x6, 0x13f, 0x7f, 
       0x2, 0x1465, 0x1467, 0x5, 0x288, 0x145, 0x2, 0x1466, 0x1460, 0x3, 
       0x2, 0x2, 0x2, 0x1466, 0x1461, 0x3, 0x2, 0x2, 0x2, 0x1466, 0x1462, 
       0x3, 0x2, 0x2, 0x2, 0x1466, 0x1463, 0x3, 0x2, 0x2, 0x2, 0x1466, 0x1464, 
       0x3, 0x2, 0x2, 0x2, 0x1467, 0x27d, 0x3, 0x2, 0x2, 0x2, 0x1468, 0x1469, 
       0x9, 0x4e, 0x2, 0x2, 0x1469, 0x146c, 0x5, 0x428, 0x215, 0x2, 0x146a, 
       0x146d, 0x5, 0x45e, 0x230, 0x2, 0x146b, 0x146d, 0x5, 0x3f0, 0x1f9, 
       0x2, 0x146c, 0x146a, 0x3, 0x2, 0x2, 0x2, 0x146c, 0x146b, 0x3, 0x2, 
       0x2, 0x2, 0x146c, 0x146d, 0x3, 0x2, 0x2, 0x2, 0x146d, 0x27f, 0x3, 
       0x2, 0x2, 0x2, 0x146e, 0x1477, 0x9, 0x4e, 0x2, 0x2, 0x146f, 0x1470, 
       0x6, 0x141, 0x80, 0x2, 0x1470, 0x1478, 0x7, 0x8c, 0x2, 0x2, 0x1471, 
       0x1472, 0x6, 0x141, 0x81, 0x2, 0x1472, 0x1478, 0x7, 0xfc, 0x2, 0x2, 
       0x1473, 0x1474, 0x6, 0x141, 0x82, 0x2, 0x1474, 0x1475, 0x7, 0x16, 
       0x2, 0x2, 0x1475, 0x1476, 0x7, 0x181, 0x2, 0x2, 0x1476, 0x1478, 0x5, 
       0x472, 0x23a, 0x2, 0x1477, 0x146f, 0x3, 0x2, 0x2, 0x2, 0x1477, 0x1471, 
       0x3, 0x2, 0x2, 0x2, 0x1477, 0x1473, 0x3, 0x2, 0x2, 0x2, 0x1477, 0x1478, 
       0x3, 0x2, 0x2, 0x2, 0x1478, 0x1479, 0x3, 0x2, 0x2, 0x2, 0x1479, 0x147a, 
       0x5, 0x282, 0x142, 0x2, 0x147a, 0x281, 0x3, 0x2, 0x2, 0x2, 0x147b, 
       0x1488, 0x5, 0x10c, 0x87, 0x2, 0x147c, 0x1481, 0x6, 0x142, 0x83, 
       0x2, 0x147d, 0x1482, 0x5, 0xe0, 0x71, 0x2, 0x147e, 0x1482, 0x5, 0xec, 
       0x77, 0x2, 0x147f, 0x1482, 0x5, 0x10a, 0x86, 0x2, 0x1480, 0x1482, 
       0x5, 0x198, 0xcd, 0x2, 0x1481, 0x147d, 0x3, 0x2, 0x2, 0x2, 0x1481, 
       0x147e, 0x3, 0x2, 0x2, 0x2, 0x1481, 0x147f, 0x3, 0x2, 0x2, 0x2, 0x1481, 
       0x1480, 0x3, 0x2, 0x2, 0x2, 0x1482, 0x1488, 0x3, 0x2, 0x2, 0x2, 0x1483, 
       0x1484, 0x6, 0x142, 0x84, 0x2, 0x1484, 0x1485, 0x7, 0x1fb, 0x2, 0x2, 
       0x1485, 0x1486, 0x7, 0x64, 0x2, 0x2, 0x1486, 0x1488, 0x5, 0x450, 
       0x229, 0x2, 0x1487, 0x147b, 0x3, 0x2, 0x2, 0x2, 0x1487, 0x147c, 0x3, 
       0x2, 0x2, 0x2, 0x1487, 0x1483, 0x3, 0x2, 0x2, 0x2, 0x1488, 0x283, 
       0x3, 0x2, 0x2, 0x2, 0x1489, 0x148a, 0x7, 0x19, 0x2, 0x2, 0x148a, 
       0x148b, 0x5, 0x472, 0x23a, 0x2, 0x148b, 0x285, 0x3, 0x2, 0x2, 0x2, 
       0x148c, 0x148d, 0x7, 0x29a, 0x2, 0x2, 0x148d, 0x148e, 0x5, 0x442, 
       0x222, 0x2, 0x148e, 0x287, 0x3, 0x2, 0x2, 0x2, 0x148f, 0x1490, 0x7, 
       0x2eb, 0x2, 0x2, 0x1490, 0x289, 0x3, 0x2, 0x2, 0x2, 0x1491, 0x1492, 
       0x8, 0x146, 0x1, 0x2, 0x1492, 0x1498, 0x5, 0x28c, 0x147, 0x2, 0x1493, 
       0x1495, 0x7, 0x216, 0x2, 0x2, 0x1494, 0x1496, 0x5, 0x2dc, 0x16f, 
       0x2, 0x1495, 0x1494, 0x3, 0x2, 0x2, 0x2, 0x1495, 0x1496, 0x3, 0x2, 
       0x2, 0x2, 0x1496, 0x1497, 0x3, 0x2, 0x2, 0x2, 0x1497, 0x1499, 0x9, 
       0x4f, 0x2, 0x2, 0x1498, 0x1493, 0x3, 0x2, 0x2, 0x2, 0x1498, 0x1499, 
       0x3, 0x2, 0x2, 0x2, 0x1499, 0x149d, 0x3, 0x2, 0x2, 0x2, 0x149a, 0x149b, 
       0x7, 0x23e, 0x2, 0x2, 0x149b, 0x149d, 0x5, 0x28a, 0x146, 0x6, 0x149c, 
       0x1491, 0x3, 0x2, 0x2, 0x2, 0x149c, 0x149a, 0x3, 0x2, 0x2, 0x2, 0x149d, 
       0x14a9, 0x3, 0x2, 0x2, 0x2, 0x149e, 0x149f, 0xc, 0x5, 0x2, 0x2, 0x149f, 
       0x14a0, 0x9, 0x50, 0x2, 0x2, 0x14a0, 0x14a8, 0x5, 0x28a, 0x146, 0x6, 
       0x14a1, 0x14a2, 0xc, 0x4, 0x2, 0x2, 0x14a2, 0x14a3, 0x7, 0x2b0, 0x2, 
       0x2, 0x14a3, 0x14a8, 0x5, 0x28a, 0x146, 0x5, 0x14a4, 0x14a5, 0xc, 
       0x3, 0x2, 0x2, 0x14a5, 0x14a6, 0x9, 0x51, 0x2, 0x2, 0x14a6, 0x14a8, 
       0x5, 0x28a, 0x146, 0x4, 0x14a7, 0x149e, 0x3, 0x2, 0x2, 0x2, 0x14a7, 
       0x14a1, 0x3, 0x2, 0x2, 0x2, 0x14a7, 0x14a4, 0x3, 0x2, 0x2, 0x2, 0x14a8, 
       0x14ab, 0x3, 0x2, 0x2, 0x2, 0x14a9, 0x14a7, 0x3, 0x2, 0x2, 0x2, 0x14a9, 
       0x14aa, 0x3, 0x2, 0x2, 0x2, 0x14aa, 0x28b, 0x3, 0x2, 0x2, 0x2, 0x14ab, 
       0x14a9, 0x3, 0x2, 0x2, 0x2, 0x14ac, 0x14ad, 0x8, 0x147, 0x1, 0x2, 
       0x14ad, 0x14ae, 0x5, 0x290, 0x149, 0x2, 0x14ae, 0x14c0, 0x3, 0x2, 
       0x2, 0x2, 0x14af, 0x14b0, 0xc, 0x5, 0x2, 0x2, 0x14b0, 0x14b2, 0x7, 
       0x216, 0x2, 0x2, 0x14b1, 0x14b3, 0x5, 0x2dc, 0x16f, 0x2, 0x14b2, 
       0x14b1, 0x3, 0x2, 0x2, 0x2, 0x14b2, 0x14b3, 0x3, 0x2, 0x2, 0x2, 0x14b3, 
       0x14b4, 0x3, 0x2, 0x2, 0x2, 0x14b4, 0x14bf, 0x7, 0x241, 0x2, 0x2, 
       0x14b5, 0x14b6, 0xc, 0x4, 0x2, 0x2, 0x14b6, 0x14b7, 0x5, 0x28e, 0x148, 
       0x2, 0x14b7, 0x14b8, 0x5, 0x290, 0x149, 0x2, 0x14b8, 0x14bf, 0x3, 
       0x2, 0x2, 0x2, 0x14b9, 0x14ba, 0xc, 0x3, 0x2, 0x2, 0x14ba, 0x14bb, 
       0x5, 0x28e, 0x148, 0x2, 0x14bb, 0x14bc, 0x9, 0x52, 0x2, 0x2, 0x14bc, 
       0x14bd, 0x5, 0x118, 0x8d, 0x2, 0x14bd, 0x14bf, 0x3, 0x2, 0x2, 0x2, 
       0x14be, 0x14af, 0x3, 0x2, 0x2, 0x2, 0x14be, 0x14b5, 0x3, 0x2, 0x2, 
       0x2, 0x14be, 0x14b9, 0x3, 0x2, 0x2, 0x2, 0x14bf, 0x14c2, 0x3, 0x2, 
       0x2, 0x2, 0x14c0, 0x14be, 0x3, 0x2, 0x2, 0x2, 0x14c0, 0x14c1, 0x3, 
       0x2, 0x2, 0x2, 0x14c1, 0x28d, 0x3, 0x2, 0x2, 0x2, 0x14c2, 0x14c0, 
       0x3, 0x2, 0x2, 0x2, 0x14c3, 0x14c4, 0x9, 0x53, 0x2, 0x2, 0x14c4, 
       0x28f, 0x3, 0x2, 0x2, 0x2, 0x14c5, 0x14cd, 0x5, 0x294, 0x14b, 0x2, 
       0x14c6, 0x14c8, 0x5, 0x2dc, 0x16f, 0x2, 0x14c7, 0x14c6, 0x3, 0x2, 
       0x2, 0x2, 0x14c7, 0x14c8, 0x3, 0x2, 0x2, 0x2, 0x14c8, 0x14c9, 0x3, 
       0x2, 0x2, 0x2, 0x14c9, 0x14ce, 0x5, 0x292, 0x14a, 0x2, 0x14ca, 0x14cb, 
       0x7, 0x13b, 0x2, 0x2, 0x14cb, 0x14cc, 0x7, 0x21f, 0x2, 0x2, 0x14cc, 
       0x14ce, 0x5, 0x294, 0x14b, 0x2, 0x14cd, 0x14c7, 0x3, 0x2, 0x2, 0x2, 
       0x14cd, 0x14ca, 0x3, 0x2, 0x2, 0x2, 0x14cd, 0x14ce, 0x3, 0x2, 0x2, 
       0x2, 0x14ce, 0x291, 0x3, 0x2, 0x2, 0x2, 0x14cf, 0x14d5, 0x7, 0x213, 
       0x2, 0x2, 0x14d0, 0x14d6, 0x5, 0x118, 0x8d, 0x2, 0x14d1, 0x14d2, 
       0x7, 0x19b, 0x2, 0x2, 0x14d2, 0x14d3, 0x5, 0x2d8, 0x16d, 0x2, 0x14d3, 
       0x14d4, 0x7, 0x19c, 0x2, 0x2, 0x14d4, 0x14d6, 0x3, 0x2, 0x2, 0x2, 
       0x14d5, 0x14d0, 0x3, 0x2, 0x2, 0x2, 0x14d5, 0x14d1, 0x3, 0x2, 0x2, 
       0x2, 0x14d6, 0x14e5, 0x3, 0x2, 0x2, 0x2, 0x14d7, 0x14d8, 0x7, 0x1b5, 
       0x2, 0x2, 0x14d8, 0x14d9, 0x5, 0x294, 0x14b, 0x2, 0x14d9, 0x14da, 
       0x7, 0x1b0, 0x2, 0x2, 0x14da, 0x14db, 0x5, 0x290, 0x149, 0x2, 0x14db, 
       0x14e5, 0x3, 0x2, 0x2, 0x2, 0x14dc, 0x14dd, 0x7, 0x21f, 0x2, 0x2, 
       0x14dd, 0x14e0, 0x5, 0x296, 0x14c, 0x2, 0x14de, 0x14df, 0x7, 0x86, 
       0x2, 0x2, 0x14df, 0x14e1, 0x5, 0x296, 0x14c, 0x2, 0x14e0, 0x14de, 
       0x3, 0x2, 0x2, 0x2, 0x14e0, 0x14e1, 0x3, 0x2, 0x2, 0x2, 0x14e1, 0x14e5, 
       0x3, 0x2, 0x2, 0x2, 0x14e2, 0x14e3, 0x7, 0x25b, 0x2, 0x2, 0x14e3, 
       0x14e5, 0x5, 0x294, 0x14b, 0x2, 0x14e4, 0x14cf, 0x3, 0x2, 0x2, 0x2, 
       0x14e4, 0x14d7, 0x3, 0x2, 0x2, 0x2, 0x14e4, 0x14dc, 0x3, 0x2, 0x2, 
       0x2, 0x14e4, 0x14e2, 0x3, 0x2, 0x2, 0x2, 0x14e5, 0x293, 0x3, 0x2, 
       0x2, 0x2, 0x14e6, 0x14e7, 0x8, 0x14b, 0x1, 0x2, 0x14e7, 0x14e8, 0x5, 
       0x296, 0x14c, 0x2, 0x14e8, 0x1503, 0x3, 0x2, 0x2, 0x2, 0x14e9, 0x14ea, 
       0xc, 0x9, 0x2, 0x2, 0x14ea, 0x14eb, 0x7, 0x194, 0x2, 0x2, 0x14eb, 
       0x1502, 0x5, 0x294, 0x14b, 0xa, 0x14ec, 0x14ed, 0xc, 0x8, 0x2, 0x2, 
       0x14ed, 0x14ee, 0x9, 0x54, 0x2, 0x2, 0x14ee, 0x1502, 0x5, 0x294, 
       0x14b, 0x9, 0x14ef, 0x14f0, 0xc, 0x7, 0x2, 0x2, 0x14f0, 0x14f1, 0x9, 
       0x55, 0x2, 0x2, 0x14f1, 0x1502, 0x5, 0x294, 0x14b, 0x8, 0x14f2, 0x14f3, 
       0xc, 0x5, 0x2, 0x2, 0x14f3, 0x14f4, 0x9, 0x56, 0x2, 0x2, 0x14f4, 
       0x1502, 0x5, 0x294, 0x14b, 0x6, 0x14f5, 0x14f6, 0xc, 0x4, 0x2, 0x2, 
       0x14f6, 0x14f7, 0x7, 0x193, 0x2, 0x2, 0x14f7, 0x1502, 0x5, 0x294, 
       0x14b, 0x5, 0x14f8, 0x14f9, 0xc, 0x3, 0x2, 0x2, 0x14f9, 0x14fa, 0x7, 
       0x196, 0x2, 0x2, 0x14fa, 0x1502, 0x5, 0x294, 0x14b, 0x4, 0x14fb, 
       0x14fc, 0xc, 0x6, 0x2, 0x2, 0x14fc, 0x14fd, 0x9, 0x55, 0x2, 0x2, 
       0x14fd, 0x14fe, 0x7, 0x210, 0x2, 0x2, 0x14fe, 0x14ff, 0x5, 0x28a, 
       0x146, 0x2, 0x14ff, 0x1500, 0x5, 0x2e0, 0x171, 0x2, 0x1500, 0x1502, 
       0x3, 0x2, 0x2, 0x2, 0x1501, 0x14e9, 0x3, 0x2, 0x2, 0x2, 0x1501, 0x14ec, 
       0x3, 0x2, 0x2, 0x2, 0x1501, 0x14ef, 0x3, 0x2, 0x2, 0x2, 0x1501, 0x14f2, 
       0x3, 0x2, 0x2, 0x2, 0x1501, 0x14f5, 0x3, 0x2, 0x2, 0x2, 0x1501, 0x14f8, 
       0x3, 0x2, 0x2, 0x2, 0x1501, 0x14fb, 0x3, 0x2, 0x2, 0x2, 0x1502, 0x1505, 
       0x3, 0x2, 0x2, 0x2, 0x1503, 0x1501, 0x3, 0x2, 0x2, 0x2, 0x1503, 0x1504, 
       0x3, 0x2, 0x2, 0x2, 0x1504, 0x295, 0x3, 0x2, 0x2, 0x2, 0x1505, 0x1503, 
       0x3, 0x2, 0x2, 0x2, 0x1506, 0x1507, 0x8, 0x14c, 0x1, 0x2, 0x1507, 
       0x156c, 0x5, 0x2c8, 0x165, 0x2, 0x1508, 0x150a, 0x5, 0x3f0, 0x1f9, 
       0x2, 0x1509, 0x150b, 0x5, 0x298, 0x14d, 0x2, 0x150a, 0x1509, 0x3, 
       0x2, 0x2, 0x2, 0x150a, 0x150b, 0x3, 0x2, 0x2, 0x2, 0x150b, 0x156c, 
       0x3, 0x2, 0x2, 0x2, 0x150c, 0x156c, 0x5, 0x2b0, 0x159, 0x2, 0x150d, 
       0x156c, 0x5, 0x2c2, 0x162, 0x2, 0x150e, 0x156c, 0x5, 0x456, 0x22c, 
       0x2, 0x150f, 0x156c, 0x7, 0x1a6, 0x2, 0x2, 0x1510, 0x156c, 0x5, 0x29a, 
       0x14e, 0x2, 0x1511, 0x1512, 0x6, 0x14c, 0x92, 0x2, 0x1512, 0x156c, 
       0x5, 0x29c, 0x14f, 0x2, 0x1513, 0x1514, 0x6, 0x14c, 0x93, 0x2, 0x1514, 
       0x156c, 0x5, 0x29e, 0x150, 0x2, 0x1515, 0x1516, 0x9, 0x57, 0x2, 0x2, 
       0x1516, 0x156c, 0x5, 0x296, 0x14c, 0x10, 0x1517, 0x1518, 0x5, 0x2de, 
       0x170, 0x2, 0x1518, 0x1519, 0x5, 0x296, 0x14c, 0xf, 0x1519, 0x156c, 
       0x3, 0x2, 0x2, 0x2, 0x151a, 0x151c, 0x7, 0x12f, 0x2, 0x2, 0x151b, 
       0x151a, 0x3, 0x2, 0x2, 0x2, 0x151b, 0x151c, 0x3, 0x2, 0x2, 0x2, 0x151c, 
       0x151d, 0x3, 0x2, 0x2, 0x2, 0x151d, 0x151e, 0x7, 0x19b, 0x2, 0x2, 
       0x151e, 0x151f, 0x5, 0x2d8, 0x16d, 0x2, 0x151f, 0x1520, 0x7, 0x19c, 
       0x2, 0x2, 0x1520, 0x156c, 0x3, 0x2, 0x2, 0x2, 0x1521, 0x1523, 0x7, 
       0x1f2, 0x2, 0x2, 0x1522, 0x1521, 0x3, 0x2, 0x2, 0x2, 0x1522, 0x1523, 
       0x3, 0x2, 0x2, 0x2, 0x1523, 0x1524, 0x3, 0x2, 0x2, 0x2, 0x1524, 0x156c, 
       0x5, 0x118, 0x8d, 0x2, 0x1525, 0x1526, 0x7, 0x19d, 0x2, 0x2, 0x1526, 
       0x1527, 0x5, 0x442, 0x222, 0x2, 0x1527, 0x1528, 0x5, 0x28a, 0x146, 
       0x2, 0x1528, 0x1529, 0x7, 0x19e, 0x2, 0x2, 0x1529, 0x156c, 0x3, 0x2, 
       0x2, 0x2, 0x152a, 0x152b, 0x7, 0x22e, 0x2, 0x2, 0x152b, 0x152c, 0x5, 
       0x2aa, 0x156, 0x2, 0x152c, 0x152d, 0x7, 0x3e, 0x2, 0x2, 0x152d, 0x152e, 
       0x7, 0x19b, 0x2, 0x2, 0x152e, 0x1530, 0x5, 0x294, 0x14b, 0x2, 0x152f, 
       0x1531, 0x5, 0x2ae, 0x158, 0x2, 0x1530, 0x152f, 0x3, 0x2, 0x2, 0x2, 
       0x1530, 0x1531, 0x3, 0x2, 0x2, 0x2, 0x1531, 0x1532, 0x3, 0x2, 0x2, 
       0x2, 0x1532, 0x1533, 0x7, 0x19c, 0x2, 0x2, 0x1533, 0x156c, 0x3, 0x2, 
       0x2, 0x2, 0x1534, 0x1535, 0x7, 0x1b7, 0x2, 0x2, 0x1535, 0x156c, 0x5, 
       0x296, 0x14c, 0xa, 0x1536, 0x1537, 0x7, 0x1c2, 0x2, 0x2, 0x1537, 
       0x1538, 0x7, 0x19b, 0x2, 0x2, 0x1538, 0x1539, 0x5, 0x28a, 0x146, 
       0x2, 0x1539, 0x153a, 0x7, 0x1b1, 0x2, 0x2, 0x153a, 0x153b, 0x5, 0x2d6, 
       0x16c, 0x2, 0x153b, 0x153c, 0x7, 0x19c, 0x2, 0x2, 0x153c, 0x156c, 
       0x3, 0x2, 0x2, 0x2, 0x153d, 0x153f, 0x7, 0x1c1, 0x2, 0x2, 0x153e, 
       0x1540, 0x5, 0x28a, 0x146, 0x2, 0x153f, 0x153e, 0x3, 0x2, 0x2, 0x2, 
       0x153f, 0x1540, 0x3, 0x2, 0x2, 0x2, 0x1540, 0x1544, 0x3, 0x2, 0x2, 
       0x2, 0x1541, 0x1542, 0x5, 0x2d0, 0x169, 0x2, 0x1542, 0x1543, 0x5, 
       0x2d2, 0x16a, 0x2, 0x1543, 0x1545, 0x3, 0x2, 0x2, 0x2, 0x1544, 0x1541, 
       0x3, 0x2, 0x2, 0x2, 0x1545, 0x1546, 0x3, 0x2, 0x2, 0x2, 0x1546, 0x1544, 
       0x3, 0x2, 0x2, 0x2, 0x1546, 0x1547, 0x3, 0x2, 0x2, 0x2, 0x1547, 0x1549, 
       0x3, 0x2, 0x2, 0x2, 0x1548, 0x154a, 0x5, 0x2d4, 0x16b, 0x2, 0x1549, 
       0x1548, 0x3, 0x2, 0x2, 0x2, 0x1549, 0x154a, 0x3, 0x2, 0x2, 0x2, 0x154a, 
       0x154b, 0x3, 0x2, 0x2, 0x2, 0x154b, 0x154c, 0x7, 0x12, 0x2, 0x2, 
       0x154c, 0x156c, 0x3, 0x2, 0x2, 0x2, 0x154d, 0x154e, 0x7, 0x1cb, 0x2, 
       0x2, 0x154e, 0x154f, 0x7, 0x19b, 0x2, 0x2, 0x154f, 0x1550, 0x5, 0x28a, 
       0x146, 0x2, 0x1550, 0x1551, 0x7, 0x198, 0x2, 0x2, 0x1551, 0x1552, 
       0x5, 0x2d6, 0x16c, 0x2, 0x1552, 0x1553, 0x7, 0x19c, 0x2, 0x2, 0x1553, 
       0x156c, 0x3, 0x2, 0x2, 0x2, 0x1554, 0x1555, 0x7, 0x1cb, 0x2, 0x2, 
       0x1555, 0x1556, 0x7, 0x19b, 0x2, 0x2, 0x1556, 0x1557, 0x5, 0x28a, 
       0x146, 0x2, 0x1557, 0x1558, 0x7, 0x29b, 0x2, 0x2, 0x1558, 0x1559, 
       0x5, 0x384, 0x1c3, 0x2, 0x1559, 0x155a, 0x7, 0x19c, 0x2, 0x2, 0x155a, 
       0x156c, 0x3, 0x2, 0x2, 0x2, 0x155b, 0x155c, 0x7, 0x1e0, 0x2, 0x2, 
       0x155c, 0x155d, 0x7, 0x19b, 0x2, 0x2, 0x155d, 0x155e, 0x5, 0x44a, 
       0x226, 0x2, 0x155e, 0x155f, 0x7, 0x19c, 0x2, 0x2, 0x155f, 0x156c, 
       0x3, 0x2, 0x2, 0x2, 0x1560, 0x1561, 0x7, 0x2a0, 0x2, 0x2, 0x1561, 
       0x1562, 0x7, 0x19b, 0x2, 0x2, 0x1562, 0x1563, 0x5, 0x44a, 0x226, 
       0x2, 0x1563, 0x1564, 0x7, 0x19c, 0x2, 0x2, 0x1564, 0x156c, 0x3, 0x2, 
       0x2, 0x2, 0x1565, 0x1566, 0x7, 0x210, 0x2, 0x2, 0x1566, 0x1567, 0x5, 
       0x28a, 0x146, 0x2, 0x1567, 0x1568, 0x5, 0x2e0, 0x171, 0x2, 0x1568, 
       0x1569, 0x7, 0x189, 0x2, 0x2, 0x1569, 0x156a, 0x5, 0x28a, 0x146, 
       0x2, 0x156a, 0x156c, 0x3, 0x2, 0x2, 0x2, 0x156b, 0x1506, 0x3, 0x2, 
       0x2, 0x2, 0x156b, 0x1508, 0x3, 0x2, 0x2, 0x2, 0x156b, 0x150c, 0x3, 
       0x2, 0x2, 0x2, 0x156b, 0x150d, 0x3, 0x2, 0x2, 0x2, 0x156b, 0x150e, 
       0x3, 0x2, 0x2, 0x2, 0x156b, 0x150f, 0x3, 0x2, 0x2, 0x2, 0x156b, 0x1510, 
       0x3, 0x2, 0x2, 0x2, 0x156b, 0x1511, 0x3, 0x2, 0x2, 0x2, 0x156b, 0x1513, 
       0x3, 0x2, 0x2, 0x2, 0x156b, 0x1515, 0x3, 0x2, 0x2, 0x2, 0x156b, 0x1517, 
       0x3, 0x2, 0x2, 0x2, 0x156b, 0x151b, 0x3, 0x2, 0x2, 0x2, 0x156b, 0x1522, 
       0x3, 0x2, 0x2, 0x2, 0x156b, 0x1525, 0x3, 0x2, 0x2, 0x2, 0x156b, 0x152a, 
       0x3, 0x2, 0x2, 0x2, 0x156b, 0x1534, 0x3, 0x2, 0x2, 0x2, 0x156b, 0x1536, 
       0x3, 0x2, 0x2, 0x2, 0x156b, 0x153d, 0x3, 0x2, 0x2, 0x2, 0x156b, 0x154d, 
       0x3, 0x2, 0x2, 0x2, 0x156b, 0x1554, 0x3, 0x2, 0x2, 0x2, 0x156b, 0x155b, 
       0x3, 0x2, 0x2, 0x2, 0x156b, 0x1560, 0x3, 0x2, 0x2, 0x2, 0x156b, 0x1565, 
       0x3, 0x2, 0x2, 0x2, 0x156c, 0x1575, 0x3, 0x2, 0x2, 0x2, 0x156d, 0x156e, 
       0xc, 0x11, 0x2, 0x2, 0x156e, 0x156f, 0x7, 0x17d, 0x2, 0x2, 0x156f, 
       0x1574, 0x5, 0x296, 0x14c, 0x12, 0x1570, 0x1571, 0xc, 0x17, 0x2, 
       0x2, 0x1571, 0x1572, 0x7, 0x1c6, 0x2, 0x2, 0x1572, 0x1574, 0x5, 0x472, 
       0x23a, 0x2, 0x1573, 0x156d, 0x3, 0x2, 0x2, 0x2, 0x1573, 0x1570, 0x3, 
       0x2, 0x2, 0x2, 0x1574, 0x1577, 0x3, 0x2, 0x2, 0x2, 0x1575, 0x1573, 
       0x3, 0x2, 0x2, 0x2, 0x1575, 0x1576, 0x3, 0x2, 0x2, 0x2, 0x1576, 0x297, 
       0x3, 0x2, 0x2, 0x2, 0x1577, 0x1575, 0x3, 0x2, 0x2, 0x2, 0x1578, 0x1579, 
       0x6, 0x14d, 0x96, 0x2, 0x1579, 0x157a, 0x7, 0x1a0, 0x2, 0x2, 0x157a, 
       0x157f, 0x5, 0x45c, 0x22f, 0x2, 0x157b, 0x157c, 0x6, 0x14d, 0x97, 
       0x2, 0x157c, 0x157d, 0x7, 0x1a1, 0x2, 0x2, 0x157d, 0x157f, 0x5, 0x45c, 
       0x22f, 0x2, 0x157e, 0x1578, 0x3, 0x2, 0x2, 0x2, 0x157e, 0x157b, 0x3, 
       0x2, 0x2, 0x2, 0x157f, 0x299, 0x3, 0x2, 0x2, 0x2, 0x1580, 0x1581, 
       0x7, 0x48, 0x2, 0x2, 0x1581, 0x1583, 0x7, 0x19b, 0x2, 0x2, 0x1582, 
       0x1584, 0x7, 0x1e6, 0x2, 0x2, 0x1583, 0x1582, 0x3, 0x2, 0x2, 0x2, 
       0x1583, 0x1584, 0x3, 0x2, 0x2, 0x2, 0x1584, 0x1585, 0x3, 0x2, 0x2, 
       0x2, 0x1585, 0x1586, 0x5, 0x2a8, 0x155, 0x2, 0x1586, 0x1589, 0x7, 
       0x19c, 0x2, 0x2, 0x1587, 0x1588, 0x6, 0x14e, 0x98, 0x2, 0x1588, 0x158a, 
       0x5, 0x2a0, 0x151, 0x2, 0x1589, 0x1587, 0x3, 0x2, 0x2, 0x2, 0x1589, 
       0x158a, 0x3, 0x2, 0x2, 0x2, 0x158a, 0x1604, 0x3, 0x2, 0x2, 0x2, 0x158b, 
       0x158c, 0x9, 0x58, 0x2, 0x2, 0x158c, 0x158d, 0x7, 0x19b, 0x2, 0x2, 
       0x158d, 0x158e, 0x5, 0x2a8, 0x155, 0x2, 0x158e, 0x1591, 0x7, 0x19c, 
       0x2, 0x2, 0x158f, 0x1590, 0x6, 0x14e, 0x99, 0x2, 0x1590, 0x1592, 
       0x5, 0x2a0, 0x151, 0x2, 0x1591, 0x158f, 0x3, 0x2, 0x2, 0x2, 0x1591, 
       0x1592, 0x3, 0x2, 0x2, 0x2, 0x1592, 0x1604, 0x3, 0x2, 0x2, 0x2, 0x1593, 
       0x1594, 0x6, 0x14e, 0x9a, 0x2, 0x1594, 0x1604, 0x5, 0x2a6, 0x154, 
       0x2, 0x1595, 0x1596, 0x7, 0x1cc, 0x2, 0x2, 0x1596, 0x1598, 0x7, 0x19b, 
       0x2, 0x2, 0x1597, 0x1599, 0x7, 0x1ad, 0x2, 0x2, 0x1598, 0x1597, 0x3, 
       0x2, 0x2, 0x2, 0x1598, 0x1599, 0x3, 0x2, 0x2, 0x2, 0x1599, 0x159a, 
       0x3, 0x2, 0x2, 0x2, 0x159a, 0x159b, 0x7, 0x18b, 0x2, 0x2, 0x159b, 
       0x159e, 0x7, 0x19c, 0x2, 0x2, 0x159c, 0x159d, 0x6, 0x14e, 0x9b, 0x2, 
       0x159d, 0x159f, 0x5, 0x2a0, 0x151, 0x2, 0x159e, 0x159c, 0x3, 0x2, 
       0x2, 0x2, 0x159e, 0x159f, 0x3, 0x2, 0x2, 0x2, 0x159f, 0x1604, 0x3, 
       0x2, 0x2, 0x2, 0x15a0, 0x15a1, 0x7, 0x1cc, 0x2, 0x2, 0x15a1, 0x15a9, 
       0x7, 0x19b, 0x2, 0x2, 0x15a2, 0x15a4, 0x7, 0x1ad, 0x2, 0x2, 0x15a3, 
       0x15a2, 0x3, 0x2, 0x2, 0x2, 0x15a3, 0x15a4, 0x3, 0x2, 0x2, 0x2, 0x15a4, 
       0x15a5, 0x3, 0x2, 0x2, 0x2, 0x15a5, 0x15aa, 0x7, 0x18b, 0x2, 0x2, 
       0x15a6, 0x15aa, 0x5, 0x2a8, 0x155, 0x2, 0x15a7, 0x15a8, 0x7, 0x1e6, 
       0x2, 0x2, 0x15a8, 0x15aa, 0x5, 0x2d8, 0x16d, 0x2, 0x15a9, 0x15a3, 
       0x3, 0x2, 0x2, 0x2, 0x15a9, 0x15a6, 0x3, 0x2, 0x2, 0x2, 0x15a9, 0x15a7, 
       0x3, 0x2, 0x2, 0x2, 0x15aa, 0x15ab, 0x3, 0x2, 0x2, 0x2, 0x15ab, 0x15ae, 
       0x7, 0x19c, 0x2, 0x2, 0x15ac, 0x15ad, 0x6, 0x14e, 0x9c, 0x2, 0x15ad, 
       0x15af, 0x5, 0x2a0, 0x151, 0x2, 0x15ae, 0x15ac, 0x3, 0x2, 0x2, 0x2, 
       0x15ae, 0x15af, 0x3, 0x2, 0x2, 0x2, 0x15af, 0x1604, 0x3, 0x2, 0x2, 
       0x2, 0x15b0, 0x15b1, 0x7, 0x237, 0x2, 0x2, 0x15b1, 0x15b3, 0x7, 0x19b, 
       0x2, 0x2, 0x15b2, 0x15b4, 0x7, 0x1e6, 0x2, 0x2, 0x15b3, 0x15b2, 0x3, 
       0x2, 0x2, 0x2, 0x15b3, 0x15b4, 0x3, 0x2, 0x2, 0x2, 0x15b4, 0x15b5, 
       0x3, 0x2, 0x2, 0x2, 0x15b5, 0x15b6, 0x5, 0x2a8, 0x155, 0x2, 0x15b6, 
       0x15b9, 0x7, 0x19c, 0x2, 0x2, 0x15b7, 0x15b8, 0x6, 0x14e, 0x9d, 0x2, 
       0x15b8, 0x15ba, 0x5, 0x2a0, 0x151, 0x2, 0x15b9, 0x15b7, 0x3, 0x2, 
       0x2, 0x2, 0x15b9, 0x15ba, 0x3, 0x2, 0x2, 0x2, 0x15ba, 0x1604, 0x3, 
       0x2, 0x2, 0x2, 0x15bb, 0x15bc, 0x7, 0x22f, 0x2, 0x2, 0x15bc, 0x15be, 
       0x7, 0x19b, 0x2, 0x2, 0x15bd, 0x15bf, 0x7, 0x1e6, 0x2, 0x2, 0x15be, 
       0x15bd, 0x3, 0x2, 0x2, 0x2, 0x15be, 0x15bf, 0x3, 0x2, 0x2, 0x2, 0x15bf, 
       0x15c0, 0x3, 0x2, 0x2, 0x2, 0x15c0, 0x15c1, 0x5, 0x2a8, 0x155, 0x2, 
       0x15c1, 0x15c4, 0x7, 0x19c, 0x2, 0x2, 0x15c2, 0x15c3, 0x6, 0x14e, 
       0x9e, 0x2, 0x15c3, 0x15c5, 0x5, 0x2a0, 0x151, 0x2, 0x15c4, 0x15c2, 
       0x3, 0x2, 0x2, 0x2, 0x15c4, 0x15c5, 0x3, 0x2, 0x2, 0x2, 0x15c5, 0x1604, 
       0x3, 0x2, 0x2, 0x2, 0x15c6, 0x15c7, 0x7, 0x27f, 0x2, 0x2, 0x15c7, 
       0x15c8, 0x7, 0x19b, 0x2, 0x2, 0x15c8, 0x15c9, 0x5, 0x2a8, 0x155, 
       0x2, 0x15c9, 0x15cc, 0x7, 0x19c, 0x2, 0x2, 0x15ca, 0x15cb, 0x6, 0x14e, 
       0x9f, 0x2, 0x15cb, 0x15cd, 0x5, 0x2a0, 0x151, 0x2, 0x15cc, 0x15ca, 
       0x3, 0x2, 0x2, 0x2, 0x15cc, 0x15cd, 0x3, 0x2, 0x2, 0x2, 0x15cd, 0x1604, 
       0x3, 0x2, 0x2, 0x2, 0x15ce, 0x15cf, 0x7, 0x2a3, 0x2, 0x2, 0x15cf, 
       0x15d0, 0x7, 0x19b, 0x2, 0x2, 0x15d0, 0x15d1, 0x5, 0x2a8, 0x155, 
       0x2, 0x15d1, 0x15d4, 0x7, 0x19c, 0x2, 0x2, 0x15d2, 0x15d3, 0x6, 0x14e, 
       0xa0, 0x2, 0x15d3, 0x15d5, 0x5, 0x2a0, 0x151, 0x2, 0x15d4, 0x15d2, 
       0x3, 0x2, 0x2, 0x2, 0x15d4, 0x15d5, 0x3, 0x2, 0x2, 0x2, 0x15d5, 0x1604, 
       0x3, 0x2, 0x2, 0x2, 0x15d6, 0x15d7, 0x7, 0x27c, 0x2, 0x2, 0x15d7, 
       0x15d8, 0x7, 0x19b, 0x2, 0x2, 0x15d8, 0x15d9, 0x5, 0x2a8, 0x155, 
       0x2, 0x15d9, 0x15dc, 0x7, 0x19c, 0x2, 0x2, 0x15da, 0x15db, 0x6, 0x14e, 
       0xa1, 0x2, 0x15db, 0x15dd, 0x5, 0x2a0, 0x151, 0x2, 0x15dc, 0x15da, 
       0x3, 0x2, 0x2, 0x2, 0x15dc, 0x15dd, 0x3, 0x2, 0x2, 0x2, 0x15dd, 0x1604, 
       0x3, 0x2, 0x2, 0x2, 0x15de, 0x15df, 0x7, 0x2a6, 0x2, 0x2, 0x15df, 
       0x15e0, 0x7, 0x19b, 0x2, 0x2, 0x15e0, 0x15e1, 0x5, 0x2a8, 0x155, 
       0x2, 0x15e1, 0x15e4, 0x7, 0x19c, 0x2, 0x2, 0x15e2, 0x15e3, 0x6, 0x14e, 
       0xa2, 0x2, 0x15e3, 0x15e5, 0x5, 0x2a0, 0x151, 0x2, 0x15e4, 0x15e2, 
       0x3, 0x2, 0x2, 0x2, 0x15e4, 0x15e5, 0x3, 0x2, 0x2, 0x2, 0x15e5, 0x1604, 
       0x3, 0x2, 0x2, 0x2, 0x15e6, 0x15e7, 0x7, 0x284, 0x2, 0x2, 0x15e7, 
       0x15e9, 0x7, 0x19b, 0x2, 0x2, 0x15e8, 0x15ea, 0x7, 0x1e6, 0x2, 0x2, 
       0x15e9, 0x15e8, 0x3, 0x2, 0x2, 0x2, 0x15e9, 0x15ea, 0x3, 0x2, 0x2, 
       0x2, 0x15ea, 0x15eb, 0x3, 0x2, 0x2, 0x2, 0x15eb, 0x15ec, 0x5, 0x2a8, 
       0x155, 0x2, 0x15ec, 0x15ef, 0x7, 0x19c, 0x2, 0x2, 0x15ed, 0x15ee, 
       0x6, 0x14e, 0xa3, 0x2, 0x15ee, 0x15f0, 0x5, 0x2a0, 0x151, 0x2, 0x15ef, 
       0x15ed, 0x3, 0x2, 0x2, 0x2, 0x15ef, 0x15f0, 0x3, 0x2, 0x2, 0x2, 0x15f0, 
       0x1604, 0x3, 0x2, 0x2, 0x2, 0x15f1, 0x15f2, 0x7, 0x202, 0x2, 0x2, 
       0x15f2, 0x15f4, 0x7, 0x19b, 0x2, 0x2, 0x15f3, 0x15f5, 0x7, 0x1e6, 
       0x2, 0x2, 0x15f4, 0x15f3, 0x3, 0x2, 0x2, 0x2, 0x15f4, 0x15f5, 0x3, 
       0x2, 0x2, 0x2, 0x15f5, 0x15f6, 0x3, 0x2, 0x2, 0x2, 0x15f6, 0x15f8, 
       0x5, 0x2d8, 0x16d, 0x2, 0x15f7, 0x15f9, 0x5, 0x148, 0xa5, 0x2, 0x15f8, 
       0x15f7, 0x3, 0x2, 0x2, 0x2, 0x15f8, 0x15f9, 0x3, 0x2, 0x2, 0x2, 0x15f9, 
       0x15fc, 0x3, 0x2, 0x2, 0x2, 0x15fa, 0x15fb, 0x7, 0x269, 0x2, 0x2, 
       0x15fb, 0x15fd, 0x5, 0x45e, 0x230, 0x2, 0x15fc, 0x15fa, 0x3, 0x2, 
       0x2, 0x2, 0x15fc, 0x15fd, 0x3, 0x2, 0x2, 0x2, 0x15fd, 0x15fe, 0x3, 
       0x2, 0x2, 0x2, 0x15fe, 0x1601, 0x7, 0x19c, 0x2, 0x2, 0x15ff, 0x1600, 
       0x6, 0x14e, 0xa4, 0x2, 0x1600, 0x1602, 0x5, 0x2a0, 0x151, 0x2, 0x1601, 
       0x15ff, 0x3, 0x2, 0x2, 0x2, 0x1601, 0x1602, 0x3, 0x2, 0x2, 0x2, 0x1602, 
       0x1604, 0x3, 0x2, 0x2, 0x2, 0x1603, 0x1580, 0x3, 0x2, 0x2, 0x2, 0x1603, 
       0x158b, 0x3, 0x2, 0x2, 0x2, 0x1603, 0x1593, 0x3, 0x2, 0x2, 0x2, 0x1603, 
       0x1595, 0x3, 0x2, 0x2, 0x2, 0x1603, 0x15a0, 0x3, 0x2, 0x2, 0x2, 0x1603, 
       0x15b0, 0x3, 0x2, 0x2, 0x2, 0x1603, 0x15bb, 0x3, 0x2, 0x2, 0x2, 0x1603, 
       0x15c6, 0x3, 0x2, 0x2, 0x2, 0x1603, 0x15ce, 0x3, 0x2, 0x2, 0x2, 0x1603, 
       0x15d6, 0x3, 0x2, 0x2, 0x2, 0x1603, 0x15de, 0x3, 0x2, 0x2, 0x2, 0x1603, 
       0x15e6, 0x3, 0x2, 0x2, 0x2, 0x1603, 0x15f1, 0x3, 0x2, 0x2, 0x2, 0x1604, 
       0x29b, 0x3, 0x2, 0x2, 0x2, 0x1605, 0x1606, 0x7, 0x2c1, 0x2, 0x2, 
       0x1606, 0x1607, 0x7, 0x19b, 0x2, 0x2, 0x1607, 0x1608, 0x5, 0x2d8, 
       0x16d, 0x2, 0x1608, 0x1609, 0x7, 0x19c, 0x2, 0x2, 0x1609, 0x29d, 
       0x3, 0x2, 0x2, 0x2, 0x160a, 0x160b, 0x9, 0x59, 0x2, 0x2, 0x160b, 
       0x160c, 0x5, 0x478, 0x23d, 0x2, 0x160c, 0x160d, 0x5, 0x2a0, 0x151, 
       0x2, 0x160d, 0x1637, 0x3, 0x2, 0x2, 0x2, 0x160e, 0x160f, 0x7, 0x2d1, 
       0x2, 0x2, 0x160f, 0x1610, 0x7, 0x19b, 0x2, 0x2, 0x1610, 0x1611, 0x5, 
       0x296, 0x14c, 0x2, 0x1611, 0x1612, 0x7, 0x19c, 0x2, 0x2, 0x1612, 
       0x1613, 0x5, 0x2a0, 0x151, 0x2, 0x1613, 0x1637, 0x3, 0x2, 0x2, 0x2, 
       0x1614, 0x1615, 0x9, 0x5a, 0x2, 0x2, 0x1615, 0x1616, 0x7, 0x19b, 
       0x2, 0x2, 0x1616, 0x1618, 0x5, 0x28a, 0x146, 0x2, 0x1617, 0x1619, 
       0x5, 0x2a2, 0x152, 0x2, 0x1618, 0x1617, 0x3, 0x2, 0x2, 0x2, 0x1618, 
       0x1619, 0x3, 0x2, 0x2, 0x2, 0x1619, 0x161a, 0x3, 0x2, 0x2, 0x2, 0x161a, 
       0x161c, 0x7, 0x19c, 0x2, 0x2, 0x161b, 0x161d, 0x5, 0x2a4, 0x153, 
       0x2, 0x161c, 0x161b, 0x3, 0x2, 0x2, 0x2, 0x161c, 0x161d, 0x3, 0x2, 
       0x2, 0x2, 0x161d, 0x161e, 0x3, 0x2, 0x2, 0x2, 0x161e, 0x161f, 0x5, 
       0x2a0, 0x151, 0x2, 0x161f, 0x1637, 0x3, 0x2, 0x2, 0x2, 0x1620, 0x1621, 
       0x9, 0x5b, 0x2, 0x2, 0x1621, 0x1623, 0x5, 0x2e6, 0x174, 0x2, 0x1622, 
       0x1624, 0x5, 0x2a4, 0x153, 0x2, 0x1623, 0x1622, 0x3, 0x2, 0x2, 0x2, 
       0x1623, 0x1624, 0x3, 0x2, 0x2, 0x2, 0x1624, 0x1625, 0x3, 0x2, 0x2, 
       0x2, 0x1625, 0x1626, 0x5, 0x2a0, 0x151, 0x2, 0x1626, 0x1637, 0x3, 
       0x2, 0x2, 0x2, 0x1627, 0x1628, 0x7, 0x2d0, 0x2, 0x2, 0x1628, 0x1629, 
       0x7, 0x19b, 0x2, 0x2, 0x1629, 0x162a, 0x5, 0x28a, 0x146, 0x2, 0x162a, 
       0x162b, 0x7, 0x198, 0x2, 0x2, 0x162b, 0x162c, 0x5, 0x296, 0x14c, 
       0x2, 0x162c, 0x162f, 0x7, 0x19c, 0x2, 0x2, 0x162d, 0x162e, 0x7, 0x1fc, 
       0x2, 0x2, 0x162e, 0x1630, 0x9, 0x5c, 0x2, 0x2, 0x162f, 0x162d, 0x3, 
       0x2, 0x2, 0x2, 0x162f, 0x1630, 0x3, 0x2, 0x2, 0x2, 0x1630, 0x1632, 
       0x3, 0x2, 0x2, 0x2, 0x1631, 0x1633, 0x5, 0x2a4, 0x153, 0x2, 0x1632, 
       0x1631, 0x3, 0x2, 0x2, 0x2, 0x1632, 0x1633, 0x3, 0x2, 0x2, 0x2, 0x1633, 
       0x1634, 0x3, 0x2, 0x2, 0x2, 0x1634, 0x1635, 0x5, 0x2a0, 0x151, 0x2, 
       0x1635, 0x1637, 0x3, 0x2, 0x2, 0x2, 0x1636, 0x160a, 0x3, 0x2, 0x2, 
       0x2, 0x1636, 0x160e, 0x3, 0x2, 0x2, 0x2, 0x1636, 0x1614, 0x3, 0x2, 
       0x2, 0x2, 0x1636, 0x1620, 0x3, 0x2, 0x2, 0x2, 0x1636, 0x1627, 0x3, 
       0x2, 0x2, 0x2, 0x1637, 0x29f, 0x3, 0x2, 0x2, 0x2, 0x1638, 0x163b, 
       0x7, 0x2d4, 0x2, 0x2, 0x1639, 0x163c, 0x5, 0x43e, 0x220, 0x2, 0x163a, 
       0x163c, 0x5, 0x12e, 0x98, 0x2, 0x163b, 0x1639, 0x3, 0x2, 0x2, 0x2, 
       0x163b, 0x163a, 0x3, 0x2, 0x2, 0x2, 0x163c, 0x2a1, 0x3, 0x2, 0x2, 
       0x2, 0x163d, 0x1640, 0x7, 0x198, 0x2, 0x2, 0x163e, 0x1641, 0x5, 0x452, 
       0x22a, 0x2, 0x163f, 0x1641, 0x7, 0x1a6, 0x2, 0x2, 0x1640, 0x163e, 
       0x3, 0x2, 0x2, 0x2, 0x1640, 0x163f, 0x3, 0x2, 0x2, 0x2, 0x1641, 0x1644, 
       0x3, 0x2, 0x2, 0x2, 0x1642, 0x1643, 0x7, 0x198, 0x2, 0x2, 0x1643, 
       0x1645, 0x5, 0x28a, 0x146, 0x2, 0x1644, 0x1642, 0x3, 0x2, 0x2, 0x2, 
       0x1644, 0x1645, 0x3, 0x2, 0x2, 0x2, 0x1645, 0x2a3, 0x3, 0x2, 0x2, 
       0x2, 0x1646, 0x1647, 0x9, 0x5d, 0x2, 0x2, 0x1647, 0x1648, 0x7, 0x2d2, 
       0x2, 0x2, 0x1648, 0x2a5, 0x3, 0x2, 0x2, 0x2, 0x1649, 0x164a, 0x7, 
       0x2bc, 0x2, 0x2, 0x164a, 0x164b, 0x7, 0x19b, 0x2, 0x2, 0x164b, 0x164c, 
       0x5, 0x2a8, 0x155, 0x2, 0x164c, 0x164e, 0x7, 0x19c, 0x2, 0x2, 0x164d, 
       0x164f, 0x5, 0x2a0, 0x151, 0x2, 0x164e, 0x164d, 0x3, 0x2, 0x2, 0x2, 
       0x164e, 0x164f, 0x3, 0x2, 0x2, 0x2, 0x164f, 0x165a, 0x3, 0x2, 0x2, 
       0x2, 0x1650, 0x1651, 0x7, 0x2bb, 0x2, 0x2, 0x1651, 0x1652, 0x7, 0x19b, 
       0x2, 0x2, 0x1652, 0x1653, 0x5, 0x2a8, 0x155, 0x2, 0x1653, 0x1654, 
       0x7, 0x198, 0x2, 0x2, 0x1654, 0x1655, 0x5, 0x2a8, 0x155, 0x2, 0x1655, 
       0x1657, 0x7, 0x19c, 0x2, 0x2, 0x1656, 0x1658, 0x5, 0x2a0, 0x151, 
       0x2, 0x1657, 0x1656, 0x3, 0x2, 0x2, 0x2, 0x1657, 0x1658, 0x3, 0x2, 
       0x2, 0x2, 0x1658, 0x165a, 0x3, 0x2, 0x2, 0x2, 0x1659, 0x1649, 0x3, 
       0x2, 0x2, 0x2, 0x1659, 0x1650, 0x3, 0x2, 0x2, 0x2, 0x165a, 0x2a7, 
       0x3, 0x2, 0x2, 0x2, 0x165b, 0x165d, 0x7, 0x1ad, 0x2, 0x2, 0x165c, 
       0x165b, 0x3, 0x2, 0x2, 0x2, 0x165c, 0x165d, 0x3, 0x2, 0x2, 0x2, 0x165d, 
       0x165e, 0x3, 0x2, 0x2, 0x2, 0x165e, 0x165f, 0x5, 0x28a, 0x146, 0x2, 
       0x165f, 0x2a9, 0x3, 0x2, 0x2, 0x2, 0x1660, 0x1666, 0x5, 0x2ac, 0x157, 
       0x2, 0x1661, 0x1662, 0x7, 0x19b, 0x2, 0x2, 0x1662, 0x1663, 0x5, 0x2ac, 
       0x157, 0x2, 0x1663, 0x1664, 0x7, 0x19c, 0x2, 0x2, 0x1664, 0x1666, 
       0x3, 0x2, 0x2, 0x2, 0x1665, 0x1660, 0x3, 0x2, 0x2, 0x2, 0x1665, 0x1661, 
       0x3, 0x2, 0x2, 0x2, 0x1666, 0x2ab, 0x3, 0x2, 0x2, 0x2, 0x1667, 0x166c, 
       0x5, 0x44a, 0x226, 0x2, 0x1668, 0x1669, 0x7, 0x198, 0x2, 0x2, 0x1669, 
       0x166b, 0x5, 0x44a, 0x226, 0x2, 0x166a, 0x1668, 0x3, 0x2, 0x2, 0x2, 
       0x166b, 0x166e, 0x3, 0x2, 0x2, 0x2, 0x166c, 0x166a, 0x3, 0x2, 0x2, 
       0x2, 0x166c, 0x166d, 0x3, 0x2, 0x2, 0x2, 0x166d, 0x2ad, 0x3, 0x2, 
       0x2, 0x2, 0x166e, 0x166c, 0x3, 0x2, 0x2, 0x2, 0x166f, 0x1670, 0x7, 
       0x213, 0x2, 0x2, 0x1670, 0x1671, 0x7, 0x4d, 0x2, 0x2, 0x1671, 0x167f, 
       0x7, 0xe0, 0x2, 0x2, 0x1672, 0x1673, 0x7, 0x213, 0x2, 0x2, 0x1673, 
       0x1674, 0x7, 0x23a, 0x2, 0x2, 0x1674, 0x1675, 0x7, 0x1c, 0x2, 0x2, 
       0x1675, 0x1679, 0x7, 0xe0, 0x2, 0x2, 0x1676, 0x1677, 0x7, 0x2ab, 
       0x2, 0x2, 0x1677, 0x1678, 0x7, 0x10d, 0x2, 0x2, 0x1678, 0x167a, 0x7, 
       0x8a, 0x2, 0x2, 0x1679, 0x1676, 0x3, 0x2, 0x2, 0x2, 0x1679, 0x167a, 
       0x3, 0x2, 0x2, 0x2, 0x167a, 0x167f, 0x3, 0x2, 0x2, 0x2, 0x167b, 0x167c, 
       0x7, 0x2ab, 0x2, 0x2, 0x167c, 0x167d, 0x7, 0x10d, 0x2, 0x2, 0x167d, 
       0x167f, 0x7, 0x8a, 0x2, 0x2, 0x167e, 0x166f, 0x3, 0x2, 0x2, 0x2, 
       0x167e, 0x1672, 0x3, 0x2, 0x2, 0x2, 0x167e, 0x167b, 0x3, 0x2, 0x2, 
       0x2, 0x167f, 0x2af, 0x3, 0x2, 0x2, 0x2, 0x1680, 0x1681, 0x7, 0x1c4, 
       0x2, 0x2, 0x1681, 0x1682, 0x7, 0x19b, 0x2, 0x2, 0x1682, 0x1685, 0x5, 
       0x2d8, 0x16d, 0x2, 0x1683, 0x1684, 0x7, 0x29b, 0x2, 0x2, 0x1684, 
       0x1686, 0x5, 0x384, 0x1c3, 0x2, 0x1685, 0x1683, 0x3, 0x2, 0x2, 0x2, 
       0x1685, 0x1686, 0x3, 0x2, 0x2, 0x2, 0x1686, 0x1687, 0x3, 0x2, 0x2, 
       0x2, 0x1687, 0x1688, 0x7, 0x19c, 0x2, 0x2, 0x1688, 0x1793, 0x3, 0x2, 
       0x2, 0x2, 0x1689, 0x168b, 0x7, 0x1d2, 0x2, 0x2, 0x168a, 0x168c, 0x5, 
       0x478, 0x23d, 0x2, 0x168b, 0x168a, 0x3, 0x2, 0x2, 0x2, 0x168b, 0x168c, 
       0x3, 0x2, 0x2, 0x2, 0x168c, 0x1793, 0x3, 0x2, 0x2, 0x2, 0x168d, 0x168e, 
       0x7, 0x72, 0x2, 0x2, 0x168e, 0x1793, 0x5, 0x2e6, 0x174, 0x2, 0x168f, 
       0x1690, 0x7, 0x73, 0x2, 0x2, 0x1690, 0x1793, 0x5, 0x2e6, 0x174, 0x2, 
       0x1691, 0x1692, 0x7, 0xa0, 0x2, 0x2, 0x1692, 0x1793, 0x5, 0x2e6, 
       0x174, 0x2, 0x1693, 0x1694, 0x7, 0x20f, 0x2, 0x2, 0x1694, 0x1695, 
       0x7, 0x19b, 0x2, 0x2, 0x1695, 0x1696, 0x5, 0x28a, 0x146, 0x2, 0x1696, 
       0x1697, 0x7, 0x198, 0x2, 0x2, 0x1697, 0x1698, 0x5, 0x28a, 0x146, 
       0x2, 0x1698, 0x1699, 0x7, 0x198, 0x2, 0x2, 0x1699, 0x169a, 0x5, 0x28a, 
       0x146, 0x2, 0x169a, 0x169b, 0x7, 0x198, 0x2, 0x2, 0x169b, 0x169c, 
       0x5, 0x28a, 0x146, 0x2, 0x169c, 0x169d, 0x7, 0x19c, 0x2, 0x2, 0x169d, 
       0x1793, 0x3, 0x2, 0x2, 0x2, 0x169e, 0x169f, 0x7, 0x210, 0x2, 0x2, 
       0x169f, 0x16a0, 0x7, 0x19b, 0x2, 0x2, 0x16a0, 0x16a3, 0x5, 0x28a, 
       0x146, 0x2, 0x16a1, 0x16a2, 0x7, 0x198, 0x2, 0x2, 0x16a2, 0x16a4, 
       0x5, 0x28a, 0x146, 0x2, 0x16a3, 0x16a1, 0x3, 0x2, 0x2, 0x2, 0x16a4, 
       0x16a5, 0x3, 0x2, 0x2, 0x2, 0x16a5, 0x16a3, 0x3, 0x2, 0x2, 0x2, 0x16a5, 
       0x16a6, 0x3, 0x2, 0x2, 0x2, 0x16a6, 0x16a7, 0x3, 0x2, 0x2, 0x2, 0x16a7, 
       0x16a8, 0x7, 0x19c, 0x2, 0x2, 0x16a8, 0x1793, 0x3, 0x2, 0x2, 0x2, 
       0x16a9, 0x16aa, 0x7, 0x21e, 0x2, 0x2, 0x16aa, 0x16ab, 0x7, 0x19b, 
       0x2, 0x2, 0x16ab, 0x16ac, 0x5, 0x28a, 0x146, 0x2, 0x16ac, 0x16ad, 
       0x7, 0x198, 0x2, 0x2, 0x16ad, 0x16ae, 0x5, 0x28a, 0x146, 0x2, 0x16ae, 
       0x16af, 0x7, 0x19c, 0x2, 0x2, 0x16af, 0x1793, 0x3, 0x2, 0x2, 0x2, 
       0x16b0, 0x16b1, 0x7, 0xdd, 0x2, 0x2, 0x16b1, 0x1793, 0x5, 0x2e6, 
       0x174, 0x2, 0x16b2, 0x16b3, 0x7, 0xe1, 0x2, 0x2, 0x16b3, 0x1793, 
       0x5, 0x2e6, 0x174, 0x2, 0x16b4, 0x16b5, 0x7, 0x265, 0x2, 0x2, 0x16b5, 
       0x16b6, 0x7, 0x19b, 0x2, 0x2, 0x16b6, 0x16b7, 0x5, 0x28a, 0x146, 
       0x2, 0x16b7, 0x16b8, 0x7, 0x198, 0x2, 0x2, 0x16b8, 0x16b9, 0x5, 0x28a, 
       0x146, 0x2, 0x16b9, 0x16ba, 0x7, 0x19c, 0x2, 0x2, 0x16ba, 0x1793, 
       0x3, 0x2, 0x2, 0x2, 0x16bb, 0x16bc, 0x7, 0x133, 0x2, 0x2, 0x16bc, 
       0x1793, 0x5, 0x2e6, 0x174, 0x2, 0x16bd, 0x16be, 0x7, 0x162, 0x2, 
       0x2, 0x16be, 0x1793, 0x5, 0x2e6, 0x174, 0x2, 0x16bf, 0x16c0, 0x7, 
       0x15f, 0x2, 0x2, 0x16c0, 0x16c1, 0x7, 0x19b, 0x2, 0x2, 0x16c1, 0x16c4, 
       0x5, 0x28a, 0x146, 0x2, 0x16c2, 0x16c3, 0x7, 0x198, 0x2, 0x2, 0x16c3, 
       0x16c5, 0x5, 0x28a, 0x146, 0x2, 0x16c4, 0x16c2, 0x3, 0x2, 0x2, 0x2, 
       0x16c4, 0x16c5, 0x3, 0x2, 0x2, 0x2, 0x16c5, 0x16c6, 0x3, 0x2, 0x2, 
       0x2, 0x16c6, 0x16c7, 0x7, 0x19c, 0x2, 0x2, 0x16c7, 0x1793, 0x3, 0x2, 
       0x2, 0x2, 0x16c8, 0x1793, 0x5, 0x2be, 0x160, 0x2, 0x16c9, 0x16ca, 
       0x7, 0x16e, 0x2, 0x2, 0x16ca, 0x1793, 0x5, 0x478, 0x23d, 0x2, 0x16cb, 
       0x16cc, 0x7, 0x2a0, 0x2, 0x2, 0x16cc, 0x1793, 0x5, 0x2e6, 0x174, 
       0x2, 0x16cd, 0x16ce, 0x7, 0x17b, 0x2, 0x2, 0x16ce, 0x1793, 0x5, 0x2e6, 
       0x174, 0x2, 0x16cf, 0x16d0, 0x9, 0x5e, 0x2, 0x2, 0x16d0, 0x16d1, 
       0x7, 0x19b, 0x2, 0x2, 0x16d1, 0x16d2, 0x5, 0x28a, 0x146, 0x2, 0x16d2, 
       0x16d8, 0x7, 0x198, 0x2, 0x2, 0x16d3, 0x16d9, 0x5, 0x28a, 0x146, 
       0x2, 0x16d4, 0x16d5, 0x7, 0x210, 0x2, 0x2, 0x16d5, 0x16d6, 0x5, 0x28a, 
       0x146, 0x2, 0x16d6, 0x16d7, 0x5, 0x2e0, 0x171, 0x2, 0x16d7, 0x16d9, 
       0x3, 0x2, 0x2, 0x2, 0x16d8, 0x16d3, 0x3, 0x2, 0x2, 0x2, 0x16d8, 0x16d4, 
       0x3, 0x2, 0x2, 0x2, 0x16d9, 0x16da, 0x3, 0x2, 0x2, 0x2, 0x16da, 0x16db, 
       0x7, 0x19c, 0x2, 0x2, 0x16db, 0x1793, 0x3, 0x2, 0x2, 0x2, 0x16dc, 
       0x16de, 0x7, 0x1cf, 0x2, 0x2, 0x16dd, 0x16df, 0x5, 0x478, 0x23d, 
       0x2, 0x16de, 0x16dd, 0x3, 0x2, 0x2, 0x2, 0x16de, 0x16df, 0x3, 0x2, 
       0x2, 0x2, 0x16df, 0x1793, 0x3, 0x2, 0x2, 0x2, 0x16e0, 0x16e2, 0x7, 
       0x1d4, 0x2, 0x2, 0x16e1, 0x16e3, 0x5, 0x2b4, 0x15b, 0x2, 0x16e2, 
       0x16e1, 0x3, 0x2, 0x2, 0x2, 0x16e2, 0x16e3, 0x3, 0x2, 0x2, 0x2, 0x16e3, 
       0x1793, 0x3, 0x2, 0x2, 0x2, 0x16e4, 0x16e5, 0x9, 0x5f, 0x2, 0x2, 
       0x16e5, 0x16e6, 0x7, 0x19b, 0x2, 0x2, 0x16e6, 0x16e7, 0x5, 0x28a, 
       0x146, 0x2, 0x16e7, 0x16e8, 0x7, 0x198, 0x2, 0x2, 0x16e8, 0x16e9, 
       0x7, 0x210, 0x2, 0x2, 0x16e9, 0x16ea, 0x5, 0x28a, 0x146, 0x2, 0x16ea, 
       0x16eb, 0x5, 0x2e0, 0x171, 0x2, 0x16eb, 0x16ec, 0x7, 0x19c, 0x2, 
       0x2, 0x16ec, 0x1793, 0x3, 0x2, 0x2, 0x2, 0x16ed, 0x16ee, 0x7, 0x1f5, 
       0x2, 0x2, 0x16ee, 0x16ef, 0x7, 0x19b, 0x2, 0x2, 0x16ef, 0x16f0, 0x5, 
       0x2e0, 0x171, 0x2, 0x16f0, 0x16f1, 0x7, 0x1fc, 0x2, 0x2, 0x16f1, 
       0x16f2, 0x5, 0x28a, 0x146, 0x2, 0x16f2, 0x16f3, 0x7, 0x19c, 0x2, 
       0x2, 0x16f3, 0x1793, 0x3, 0x2, 0x2, 0x2, 0x16f4, 0x16f5, 0x7, 0x9b, 
       0x2, 0x2, 0x16f5, 0x16f6, 0x7, 0x19b, 0x2, 0x2, 0x16f6, 0x16f7, 0x5, 
       0x2bc, 0x15f, 0x2, 0x16f7, 0x16f8, 0x7, 0x198, 0x2, 0x2, 0x16f8, 
       0x16f9, 0x5, 0x28a, 0x146, 0x2, 0x16f9, 0x16fa, 0x7, 0x19c, 0x2, 
       0x2, 0x16fa, 0x1793, 0x3, 0x2, 0x2, 0x2, 0x16fb, 0x16fd, 0x7, 0x23f, 
       0x2, 0x2, 0x16fc, 0x16fe, 0x5, 0x2b4, 0x15b, 0x2, 0x16fd, 0x16fc, 
       0x3, 0x2, 0x2, 0x2, 0x16fd, 0x16fe, 0x3, 0x2, 0x2, 0x2, 0x16fe, 0x1793, 
       0x3, 0x2, 0x2, 0x2, 0x16ff, 0x1700, 0x7, 0x250, 0x2, 0x2, 0x1700, 
       0x1701, 0x7, 0x19b, 0x2, 0x2, 0x1701, 0x1702, 0x5, 0x294, 0x14b, 
       0x2, 0x1702, 0x1703, 0x7, 0x213, 0x2, 0x2, 0x1703, 0x1704, 0x5, 0x28a, 
       0x146, 0x2, 0x1704, 0x1705, 0x7, 0x19c, 0x2, 0x2, 0x1705, 0x1793, 
       0x3, 0x2, 0x2, 0x2, 0x1706, 0x1793, 0x5, 0x2c0, 0x161, 0x2, 0x1707, 
       0x1709, 0x7, 0x285, 0x2, 0x2, 0x1708, 0x170a, 0x5, 0x2b4, 0x15b, 
       0x2, 0x1709, 0x1708, 0x3, 0x2, 0x2, 0x2, 0x1709, 0x170a, 0x3, 0x2, 
       0x2, 0x2, 0x170a, 0x1793, 0x3, 0x2, 0x2, 0x2, 0x170b, 0x170c, 0x9, 
       0x60, 0x2, 0x2, 0x170c, 0x170d, 0x7, 0x19b, 0x2, 0x2, 0x170d, 0x170e, 
       0x5, 0x2e2, 0x172, 0x2, 0x170e, 0x170f, 0x7, 0x198, 0x2, 0x2, 0x170f, 
       0x1710, 0x5, 0x28a, 0x146, 0x2, 0x1710, 0x1711, 0x7, 0x198, 0x2, 
       0x2, 0x1711, 0x1712, 0x5, 0x28a, 0x146, 0x2, 0x1712, 0x1713, 0x7, 
       0x19c, 0x2, 0x2, 0x1713, 0x1793, 0x3, 0x2, 0x2, 0x2, 0x1714, 0x1716, 
       0x7, 0x29c, 0x2, 0x2, 0x1715, 0x1717, 0x5, 0x478, 0x23d, 0x2, 0x1716, 
       0x1715, 0x3, 0x2, 0x2, 0x2, 0x1716, 0x1717, 0x3, 0x2, 0x2, 0x2, 0x1717, 
       0x1793, 0x3, 0x2, 0x2, 0x2, 0x1718, 0x171a, 0x7, 0x29e, 0x2, 0x2, 
       0x1719, 0x171b, 0x5, 0x2b4, 0x15b, 0x2, 0x171a, 0x1719, 0x3, 0x2, 
       0x2, 0x2, 0x171a, 0x171b, 0x3, 0x2, 0x2, 0x2, 0x171b, 0x1793, 0x3, 
       0x2, 0x2, 0x2, 0x171c, 0x171e, 0x7, 0x29d, 0x2, 0x2, 0x171d, 0x171f, 
       0x5, 0x2b4, 0x15b, 0x2, 0x171e, 0x171d, 0x3, 0x2, 0x2, 0x2, 0x171e, 
       0x171f, 0x3, 0x2, 0x2, 0x2, 0x171f, 0x1793, 0x3, 0x2, 0x2, 0x2, 0x1720, 
       0x1721, 0x7, 0x4, 0x2, 0x2, 0x1721, 0x1793, 0x5, 0x2e6, 0x174, 0x2, 
       0x1722, 0x1723, 0x7, 0xa, 0x2, 0x2, 0x1723, 0x1793, 0x5, 0x2e6, 0x174, 
       0x2, 0x1724, 0x1725, 0x7, 0x57, 0x2, 0x2, 0x1725, 0x1793, 0x5, 0x2e4, 
       0x173, 0x2, 0x1726, 0x1727, 0x7, 0x59, 0x2, 0x2, 0x1727, 0x1793, 
       0x5, 0x2e6, 0x174, 0x2, 0x1728, 0x1729, 0x7, 0x1d5, 0x2, 0x2, 0x1729, 
       0x1793, 0x5, 0x478, 0x23d, 0x2, 0x172a, 0x172b, 0x7, 0x208, 0x2, 
       0x2, 0x172b, 0x172c, 0x7, 0x19b, 0x2, 0x2, 0x172c, 0x172d, 0x5, 0x28a, 
       0x146, 0x2, 0x172d, 0x172e, 0x7, 0x198, 0x2, 0x2, 0x172e, 0x172f, 
       0x5, 0x28a, 0x146, 0x2, 0x172f, 0x1730, 0x7, 0x198, 0x2, 0x2, 0x1730, 
       0x1731, 0x5, 0x28a, 0x146, 0x2, 0x1731, 0x1732, 0x7, 0x19c, 0x2, 
       0x2, 0x1732, 0x1793, 0x3, 0x2, 0x2, 0x2, 0x1733, 0x1734, 0x7, 0x16, 
       0x2, 0x2, 0x1734, 0x1735, 0x7, 0x19b, 0x2, 0x2, 0x1735, 0x1736, 0x5, 
       0x28a, 0x146, 0x2, 0x1736, 0x1737, 0x7, 0x198, 0x2, 0x2, 0x1737, 
       0x173a, 0x5, 0x28a, 0x146, 0x2, 0x1738, 0x1739, 0x7, 0x198, 0x2, 
       0x2, 0x1739, 0x173b, 0x5, 0x28a, 0x146, 0x2, 0x173a, 0x1738, 0x3, 
       0x2, 0x2, 0x2, 0x173a, 0x173b, 0x3, 0x2, 0x2, 0x2, 0x173b, 0x173c, 
       0x3, 0x2, 0x2, 0x2, 0x173c, 0x173d, 0x7, 0x19c, 0x2, 0x2, 0x173d, 
       0x1793, 0x3, 0x2, 0x2, 0x2, 0x173e, 0x173f, 0x7, 0xdb, 0x2, 0x2, 
       0x173f, 0x1793, 0x5, 0x2e6, 0x174, 0x2, 0x1740, 0x1741, 0x7, 0x239, 
       0x2, 0x2, 0x1741, 0x1742, 0x7, 0x19b, 0x2, 0x2, 0x1742, 0x1743, 0x5, 
       0x28a, 0x146, 0x2, 0x1743, 0x1744, 0x7, 0x198, 0x2, 0x2, 0x1744, 
       0x1745, 0x5, 0x28a, 0x146, 0x2, 0x1745, 0x1746, 0x7, 0x19c, 0x2, 
       0x2, 0x1746, 0x1793, 0x3, 0x2, 0x2, 0x2, 0x1747, 0x1748, 0x6, 0x159, 
       0xa5, 0x2, 0x1748, 0x1749, 0x7, 0xf5, 0x2, 0x2, 0x1749, 0x174a, 0x7, 
       0x19b, 0x2, 0x2, 0x174a, 0x174b, 0x5, 0x460, 0x231, 0x2, 0x174b, 
       0x174c, 0x7, 0x19c, 0x2, 0x2, 0x174c, 0x1793, 0x3, 0x2, 0x2, 0x2, 
       0x174d, 0x174e, 0x6, 0x159, 0xa6, 0x2, 0x174e, 0x174f, 0x7, 0xfd, 
       0x2, 0x2, 0x174f, 0x1793, 0x5, 0x2e6, 0x174, 0x2, 0x1750, 0x1751, 
       0x7, 0x10c, 0x2, 0x2, 0x1751, 0x1793, 0x5, 0x2e6, 0x174, 0x2, 0x1752, 
       0x1753, 0x7, 0x25e, 0x2, 0x2, 0x1753, 0x1754, 0x7, 0x19b, 0x2, 0x2, 
       0x1754, 0x1755, 0x5, 0x28a, 0x146, 0x2, 0x1755, 0x1756, 0x7, 0x198, 
       0x2, 0x2, 0x1756, 0x1757, 0x5, 0x28a, 0x146, 0x2, 0x1757, 0x1758, 
       0x7, 0x19c, 0x2, 0x2, 0x1758, 0x1793, 0x3, 0x2, 0x2, 0x2, 0x1759, 
       0x175a, 0x7, 0x25f, 0x2, 0x2, 0x175a, 0x175b, 0x7, 0x19b, 0x2, 0x2, 
       0x175b, 0x175c, 0x5, 0x28a, 0x146, 0x2, 0x175c, 0x175d, 0x7, 0x198, 
       0x2, 0x2, 0x175d, 0x175e, 0x5, 0x28a, 0x146, 0x2, 0x175e, 0x175f, 
       0x7, 0x198, 0x2, 0x2, 0x175f, 0x1760, 0x5, 0x28a, 0x146, 0x2, 0x1760, 
       0x1761, 0x7, 0x19c, 0x2, 0x2, 0x1761, 0x1793, 0x3, 0x2, 0x2, 0x2, 
       0x1762, 0x1763, 0x7, 0x128, 0x2, 0x2, 0x1763, 0x1793, 0x5, 0x2e6, 
       0x174, 0x2, 0x1764, 0x1765, 0x7, 0x12d, 0x2, 0x2, 0x1765, 0x1793, 
       0x5, 0x478, 0x23d, 0x2, 0x1766, 0x1767, 0x7, 0x34, 0x2, 0x2, 0x1767, 
       0x1768, 0x7, 0x19b, 0x2, 0x2, 0x1768, 0x1769, 0x5, 0x28a, 0x146, 
       0x2, 0x1769, 0x176a, 0x7, 0x198, 0x2, 0x2, 0x176a, 0x176b, 0x5, 0x28a, 
       0x146, 0x2, 0x176b, 0x176c, 0x7, 0x19c, 0x2, 0x2, 0x176c, 0x1793, 
       0x3, 0x2, 0x2, 0x2, 0x176d, 0x176e, 0x7, 0x175, 0x2, 0x2, 0x176e, 
       0x176f, 0x7, 0x19b, 0x2, 0x2, 0x176f, 0x1772, 0x5, 0x28a, 0x146, 
       0x2, 0x1770, 0x1771, 0x7, 0x198, 0x2, 0x2, 0x1771, 0x1773, 0x5, 0x28a, 
       0x146, 0x2, 0x1772, 0x1770, 0x3, 0x2, 0x2, 0x2, 0x1772, 0x1773, 0x3, 
       0x2, 0x2, 0x2, 0x1773, 0x1774, 0x3, 0x2, 0x2, 0x2, 0x1774, 0x1775, 
       0x7, 0x19c, 0x2, 0x2, 0x1775, 0x1793, 0x3, 0x2, 0x2, 0x2, 0x1776, 
       0x1777, 0x6, 0x159, 0xa7, 0x2, 0x1777, 0x1778, 0x7, 0x177, 0x2, 0x2, 
       0x1778, 0x1779, 0x7, 0x19b, 0x2, 0x2, 0x1779, 0x178d, 0x5, 0x28a, 
       0x146, 0x2, 0x177a, 0x177b, 0x7, 0x1b1, 0x2, 0x2, 0x177b, 0x177c, 
       0x7, 0x1c4, 0x2, 0x2, 0x177c, 0x177e, 0x5, 0x380, 0x1c1, 0x2, 0x177d, 
       0x177a, 0x3, 0x2, 0x2, 0x2, 0x177d, 0x177e, 0x3, 0x2, 0x2, 0x2, 0x177e, 
       0x1781, 0x3, 0x2, 0x2, 0x2, 0x177f, 0x1780, 0x6, 0x159, 0xa8, 0x2, 
       0x1780, 0x1782, 0x5, 0x2b8, 0x15d, 0x2, 0x1781, 0x177f, 0x3, 0x2, 
       0x2, 0x2, 0x1781, 0x1782, 0x3, 0x2, 0x2, 0x2, 0x1782, 0x178e, 0x3, 
       0x2, 0x2, 0x2, 0x1783, 0x1784, 0x7, 0x1b1, 0x2, 0x2, 0x1784, 0x1785, 
       0x7, 0x1b7, 0x2, 0x2, 0x1785, 0x178e, 0x5, 0x380, 0x1c1, 0x2, 0x1786, 
       0x1787, 0x7, 0x198, 0x2, 0x2, 0x1787, 0x1788, 0x5, 0x44e, 0x228, 
       0x2, 0x1788, 0x1789, 0x7, 0x198, 0x2, 0x2, 0x1789, 0x178a, 0x5, 0x44e, 
       0x228, 0x2, 0x178a, 0x178b, 0x7, 0x198, 0x2, 0x2, 0x178b, 0x178c, 
       0x5, 0x44e, 0x228, 0x2, 0x178c, 0x178e, 0x3, 0x2, 0x2, 0x2, 0x178d, 
       0x177d, 0x3, 0x2, 0x2, 0x2, 0x178d, 0x1783, 0x3, 0x2, 0x2, 0x2, 0x178d, 
       0x1786, 0x3, 0x2, 0x2, 0x2, 0x178e, 0x178f, 0x3, 0x2, 0x2, 0x2, 0x178f, 
       0x1790, 0x7, 0x19c, 0x2, 0x2, 0x1790, 0x1793, 0x3, 0x2, 0x2, 0x2, 
       0x1791, 0x1793, 0x5, 0x2b2, 0x15a, 0x2, 0x1792, 0x1680, 0x3, 0x2, 
       0x2, 0x2, 0x1792, 0x1689, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x168d, 0x3, 
       0x2, 0x2, 0x2, 0x1792, 0x168f, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x1691, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x1693, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x169e, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x16a9, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x16b0, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x16b2, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x16b4, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x16bb, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x16bd, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x16bf, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x16c8, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x16c9, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x16cb, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x16cd, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x16cf, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x16dc, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x16e0, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x16e4, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x16ed, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x16f4, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x16fb, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x16ff, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x1706, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x1707, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x170b, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x1714, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x1718, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x171c, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x1720, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x1722, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x1724, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x1726, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x1728, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x172a, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x1733, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x173e, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x1740, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x1747, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x174d, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x1750, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x1752, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x1759, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x1762, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x1764, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x1766, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x176d, 0x3, 0x2, 0x2, 0x2, 0x1792, 0x1776, 
       0x3, 0x2, 0x2, 0x2, 0x1792, 0x1791, 0x3, 0x2, 0x2, 0x2, 0x1793, 0x2b1, 
       0x3, 0x2, 0x2, 0x2, 0x1794, 0x1795, 0x6, 0x15a, 0xa9, 0x2, 0x1795, 
       0x1796, 0x7, 0xf, 0x2, 0x2, 0x1796, 0x1797, 0x7, 0x19b, 0x2, 0x2, 
       0x1797, 0x1798, 0x5, 0x28a, 0x146, 0x2, 0x1798, 0x1799, 0x7, 0x198, 
       0x2, 0x2, 0x1799, 0x179a, 0x5, 0x28a, 0x146, 0x2, 0x179a, 0x179b, 
       0x7, 0x19c, 0x2, 0x2, 0x179b, 0x17b4, 0x3, 0x2, 0x2, 0x2, 0x179c, 
       0x179d, 0x7, 0x9a, 0x2, 0x2, 0x179d, 0x179f, 0x7, 0x19b, 0x2, 0x2, 
       0x179e, 0x17a0, 0x5, 0x2d8, 0x16d, 0x2, 0x179f, 0x179e, 0x3, 0x2, 
       0x2, 0x2, 0x179f, 0x17a0, 0x3, 0x2, 0x2, 0x2, 0x17a0, 0x17a1, 0x3, 
       0x2, 0x2, 0x2, 0x17a1, 0x17b4, 0x7, 0x19c, 0x2, 0x2, 0x17a2, 0x17a3, 
       0x7, 0xb4, 0x2, 0x2, 0x17a3, 0x17b4, 0x5, 0x2e4, 0x173, 0x2, 0x17a4, 
       0x17a5, 0x7, 0xe2, 0x2, 0x2, 0x17a5, 0x17b4, 0x5, 0x2e4, 0x173, 0x2, 
       0x17a6, 0x17a7, 0x7, 0xe3, 0x2, 0x2, 0x17a7, 0x17b4, 0x5, 0x2e4, 
       0x173, 0x2, 0x17a8, 0x17a9, 0x7, 0xe4, 0x2, 0x2, 0x17a9, 0x17b4, 
       0x5, 0x2e4, 0x173, 0x2, 0x17aa, 0x17ab, 0x7, 0x102, 0x2, 0x2, 0x17ab, 
       0x17ac, 0x7, 0x19b, 0x2, 0x2, 0x17ac, 0x17ad, 0x5, 0x28a, 0x146, 
       0x2, 0x17ad, 0x17ae, 0x7, 0x198, 0x2, 0x2, 0x17ae, 0x17af, 0x5, 0x28a, 
       0x146, 0x2, 0x17af, 0x17b0, 0x7, 0x19c, 0x2, 0x2, 0x17b0, 0x17b4, 
       0x3, 0x2, 0x2, 0x2, 0x17b1, 0x17b2, 0x7, 0x103, 0x2, 0x2, 0x17b2, 
       0x17b4, 0x5, 0x2e4, 0x173, 0x2, 0x17b3, 0x1794, 0x3, 0x2, 0x2, 0x2, 
       0x17b3, 0x179c, 0x3, 0x2, 0x2, 0x2, 0x17b3, 0x17a2, 0x3, 0x2, 0x2, 
       0x2, 0x17b3, 0x17a4, 0x3, 0x2, 0x2, 0x2, 0x17b3, 0x17a6, 0x3, 0x2, 
       0x2, 0x2, 0x17b3, 0x17a8, 0x3, 0x2, 0x2, 0x2, 0x17b3, 0x17aa, 0x3, 
       0x2, 0x2, 0x2, 0x17b3, 0x17b1, 0x3, 0x2, 0x2, 0x2, 0x17b4, 0x2b3, 
       0x3, 0x2, 0x2, 0x2, 0x17b5, 0x17b7, 0x7, 0x19b, 0x2, 0x2, 0x17b6, 
       0x17b8, 0x5, 0x2b6, 0x15c, 0x2, 0x17b7, 0x17b6, 0x3, 0x2, 0x2, 0x2, 
       0x17b7, 0x17b8, 0x3, 0x2, 0x2, 0x2, 0x17b8, 0x17b9, 0x3, 0x2, 0x2, 
       0x2, 0x17b9, 0x17ba, 0x7, 0x19c, 0x2, 0x2, 0x17ba, 0x2b5, 0x3, 0x2, 
       0x2, 0x2, 0x17bb, 0x17bc, 0x6, 0x15c, 0xaa, 0x2, 0x17bc, 0x17bd, 
       0x7, 0x17e, 0x2, 0x2, 0x17bd, 0x2b7, 0x3, 0x2, 0x2, 0x2, 0x17be, 
       0x17cb, 0x7, 0xb3, 0x2, 0x2, 0x17bf, 0x17c0, 0x5, 0x450, 0x229, 0x2, 
       0x17c0, 0x17c1, 0x7, 0x18a, 0x2, 0x2, 0x17c1, 0x17c2, 0x5, 0x450, 
       0x229, 0x2, 0x17c2, 0x17cc, 0x3, 0x2, 0x2, 0x2, 0x17c3, 0x17c8, 0x5, 
       0x2ba, 0x15e, 0x2, 0x17c4, 0x17c5, 0x7, 0x198, 0x2, 0x2, 0x17c5, 
       0x17c7, 0x5, 0x2ba, 0x15e, 0x2, 0x17c6, 0x17c4, 0x3, 0x2, 0x2, 0x2, 
       0x17c7, 0x17ca, 0x3, 0x2, 0x2, 0x2, 0x17c8, 0x17c6, 0x3, 0x2, 0x2, 
       0x2, 0x17c8, 0x17c9, 0x3, 0x2, 0x2, 0x2, 0x17c9, 0x17cc, 0x3, 0x2, 
       0x2, 0x2, 0x17ca, 0x17c8, 0x3, 0x2, 0x2, 0x2, 0x17cb, 0x17bf, 0x3, 
       0x2, 0x2, 0x2, 0x17cb, 0x17c3, 0x3, 0x2, 0x2, 0x2, 0x17cc, 0x2b9, 
       0x3, 0x2, 0x2, 0x2, 0x17cd, 0x17d3, 0x5, 0x450, 0x229, 0x2, 0x17ce, 
       0x17d0, 0x9, 0x22, 0x2, 0x2, 0x17cf, 0x17d1, 0x7, 0x128, 0x2, 0x2, 
       0x17d0, 0x17cf, 0x3, 0x2, 0x2, 0x2, 0x17d0, 0x17d1, 0x3, 0x2, 0x2, 
       0x2, 0x17d1, 0x17d4, 0x3, 0x2, 0x2, 0x2, 0x17d2, 0x17d4, 0x7, 0x128, 
       0x2, 0x2, 0x17d3, 0x17ce, 0x3, 0x2, 0x2, 0x2, 0x17d3, 0x17d2, 0x3, 
       0x2, 0x2, 0x2, 0x17d3, 0x17d4, 0x3, 0x2, 0x2, 0x2, 0x17d4, 0x2bb, 
       0x3, 0x2, 0x2, 0x2, 0x17d5, 0x17d6, 0x9, 0x61, 0x2, 0x2, 0x17d6, 
       0x2bd, 0x3, 0x2, 0x2, 0x2, 0x17d7, 0x17d8, 0x7, 0x291, 0x2, 0x2, 
       0x17d8, 0x17f0, 0x7, 0x19b, 0x2, 0x2, 0x17d9, 0x17dc, 0x5, 0x28a, 
       0x146, 0x2, 0x17da, 0x17db, 0x7, 0x1fc, 0x2, 0x2, 0x17db, 0x17dd, 
       0x5, 0x28a, 0x146, 0x2, 0x17dc, 0x17da, 0x3, 0x2, 0x2, 0x2, 0x17dc, 
       0x17dd, 0x3, 0x2, 0x2, 0x2, 0x17dd, 0x17f1, 0x3, 0x2, 0x2, 0x2, 0x17de, 
       0x17e0, 0x7, 0x21c, 0x2, 0x2, 0x17df, 0x17e1, 0x5, 0x28a, 0x146, 
       0x2, 0x17e0, 0x17df, 0x3, 0x2, 0x2, 0x2, 0x17e0, 0x17e1, 0x3, 0x2, 
       0x2, 0x2, 0x17e1, 0x17e2, 0x3, 0x2, 0x2, 0x2, 0x17e2, 0x17e3, 0x7, 
       0x1fc, 0x2, 0x2, 0x17e3, 0x17f1, 0x5, 0x28a, 0x146, 0x2, 0x17e4, 
       0x17e6, 0x7, 0x28f, 0x2, 0x2, 0x17e5, 0x17e7, 0x5, 0x28a, 0x146, 
       0x2, 0x17e6, 0x17e5, 0x3, 0x2, 0x2, 0x2, 0x17e6, 0x17e7, 0x3, 0x2, 
       0x2, 0x2, 0x17e7, 0x17e8, 0x3, 0x2, 0x2, 0x2, 0x17e8, 0x17e9, 0x7, 
       0x1fc, 0x2, 0x2, 0x17e9, 0x17f1, 0x5, 0x28a, 0x146, 0x2, 0x17ea, 
       0x17ec, 0x7, 0x1bd, 0x2, 0x2, 0x17eb, 0x17ed, 0x5, 0x28a, 0x146, 
       0x2, 0x17ec, 0x17eb, 0x3, 0x2, 0x2, 0x2, 0x17ec, 0x17ed, 0x3, 0x2, 
       0x2, 0x2, 0x17ed, 0x17ee, 0x3, 0x2, 0x2, 0x2, 0x17ee, 0x17ef, 0x7, 
       0x1fc, 0x2, 0x2, 0x17ef, 0x17f1, 0x5, 0x28a, 0x146, 0x2, 0x17f0, 
       0x17d9, 0x3, 0x2, 0x2, 0x2, 0x17f0, 0x17de, 0x3, 0x2, 0x2, 0x2, 0x17f0, 
       0x17e4, 0x3, 0x2, 0x2, 0x2, 0x17f0, 0x17ea, 0x3, 0x2, 0x2, 0x2, 0x17f1, 
       0x17f2, 0x3, 0x2, 0x2, 0x2, 0x17f2, 0x17f3, 0x7, 0x19c, 0x2, 0x2, 
       0x17f3, 0x2bf, 0x3, 0x2, 0x2, 0x2, 0x17f4, 0x17f5, 0x7, 0x283, 0x2, 
       0x2, 0x17f5, 0x17f6, 0x7, 0x19b, 0x2, 0x2, 0x17f6, 0x1803, 0x5, 0x28a, 
       0x146, 0x2, 0x17f7, 0x17f8, 0x7, 0x198, 0x2, 0x2, 0x17f8, 0x17fb, 
       0x5, 0x28a, 0x146, 0x2, 0x17f9, 0x17fa, 0x7, 0x198, 0x2, 0x2, 0x17fa, 
       0x17fc, 0x5, 0x28a, 0x146, 0x2, 0x17fb, 0x17f9, 0x3, 0x2, 0x2, 0x2, 
       0x17fb, 0x17fc, 0x3, 0x2, 0x2, 0x2, 0x17fc, 0x1804, 0x3, 0x2, 0x2, 
       0x2, 0x17fd, 0x17fe, 0x7, 0x1fc, 0x2, 0x2, 0x17fe, 0x1801, 0x5, 0x28a, 
       0x146, 0x2, 0x17ff, 0x1800, 0x7, 0x1fb, 0x2, 0x2, 0x1800, 0x1802, 
       0x5, 0x28a, 0x146, 0x2, 0x1801, 0x17ff, 0x3, 0x2, 0x2, 0x2, 0x1801, 
       0x1802, 0x3, 0x2, 0x2, 0x2, 0x1802, 0x1804, 0x3, 0x2, 0x2, 0x2, 0x1803, 
       0x17f7, 0x3, 0x2, 0x2, 0x2, 0x1803, 0x17fd, 0x3, 0x2, 0x2, 0x2, 0x1804, 
       0x1805, 0x3, 0x2, 0x2, 0x2, 0x1805, 0x1806, 0x7, 0x19c, 0x2, 0x2, 
       0x1806, 0x2c1, 0x3, 0x2, 0x2, 0x2, 0x1807, 0x1808, 0x5, 0x440, 0x221, 
       0x2, 0x1808, 0x180a, 0x7, 0x19b, 0x2, 0x2, 0x1809, 0x180b, 0x5, 0x2c4, 
       0x163, 0x2, 0x180a, 0x1809, 0x3, 0x2, 0x2, 0x2, 0x180a, 0x180b, 0x3, 
       0x2, 0x2, 0x2, 0x180b, 0x180c, 0x3, 0x2, 0x2, 0x2, 0x180c, 0x180d, 
       0x7, 0x19c, 0x2, 0x2, 0x180d, 0x1816, 0x3, 0x2, 0x2, 0x2, 0x180e, 
       0x180f, 0x5, 0x448, 0x225, 0x2, 0x180f, 0x1811, 0x7, 0x19b, 0x2, 
       0x2, 0x1810, 0x1812, 0x5, 0x2d8, 0x16d, 0x2, 0x1811, 0x1810, 0x3, 
       0x2, 0x2, 0x2, 0x1811, 0x1812, 0x3, 0x2, 0x2, 0x2, 0x1812, 0x1813, 
       0x3, 0x2, 0x2, 0x2, 0x1813, 0x1814, 0x7, 0x19c, 0x2, 0x2, 0x1814, 
       0x1816, 0x3, 0x2, 0x2, 0x2, 0x1815, 0x1807, 0x3, 0x2, 0x2, 0x2, 0x1815, 
       0x180e, 0x3, 0x2, 0x2, 0x2, 0x1816, 0x2c3, 0x3, 0x2, 0x2, 0x2, 0x1817, 
       0x181c, 0x5, 0x2c6, 0x164, 0x2, 0x1818, 0x1819, 0x7, 0x198, 0x2, 
       0x2, 0x1819, 0x181b, 0x5, 0x2c6, 0x164, 0x2, 0x181a, 0x1818, 0x3, 
       0x2, 0x2, 0x2, 0x181b, 0x181e, 0x3, 0x2, 0x2, 0x2, 0x181c, 0x181a, 
       0x3, 0x2, 0x2, 0x2, 0x181c, 0x181d, 0x3, 0x2, 0x2, 0x2, 0x181d, 0x2c5, 
       0x3, 0x2, 0x2, 0x2, 0x181e, 0x181c, 0x3, 0x2, 0x2, 0x2, 0x181f, 0x1821, 
       0x5, 0x28a, 0x146, 0x2, 0x1820, 0x1822, 0x5, 0x15c, 0xaf, 0x2, 0x1821, 
       0x1820, 0x3, 0x2, 0x2, 0x2, 0x1821, 0x1822, 0x3, 0x2, 0x2, 0x2, 0x1822, 
       0x2c7, 0x3, 0x2, 0x2, 0x2, 0x1823, 0x1826, 0x5, 0x2ca, 0x166, 0x2, 
       0x1824, 0x1825, 0x7, 0x182, 0x2, 0x2, 0x1825, 0x1827, 0x5, 0x28a, 
       0x146, 0x2, 0x1826, 0x1824, 0x3, 0x2, 0x2, 0x2, 0x1826, 0x1827, 0x3, 
       0x2, 0x2, 0x2, 0x1827, 0x182a, 0x3, 0x2, 0x2, 0x2, 0x1828, 0x182a, 
       0x5, 0x2cc, 0x167, 0x2, 0x1829, 0x1823, 0x3, 0x2, 0x2, 0x2, 0x1829, 
       0x1828, 0x3, 0x2, 0x2, 0x2, 0x182a, 0x2c9, 0x3, 0x2, 0x2, 0x2, 0x182b, 
       0x182c, 0x7, 0x1a2, 0x2, 0x2, 0x182c, 0x182f, 0x5, 0x472, 0x23a, 
       0x2, 0x182d, 0x182f, 0x7, 0x1a3, 0x2, 0x2, 0x182e, 0x182b, 0x3, 0x2, 
       0x2, 0x2, 0x182e, 0x182d, 0x3, 0x2, 0x2, 0x2, 0x182f, 0x2cb, 0x3, 
       0x2, 0x2, 0x2, 0x1830, 0x1832, 0x7, 0x1a4, 0x2, 0x2, 0x1831, 0x1833, 
       0x5, 0x47e, 0x240, 0x2, 0x1832, 0x1831, 0x3, 0x2, 0x2, 0x2, 0x1832, 
       0x1833, 0x3, 0x2, 0x2, 0x2, 0x1833, 0x1834, 0x3, 0x2, 0x2, 0x2, 0x1834, 
       0x1836, 0x5, 0x472, 0x23a, 0x2, 0x1835, 0x1837, 0x5, 0x44c, 0x227, 
       0x2, 0x1836, 0x1835, 0x3, 0x2, 0x2, 0x2, 0x1836, 0x1837, 0x3, 0x2, 
       0x2, 0x2, 0x1837, 0x2cd, 0x3, 0x2, 0x2, 0x2, 0x1838, 0x183a, 0x5, 
       0x442, 0x222, 0x2, 0x1839, 0x183b, 0x5, 0x44c, 0x227, 0x2, 0x183a, 
       0x1839, 0x3, 0x2, 0x2, 0x2, 0x183a, 0x183b, 0x3, 0x2, 0x2, 0x2, 0x183b, 
       0x183f, 0x3, 0x2, 0x2, 0x2, 0x183c, 0x183d, 0x7, 0x1e0, 0x2, 0x2, 
       0x183d, 0x183f, 0x5, 0x44c, 0x227, 0x2, 0x183e, 0x1838, 0x3, 0x2, 
       0x2, 0x2, 0x183e, 0x183c, 0x3, 0x2, 0x2, 0x2, 0x183f, 0x2cf, 0x3, 
       0x2, 0x2, 0x2, 0x1840, 0x1841, 0x7, 0x2a8, 0x2, 0x2, 0x1841, 0x1842, 
       0x5, 0x28a, 0x146, 0x2, 0x1842, 0x2d1, 0x3, 0x2, 0x2, 0x2, 0x1843, 
       0x1844, 0x7, 0x28a, 0x2, 0x2, 0x1844, 0x1845, 0x5, 0x28a, 0x146, 
       0x2, 0x1845, 0x2d3, 0x3, 0x2, 0x2, 0x2, 0x1846, 0x1847, 0x7, 0x1ec, 
       0x2, 0x2, 0x1847, 0x1848, 0x5, 0x28a, 0x146, 0x2, 0x1848, 0x2d5, 
       0x3, 0x2, 0x2, 0x2, 0x1849, 0x184b, 0x7, 0x1b7, 0x2, 0x2, 0x184a, 
       0x184c, 0x5, 0x376, 0x1bc, 0x2, 0x184b, 0x184a, 0x3, 0x2, 0x2, 0x2, 
       0x184b, 0x184c, 0x3, 0x2, 0x2, 0x2, 0x184c, 0x1870, 0x3, 0x2, 0x2, 
       0x2, 0x184d, 0x184f, 0x7, 0x1c4, 0x2, 0x2, 0x184e, 0x1850, 0x5, 0x376, 
       0x1bc, 0x2, 0x184f, 0x184e, 0x3, 0x2, 0x2, 0x2, 0x184f, 0x1850, 0x3, 
       0x2, 0x2, 0x2, 0x1850, 0x1852, 0x3, 0x2, 0x2, 0x2, 0x1851, 0x1853, 
       0x5, 0x37a, 0x1be, 0x2, 0x1852, 0x1851, 0x3, 0x2, 0x2, 0x2, 0x1852, 
       0x1853, 0x3, 0x2, 0x2, 0x2, 0x1853, 0x1870, 0x3, 0x2, 0x2, 0x2, 0x1854, 
       0x1856, 0x5, 0x370, 0x1b9, 0x2, 0x1855, 0x1857, 0x5, 0x376, 0x1bc, 
       0x2, 0x1856, 0x1855, 0x3, 0x2, 0x2, 0x2, 0x1856, 0x1857, 0x3, 0x2, 
       0x2, 0x2, 0x1857, 0x1870, 0x3, 0x2, 0x2, 0x2, 0x1858, 0x185a, 0x7, 
       0x2e, 0x2, 0x2, 0x1859, 0x185b, 0x7, 0x212, 0x2, 0x2, 0x185a, 0x1859, 
       0x3, 0x2, 0x2, 0x2, 0x185a, 0x185b, 0x3, 0x2, 0x2, 0x2, 0x185b, 0x1870, 
       0x3, 0x2, 0x2, 0x2, 0x185c, 0x185e, 0x7, 0x297, 0x2, 0x2, 0x185d, 
       0x185f, 0x7, 0x212, 0x2, 0x2, 0x185e, 0x185d, 0x3, 0x2, 0x2, 0x2, 
       0x185e, 0x185f, 0x3, 0x2, 0x2, 0x2, 0x185f, 0x1870, 0x3, 0x2, 0x2, 
       0x2, 0x1860, 0x1870, 0x7, 0x72, 0x2, 0x2, 0x1861, 0x1863, 0x7, 0x162, 
       0x2, 0x2, 0x1862, 0x1864, 0x5, 0x382, 0x1c2, 0x2, 0x1863, 0x1862, 
       0x3, 0x2, 0x2, 0x2, 0x1863, 0x1864, 0x3, 0x2, 0x2, 0x2, 0x1864, 0x1870, 
       0x3, 0x2, 0x2, 0x2, 0x1865, 0x1867, 0x7, 0x71, 0x2, 0x2, 0x1866, 
       0x1868, 0x5, 0x382, 0x1c2, 0x2, 0x1867, 0x1866, 0x3, 0x2, 0x2, 0x2, 
       0x1867, 0x1868, 0x3, 0x2, 0x2, 0x2, 0x1868, 0x1870, 0x3, 0x2, 0x2, 
       0x2, 0x1869, 0x186b, 0x7, 0x1de, 0x2, 0x2, 0x186a, 0x186c, 0x5, 0x46e, 
       0x238, 0x2, 0x186b, 0x186a, 0x3, 0x2, 0x2, 0x2, 0x186b, 0x186c, 0x3, 
       0x2, 0x2, 0x2, 0x186c, 0x1870, 0x3, 0x2, 0x2, 0x2, 0x186d, 0x186e, 
       0x6, 0x16c, 0xab, 0x2, 0x186e, 0x1870, 0x7, 0xae, 0x2, 0x2, 0x186f, 
       0x1849, 0x3, 0x2, 0x2, 0x2, 0x186f, 0x184d, 0x3, 0x2, 0x2, 0x2, 0x186f, 
       0x1854, 0x3, 0x2, 0x2, 0x2, 0x186f, 0x1858, 0x3, 0x2, 0x2, 0x2, 0x186f, 
       0x185c, 0x3, 0x2, 0x2, 0x2, 0x186f, 0x1860, 0x3, 0x2, 0x2, 0x2, 0x186f, 
       0x1861, 0x3, 0x2, 0x2, 0x2, 0x186f, 0x1865, 0x3, 0x2, 0x2, 0x2, 0x186f, 
       0x1869, 0x3, 0x2, 0x2, 0x2, 0x186f, 0x186d, 0x3, 0x2, 0x2, 0x2, 0x1870, 
       0x2d7, 0x3, 0x2, 0x2, 0x2, 0x1871, 0x1876, 0x5, 0x28a, 0x146, 0x2, 
       0x1872, 0x1873, 0x7, 0x198, 0x2, 0x2, 0x1873, 0x1875, 0x5, 0x28a, 
       0x146, 0x2, 0x1874, 0x1872, 0x3, 0x2, 0x2, 0x2, 0x1875, 0x1878, 0x3, 
       0x2, 0x2, 0x2, 0x1876, 0x1874, 0x3, 0x2, 0x2, 0x2, 0x1876, 0x1877, 
       0x3, 0x2, 0x2, 0x2, 0x1877, 0x2d9, 0x3, 0x2, 0x2, 0x2, 0x1878, 0x1876, 
       0x3, 0x2, 0x2, 0x2, 0x1879, 0x187a, 0x7, 0x1c4, 0x2, 0x2, 0x187a, 
       0x187d, 0x7, 0x26c, 0x2, 0x2, 0x187b, 0x187d, 0x7, 0xa, 0x2, 0x2, 
       0x187c, 0x1879, 0x3, 0x2, 0x2, 0x2, 0x187c, 0x187b, 0x3, 0x2, 0x2, 
       0x2, 0x187d, 0x2db, 0x3, 0x2, 0x2, 0x2, 0x187e, 0x187f, 0x9, 0x62, 
       0x2, 0x2, 0x187f, 0x2dd, 0x3, 0x2, 0x2, 0x2, 0x1880, 0x1881, 0x9, 
       0x63, 0x2, 0x2, 0x1881, 0x2df, 0x3, 0x2, 0x2, 0x2, 0x1882, 0x1885, 
       0x5, 0x2e2, 0x172, 0x2, 0x1883, 0x1885, 0x9, 0x64, 0x2, 0x2, 0x1884, 
       0x1882, 0x3, 0x2, 0x2, 0x2, 0x1884, 0x1883, 0x3, 0x2, 0x2, 0x2, 0x1885, 
       0x2e1, 0x3, 0x2, 0x2, 0x2, 0x1886, 0x1887, 0x9, 0x65, 0x2, 0x2, 0x1887, 
       0x2e3, 0x3, 0x2, 0x2, 0x2, 0x1888, 0x1889, 0x7, 0x19b, 0x2, 0x2, 
       0x1889, 0x188a, 0x5, 0x2d8, 0x16d, 0x2, 0x188a, 0x188b, 0x7, 0x19c, 
       0x2, 0x2, 0x188b, 0x2e5, 0x3, 0x2, 0x2, 0x2, 0x188c, 0x188d, 0x7, 
       0x19b, 0x2, 0x2, 0x188d, 0x188e, 0x5, 0x28a, 0x146, 0x2, 0x188e, 
       0x188f, 0x7, 0x19c, 0x2, 0x2, 0x188f, 0x2e7, 0x3, 0x2, 0x2, 0x2, 
       0x1890, 0x1895, 0x5, 0x2ea, 0x176, 0x2, 0x1891, 0x1892, 0x7, 0x198, 
       0x2, 0x2, 0x1892, 0x1894, 0x5, 0x2ea, 0x176, 0x2, 0x1893, 0x1891, 
       0x3, 0x2, 0x2, 0x2, 0x1894, 0x1897, 0x3, 0x2, 0x2, 0x2, 0x1895, 0x1893, 
       0x3, 0x2, 0x2, 0x2, 0x1895, 0x1896, 0x3, 0x2, 0x2, 0x2, 0x1896, 0x2e9, 
       0x3, 0x2, 0x2, 0x2, 0x1897, 0x1895, 0x3, 0x2, 0x2, 0x2, 0x1898, 0x189a, 
       0x5, 0x28a, 0x146, 0x2, 0x1899, 0x189b, 0x5, 0x14a, 0xa6, 0x2, 0x189a, 
       0x1899, 0x3, 0x2, 0x2, 0x2, 0x189a, 0x189b, 0x3, 0x2, 0x2, 0x2, 0x189b, 
       0x2eb, 0x3, 0x2, 0x2, 0x2, 0x189c, 0x18a1, 0x5, 0x2ee, 0x178, 0x2, 
       0x189d, 0x189e, 0x7, 0x198, 0x2, 0x2, 0x189e, 0x18a0, 0x5, 0x2ee, 
       0x178, 0x2, 0x189f, 0x189d, 0x3, 0x2, 0x2, 0x2, 0x18a0, 0x18a3, 0x3, 
       0x2, 0x2, 0x2, 0x18a1, 0x189f, 0x3, 0x2, 0x2, 0x2, 0x18a1, 0x18a2, 
       0x3, 0x2, 0x2, 0x2, 0x18a2, 0x2ed, 0x3, 0x2, 0x2, 0x2, 0x18a3, 0x18a1, 
       0x3, 0x2, 0x2, 0x2, 0x18a4, 0x18a5, 0x5, 0x28a, 0x146, 0x2, 0x18a5, 
       0x2ef, 0x3, 0x2, 0x2, 0x2, 0x18a6, 0x18a7, 0x6, 0x179, 0xac, 0x2, 
       0x18a7, 0x18a8, 0x7, 0x1fb, 0x2, 0x2, 0x18a8, 0x18a9, 0x7, 0x53, 
       0x2, 0x2, 0x18a9, 0x18aa, 0x5, 0x462, 0x232, 0x2, 0x18aa, 0x2f1, 
       0x3, 0x2, 0x2, 0x2, 0x18ab, 0x18b9, 0x5, 0x4, 0x3, 0x2, 0x18ac, 0x18b9, 
       0x5, 0x2f4, 0x17b, 0x2, 0x18ad, 0x18b9, 0x5, 0x2f6, 0x17c, 0x2, 0x18ae, 
       0x18b9, 0x5, 0x2fe, 0x180, 0x2, 0x18af, 0x18b9, 0x5, 0x302, 0x182, 
       0x2, 0x18b0, 0x18b9, 0x5, 0x304, 0x183, 0x2, 0x18b1, 0x18b9, 0x5, 
       0x30a, 0x186, 0x2, 0x18b2, 0x18b9, 0x5, 0x30c, 0x187, 0x2, 0x18b3, 
       0x18b9, 0x5, 0x328, 0x195, 0x2, 0x18b4, 0x18b9, 0x5, 0x326, 0x194, 
       0x2, 0x18b5, 0x18b9, 0x5, 0x33a, 0x19e, 0x2, 0x18b6, 0x18b9, 0x5, 
       0x33e, 0x1a0, 0x2, 0x18b7, 0x18b9, 0x5, 0x33c, 0x19f, 0x2, 0x18b8, 
       0x18ab, 0x3, 0x2, 0x2, 0x2, 0x18b8, 0x18ac, 0x3, 0x2, 0x2, 0x2, 0x18b8, 
       0x18ad, 0x3, 0x2, 0x2, 0x2, 0x18b8, 0x18ae, 0x3, 0x2, 0x2, 0x2, 0x18b8, 
       0x18af, 0x3, 0x2, 0x2, 0x2, 0x18b8, 0x18b0, 0x3, 0x2, 0x2, 0x2, 0x18b8, 
       0x18b1, 0x3, 0x2, 0x2, 0x2, 0x18b8, 0x18b2, 0x3, 0x2, 0x2, 0x2, 0x18b8, 
       0x18b3, 0x3, 0x2, 0x2, 0x2, 0x18b8, 0x18b4, 0x3, 0x2, 0x2, 0x2, 0x18b8, 
       0x18b5, 0x3, 0x2, 0x2, 0x2, 0x18b8, 0x18b6, 0x3, 0x2, 0x2, 0x2, 0x18b8, 
       0x18b7, 0x3, 0x2, 0x2, 0x2, 0x18b9, 0x2f3, 0x3, 0x2, 0x2, 0x2, 0x18ba, 
       0x18bb, 0x7, 0x263, 0x2, 0x2, 0x18bb, 0x18bc, 0x5, 0x28a, 0x146, 
       0x2, 0x18bc, 0x2f5, 0x3, 0x2, 0x2, 0x2, 0x18bd, 0x18be, 0x7, 0x208, 
       0x2, 0x2, 0x18be, 0x18bf, 0x5, 0x2f8, 0x17d, 0x2, 0x18bf, 0x18c0, 
       0x7, 0x12, 0x2, 0x2, 0x18c0, 0x18c1, 0x7, 0x208, 0x2, 0x2, 0x18c1, 
       0x2f7, 0x3, 0x2, 0x2, 0x2, 0x18c2, 0x18c3, 0x5, 0x28a, 0x146, 0x2, 
       0x18c3, 0x18c8, 0x5, 0x2fa, 0x17e, 0x2, 0x18c4, 0x18c5, 0x7, 0x1ed, 
       0x2, 0x2, 0x18c5, 0x18c9, 0x5, 0x2f8, 0x17d, 0x2, 0x18c6, 0x18c7, 
       0x7, 0x1ec, 0x2, 0x2, 0x18c7, 0x18c9, 0x5, 0x2fc, 0x17f, 0x2, 0x18c8, 
       0x18c4, 0x3, 0x2, 0x2, 0x2, 0x18c8, 0x18c6, 0x3, 0x2, 0x2, 0x2, 0x18c8, 
       0x18c9, 0x3, 0x2, 0x2, 0x2, 0x18c9, 0x2f9, 0x3, 0x2, 0x2, 0x2, 0x18ca, 
       0x18cb, 0x7, 0x28a, 0x2, 0x2, 0x18cb, 0x18cc, 0x5, 0x2fc, 0x17f, 
       0x2, 0x18cc, 0x2fb, 0x3, 0x2, 0x2, 0x2, 0x18cd, 0x18ce, 0x5, 0x2f2, 
       0x17a, 0x2, 0x18ce, 0x18cf, 0x7, 0x199, 0x2, 0x2, 0x18cf, 0x18d1, 
       0x3, 0x2, 0x2, 0x2, 0x18d0, 0x18cd, 0x3, 0x2, 0x2, 0x2, 0x18d1, 0x18d2, 
       0x3, 0x2, 0x2, 0x2, 0x18d2, 0x18d0, 0x3, 0x2, 0x2, 0x2, 0x18d2, 0x18d3, 
       0x3, 0x2, 0x2, 0x2, 0x18d3, 0x2fd, 0x3, 0x2, 0x2, 0x2, 0x18d4, 0x18d6, 
       0x7, 0x1c1, 0x2, 0x2, 0x18d5, 0x18d7, 0x5, 0x28a, 0x146, 0x2, 0x18d6, 
       0x18d5, 0x3, 0x2, 0x2, 0x2, 0x18d6, 0x18d7, 0x3, 0x2, 0x2, 0x2, 0x18d7, 
       0x18db, 0x3, 0x2, 0x2, 0x2, 0x18d8, 0x18d9, 0x5, 0x2d0, 0x169, 0x2, 
       0x18d9, 0x18da, 0x5, 0x2fa, 0x17e, 0x2, 0x18da, 0x18dc, 0x3, 0x2, 
       0x2, 0x2, 0x18db, 0x18d8, 0x3, 0x2, 0x2, 0x2, 0x18dc, 0x18dd, 0x3, 
       0x2, 0x2, 0x2, 0x18dd, 0x18db, 0x3, 0x2, 0x2, 0x2, 0x18dd, 0x18de, 
       0x3, 0x2, 0x2, 0x2, 0x18de, 0x18e0, 0x3, 0x2, 0x2, 0x2, 0x18df, 0x18e1, 
       0x5, 0x300, 0x181, 0x2, 0x18e0, 0x18df, 0x3, 0x2, 0x2, 0x2, 0x18e0, 
       0x18e1, 0x3, 0x2, 0x2, 0x2, 0x18e1, 0x18e2, 0x3, 0x2, 0x2, 0x2, 0x18e2, 
       0x18e3, 0x7, 0x12, 0x2, 0x2, 0x18e3, 0x18e4, 0x7, 0x1c1, 0x2, 0x2, 
       0x18e4, 0x2ff, 0x3, 0x2, 0x2, 0x2, 0x18e5, 0x18e6, 0x7, 0x1ec, 0x2, 
       0x2, 0x18e6, 0x18e7, 0x5, 0x2fc, 0x17f, 0x2, 0x18e7, 0x301, 0x3, 
       0x2, 0x2, 0x2, 0x18e8, 0x18e9, 0x5, 0x306, 0x184, 0x2, 0x18e9, 0x18eb, 
       0x5, 0x308, 0x185, 0x2, 0x18ea, 0x18ec, 0x5, 0x432, 0x21a, 0x2, 0x18eb, 
       0x18ea, 0x3, 0x2, 0x2, 0x2, 0x18eb, 0x18ec, 0x3, 0x2, 0x2, 0x2, 0x18ec, 
       0x303, 0x3, 0x2, 0x2, 0x2, 0x18ed, 0x18ee, 0x5, 0x308, 0x185, 0x2, 
       0x18ee, 0x305, 0x3, 0x2, 0x2, 0x2, 0x18ef, 0x18f0, 0x5, 0x430, 0x219, 
       0x2, 0x18f0, 0x18f1, 0x7, 0x19a, 0x2, 0x2, 0x18f1, 0x307, 0x3, 0x2, 
       0x2, 0x2, 0x18f2, 0x18f4, 0x7, 0x7, 0x2, 0x2, 0x18f3, 0x18f5, 0x5, 
       0x314, 0x18b, 0x2, 0x18f4, 0x18f3, 0x3, 0x2, 0x2, 0x2, 0x18f4, 0x18f5, 
       0x3, 0x2, 0x2, 0x2, 0x18f5, 0x18f7, 0x3, 0x2, 0x2, 0x2, 0x18f6, 0x18f8, 
       0x5, 0x2fc, 0x17f, 0x2, 0x18f7, 0x18f6, 0x3, 0x2, 0x2, 0x2, 0x18f7, 
       0x18f8, 0x3, 0x2, 0x2, 0x2, 0x18f8, 0x18f9, 0x3, 0x2, 0x2, 0x2, 0x18f9, 
       0x18fa, 0x7, 0x12, 0x2, 0x2, 0x18fa, 0x309, 0x3, 0x2, 0x2, 0x2, 0x18fb, 
       0x18fc, 0x5, 0x306, 0x184, 0x2, 0x18fc, 0x18fe, 0x5, 0x30c, 0x187, 
       0x2, 0x18fd, 0x18ff, 0x5, 0x432, 0x21a, 0x2, 0x18fe, 0x18fd, 0x3, 
       0x2, 0x2, 0x2, 0x18fe, 0x18ff, 0x3, 0x2, 0x2, 0x2, 0x18ff, 0x30b, 
       0x3, 0x2, 0x2, 0x2, 0x1900, 0x1904, 0x5, 0x30e, 0x188, 0x2, 0x1901, 
       0x1904, 0x5, 0x310, 0x189, 0x2, 0x1902, 0x1904, 0x5, 0x312, 0x18a, 
       0x2, 0x1903, 0x1900, 0x3, 0x2, 0x2, 0x2, 0x1903, 0x1901, 0x3, 0x2, 
       0x2, 0x2, 0x1903, 0x1902, 0x3, 0x2, 0x2, 0x2, 0x1904, 0x30d, 0x3, 
       0x2, 0x2, 0x2, 0x1905, 0x1906, 0x7, 0x22a, 0x2, 0x2, 0x1906, 0x1907, 
       0x5, 0x2fc, 0x17f, 0x2, 0x1907, 0x1908, 0x7, 0x12, 0x2, 0x2, 0x1908, 
       0x1909, 0x7, 0x22a, 0x2, 0x2, 0x1909, 0x30f, 0x3, 0x2, 0x2, 0x2, 
       0x190a, 0x190b, 0x7, 0x2aa, 0x2, 0x2, 0x190b, 0x190c, 0x5, 0x28a, 
       0x146, 0x2, 0x190c, 0x190d, 0x7, 0x11, 0x2, 0x2, 0x190d, 0x190e, 
       0x5, 0x2fc, 0x17f, 0x2, 0x190e, 0x190f, 0x7, 0x12, 0x2, 0x2, 0x190f, 
       0x1910, 0x7, 0x2aa, 0x2, 0x2, 0x1910, 0x311, 0x3, 0x2, 0x2, 0x2, 
       0x1911, 0x1912, 0x7, 0x25e, 0x2, 0x2, 0x1912, 0x1913, 0x5, 0x2fc, 
       0x17f, 0x2, 0x1913, 0x1914, 0x7, 0x16c, 0x2, 0x2, 0x1914, 0x1915, 
       0x5, 0x28a, 0x146, 0x2, 0x1915, 0x1916, 0x7, 0x12, 0x2, 0x2, 0x1916, 
       0x1917, 0x7, 0x25e, 0x2, 0x2, 0x1917, 0x313, 0x3, 0x2, 0x2, 0x2, 
       0x1918, 0x1919, 0x5, 0x316, 0x18c, 0x2, 0x1919, 0x191a, 0x7, 0x199, 
       0x2, 0x2, 0x191a, 0x191c, 0x3, 0x2, 0x2, 0x2, 0x191b, 0x1918, 0x3, 
       0x2, 0x2, 0x2, 0x191c, 0x191d, 0x3, 0x2, 0x2, 0x2, 0x191d, 0x191b, 
       0x3, 0x2, 0x2, 0x2, 0x191d, 0x191e, 0x3, 0x2, 0x2, 0x2, 0x191e, 0x315, 
       0x3, 0x2, 0x2, 0x2, 0x191f, 0x1924, 0x5, 0x318, 0x18d, 0x2, 0x1920, 
       0x1924, 0x5, 0x31a, 0x18e, 0x2, 0x1921, 0x1924, 0x5, 0x320, 0x191, 
       0x2, 0x1922, 0x1924, 0x5, 0x324, 0x193, 0x2, 0x1923, 0x191f, 0x3, 
       0x2, 0x2, 0x2, 0x1923, 0x1920, 0x3, 0x2, 0x2, 0x2, 0x1923, 0x1921, 
       0x3, 0x2, 0x2, 0x2, 0x1923, 0x1922, 0x3, 0x2, 0x2, 0x2, 0x1924, 0x317, 
       0x3, 0x2, 0x2, 0x2, 0x1925, 0x1926, 0x7, 0x1df, 0x2, 0x2, 0x1926, 
       0x1927, 0x5, 0x444, 0x223, 0x2, 0x1927, 0x1929, 0x5, 0x36e, 0x1b8, 
       0x2, 0x1928, 0x192a, 0x5, 0x3b6, 0x1dc, 0x2, 0x1929, 0x1928, 0x3, 
       0x2, 0x2, 0x2, 0x1929, 0x192a, 0x3, 0x2, 0x2, 0x2, 0x192a, 0x192d, 
       0x3, 0x2, 0x2, 0x2, 0x192b, 0x192c, 0x7, 0x1e0, 0x2, 0x2, 0x192c, 
       0x192e, 0x5, 0x28a, 0x146, 0x2, 0x192d, 0x192b, 0x3, 0x2, 0x2, 0x2, 
       0x192d, 0x192e, 0x3, 0x2, 0x2, 0x2, 0x192e, 0x319, 0x3, 0x2, 0x2, 
       0x2, 0x192f, 0x1930, 0x7, 0x1df, 0x2, 0x2, 0x1930, 0x1931, 0x5, 0x442, 
       0x222, 0x2, 0x1931, 0x1932, 0x7, 0x1c8, 0x2, 0x2, 0x1932, 0x1933, 
       0x7, 0x1fb, 0x2, 0x2, 0x1933, 0x1934, 0x5, 0x31c, 0x18f, 0x2, 0x1934, 
       0x31b, 0x3, 0x2, 0x2, 0x2, 0x1935, 0x1938, 0x5, 0x44e, 0x228, 0x2, 
       0x1936, 0x1938, 0x5, 0x31e, 0x190, 0x2, 0x1937, 0x1935, 0x3, 0x2, 
       0x2, 0x2, 0x1937, 0x1936, 0x3, 0x2, 0x2, 0x2, 0x1938, 0x31d, 0x3, 
       0x2, 0x2, 0x2, 0x1939, 0x193b, 0x7, 0x274, 0x2, 0x2, 0x193a, 0x193c, 
       0x7, 0x172, 0x2, 0x2, 0x193b, 0x193a, 0x3, 0x2, 0x2, 0x2, 0x193b, 
       0x193c, 0x3, 0x2, 0x2, 0x2, 0x193c, 0x193d, 0x3, 0x2, 0x2, 0x2, 0x193d, 
       0x193e, 0x5, 0x460, 0x231, 0x2, 0x193e, 0x31f, 0x3, 0x2, 0x2, 0x2, 
       0x193f, 0x1940, 0x7, 0x1df, 0x2, 0x2, 0x1940, 0x1941, 0x9, 0x66, 
       0x2, 0x2, 0x1941, 0x1942, 0x7, 0x18, 0x2, 0x2, 0x1942, 0x1943, 0x7, 
       0x1fb, 0x2, 0x2, 0x1943, 0x1948, 0x5, 0x322, 0x192, 0x2, 0x1944, 
       0x1945, 0x7, 0x198, 0x2, 0x2, 0x1945, 0x1947, 0x5, 0x322, 0x192, 
       0x2, 0x1946, 0x1944, 0x3, 0x2, 0x2, 0x2, 0x1947, 0x194a, 0x3, 0x2, 
       0x2, 0x2, 0x1948, 0x1946, 0x3, 0x2, 0x2, 0x2, 0x1948, 0x1949, 0x3, 
       0x2, 0x2, 0x2, 0x1949, 0x194b, 0x3, 0x2, 0x2, 0x2, 0x194a, 0x1948, 
       0x3, 0x2, 0x2, 0x2, 0x194b, 0x194c, 0x5, 0x2f2, 0x17a, 0x2, 0x194c, 
       0x321, 0x3, 0x2, 0x2, 0x2, 0x194d, 0x1955, 0x5, 0x31c, 0x18f, 0x2, 
       0x194e, 0x1955, 0x5, 0x442, 0x222, 0x2, 0x194f, 0x1955, 0x7, 0x275, 
       0x2, 0x2, 0x1950, 0x1951, 0x5, 0x2dc, 0x16f, 0x2, 0x1951, 0x1952, 
       0x7, 0x90, 0x2, 0x2, 0x1952, 0x1955, 0x3, 0x2, 0x2, 0x2, 0x1953, 
       0x1955, 0x7, 0x273, 0x2, 0x2, 0x1954, 0x194d, 0x3, 0x2, 0x2, 0x2, 
       0x1954, 0x194e, 0x3, 0x2, 0x2, 0x2, 0x1954, 0x194f, 0x3, 0x2, 0x2, 
       0x2, 0x1954, 0x1950, 0x3, 0x2, 0x2, 0x2, 0x1954, 0x1953, 0x3, 0x2, 
       0x2, 0x2, 0x1955, 0x323, 0x3, 0x2, 0x2, 0x2, 0x1956, 0x1957, 0x7, 
       0x1df, 0x2, 0x2, 0x1957, 0x1958, 0x5, 0x442, 0x222, 0x2, 0x1958, 
       0x1959, 0x7, 0x1d3, 0x2, 0x2, 0x1959, 0x195a, 0x7, 0x1fb, 0x2, 0x2, 
       0x195a, 0x195b, 0x5, 0x10c, 0x87, 0x2, 0x195b, 0x325, 0x3, 0x2, 0x2, 
       0x2, 0x195c, 0x195d, 0x7, 0x217, 0x2, 0x2, 0x195d, 0x195e, 0x5, 0x432, 
       0x21a, 0x2, 0x195e, 0x327, 0x3, 0x2, 0x2, 0x2, 0x195f, 0x1960, 0x7, 
       0x21d, 0x2, 0x2, 0x1960, 0x1961, 0x5, 0x432, 0x21a, 0x2, 0x1961, 
       0x329, 0x3, 0x2, 0x2, 0x2, 0x1962, 0x1966, 0x7, 0x1fe, 0x2, 0x2, 
       0x1963, 0x1967, 0x7, 0x6d, 0x2, 0x2, 0x1964, 0x1965, 0x6, 0x196, 
       0xad, 0x2, 0x1965, 0x1967, 0x7, 0x144, 0x2, 0x2, 0x1966, 0x1963, 
       0x3, 0x2, 0x2, 0x2, 0x1966, 0x1964, 0x3, 0x2, 0x2, 0x2, 0x1966, 0x1967, 
       0x3, 0x2, 0x2, 0x2, 0x1967, 0x1968, 0x3, 0x2, 0x2, 0x2, 0x1968, 0x197b, 
       0x7, 0x78, 0x2, 0x2, 0x1969, 0x196e, 0x5, 0x32e, 0x198, 0x2, 0x196a, 
       0x196b, 0x7, 0x198, 0x2, 0x2, 0x196b, 0x196d, 0x5, 0x32e, 0x198, 
       0x2, 0x196c, 0x196a, 0x3, 0x2, 0x2, 0x2, 0x196d, 0x1970, 0x3, 0x2, 
       0x2, 0x2, 0x196e, 0x196c, 0x3, 0x2, 0x2, 0x2, 0x196e, 0x196f, 0x3, 
       0x2, 0x2, 0x2, 0x196f, 0x197c, 0x3, 0x2, 0x2, 0x2, 0x1970, 0x196e, 
       0x3, 0x2, 0x2, 0x2, 0x1971, 0x1972, 0x7, 0x1c8, 0x2, 0x2, 0x1972, 
       0x1973, 0x5, 0x32c, 0x197, 0x2, 0x1973, 0x1978, 0x5, 0x330, 0x199, 
       0x2, 0x1974, 0x1975, 0x7, 0x198, 0x2, 0x2, 0x1975, 0x1977, 0x5, 0x330, 
       0x199, 0x2, 0x1976, 0x1974, 0x3, 0x2, 0x2, 0x2, 0x1977, 0x197a, 0x3, 
       0x2, 0x2, 0x2, 0x1978, 0x1976, 0x3, 0x2, 0x2, 0x2, 0x1978, 0x1979, 
       0x3, 0x2, 0x2, 0x2, 0x1979, 0x197c, 0x3, 0x2, 0x2, 0x2, 0x197a, 0x1978, 
       0x3, 0x2, 0x2, 0x2, 0x197b, 0x1969, 0x3, 0x2, 0x2, 0x2, 0x197b, 0x1971, 
       0x3, 0x2, 0x2, 0x2, 0x197c, 0x32b, 0x3, 0x2, 0x2, 0x2, 0x197d, 0x1981, 
       0x5, 0x456, 0x22c, 0x2, 0x197e, 0x1981, 0x5, 0x2c8, 0x165, 0x2, 0x197f, 
       0x1981, 0x5, 0x448, 0x225, 0x2, 0x1980, 0x197d, 0x3, 0x2, 0x2, 0x2, 
       0x1980, 0x197e, 0x3, 0x2, 0x2, 0x2, 0x1980, 0x197f, 0x3, 0x2, 0x2, 
       0x2, 0x1981, 0x32d, 0x3, 0x2, 0x2, 0x2, 0x1982, 0x1985, 0x5, 0x2c8, 
       0x165, 0x2, 0x1983, 0x1985, 0x5, 0x442, 0x222, 0x2, 0x1984, 0x1982, 
       0x3, 0x2, 0x2, 0x2, 0x1984, 0x1983, 0x3, 0x2, 0x2, 0x2, 0x1985, 0x1986, 
       0x3, 0x2, 0x2, 0x2, 0x1986, 0x1987, 0x7, 0x181, 0x2, 0x2, 0x1987, 
       0x1988, 0x9, 0x67, 0x2, 0x2, 0x1988, 0x32f, 0x3, 0x2, 0x2, 0x2, 0x1989, 
       0x198c, 0x5, 0x2c8, 0x165, 0x2, 0x198a, 0x198c, 0x5, 0x442, 0x222, 
       0x2, 0x198b, 0x1989, 0x3, 0x2, 0x2, 0x2, 0x198b, 0x198a, 0x3, 0x2, 
       0x2, 0x2, 0x198c, 0x198d, 0x3, 0x2, 0x2, 0x2, 0x198d, 0x1990, 0x7, 
       0x181, 0x2, 0x2, 0x198e, 0x1991, 0x5, 0x332, 0x19a, 0x2, 0x198f, 
       0x1991, 0x7, 0x126, 0x2, 0x2, 0x1990, 0x198e, 0x3, 0x2, 0x2, 0x2, 
       0x1990, 0x198f, 0x3, 0x2, 0x2, 0x2, 0x1991, 0x331, 0x3, 0x2, 0x2, 
       0x2, 0x1992, 0x1993, 0x9, 0x68, 0x2, 0x2, 0x1993, 0x333, 0x3, 0x2, 
       0x2, 0x2, 0x1994, 0x1997, 0x7, 0x26f, 0x2, 0x2, 0x1995, 0x1998, 0x5, 
       0x442, 0x222, 0x2, 0x1996, 0x1998, 0x5, 0x31e, 0x190, 0x2, 0x1997, 
       0x1995, 0x3, 0x2, 0x2, 0x2, 0x1997, 0x1996, 0x3, 0x2, 0x2, 0x2, 0x1998, 
       0x19a2, 0x3, 0x2, 0x2, 0x2, 0x1999, 0x199a, 0x7, 0x26c, 0x2, 0x2, 
       0x199a, 0x199f, 0x5, 0x338, 0x19d, 0x2, 0x199b, 0x199c, 0x7, 0x198, 
       0x2, 0x2, 0x199c, 0x199e, 0x5, 0x338, 0x19d, 0x2, 0x199d, 0x199b, 
       0x3, 0x2, 0x2, 0x2, 0x199e, 0x19a1, 0x3, 0x2, 0x2, 0x2, 0x199f, 0x199d, 
       0x3, 0x2, 0x2, 0x2, 0x199f, 0x19a0, 0x3, 0x2, 0x2, 0x2, 0x19a0, 0x19a3, 
       0x3, 0x2, 0x2, 0x2, 0x19a1, 0x199f, 0x3, 0x2, 0x2, 0x2, 0x19a2, 0x1999, 
       0x3, 0x2, 0x2, 0x2, 0x19a2, 0x19a3, 0x3, 0x2, 0x2, 0x2, 0x19a3, 0x335, 
       0x3, 0x2, 0x2, 0x2, 0x19a4, 0x19aa, 0x7, 0x261, 0x2, 0x2, 0x19a5, 
       0x19a7, 0x7, 0x274, 0x2, 0x2, 0x19a6, 0x19a8, 0x7, 0x172, 0x2, 0x2, 
       0x19a7, 0x19a6, 0x3, 0x2, 0x2, 0x2, 0x19a7, 0x19a8, 0x3, 0x2, 0x2, 
       0x2, 0x19a8, 0x19a9, 0x3, 0x2, 0x2, 0x2, 0x19a9, 0x19ab, 0x5, 0x472, 
       0x23a, 0x2, 0x19aa, 0x19a5, 0x3, 0x2, 0x2, 0x2, 0x19aa, 0x19ab, 0x3, 
       0x2, 0x2, 0x2, 0x19ab, 0x19b5, 0x3, 0x2, 0x2, 0x2, 0x19ac, 0x19ad, 
       0x7, 0x26c, 0x2, 0x2, 0x19ad, 0x19b2, 0x5, 0x338, 0x19d, 0x2, 0x19ae, 
       0x19af, 0x7, 0x198, 0x2, 0x2, 0x19af, 0x19b1, 0x5, 0x338, 0x19d, 
       0x2, 0x19b0, 0x19ae, 0x3, 0x2, 0x2, 0x2, 0x19b1, 0x19b4, 0x3, 0x2, 
       0x2, 0x2, 0x19b2, 0x19b0, 0x3, 0x2, 0x2, 0x2, 0x19b2, 0x19b3, 0x3, 
       0x2, 0x2, 0x2, 0x19b3, 0x19b6, 0x3, 0x2, 0x2, 0x2, 0x19b4, 0x19b2, 
       0x3, 0x2, 0x2, 0x2, 0x19b5, 0x19ac, 0x3, 0x2, 0x2, 0x2, 0x19b5, 0x19b6, 
       0x3, 0x2, 0x2, 0x2, 0x19b6, 0x337, 0x3, 0x2, 0x2, 0x2, 0x19b7, 0x19b8, 
       0x5, 0x332, 0x19a, 0x2, 0x19b8, 0x19b9, 0x7, 0x181, 0x2, 0x2, 0x19b9, 
       0x19ba, 0x5, 0x32c, 0x197, 0x2, 0x19ba, 0x339, 0x3, 0x2, 0x2, 0x2, 
       0x19bb, 0x19bc, 0x7, 0x1e, 0x2, 0x2, 0x19bc, 0x19bd, 0x5, 0x442, 
       0x222, 0x2, 0x19bd, 0x33b, 0x3, 0x2, 0x2, 0x2, 0x19be, 0x19bf, 0x7, 
       0xc, 0x2, 0x2, 0x19bf, 0x19c0, 0x5, 0x442, 0x222, 0x2, 0x19c0, 0x33d, 
       0x3, 0x2, 0x2, 0x2, 0x19c1, 0x19c6, 0x7, 0x1f7, 0x2, 0x2, 0x19c2, 
       0x19c4, 0x7, 0xed, 0x2, 0x2, 0x19c3, 0x19c2, 0x3, 0x2, 0x2, 0x2, 
       0x19c3, 0x19c4, 0x3, 0x2, 0x2, 0x2, 0x19c4, 0x19c5, 0x3, 0x2, 0x2, 
       0x2, 0x19c5, 0x19c7, 0x7, 0x1fc, 0x2, 0x2, 0x19c6, 0x19c3, 0x3, 0x2, 
       0x2, 0x2, 0x19c6, 0x19c7, 0x3, 0x2, 0x2, 0x2, 0x19c7, 0x19c8, 0x3, 
       0x2, 0x2, 0x2, 0x19c8, 0x19c9, 0x5, 0x442, 0x222, 0x2, 0x19c9, 0x19ca, 
       0x7, 0x211, 0x2, 0x2, 0x19ca, 0x19cb, 0x5, 0x444, 0x223, 0x2, 0x19cb, 
       0x33f, 0x3, 0x2, 0x2, 0x2, 0x19cc, 0x19cd, 0x7, 0x43, 0x2, 0x2, 0x19cd, 
       0x19da, 0x5, 0x28a, 0x146, 0x2, 0x19ce, 0x19cf, 0x7, 0x89, 0x2, 0x2, 
       0x19cf, 0x19d0, 0x5, 0x28a, 0x146, 0x2, 0x19d0, 0x19d3, 0x5, 0x2e0, 
       0x171, 0x2, 0x19d1, 0x19d2, 0x7, 0x145, 0x2, 0x2, 0x19d2, 0x19d4, 
       0x5, 0x28a, 0x146, 0x2, 0x19d3, 0x19d1, 0x3, 0x2, 0x2, 0x2, 0x19d3, 
       0x19d4, 0x3, 0x2, 0x2, 0x2, 0x19d4, 0x19d7, 0x3, 0x2, 0x2, 0x2, 0x19d5, 
       0x19d6, 0x7, 0x80, 0x2, 0x2, 0x19d6, 0x19d8, 0x5, 0x28a, 0x146, 0x2, 
       0x19d7, 0x19d5, 0x3, 0x2, 0x2, 0x2, 0x19d7, 0x19d8, 0x3, 0x2, 0x2, 
       0x2, 0x19d8, 0x19da, 0x3, 0x2, 0x2, 0x2, 0x19d9, 0x19cc, 0x3, 0x2, 
       0x2, 0x2, 0x19d9, 0x19ce, 0x3, 0x2, 0x2, 0x2, 0x19da, 0x341, 0x3, 
       0x2, 0x2, 0x2, 0x19db, 0x19dc, 0x5, 0x3ea, 0x1f6, 0x2, 0x19dc, 0x19de, 
       0x5, 0x34a, 0x1a6, 0x2, 0x19dd, 0x19df, 0x5, 0x344, 0x1a3, 0x2, 0x19de, 
       0x19dd, 0x3, 0x2, 0x2, 0x2, 0x19de, 0x19df, 0x3, 0x2, 0x2, 0x2, 0x19df, 
       0x343, 0x3, 0x2, 0x2, 0x2, 0x19e0, 0x19e3, 0x5, 0x346, 0x1a4, 0x2, 
       0x19e1, 0x19e3, 0x5, 0x350, 0x1a9, 0x2, 0x19e2, 0x19e0, 0x3, 0x2, 
       0x2, 0x2, 0x19e2, 0x19e1, 0x3, 0x2, 0x2, 0x2, 0x19e3, 0x345, 0x3, 
       0x2, 0x2, 0x2, 0x19e4, 0x19e5, 0x7, 0x1c5, 0x2, 0x2, 0x19e5, 0x19e6, 
       0x5, 0x2e6, 0x174, 0x2, 0x19e6, 0x347, 0x3, 0x2, 0x2, 0x2, 0x19e7, 
       0x19e9, 0x9, 0x28, 0x2, 0x2, 0x19e8, 0x19ea, 0x5, 0x70, 0x39, 0x2, 
       0x19e9, 0x19e8, 0x3, 0x2, 0x2, 0x2, 0x19e9, 0x19ea, 0x3, 0x2, 0x2, 
       0x2, 0x19ea, 0x19eb, 0x3, 0x2, 0x2, 0x2, 0x19eb, 0x19ef, 0x5, 0x35c, 
       0x1af, 0x2, 0x19ec, 0x19ee, 0x5, 0x360, 0x1b1, 0x2, 0x19ed, 0x19ec, 
       0x3, 0x2, 0x2, 0x2, 0x19ee, 0x19f1, 0x3, 0x2, 0x2, 0x2, 0x19ef, 0x19ed, 
       0x3, 0x2, 0x2, 0x2, 0x19ef, 0x19f0, 0x3, 0x2, 0x2, 0x2, 0x19f0, 0x1a32, 
       0x3, 0x2, 0x2, 0x2, 0x19f1, 0x19ef, 0x3, 0x2, 0x2, 0x2, 0x19f2, 0x19f4, 
       0x7, 0x1fd, 0x2, 0x2, 0x19f3, 0x19f5, 0x5, 0x18e, 0xc8, 0x2, 0x19f4, 
       0x19f3, 0x3, 0x2, 0x2, 0x2, 0x19f4, 0x19f5, 0x3, 0x2, 0x2, 0x2, 0x19f5, 
       0x19f7, 0x3, 0x2, 0x2, 0x2, 0x19f6, 0x19f8, 0x5, 0x3f4, 0x1fb, 0x2, 
       0x19f7, 0x19f6, 0x3, 0x2, 0x2, 0x2, 0x19f7, 0x19f8, 0x3, 0x2, 0x2, 
       0x2, 0x19f8, 0x19f9, 0x3, 0x2, 0x2, 0x2, 0x19f9, 0x19fd, 0x5, 0x35c, 
       0x1af, 0x2, 0x19fa, 0x19fc, 0x5, 0x368, 0x1b5, 0x2, 0x19fb, 0x19fa, 
       0x3, 0x2, 0x2, 0x2, 0x19fc, 0x19ff, 0x3, 0x2, 0x2, 0x2, 0x19fd, 0x19fb, 
       0x3, 0x2, 0x2, 0x2, 0x19fd, 0x19fe, 0x3, 0x2, 0x2, 0x2, 0x19fe, 0x1a32, 
       0x3, 0x2, 0x2, 0x2, 0x19ff, 0x19fd, 0x3, 0x2, 0x2, 0x2, 0x1a00, 0x1a02, 
       0x7, 0x271, 0x2, 0x2, 0x1a01, 0x1a03, 0x5, 0x18e, 0xc8, 0x2, 0x1a02, 
       0x1a01, 0x3, 0x2, 0x2, 0x2, 0x1a02, 0x1a03, 0x3, 0x2, 0x2, 0x2, 0x1a03, 
       0x1a05, 0x3, 0x2, 0x2, 0x2, 0x1a04, 0x1a06, 0x5, 0x3f4, 0x1fb, 0x2, 
       0x1a05, 0x1a04, 0x3, 0x2, 0x2, 0x2, 0x1a05, 0x1a06, 0x3, 0x2, 0x2, 
       0x2, 0x1a06, 0x1a07, 0x3, 0x2, 0x2, 0x2, 0x1a07, 0x1a0b, 0x5, 0x35c, 
       0x1af, 0x2, 0x1a08, 0x1a0a, 0x5, 0x36a, 0x1b6, 0x2, 0x1a09, 0x1a08, 
       0x3, 0x2, 0x2, 0x2, 0x1a0a, 0x1a0d, 0x3, 0x2, 0x2, 0x2, 0x1a0b, 0x1a09, 
       0x3, 0x2, 0x2, 0x2, 0x1a0b, 0x1a0c, 0x3, 0x2, 0x2, 0x2, 0x1a0c, 0x1a32, 
       0x3, 0x2, 0x2, 0x2, 0x1a0d, 0x1a0b, 0x3, 0x2, 0x2, 0x2, 0x1a0e, 0x1a10, 
       0x7, 0x1c9, 0x2, 0x2, 0x1a0f, 0x1a11, 0x5, 0x442, 0x222, 0x2, 0x1a10, 
       0x1a0f, 0x3, 0x2, 0x2, 0x2, 0x1a10, 0x1a11, 0x3, 0x2, 0x2, 0x2, 0x1a11, 
       0x1a13, 0x3, 0x2, 0x2, 0x2, 0x1a12, 0x1a0e, 0x3, 0x2, 0x2, 0x2, 0x1a12, 
       0x1a13, 0x3, 0x2, 0x2, 0x2, 0x1a13, 0x1a2f, 0x3, 0x2, 0x2, 0x2, 0x1a14, 
       0x1a15, 0x7, 0x252, 0x2, 0x2, 0x1a15, 0x1a1b, 0x7, 0x21a, 0x2, 0x2, 
       0x1a16, 0x1a18, 0x7, 0x295, 0x2, 0x2, 0x1a17, 0x1a19, 0x5, 0x18e, 
       0xc8, 0x2, 0x1a18, 0x1a17, 0x3, 0x2, 0x2, 0x2, 0x1a18, 0x1a19, 0x3, 
       0x2, 0x2, 0x2, 0x1a19, 0x1a1b, 0x3, 0x2, 0x2, 0x2, 0x1a1a, 0x1a14, 
       0x3, 0x2, 0x2, 0x2, 0x1a1a, 0x1a16, 0x3, 0x2, 0x2, 0x2, 0x1a1b, 0x1a1d, 
       0x3, 0x2, 0x2, 0x2, 0x1a1c, 0x1a1e, 0x5, 0x70, 0x39, 0x2, 0x1a1d, 
       0x1a1c, 0x3, 0x2, 0x2, 0x2, 0x1a1d, 0x1a1e, 0x3, 0x2, 0x2, 0x2, 0x1a1e, 
       0x1a1f, 0x3, 0x2, 0x2, 0x2, 0x1a1f, 0x1a23, 0x5, 0x35c, 0x1af, 0x2, 
       0x1a20, 0x1a22, 0x5, 0x360, 0x1b1, 0x2, 0x1a21, 0x1a20, 0x3, 0x2, 
       0x2, 0x2, 0x1a22, 0x1a25, 0x3, 0x2, 0x2, 0x2, 0x1a23, 0x1a21, 0x3, 
       0x2, 0x2, 0x2, 0x1a23, 0x1a24, 0x3, 0x2, 0x2, 0x2, 0x1a24, 0x1a30, 
       0x3, 0x2, 0x2, 0x2, 0x1a25, 0x1a23, 0x3, 0x2, 0x2, 0x2, 0x1a26, 0x1a27, 
       0x7, 0x1fa, 0x2, 0x2, 0x1a27, 0x1a29, 0x7, 0x21a, 0x2, 0x2, 0x1a28, 
       0x1a2a, 0x5, 0x3f4, 0x1fb, 0x2, 0x1a29, 0x1a28, 0x3, 0x2, 0x2, 0x2, 
       0x1a29, 0x1a2a, 0x3, 0x2, 0x2, 0x2, 0x1a2a, 0x1a2b, 0x3, 0x2, 0x2, 
       0x2, 0x1a2b, 0x1a2c, 0x5, 0x354, 0x1ab, 0x2, 0x1a2c, 0x1a2d, 0x5, 
       0x350, 0x1a9, 0x2, 0x1a2d, 0x1a30, 0x3, 0x2, 0x2, 0x2, 0x1a2e, 0x1a30, 
       0x5, 0x346, 0x1a4, 0x2, 0x1a2f, 0x1a1a, 0x3, 0x2, 0x2, 0x2, 0x1a2f, 
       0x1a26, 0x3, 0x2, 0x2, 0x2, 0x1a2f, 0x1a2e, 0x3, 0x2, 0x2, 0x2, 0x1a30, 
       0x1a32, 0x3, 0x2, 0x2, 0x2, 0x1a31, 0x19e7, 0x3, 0x2, 0x2, 0x2, 0x1a31, 
       0x19f2, 0x3, 0x2, 0x2, 0x2, 0x1a31, 0x1a00, 0x3, 0x2, 0x2, 0x2, 0x1a31, 
       0x1a12, 0x3, 0x2, 0x2, 0x2, 0x1a32, 0x349, 0x3, 0x2, 0x2, 0x2, 0x1a33, 
       0x1a57, 0x5, 0x36e, 0x1b8, 0x2, 0x1a34, 0x1a36, 0x5, 0x34c, 0x1a7, 
       0x2, 0x1a35, 0x1a34, 0x3, 0x2, 0x2, 0x2, 0x1a36, 0x1a39, 0x3, 0x2, 
       0x2, 0x2, 0x1a37, 0x1a35, 0x3, 0x2, 0x2, 0x2, 0x1a37, 0x1a38, 0x3, 
       0x2, 0x2, 0x2, 0x1a38, 0x1a58, 0x3, 0x2, 0x2, 0x2, 0x1a39, 0x1a37, 
       0x3, 0x2, 0x2, 0x2, 0x1a3a, 0x1a3c, 0x6, 0x1a6, 0xae, 0x2, 0x1a3b, 
       0x1a3d, 0x5, 0x3b6, 0x1dc, 0x2, 0x1a3c, 0x1a3b, 0x3, 0x2, 0x2, 0x2, 
       0x1a3c, 0x1a3d, 0x3, 0x2, 0x2, 0x2, 0x1a3d, 0x1a40, 0x3, 0x2, 0x2, 
       0x2, 0x1a3e, 0x1a3f, 0x7, 0x1ff, 0x2, 0x2, 0x1a3f, 0x1a41, 0x7, 0x5, 
       0x2, 0x2, 0x1a40, 0x1a3e, 0x3, 0x2, 0x2, 0x2, 0x1a40, 0x1a41, 0x3, 
       0x2, 0x2, 0x2, 0x1a41, 0x1a42, 0x3, 0x2, 0x2, 0x2, 0x1a42, 0x1a43, 
       0x7, 0x1b1, 0x2, 0x2, 0x1a43, 0x1a45, 0x5, 0x2e6, 0x174, 0x2, 0x1a44, 
       0x1a46, 0x9, 0x69, 0x2, 0x2, 0x1a45, 0x1a44, 0x3, 0x2, 0x2, 0x2, 
       0x1a45, 0x1a46, 0x3, 0x2, 0x2, 0x2, 0x1a46, 0x1a55, 0x3, 0x2, 0x2, 
       0x2, 0x1a47, 0x1a4b, 0x6, 0x1a6, 0xaf, 0x2, 0x1a48, 0x1a4a, 0x5, 
       0x34e, 0x1a8, 0x2, 0x1a49, 0x1a48, 0x3, 0x2, 0x2, 0x2, 0x1a4a, 0x1a4d, 
       0x3, 0x2, 0x2, 0x2, 0x1a4b, 0x1a49, 0x3, 0x2, 0x2, 0x2, 0x1a4b, 0x1a4c, 
       0x3, 0x2, 0x2, 0x2, 0x1a4c, 0x1a56, 0x3, 0x2, 0x2, 0x2, 0x1a4d, 0x1a4b, 
       0x3, 0x2, 0x2, 0x2, 0x1a4e, 0x1a52, 0x6, 0x1a6, 0xb0, 0x2, 0x1a4f, 
       0x1a51, 0x5, 0x34c, 0x1a7, 0x2, 0x1a50, 0x1a4f, 0x3, 0x2, 0x2, 0x2, 
       0x1a51, 0x1a54, 0x3, 0x2, 0x2, 0x2, 0x1a52, 0x1a50, 0x3, 0x2, 0x2, 
       0x2, 0x1a52, 0x1a53, 0x3, 0x2, 0x2, 0x2, 0x1a53, 0x1a56, 0x3, 0x2, 
       0x2, 0x2, 0x1a54, 0x1a52, 0x3, 0x2, 0x2, 0x2, 0x1a55, 0x1a47, 0x3, 
       0x2, 0x2, 0x2, 0x1a55, 0x1a4e, 0x3, 0x2, 0x2, 0x2, 0x1a56, 0x1a58, 
       0x3, 0x2, 0x2, 0x2, 0x1a57, 0x1a37, 0x3, 0x2, 0x2, 0x2, 0x1a57, 0x1a3a, 
       0x3, 0x2, 0x2, 0x2, 0x1a58, 0x34b, 0x3, 0x2, 0x2, 0x2, 0x1a59, 0x1a5b, 
       0x7, 0x23e, 0x2, 0x2, 0x1a5a, 0x1a59, 0x3, 0x2, 0x2, 0x2, 0x1a5a, 
       0x1a5b, 0x3, 0x2, 0x2, 0x2, 0x1a5b, 0x1a5c, 0x3, 0x2, 0x2, 0x2, 0x1a5c, 
       0x1a87, 0x5, 0x46a, 0x236, 0x2, 0x1a5d, 0x1a5e, 0x6, 0x1a7, 0xb1, 
       0x2, 0x1a5e, 0x1a5f, 0x7, 0x23e, 0x2, 0x2, 0x1a5f, 0x1a87, 0x7, 0x2f1, 
       0x2, 0x2, 0x1a60, 0x1a68, 0x7, 0x1e0, 0x2, 0x2, 0x1a61, 0x1a69, 0x5, 
       0x458, 0x22d, 0x2, 0x1a62, 0x1a64, 0x7, 0x23f, 0x2, 0x2, 0x1a63, 
       0x1a65, 0x5, 0x2b4, 0x15b, 0x2, 0x1a64, 0x1a63, 0x3, 0x2, 0x2, 0x2, 
       0x1a64, 0x1a65, 0x3, 0x2, 0x2, 0x2, 0x1a65, 0x1a69, 0x3, 0x2, 0x2, 
       0x2, 0x1a66, 0x1a67, 0x6, 0x1a7, 0xb2, 0x2, 0x1a67, 0x1a69, 0x5, 
       0x2e6, 0x174, 0x2, 0x1a68, 0x1a61, 0x3, 0x2, 0x2, 0x2, 0x1a68, 0x1a62, 
       0x3, 0x2, 0x2, 0x2, 0x1a68, 0x1a66, 0x3, 0x2, 0x2, 0x2, 0x1a69, 0x1a87, 
       0x3, 0x2, 0x2, 0x2, 0x1a6a, 0x1a6b, 0x7, 0x244, 0x2, 0x2, 0x1a6b, 
       0x1a6c, 0x7, 0x298, 0x2, 0x2, 0x1a6c, 0x1a6e, 0x7, 0x23f, 0x2, 0x2, 
       0x1a6d, 0x1a6f, 0x5, 0x2b4, 0x15b, 0x2, 0x1a6e, 0x1a6d, 0x3, 0x2, 
       0x2, 0x2, 0x1a6e, 0x1a6f, 0x3, 0x2, 0x2, 0x2, 0x1a6f, 0x1a87, 0x3, 
       0x2, 0x2, 0x2, 0x1a70, 0x1a87, 0x7, 0x45, 0x2, 0x2, 0x1a71, 0x1a72, 
       0x7, 0x134, 0x2, 0x2, 0x1a72, 0x1a73, 0x7, 0x1e0, 0x2, 0x2, 0x1a73, 
       0x1a87, 0x7, 0x172, 0x2, 0x2, 0x1a74, 0x1a76, 0x7, 0x295, 0x2, 0x2, 
       0x1a75, 0x1a77, 0x7, 0x21a, 0x2, 0x2, 0x1a76, 0x1a75, 0x3, 0x2, 0x2, 
       0x2, 0x1a76, 0x1a77, 0x3, 0x2, 0x2, 0x2, 0x1a77, 0x1a87, 0x3, 0x2, 
       0x2, 0x2, 0x1a78, 0x1a7a, 0x7, 0x252, 0x2, 0x2, 0x1a79, 0x1a78, 0x3, 
       0x2, 0x2, 0x2, 0x1a79, 0x1a7a, 0x3, 0x2, 0x2, 0x2, 0x1a7a, 0x1a7b, 
       0x3, 0x2, 0x2, 0x2, 0x1a7b, 0x1a87, 0x7, 0x21a, 0x2, 0x2, 0x1a7c, 
       0x1a7d, 0x7, 0xd, 0x2, 0x2, 0x1a7d, 0x1a87, 0x5, 0x460, 0x231, 0x2, 
       0x1a7e, 0x1a87, 0x5, 0x3b6, 0x1dc, 0x2, 0x1a7f, 0x1a80, 0x7, 0x5b, 
       0x2, 0x2, 0x1a80, 0x1a87, 0x9, 0x6a, 0x2, 0x2, 0x1a81, 0x1a82, 0x7, 
       0x14a, 0x2, 0x2, 0x1a82, 0x1a87, 0x9, 0x6b, 0x2, 0x2, 0x1a83, 0x1a84, 
       0x6, 0x1a7, 0xb3, 0x2, 0x1a84, 0x1a85, 0x7, 0x2e4, 0x2, 0x2, 0x1a85, 
       0x1a87, 0x5, 0x454, 0x22b, 0x2, 0x1a86, 0x1a5a, 0x3, 0x2, 0x2, 0x2, 
       0x1a86, 0x1a5d, 0x3, 0x2, 0x2, 0x2, 0x1a86, 0x1a60, 0x3, 0x2, 0x2, 
       0x2, 0x1a86, 0x1a6a, 0x3, 0x2, 0x2, 0x2, 0x1a86, 0x1a70, 0x3, 0x2, 
       0x2, 0x2, 0x1a86, 0x1a71, 0x3, 0x2, 0x2, 0x2, 0x1a86, 0x1a74, 0x3, 
       0x2, 0x2, 0x2, 0x1a86, 0x1a79, 0x3, 0x2, 0x2, 0x2, 0x1a86, 0x1a7c, 
       0x3, 0x2, 0x2, 0x2, 0x1a86, 0x1a7e, 0x3, 0x2, 0x2, 0x2, 0x1a86, 0x1a7f, 
       0x3, 0x2, 0x2, 0x2, 0x1a86, 0x1a81, 0x3, 0x2, 0x2, 0x2, 0x1a86, 0x1a83, 
       0x3, 0x2, 0x2, 0x2, 0x1a87, 0x34d, 0x3, 0x2, 0x2, 0x2, 0x1a88, 0x1a8a, 
       0x7, 0x295, 0x2, 0x2, 0x1a89, 0x1a8b, 0x7, 0x21a, 0x2, 0x2, 0x1a8a, 
       0x1a89, 0x3, 0x2, 0x2, 0x2, 0x1a8a, 0x1a8b, 0x3, 0x2, 0x2, 0x2, 0x1a8b, 
       0x1a97, 0x3, 0x2, 0x2, 0x2, 0x1a8c, 0x1a8d, 0x7, 0xd, 0x2, 0x2, 0x1a8d, 
       0x1a97, 0x5, 0x45e, 0x230, 0x2, 0x1a8e, 0x1a90, 0x5, 0x2dc, 0x16f, 
       0x2, 0x1a8f, 0x1a8e, 0x3, 0x2, 0x2, 0x2, 0x1a8f, 0x1a90, 0x3, 0x2, 
       0x2, 0x2, 0x1a90, 0x1a91, 0x3, 0x2, 0x2, 0x2, 0x1a91, 0x1a97, 0x7, 
       0x241, 0x2, 0x2, 0x1a92, 0x1a94, 0x7, 0x252, 0x2, 0x2, 0x1a93, 0x1a92, 
       0x3, 0x2, 0x2, 0x2, 0x1a93, 0x1a94, 0x3, 0x2, 0x2, 0x2, 0x1a94, 0x1a95, 
       0x3, 0x2, 0x2, 0x2, 0x1a95, 0x1a97, 0x7, 0x21a, 0x2, 0x2, 0x1a96, 
       0x1a88, 0x3, 0x2, 0x2, 0x2, 0x1a96, 0x1a8c, 0x3, 0x2, 0x2, 0x2, 0x1a96, 
       0x1a8f, 0x3, 0x2, 0x2, 0x2, 0x1a96, 0x1a93, 0x3, 0x2, 0x2, 0x2, 0x1a97, 
       0x34f, 0x3, 0x2, 0x2, 0x2, 0x1a98, 0x1a99, 0x7, 0x25a, 0x2, 0x2, 
       0x1a99, 0x1a9b, 0x5, 0x428, 0x215, 0x2, 0x1a9a, 0x1a9c, 0x5, 0x446, 
       0x224, 0x2, 0x1a9b, 0x1a9a, 0x3, 0x2, 0x2, 0x2, 0x1a9b, 0x1a9c, 0x3, 
       0x2, 0x2, 0x2, 0x1a9c, 0x1a9f, 0x3, 0x2, 0x2, 0x2, 0x1a9d, 0x1a9e, 
       0x7, 0x22e, 0x2, 0x2, 0x1a9e, 0x1aa0, 0x9, 0x6c, 0x2, 0x2, 0x1a9f, 
       0x1a9d, 0x3, 0x2, 0x2, 0x2, 0x1a9f, 0x1aa0, 0x3, 0x2, 0x2, 0x2, 0x1aa0, 
       0x1ab1, 0x3, 0x2, 0x2, 0x2, 0x1aa1, 0x1aa2, 0x7, 0x244, 0x2, 0x2, 
       0x1aa2, 0x1aa3, 0x7, 0x298, 0x2, 0x2, 0x1aa3, 0x1aa7, 0x5, 0x352, 
       0x1aa, 0x2, 0x1aa4, 0x1aa5, 0x7, 0x244, 0x2, 0x2, 0x1aa5, 0x1aa6, 
       0x7, 0x1e2, 0x2, 0x2, 0x1aa6, 0x1aa8, 0x5, 0x352, 0x1aa, 0x2, 0x1aa7, 
       0x1aa4, 0x3, 0x2, 0x2, 0x2, 0x1aa7, 0x1aa8, 0x3, 0x2, 0x2, 0x2, 0x1aa8, 
       0x1ab2, 0x3, 0x2, 0x2, 0x2, 0x1aa9, 0x1aaa, 0x7, 0x244, 0x2, 0x2, 
       0x1aaa, 0x1aab, 0x7, 0x1e2, 0x2, 0x2, 0x1aab, 0x1aaf, 0x5, 0x352, 
       0x1aa, 0x2, 0x1aac, 0x1aad, 0x7, 0x244, 0x2, 0x2, 0x1aad, 0x1aae, 
       0x7, 0x298, 0x2, 0x2, 0x1aae, 0x1ab0, 0x5, 0x352, 0x1aa, 0x2, 0x1aaf, 
       0x1aac, 0x3, 0x2, 0x2, 0x2, 0x1aaf, 0x1ab0, 0x3, 0x2, 0x2, 0x2, 0x1ab0, 
       0x1ab2, 0x3, 0x2, 0x2, 0x2, 0x1ab1, 0x1aa1, 0x3, 0x2, 0x2, 0x2, 0x1ab1, 
       0x1aa9, 0x3, 0x2, 0x2, 0x2, 0x1ab1, 0x1ab2, 0x3, 0x2, 0x2, 0x2, 0x1ab2, 
       0x351, 0x3, 0x2, 0x2, 0x2, 0x1ab3, 0x1ab9, 0x9, 0x4, 0x2, 0x2, 0x1ab4, 
       0x1ab5, 0x7, 0x26c, 0x2, 0x2, 0x1ab5, 0x1ab9, 0x5, 0x46a, 0x236, 
       0x2, 0x1ab6, 0x1ab7, 0x7, 0x1d, 0x2, 0x2, 0x1ab7, 0x1ab9, 0x7, 0x3b, 
       0x2, 0x2, 0x1ab8, 0x1ab3, 0x3, 0x2, 0x2, 0x2, 0x1ab8, 0x1ab4, 0x3, 
       0x2, 0x2, 0x2, 0x1ab8, 0x1ab6, 0x3, 0x2, 0x2, 0x2, 0x1ab9, 0x353, 
       0x3, 0x2, 0x2, 0x2, 0x1aba, 0x1abb, 0x7, 0x19b, 0x2, 0x2, 0x1abb, 
       0x1ac0, 0x5, 0x356, 0x1ac, 0x2, 0x1abc, 0x1abd, 0x7, 0x198, 0x2, 
       0x2, 0x1abd, 0x1abf, 0x5, 0x356, 0x1ac, 0x2, 0x1abe, 0x1abc, 0x3, 
       0x2, 0x2, 0x2, 0x1abf, 0x1ac2, 0x3, 0x2, 0x2, 0x2, 0x1ac0, 0x1abe, 
       0x3, 0x2, 0x2, 0x2, 0x1ac0, 0x1ac1, 0x3, 0x2, 0x2, 0x2, 0x1ac1, 0x1ac3, 
       0x3, 0x2, 0x2, 0x2, 0x1ac2, 0x1ac0, 0x3, 0x2, 0x2, 0x2, 0x1ac3, 0x1ac4, 
       0x7, 0x19c, 0x2, 0x2, 0x1ac4, 0x355, 0x3, 0x2, 0x2, 0x2, 0x1ac5, 
       0x1ac7, 0x5, 0x442, 0x222, 0x2, 0x1ac6, 0x1ac8, 0x5, 0x376, 0x1bc, 
       0x2, 0x1ac7, 0x1ac6, 0x3, 0x2, 0x2, 0x2, 0x1ac7, 0x1ac8, 0x3, 0x2, 
       0x2, 0x2, 0x1ac8, 0x1aca, 0x3, 0x2, 0x2, 0x2, 0x1ac9, 0x1acb, 0x5, 
       0x14a, 0xa6, 0x2, 0x1aca, 0x1ac9, 0x3, 0x2, 0x2, 0x2, 0x1aca, 0x1acb, 
       0x3, 0x2, 0x2, 0x2, 0x1acb, 0x357, 0x3, 0x2, 0x2, 0x2, 0x1acc, 0x1acd, 
       0x7, 0x19b, 0x2, 0x2, 0x1acd, 0x1ad2, 0x5, 0x35a, 0x1ae, 0x2, 0x1ace, 
       0x1acf, 0x7, 0x198, 0x2, 0x2, 0x1acf, 0x1ad1, 0x5, 0x35a, 0x1ae, 
       0x2, 0x1ad0, 0x1ace, 0x3, 0x2, 0x2, 0x2, 0x1ad1, 0x1ad4, 0x3, 0x2, 
       0x2, 0x2, 0x1ad2, 0x1ad0, 0x3, 0x2, 0x2, 0x2, 0x1ad2, 0x1ad3, 0x3, 
       0x2, 0x2, 0x2, 0x1ad3, 0x1ad5, 0x3, 0x2, 0x2, 0x2, 0x1ad4, 0x1ad2, 
       0x3, 0x2, 0x2, 0x2, 0x1ad5, 0x1ad6, 0x7, 0x19c, 0x2, 0x2, 0x1ad6, 
       0x359, 0x3, 0x2, 0x2, 0x2, 0x1ad7, 0x1add, 0x5, 0x356, 0x1ac, 0x2, 
       0x1ad8, 0x1ada, 0x5, 0x2e6, 0x174, 0x2, 0x1ad9, 0x1adb, 0x5, 0x14a, 
       0xa6, 0x2, 0x1ada, 0x1ad9, 0x3, 0x2, 0x2, 0x2, 0x1ada, 0x1adb, 0x3, 
       0x2, 0x2, 0x2, 0x1adb, 0x1add, 0x3, 0x2, 0x2, 0x2, 0x1adc, 0x1ad7, 
       0x3, 0x2, 0x2, 0x2, 0x1adc, 0x1ad8, 0x3, 0x2, 0x2, 0x2, 0x1add, 0x35b, 
       0x3, 0x2, 0x2, 0x2, 0x1ade, 0x1adf, 0x6, 0x1af, 0xb4, 0x2, 0x1adf, 
       0x1ae3, 0x5, 0x358, 0x1ad, 0x2, 0x1ae0, 0x1ae1, 0x6, 0x1af, 0xb5, 
       0x2, 0x1ae1, 0x1ae3, 0x5, 0x354, 0x1ab, 0x2, 0x1ae2, 0x1ade, 0x3, 
       0x2, 0x2, 0x2, 0x1ae2, 0x1ae0, 0x3, 0x2, 0x2, 0x2, 0x1ae3, 0x35d, 
       0x3, 0x2, 0x2, 0x2, 0x1ae4, 0x1ae5, 0x9, 0x6d, 0x2, 0x2, 0x1ae5, 
       0x35f, 0x3, 0x2, 0x2, 0x2, 0x1ae6, 0x1ae9, 0x5, 0x362, 0x1b2, 0x2, 
       0x1ae7, 0x1ae9, 0x5, 0x366, 0x1b4, 0x2, 0x1ae8, 0x1ae6, 0x3, 0x2, 
       0x2, 0x2, 0x1ae8, 0x1ae7, 0x3, 0x2, 0x2, 0x2, 0x1ae9, 0x361, 0x3, 
       0x2, 0x2, 0x2, 0x1aea, 0x1aec, 0x7, 0xaf, 0x2, 0x2, 0x1aeb, 0x1aed, 
       0x7, 0x181, 0x2, 0x2, 0x1aec, 0x1aeb, 0x3, 0x2, 0x2, 0x2, 0x1aec, 
       0x1aed, 0x3, 0x2, 0x2, 0x2, 0x1aed, 0x1aee, 0x3, 0x2, 0x2, 0x2, 0x1aee, 
       0x1af5, 0x5, 0x44e, 0x228, 0x2, 0x1aef, 0x1af0, 0x6, 0x1b2, 0xb6, 
       0x2, 0x1af0, 0x1af1, 0x7, 0xd, 0x2, 0x2, 0x1af1, 0x1af5, 0x5, 0x460, 
       0x231, 0x2, 0x1af2, 0x1af3, 0x6, 0x1b2, 0xb7, 0x2, 0x1af3, 0x1af5, 
       0x5, 0x364, 0x1b3, 0x2, 0x1af4, 0x1aea, 0x3, 0x2, 0x2, 0x2, 0x1af4, 
       0x1aef, 0x3, 0x2, 0x2, 0x2, 0x1af4, 0x1af2, 0x3, 0x2, 0x2, 0x2, 0x1af5, 
       0x363, 0x3, 0x2, 0x2, 0x2, 0x1af6, 0x1af7, 0x9, 0x6e, 0x2, 0x2, 0x1af7, 
       0x365, 0x3, 0x2, 0x2, 0x2, 0x1af8, 0x1af9, 0x9, 0x6f, 0x2, 0x2, 0x1af9, 
       0x1afa, 0x5, 0x35e, 0x1b0, 0x2, 0x1afa, 0x367, 0x3, 0x2, 0x2, 0x2, 
       0x1afb, 0x1b00, 0x5, 0x362, 0x1b2, 0x2, 0x1afc, 0x1afd, 0x7, 0x2ab, 
       0x2, 0x2, 0x1afd, 0x1afe, 0x7, 0x21, 0x2, 0x2, 0x1afe, 0x1b00, 0x5, 
       0x442, 0x222, 0x2, 0x1aff, 0x1afb, 0x3, 0x2, 0x2, 0x2, 0x1aff, 0x1afc, 
       0x3, 0x2, 0x2, 0x2, 0x1b00, 0x369, 0x3, 0x2, 0x2, 0x2, 0x1b01, 0x1b02, 
       0x5, 0x362, 0x1b2, 0x2, 0x1b02, 0x36b, 0x3, 0x2, 0x2, 0x2, 0x1b03, 
       0x1b04, 0x5, 0x36e, 0x1b8, 0x2, 0x1b04, 0x1b05, 0x7, 0x2, 0x2, 0x3, 
       0x1b05, 0x36d, 0x3, 0x2, 0x2, 0x2, 0x1b06, 0x1b08, 0x9, 0x70, 0x2, 
       0x2, 0x1b07, 0x1b09, 0x5, 0x376, 0x1bc, 0x2, 0x1b08, 0x1b07, 0x3, 
       0x2, 0x2, 0x2, 0x1b08, 0x1b09, 0x3, 0x2, 0x2, 0x2, 0x1b09, 0x1b0b, 
       0x3, 0x2, 0x2, 0x2, 0x1b0a, 0x1b0c, 0x5, 0x378, 0x1bd, 0x2, 0x1b0b, 
       0x1b0a, 0x3, 0x2, 0x2, 0x2, 0x1b0b, 0x1b0c, 0x3, 0x2, 0x2, 0x2, 0x1b0c, 
       0x1b9a, 0x3, 0x2, 0x2, 0x2, 0x1b0d, 0x1b13, 0x7, 0x259, 0x2, 0x2, 
       0x1b0e, 0x1b10, 0x7, 0x1e8, 0x2, 0x2, 0x1b0f, 0x1b11, 0x7, 0x251, 
       0x2, 0x2, 0x1b10, 0x1b0f, 0x3, 0x2, 0x2, 0x2, 0x1b10, 0x1b11, 0x3, 
       0x2, 0x2, 0x2, 0x1b11, 0x1b13, 0x3, 0x2, 0x2, 0x2, 0x1b12, 0x1b0d, 
       0x3, 0x2, 0x2, 0x2, 0x1b12, 0x1b0e, 0x3, 0x2, 0x2, 0x2, 0x1b13, 0x1b15, 
       0x3, 0x2, 0x2, 0x2, 0x1b14, 0x1b16, 0x5, 0x470, 0x239, 0x2, 0x1b15, 
       0x1b14, 0x3, 0x2, 0x2, 0x2, 0x1b15, 0x1b16, 0x3, 0x2, 0x2, 0x2, 0x1b16, 
       0x1b18, 0x3, 0x2, 0x2, 0x2, 0x1b17, 0x1b19, 0x5, 0x378, 0x1bd, 0x2, 
       0x1b18, 0x1b17, 0x3, 0x2, 0x2, 0x2, 0x1b18, 0x1b19, 0x3, 0x2, 0x2, 
       0x2, 0x1b19, 0x1b9a, 0x3, 0x2, 0x2, 0x2, 0x1b1a, 0x1b1c, 0x9, 0x71, 
       0x2, 0x2, 0x1b1b, 0x1b1d, 0x5, 0x46e, 0x238, 0x2, 0x1b1c, 0x1b1b, 
       0x3, 0x2, 0x2, 0x2, 0x1b1c, 0x1b1d, 0x3, 0x2, 0x2, 0x2, 0x1b1d, 0x1b1f, 
       0x3, 0x2, 0x2, 0x2, 0x1b1e, 0x1b20, 0x5, 0x378, 0x1bd, 0x2, 0x1b1f, 
       0x1b1e, 0x3, 0x2, 0x2, 0x2, 0x1b1f, 0x1b20, 0x3, 0x2, 0x2, 0x2, 0x1b20, 
       0x1b9a, 0x3, 0x2, 0x2, 0x2, 0x1b21, 0x1b23, 0x7, 0x4a, 0x2, 0x2, 
       0x1b22, 0x1b24, 0x5, 0x376, 0x1bc, 0x2, 0x1b23, 0x1b22, 0x3, 0x2, 
       0x2, 0x2, 0x1b23, 0x1b24, 0x3, 0x2, 0x2, 0x2, 0x1b24, 0x1b9a, 0x3, 
       0x2, 0x2, 0x2, 0x1b25, 0x1b9a, 0x9, 0x72, 0x2, 0x2, 0x1b26, 0x1b28, 
       0x7, 0x1c4, 0x2, 0x2, 0x1b27, 0x1b29, 0x5, 0x376, 0x1bc, 0x2, 0x1b28, 
       0x1b27, 0x3, 
  };
  static uint16_t serializedATNSegment3[] = {
    0x2, 0x2, 0x2, 0x1b28, 0x1b29, 0x3, 0x2, 0x2, 0x2, 0x1b29, 0x1b2b, 0x3, 
       0x2, 0x2, 0x2, 0x1b2a, 0x1b2c, 0x5, 0x37a, 0x1be, 0x2, 0x1b2b, 0x1b2a, 
       0x3, 0x2, 0x2, 0x2, 0x1b2b, 0x1b2c, 0x3, 0x2, 0x2, 0x2, 0x1b2c, 0x1b9a, 
       0x3, 0x2, 0x2, 0x2, 0x1b2d, 0x1b2f, 0x5, 0x370, 0x1b9, 0x2, 0x1b2e, 
       0x1b30, 0x5, 0x376, 0x1bc, 0x2, 0x1b2f, 0x1b2e, 0x3, 0x2, 0x2, 0x2, 
       0x1b2f, 0x1b30, 0x3, 0x2, 0x2, 0x2, 0x1b30, 0x1b32, 0x3, 0x2, 0x2, 
       0x2, 0x1b31, 0x1b33, 0x7, 0x1b7, 0x2, 0x2, 0x1b32, 0x1b31, 0x3, 0x2, 
       0x2, 0x2, 0x1b32, 0x1b33, 0x3, 0x2, 0x2, 0x2, 0x1b33, 0x1b9a, 0x3, 
       0x2, 0x2, 0x2, 0x1b34, 0x1b36, 0x7, 0x1b7, 0x2, 0x2, 0x1b35, 0x1b37, 
       0x5, 0x376, 0x1bc, 0x2, 0x1b36, 0x1b35, 0x3, 0x2, 0x2, 0x2, 0x1b36, 
       0x1b37, 0x3, 0x2, 0x2, 0x2, 0x1b37, 0x1b9a, 0x3, 0x2, 0x2, 0x2, 0x1b38, 
       0x1b39, 0x7, 0x1c4, 0x2, 0x2, 0x1b39, 0x1b3c, 0x7, 0x2a4, 0x2, 0x2, 
       0x1b3a, 0x1b3c, 0x7, 0x2a2, 0x2, 0x2, 0x1b3b, 0x1b38, 0x3, 0x2, 0x2, 
       0x2, 0x1b3b, 0x1b3a, 0x3, 0x2, 0x2, 0x2, 0x1b3c, 0x1b3d, 0x3, 0x2, 
       0x2, 0x2, 0x1b3d, 0x1b3f, 0x5, 0x376, 0x1bc, 0x2, 0x1b3e, 0x1b40, 
       0x5, 0x37a, 0x1be, 0x2, 0x1b3f, 0x1b3e, 0x3, 0x2, 0x2, 0x2, 0x1b3f, 
       0x1b40, 0x3, 0x2, 0x2, 0x2, 0x1b40, 0x1b9a, 0x3, 0x2, 0x2, 0x2, 0x1b41, 
       0x1b42, 0x7, 0xe9, 0x2, 0x2, 0x1b42, 0x1b4c, 0x7, 0x2a2, 0x2, 0x2, 
       0x1b43, 0x1b4c, 0x7, 0xf3, 0x2, 0x2, 0x1b44, 0x1b45, 0x7, 0xea, 0x2, 
       0x2, 0x1b45, 0x1b4c, 0x7, 0x2a2, 0x2, 0x2, 0x1b46, 0x1b47, 0x7, 0xe9, 
       0x2, 0x2, 0x1b47, 0x1b48, 0x7, 0x1c4, 0x2, 0x2, 0x1b48, 0x1b4c, 0x7, 
       0x2a4, 0x2, 0x2, 0x1b49, 0x1b4a, 0x7, 0xea, 0x2, 0x2, 0x1b4a, 0x1b4c, 
       0x7, 0x2a4, 0x2, 0x2, 0x1b4b, 0x1b41, 0x3, 0x2, 0x2, 0x2, 0x1b4b, 
       0x1b43, 0x3, 0x2, 0x2, 0x2, 0x1b4b, 0x1b44, 0x3, 0x2, 0x2, 0x2, 0x1b4b, 
       0x1b46, 0x3, 0x2, 0x2, 0x2, 0x1b4b, 0x1b49, 0x3, 0x2, 0x2, 0x2, 0x1b4c, 
       0x1b4d, 0x3, 0x2, 0x2, 0x2, 0x1b4d, 0x1b4f, 0x5, 0x376, 0x1bc, 0x2, 
       0x1b4e, 0x1b50, 0x7, 0x1b7, 0x2, 0x2, 0x1b4f, 0x1b4e, 0x3, 0x2, 0x2, 
       0x2, 0x1b4f, 0x1b50, 0x3, 0x2, 0x2, 0x2, 0x1b50, 0x1b9a, 0x3, 0x2, 
       0x2, 0x2, 0x1b51, 0x1b52, 0x7, 0x2a1, 0x2, 0x2, 0x1b52, 0x1b9a, 0x5, 
       0x376, 0x1bc, 0x2, 0x1b53, 0x1b55, 0x7, 0x17b, 0x2, 0x2, 0x1b54, 
       0x1b56, 0x5, 0x376, 0x1bc, 0x2, 0x1b55, 0x1b54, 0x3, 0x2, 0x2, 0x2, 
       0x1b55, 0x1b56, 0x3, 0x2, 0x2, 0x2, 0x1b56, 0x1b58, 0x3, 0x2, 0x2, 
       0x2, 0x1b57, 0x1b59, 0x5, 0x378, 0x1bd, 0x2, 0x1b58, 0x1b57, 0x3, 
       0x2, 0x2, 0x2, 0x1b58, 0x1b59, 0x3, 0x2, 0x2, 0x2, 0x1b59, 0x1b9a, 
       0x3, 0x2, 0x2, 0x2, 0x1b5a, 0x1b9a, 0x7, 0x72, 0x2, 0x2, 0x1b5b, 
       0x1b5d, 0x7, 0x162, 0x2, 0x2, 0x1b5c, 0x1b5e, 0x5, 0x382, 0x1c2, 
       0x2, 0x1b5d, 0x1b5c, 0x3, 0x2, 0x2, 0x2, 0x1b5d, 0x1b5e, 0x3, 0x2, 
       0x2, 0x2, 0x1b5e, 0x1b9a, 0x3, 0x2, 0x2, 0x2, 0x1b5f, 0x1b61, 0x7, 
       0x15f, 0x2, 0x2, 0x1b60, 0x1b62, 0x5, 0x382, 0x1c2, 0x2, 0x1b61, 
       0x1b60, 0x3, 0x2, 0x2, 0x2, 0x1b61, 0x1b62, 0x3, 0x2, 0x2, 0x2, 0x1b62, 
       0x1b9a, 0x3, 0x2, 0x2, 0x2, 0x1b63, 0x1b65, 0x7, 0x71, 0x2, 0x2, 
       0x1b64, 0x1b66, 0x5, 0x382, 0x1c2, 0x2, 0x1b65, 0x1b64, 0x3, 0x2, 
       0x2, 0x2, 0x1b65, 0x1b66, 0x3, 0x2, 0x2, 0x2, 0x1b66, 0x1b9a, 0x3, 
       0x2, 0x2, 0x2, 0x1b67, 0x1b9a, 0x7, 0x28b, 0x2, 0x2, 0x1b68, 0x1b6a, 
       0x7, 0x1bc, 0x2, 0x2, 0x1b69, 0x1b6b, 0x5, 0x376, 0x1bc, 0x2, 0x1b6a, 
       0x1b69, 0x3, 0x2, 0x2, 0x2, 0x1b6a, 0x1b6b, 0x3, 0x2, 0x2, 0x2, 0x1b6b, 
       0x1b9a, 0x3, 0x2, 0x2, 0x2, 0x1b6c, 0x1b9a, 0x9, 0x73, 0x2, 0x2, 
       0x1b6d, 0x1b6e, 0x7, 0x229, 0x2, 0x2, 0x1b6e, 0x1b9a, 0x7, 0x2a1, 
       0x2, 0x2, 0x1b6f, 0x1b73, 0x7, 0x229, 0x2, 0x2, 0x1b70, 0x1b71, 0x7, 
       0x1c4, 0x2, 0x2, 0x1b71, 0x1b74, 0x7, 0x2a4, 0x2, 0x2, 0x1b72, 0x1b74, 
       0x7, 0x2a2, 0x2, 0x2, 0x1b73, 0x1b70, 0x3, 0x2, 0x2, 0x2, 0x1b73, 
       0x1b72, 0x3, 0x2, 0x2, 0x2, 0x1b73, 0x1b74, 0x3, 0x2, 0x2, 0x2, 0x1b74, 
       0x1b76, 0x3, 0x2, 0x2, 0x2, 0x1b75, 0x1b77, 0x5, 0x37a, 0x1be, 0x2, 
       0x1b76, 0x1b75, 0x3, 0x2, 0x2, 0x2, 0x1b76, 0x1b77, 0x3, 0x2, 0x2, 
       0x2, 0x1b77, 0x1b9a, 0x3, 0x2, 0x2, 0x2, 0x1b78, 0x1b7a, 0x7, 0x28d, 
       0x2, 0x2, 0x1b79, 0x1b7b, 0x5, 0x37a, 0x1be, 0x2, 0x1b7a, 0x1b79, 
       0x3, 0x2, 0x2, 0x2, 0x1b7a, 0x1b7b, 0x3, 0x2, 0x2, 0x2, 0x1b7b, 0x1b9a, 
       0x3, 0x2, 0x2, 0x2, 0x1b7c, 0x1b7e, 0x7, 0x15b, 0x2, 0x2, 0x1b7d, 
       0x1b7f, 0x5, 0x376, 0x1bc, 0x2, 0x1b7e, 0x1b7d, 0x3, 0x2, 0x2, 0x2, 
       0x1b7e, 0x1b7f, 0x3, 0x2, 0x2, 0x2, 0x1b7f, 0x1b81, 0x3, 0x2, 0x2, 
       0x2, 0x1b80, 0x1b82, 0x5, 0x37a, 0x1be, 0x2, 0x1b81, 0x1b80, 0x3, 
       0x2, 0x2, 0x2, 0x1b81, 0x1b82, 0x3, 0x2, 0x2, 0x2, 0x1b82, 0x1b9a, 
       0x3, 0x2, 0x2, 0x2, 0x1b83, 0x1b85, 0x7, 0x233, 0x2, 0x2, 0x1b84, 
       0x1b86, 0x5, 0x37a, 0x1be, 0x2, 0x1b85, 0x1b84, 0x3, 0x2, 0x2, 0x2, 
       0x1b85, 0x1b86, 0x3, 0x2, 0x2, 0x2, 0x1b86, 0x1b9a, 0x3, 0x2, 0x2, 
       0x2, 0x1b87, 0x1b89, 0x7, 0x227, 0x2, 0x2, 0x1b88, 0x1b8a, 0x5, 0x37a, 
       0x1be, 0x2, 0x1b89, 0x1b88, 0x3, 0x2, 0x2, 0x2, 0x1b89, 0x1b8a, 0x3, 
       0x2, 0x2, 0x2, 0x1b8a, 0x1b9a, 0x3, 0x2, 0x2, 0x2, 0x1b8b, 0x1b8c, 
       0x7, 0x81, 0x2, 0x2, 0x1b8c, 0x1b8e, 0x5, 0x45a, 0x22e, 0x2, 0x1b8d, 
       0x1b8f, 0x5, 0x37a, 0x1be, 0x2, 0x1b8e, 0x1b8d, 0x3, 0x2, 0x2, 0x2, 
       0x1b8e, 0x1b8f, 0x3, 0x2, 0x2, 0x2, 0x1b8f, 0x1b9a, 0x3, 0x2, 0x2, 
       0x2, 0x1b90, 0x1b91, 0x7, 0x26c, 0x2, 0x2, 0x1b91, 0x1b93, 0x5, 0x45a, 
       0x22e, 0x2, 0x1b92, 0x1b94, 0x5, 0x37a, 0x1be, 0x2, 0x1b93, 0x1b92, 
       0x3, 0x2, 0x2, 0x2, 0x1b93, 0x1b94, 0x3, 0x2, 0x2, 0x2, 0x1b94, 0x1b9a, 
       0x3, 0x2, 0x2, 0x2, 0x1b95, 0x1b9a, 0x7, 0x134, 0x2, 0x2, 0x1b96, 
       0x1b97, 0x6, 0x1b8, 0xb8, 0x2, 0x1b97, 0x1b9a, 0x7, 0xae, 0x2, 0x2, 
       0x1b98, 0x1b9a, 0x9, 0x74, 0x2, 0x2, 0x1b99, 0x1b06, 0x3, 0x2, 0x2, 
       0x2, 0x1b99, 0x1b12, 0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b1a, 0x3, 0x2, 
       0x2, 0x2, 0x1b99, 0x1b21, 0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b25, 0x3, 
       0x2, 0x2, 0x2, 0x1b99, 0x1b26, 0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b2d, 
       0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b34, 0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b3b, 
       0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b4b, 0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b51, 
       0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b53, 0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b5a, 
       0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b5b, 0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b5f, 
       0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b63, 0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b67, 
       0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b68, 0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b6c, 
       0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b6d, 0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b6f, 
       0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b78, 0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b7c, 
       0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b83, 0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b87, 
       0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b8b, 0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b90, 
       0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b95, 0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b96, 
       0x3, 0x2, 0x2, 0x2, 0x1b99, 0x1b98, 0x3, 0x2, 0x2, 0x2, 0x1b9a, 0x36f, 
       0x3, 0x2, 0x2, 0x2, 0x1b9b, 0x1b9f, 0x7, 0xea, 0x2, 0x2, 0x1b9c, 
       0x1b9d, 0x7, 0xe9, 0x2, 0x2, 0x1b9d, 0x1b9f, 0x7, 0x1c4, 0x2, 0x2, 
       0x1b9e, 0x1b9b, 0x3, 0x2, 0x2, 0x2, 0x1b9e, 0x1b9c, 0x3, 0x2, 0x2, 
       0x2, 0x1b9f, 0x371, 0x3, 0x2, 0x2, 0x2, 0x1ba0, 0x1ba1, 0x7, 0x1c4, 
       0x2, 0x2, 0x1ba1, 0x1ba4, 0x7, 0x2a4, 0x2, 0x2, 0x1ba2, 0x1ba4, 0x7, 
       0x2a2, 0x2, 0x2, 0x1ba3, 0x1ba0, 0x3, 0x2, 0x2, 0x2, 0x1ba3, 0x1ba2, 
       0x3, 0x2, 0x2, 0x2, 0x1ba4, 0x373, 0x3, 0x2, 0x2, 0x2, 0x1ba5, 0x1ba6, 
       0x7, 0xe9, 0x2, 0x2, 0x1ba6, 0x1bb0, 0x7, 0x2a2, 0x2, 0x2, 0x1ba7, 
       0x1bb0, 0x7, 0xf3, 0x2, 0x2, 0x1ba8, 0x1ba9, 0x7, 0xea, 0x2, 0x2, 
       0x1ba9, 0x1bb0, 0x7, 0x2a2, 0x2, 0x2, 0x1baa, 0x1bab, 0x7, 0xe9, 
       0x2, 0x2, 0x1bab, 0x1bac, 0x7, 0x1c4, 0x2, 0x2, 0x1bac, 0x1bb0, 0x7, 
       0x2a4, 0x2, 0x2, 0x1bad, 0x1bae, 0x7, 0xea, 0x2, 0x2, 0x1bae, 0x1bb0, 
       0x7, 0x2a4, 0x2, 0x2, 0x1baf, 0x1ba5, 0x3, 0x2, 0x2, 0x2, 0x1baf, 
       0x1ba7, 0x3, 0x2, 0x2, 0x2, 0x1baf, 0x1ba8, 0x3, 0x2, 0x2, 0x2, 0x1baf, 
       0x1baa, 0x3, 0x2, 0x2, 0x2, 0x1baf, 0x1bad, 0x3, 0x2, 0x2, 0x2, 0x1bb0, 
       0x375, 0x3, 0x2, 0x2, 0x2, 0x1bb1, 0x1bb4, 0x7, 0x19b, 0x2, 0x2, 
       0x1bb2, 0x1bb5, 0x5, 0x454, 0x22b, 0x2, 0x1bb3, 0x1bb5, 0x7, 0x1a9, 
       0x2, 0x2, 0x1bb4, 0x1bb2, 0x3, 0x2, 0x2, 0x2, 0x1bb4, 0x1bb3, 0x3, 
       0x2, 0x2, 0x2, 0x1bb5, 0x1bb6, 0x3, 0x2, 0x2, 0x2, 0x1bb6, 0x1bb7, 
       0x7, 0x19c, 0x2, 0x2, 0x1bb7, 0x377, 0x3, 0x2, 0x2, 0x2, 0x1bb8, 
       0x1bba, 0x9, 0x75, 0x2, 0x2, 0x1bb9, 0x1bb8, 0x3, 0x2, 0x2, 0x2, 
       0x1bba, 0x1bbb, 0x3, 0x2, 0x2, 0x2, 0x1bbb, 0x1bb9, 0x3, 0x2, 0x2, 
       0x2, 0x1bbb, 0x1bbc, 0x3, 0x2, 0x2, 0x2, 0x1bbc, 0x379, 0x3, 0x2, 
       0x2, 0x2, 0x1bbd, 0x1bcc, 0x5, 0x37c, 0x1bf, 0x2, 0x1bbe, 0x1bcc, 
       0x5, 0x37e, 0x1c0, 0x2, 0x1bbf, 0x1bcc, 0x7, 0x8, 0x2, 0x2, 0x1bc0, 
       0x1bc1, 0x5, 0x2da, 0x16e, 0x2, 0x1bc1, 0x1bc3, 0x5, 0x384, 0x1c3, 
       0x2, 0x1bc2, 0x1bc4, 0x7, 0x1b7, 0x2, 0x2, 0x1bc3, 0x1bc2, 0x3, 0x2, 
       0x2, 0x2, 0x1bc3, 0x1bc4, 0x3, 0x2, 0x2, 0x2, 0x1bc4, 0x1bcc, 0x3, 
       0x2, 0x2, 0x2, 0x1bc5, 0x1bc9, 0x7, 0x1b7, 0x2, 0x2, 0x1bc6, 0x1bc7, 
       0x5, 0x2da, 0x16e, 0x2, 0x1bc7, 0x1bc8, 0x5, 0x384, 0x1c3, 0x2, 0x1bc8, 
       0x1bca, 0x3, 0x2, 0x2, 0x2, 0x1bc9, 0x1bc6, 0x3, 0x2, 0x2, 0x2, 0x1bc9, 
       0x1bca, 0x3, 0x2, 0x2, 0x2, 0x1bca, 0x1bcc, 0x3, 0x2, 0x2, 0x2, 0x1bcb, 
       0x1bbd, 0x3, 0x2, 0x2, 0x2, 0x1bcb, 0x1bbe, 0x3, 0x2, 0x2, 0x2, 0x1bcb, 
       0x1bbf, 0x3, 0x2, 0x2, 0x2, 0x1bcb, 0x1bc0, 0x3, 0x2, 0x2, 0x2, 0x1bcb, 
       0x1bc5, 0x3, 0x2, 0x2, 0x2, 0x1bcc, 0x37b, 0x3, 0x2, 0x2, 0x2, 0x1bcd, 
       0x1bcf, 0x7, 0x4, 0x2, 0x2, 0x1bce, 0x1bd0, 0x7, 0x1b7, 0x2, 0x2, 
       0x1bcf, 0x1bce, 0x3, 0x2, 0x2, 0x2, 0x1bcf, 0x1bd0, 0x3, 0x2, 0x2, 
       0x2, 0x1bd0, 0x1bd4, 0x3, 0x2, 0x2, 0x2, 0x1bd1, 0x1bd2, 0x7, 0x1b7, 
       0x2, 0x2, 0x1bd2, 0x1bd4, 0x7, 0x4, 0x2, 0x2, 0x1bd3, 0x1bcd, 0x3, 
       0x2, 0x2, 0x2, 0x1bd3, 0x1bd1, 0x3, 0x2, 0x2, 0x2, 0x1bd4, 0x37d, 
       0x3, 0x2, 0x2, 0x2, 0x1bd5, 0x1bd7, 0x7, 0x35, 0x2, 0x2, 0x1bd6, 
       0x1bd8, 0x7, 0x1b7, 0x2, 0x2, 0x1bd7, 0x1bd6, 0x3, 0x2, 0x2, 0x2, 
       0x1bd7, 0x1bd8, 0x3, 0x2, 0x2, 0x2, 0x1bd8, 0x1bdc, 0x3, 0x2, 0x2, 
       0x2, 0x1bd9, 0x1bda, 0x7, 0x1b7, 0x2, 0x2, 0x1bda, 0x1bdc, 0x7, 0x35, 
       0x2, 0x2, 0x1bdb, 0x1bd5, 0x3, 0x2, 0x2, 0x2, 0x1bdb, 0x1bd9, 0x3, 
       0x2, 0x2, 0x2, 0x1bdc, 0x37f, 0x3, 0x2, 0x2, 0x2, 0x1bdd, 0x1bde, 
       0x7, 0x19b, 0x2, 0x2, 0x1bde, 0x1bdf, 0x5, 0x450, 0x229, 0x2, 0x1bdf, 
       0x1be0, 0x7, 0x19c, 0x2, 0x2, 0x1be0, 0x381, 0x3, 0x2, 0x2, 0x2, 
       0x1be1, 0x1be2, 0x6, 0x1c2, 0xb9, 0x2, 0x1be2, 0x1be3, 0x7, 0x19b, 
       0x2, 0x2, 0x1be3, 0x1be4, 0x7, 0x17e, 0x2, 0x2, 0x1be4, 0x1be5, 0x7, 
       0x19c, 0x2, 0x2, 0x1be5, 0x383, 0x3, 0x2, 0x2, 0x2, 0x1be6, 0x1beb, 
       0x5, 0x472, 0x23a, 0x2, 0x1be7, 0x1beb, 0x7, 0x1b7, 0x2, 0x2, 0x1be8, 
       0x1be9, 0x6, 0x1c3, 0xba, 0x2, 0x1be9, 0x1beb, 0x7, 0x1e0, 0x2, 0x2, 
       0x1bea, 0x1be6, 0x3, 0x2, 0x2, 0x2, 0x1bea, 0x1be7, 0x3, 0x2, 0x2, 
       0x2, 0x1bea, 0x1be8, 0x3, 0x2, 0x2, 0x2, 0x1beb, 0x385, 0x3, 0x2, 
       0x2, 0x2, 0x1bec, 0x1bf0, 0x5, 0x472, 0x23a, 0x2, 0x1bed, 0x1bee, 
       0x6, 0x1c4, 0xbb, 0x2, 0x1bee, 0x1bf0, 0x7, 0x1e0, 0x2, 0x2, 0x1bef, 
       0x1bec, 0x3, 0x2, 0x2, 0x2, 0x1bef, 0x1bed, 0x3, 0x2, 0x2, 0x2, 0x1bf0, 
       0x387, 0x3, 0x2, 0x2, 0x2, 0x1bf1, 0x1bf8, 0x5, 0x38c, 0x1c7, 0x2, 
       0x1bf2, 0x1bf4, 0x7, 0x198, 0x2, 0x2, 0x1bf3, 0x1bf2, 0x3, 0x2, 0x2, 
       0x2, 0x1bf3, 0x1bf4, 0x3, 0x2, 0x2, 0x2, 0x1bf4, 0x1bf5, 0x3, 0x2, 
       0x2, 0x2, 0x1bf5, 0x1bf7, 0x5, 0x38c, 0x1c7, 0x2, 0x1bf6, 0x1bf3, 
       0x3, 0x2, 0x2, 0x2, 0x1bf7, 0x1bfa, 0x3, 0x2, 0x2, 0x2, 0x1bf8, 0x1bf6, 
       0x3, 0x2, 0x2, 0x2, 0x1bf8, 0x1bf9, 0x3, 0x2, 0x2, 0x2, 0x1bf9, 0x389, 
       0x3, 0x2, 0x2, 0x2, 0x1bfa, 0x1bf8, 0x3, 0x2, 0x2, 0x2, 0x1bfb, 0x1bfd, 
       0x5, 0x38c, 0x1c7, 0x2, 0x1bfc, 0x1bfb, 0x3, 0x2, 0x2, 0x2, 0x1bfd, 
       0x1bfe, 0x3, 0x2, 0x2, 0x2, 0x1bfe, 0x1bfc, 0x3, 0x2, 0x2, 0x2, 0x1bfe, 
       0x1bff, 0x3, 0x2, 0x2, 0x2, 0x1bff, 0x38b, 0x3, 0x2, 0x2, 0x2, 0x1c00, 
       0x1c02, 0x7, 0x82, 0x2, 0x2, 0x1c01, 0x1c03, 0x7, 0x181, 0x2, 0x2, 
       0x1c02, 0x1c01, 0x3, 0x2, 0x2, 0x2, 0x1c02, 0x1c03, 0x3, 0x2, 0x2, 
       0x2, 0x1c03, 0x1c04, 0x3, 0x2, 0x2, 0x2, 0x1c04, 0x1c83, 0x5, 0x420, 
       0x211, 0x2, 0x1c05, 0x1c06, 0x6, 0x1c7, 0xbc, 0x2, 0x1c06, 0x1c08, 
       0x7, 0x2f2, 0x2, 0x2, 0x1c07, 0x1c09, 0x5, 0x47a, 0x23e, 0x2, 0x1c08, 
       0x1c07, 0x3, 0x2, 0x2, 0x2, 0x1c08, 0x1c09, 0x3, 0x2, 0x2, 0x2, 0x1c09, 
       0x1c0c, 0x3, 0x2, 0x2, 0x2, 0x1c0a, 0x1c0d, 0x7, 0x241, 0x2, 0x2, 
       0x1c0b, 0x1c0d, 0x5, 0x472, 0x23a, 0x2, 0x1c0c, 0x1c0a, 0x3, 0x2, 
       0x2, 0x2, 0x1c0c, 0x1c0b, 0x3, 0x2, 0x2, 0x2, 0x1c0d, 0x1c83, 0x3, 
       0x2, 0x2, 0x2, 0x1c0e, 0x1c10, 0x7, 0xba, 0x2, 0x2, 0x1c0f, 0x1c11, 
       0x7, 0x181, 0x2, 0x2, 0x1c10, 0x1c0f, 0x3, 0x2, 0x2, 0x2, 0x1c10, 
       0x1c11, 0x3, 0x2, 0x2, 0x2, 0x1c11, 0x1c12, 0x3, 0x2, 0x2, 0x2, 0x1c12, 
       0x1c83, 0x5, 0x452, 0x22a, 0x2, 0x1c13, 0x1c15, 0x7, 0xde, 0x2, 0x2, 
       0x1c14, 0x1c16, 0x7, 0x181, 0x2, 0x2, 0x1c15, 0x1c14, 0x3, 0x2, 0x2, 
       0x2, 0x1c15, 0x1c16, 0x3, 0x2, 0x2, 0x2, 0x1c16, 0x1c17, 0x3, 0x2, 
       0x2, 0x2, 0x1c17, 0x1c83, 0x5, 0x452, 0x22a, 0x2, 0x1c18, 0x1c1a, 
       0x7, 0x47, 0x2, 0x2, 0x1c19, 0x1c1b, 0x7, 0x181, 0x2, 0x2, 0x1c1a, 
       0x1c19, 0x3, 0x2, 0x2, 0x2, 0x1c1a, 0x1c1b, 0x3, 0x2, 0x2, 0x2, 0x1c1b, 
       0x1c1c, 0x3, 0x2, 0x2, 0x2, 0x1c1c, 0x1c83, 0x5, 0x44e, 0x228, 0x2, 
       0x1c1d, 0x1c1f, 0x7, 0xfd, 0x2, 0x2, 0x1c1e, 0x1c20, 0x7, 0x181, 
       0x2, 0x2, 0x1c1f, 0x1c1e, 0x3, 0x2, 0x2, 0x2, 0x1c1f, 0x1c20, 0x3, 
       0x2, 0x2, 0x2, 0x1c20, 0x1c21, 0x3, 0x2, 0x2, 0x2, 0x1c21, 0x1c83, 
       0x5, 0x45c, 0x22f, 0x2, 0x1c22, 0x1c24, 0x7, 0xd, 0x2, 0x2, 0x1c23, 
       0x1c25, 0x7, 0x181, 0x2, 0x2, 0x1c24, 0x1c23, 0x3, 0x2, 0x2, 0x2, 
       0x1c24, 0x1c25, 0x3, 0x2, 0x2, 0x2, 0x1c25, 0x1c26, 0x3, 0x2, 0x2, 
       0x2, 0x1c26, 0x1c83, 0x5, 0x45c, 0x22f, 0x2, 0x1c27, 0x1c28, 0x6, 
       0x1c7, 0xbd, 0x2, 0x1c28, 0x1c2a, 0x7, 0x61, 0x2, 0x2, 0x1c29, 0x1c2b, 
       0x7, 0x181, 0x2, 0x2, 0x1c2a, 0x1c29, 0x3, 0x2, 0x2, 0x2, 0x1c2a, 
       0x1c2b, 0x3, 0x2, 0x2, 0x2, 0x1c2b, 0x1c2c, 0x3, 0x2, 0x2, 0x2, 0x1c2c, 
       0x1c83, 0x5, 0x45e, 0x230, 0x2, 0x1c2d, 0x1c2e, 0x6, 0x1c7, 0xbe, 
       0x2, 0x1c2e, 0x1c30, 0x7, 0x62, 0x2, 0x2, 0x1c2f, 0x1c31, 0x7, 0x181, 
       0x2, 0x2, 0x1c30, 0x1c2f, 0x3, 0x2, 0x2, 0x2, 0x1c30, 0x1c31, 0x3, 
       0x2, 0x2, 0x2, 0x1c31, 0x1c32, 0x3, 0x2, 0x2, 0x2, 0x1c32, 0x1c83, 
       0x5, 0x45e, 0x230, 0x2, 0x1c33, 0x1c35, 0x7, 0x45, 0x2, 0x2, 0x1c34, 
       0x1c36, 0x7, 0x181, 0x2, 0x2, 0x1c35, 0x1c34, 0x3, 0x2, 0x2, 0x2, 
       0x1c35, 0x1c36, 0x3, 0x2, 0x2, 0x2, 0x1c36, 0x1c37, 0x3, 0x2, 0x2, 
       0x2, 0x1c37, 0x1c83, 0x5, 0x452, 0x22a, 0x2, 0x1c38, 0x1c3a, 0x7, 
       0xf8, 0x2, 0x2, 0x1c39, 0x1c3b, 0x7, 0x181, 0x2, 0x2, 0x1c3a, 0x1c39, 
       0x3, 0x2, 0x2, 0x2, 0x1c3a, 0x1c3b, 0x3, 0x2, 0x2, 0x2, 0x1c3b, 0x1c3c, 
       0x3, 0x2, 0x2, 0x2, 0x1c3c, 0x1c83, 0x5, 0x38e, 0x1c8, 0x2, 0x1c3d, 
       0x1c3e, 0x6, 0x1c7, 0xbf, 0x2, 0x1c3e, 0x1c40, 0x9, 0x76, 0x2, 0x2, 
       0x1c3f, 0x1c41, 0x7, 0x181, 0x2, 0x2, 0x1c40, 0x1c3f, 0x3, 0x2, 0x2, 
       0x2, 0x1c40, 0x1c41, 0x3, 0x2, 0x2, 0x2, 0x1c41, 0x1c42, 0x3, 0x2, 
       0x2, 0x2, 0x1c42, 0x1c83, 0x5, 0x38e, 0x1c8, 0x2, 0x1c43, 0x1c45, 
       0x9, 0x77, 0x2, 0x2, 0x1c44, 0x1c46, 0x7, 0x181, 0x2, 0x2, 0x1c45, 
       0x1c44, 0x3, 0x2, 0x2, 0x2, 0x1c45, 0x1c46, 0x3, 0x2, 0x2, 0x2, 0x1c46, 
       0x1c47, 0x3, 0x2, 0x2, 0x2, 0x1c47, 0x1c83, 0x5, 0x44e, 0x228, 0x2, 
       0x1c48, 0x1c4a, 0x7, 0x76, 0x2, 0x2, 0x1c49, 0x1c4b, 0x7, 0x181, 
       0x2, 0x2, 0x1c4a, 0x1c49, 0x3, 0x2, 0x2, 0x2, 0x1c4a, 0x1c4b, 0x3, 
       0x2, 0x2, 0x2, 0x1c4b, 0x1c4c, 0x3, 0x2, 0x2, 0x2, 0x1c4c, 0x1c83, 
       0x5, 0x44e, 0x228, 0x2, 0x1c4d, 0x1c4f, 0x7, 0x12e, 0x2, 0x2, 0x1c4e, 
       0x1c50, 0x7, 0x181, 0x2, 0x2, 0x1c4f, 0x1c4e, 0x3, 0x2, 0x2, 0x2, 
       0x1c4f, 0x1c50, 0x3, 0x2, 0x2, 0x2, 0x1c50, 0x1c51, 0x3, 0x2, 0x2, 
       0x2, 0x1c51, 0x1c83, 0x9, 0x78, 0x2, 0x2, 0x1c52, 0x1c54, 0x7, 0x294, 
       0x2, 0x2, 0x1c53, 0x1c55, 0x7, 0x181, 0x2, 0x2, 0x1c54, 0x1c53, 0x3, 
       0x2, 0x2, 0x2, 0x1c54, 0x1c55, 0x3, 0x2, 0x2, 0x2, 0x1c55, 0x1c56, 
       0x3, 0x2, 0x2, 0x2, 0x1c56, 0x1c57, 0x7, 0x19b, 0x2, 0x2, 0x1c57, 
       0x1c58, 0x5, 0x42a, 0x216, 0x2, 0x1c58, 0x1c59, 0x7, 0x19c, 0x2, 
       0x2, 0x1c59, 0x1c83, 0x3, 0x2, 0x2, 0x2, 0x1c5a, 0x1c83, 0x5, 0x394, 
       0x1cb, 0x2, 0x1c5b, 0x1c83, 0x5, 0x390, 0x1c9, 0x2, 0x1c5c, 0x1c5e, 
       0x7, 0xad, 0x2, 0x2, 0x1c5d, 0x1c5f, 0x7, 0x181, 0x2, 0x2, 0x1c5e, 
       0x1c5d, 0x3, 0x2, 0x2, 0x2, 0x1c5e, 0x1c5f, 0x3, 0x2, 0x2, 0x2, 0x1c5f, 
       0x1c60, 0x3, 0x2, 0x2, 0x2, 0x1c60, 0x1c83, 0x9, 0x79, 0x2, 0x2, 
       0x1c61, 0x1c62, 0x7, 0x6f, 0x2, 0x2, 0x1c62, 0x1c64, 0x7, 0x79, 0x2, 
       0x2, 0x1c63, 0x1c65, 0x7, 0x181, 0x2, 0x2, 0x1c64, 0x1c63, 0x3, 0x2, 
       0x2, 0x2, 0x1c64, 0x1c65, 0x3, 0x2, 0x2, 0x2, 0x1c65, 0x1c66, 0x3, 
       0x2, 0x2, 0x2, 0x1c66, 0x1c83, 0x5, 0x45e, 0x230, 0x2, 0x1c67, 0x1c68, 
       0x7, 0x20a, 0x2, 0x2, 0x1c68, 0x1c6a, 0x7, 0x79, 0x2, 0x2, 0x1c69, 
       0x1c6b, 0x7, 0x181, 0x2, 0x2, 0x1c6a, 0x1c69, 0x3, 0x2, 0x2, 0x2, 
       0x1c6a, 0x1c6b, 0x3, 0x2, 0x2, 0x2, 0x1c6b, 0x1c6c, 0x3, 0x2, 0x2, 
       0x2, 0x1c6c, 0x1c83, 0x5, 0x45e, 0x230, 0x2, 0x1c6d, 0x1c73, 0x7, 
       0x158, 0x2, 0x2, 0x1c6e, 0x1c70, 0x6, 0x1c7, 0xc0, 0x2, 0x1c6f, 0x1c71, 
       0x7, 0x181, 0x2, 0x2, 0x1c70, 0x1c6f, 0x3, 0x2, 0x2, 0x2, 0x1c70, 
       0x1c71, 0x3, 0x2, 0x2, 0x2, 0x1c71, 0x1c74, 0x3, 0x2, 0x2, 0x2, 0x1c72, 
       0x1c74, 0x3, 0x2, 0x2, 0x2, 0x1c73, 0x1c6e, 0x3, 0x2, 0x2, 0x2, 0x1c73, 
       0x1c72, 0x3, 0x2, 0x2, 0x2, 0x1c74, 0x1c75, 0x3, 0x2, 0x2, 0x2, 0x1c75, 
       0x1c83, 0x5, 0x442, 0x222, 0x2, 0x1c76, 0x1c77, 0x7, 0x14a, 0x2, 
       0x2, 0x1c77, 0x1c83, 0x9, 0x7a, 0x2, 0x2, 0x1c78, 0x1c7a, 0x7, 0x64, 
       0x2, 0x2, 0x1c79, 0x1c7b, 0x7, 0x181, 0x2, 0x2, 0x1c7a, 0x1c79, 0x3, 
       0x2, 0x2, 0x2, 0x1c7a, 0x1c7b, 0x3, 0x2, 0x2, 0x2, 0x1c7b, 0x1c7c, 
       0x3, 0x2, 0x2, 0x2, 0x1c7c, 0x1c83, 0x5, 0x45e, 0x230, 0x2, 0x1c7d, 
       0x1c7f, 0x7, 0xaf, 0x2, 0x2, 0x1c7e, 0x1c80, 0x7, 0x181, 0x2, 0x2, 
       0x1c7f, 0x1c7e, 0x3, 0x2, 0x2, 0x2, 0x1c7f, 0x1c80, 0x3, 0x2, 0x2, 
       0x2, 0x1c80, 0x1c81, 0x3, 0x2, 0x2, 0x2, 0x1c81, 0x1c83, 0x5, 0x44e, 
       0x228, 0x2, 0x1c82, 0x1c00, 0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c05, 0x3, 
       0x2, 0x2, 0x2, 0x1c82, 0x1c0e, 0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c13, 
       0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c18, 0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c1d, 
       0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c22, 0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c27, 
       0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c2d, 0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c33, 
       0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c38, 0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c3d, 
       0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c43, 0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c48, 
       0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c4d, 0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c52, 
       0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c5a, 0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c5b, 
       0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c5c, 0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c61, 
       0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c67, 0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c6d, 
       0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c76, 0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c78, 
       0x3, 0x2, 0x2, 0x2, 0x1c82, 0x1c7d, 0x3, 0x2, 0x2, 0x2, 0x1c83, 0x38d, 
       0x3, 0x2, 0x2, 0x2, 0x1c84, 0x1c87, 0x5, 0x44e, 0x228, 0x2, 0x1c85, 
       0x1c87, 0x7, 0x1e0, 0x2, 0x2, 0x1c86, 0x1c84, 0x3, 0x2, 0x2, 0x2, 
       0x1c86, 0x1c85, 0x3, 0x2, 0x2, 0x2, 0x1c87, 0x38f, 0x3, 0x2, 0x2, 
       0x2, 0x1c88, 0x1c8a, 0x7, 0x1e0, 0x2, 0x2, 0x1c89, 0x1c88, 0x3, 0x2, 
       0x2, 0x2, 0x1c89, 0x1c8a, 0x3, 0x2, 0x2, 0x2, 0x1c8a, 0x1c8b, 0x3, 
       0x2, 0x2, 0x2, 0x1c8b, 0x1c8d, 0x7, 0x1c6, 0x2, 0x2, 0x1c8c, 0x1c8e, 
       0x7, 0x181, 0x2, 0x2, 0x1c8d, 0x1c8c, 0x3, 0x2, 0x2, 0x2, 0x1c8d, 
       0x1c8e, 0x3, 0x2, 0x2, 0x2, 0x1c8e, 0x1c8f, 0x3, 0x2, 0x2, 0x2, 0x1c8f, 
       0x1c90, 0x5, 0x386, 0x1c4, 0x2, 0x1c90, 0x391, 0x3, 0x2, 0x2, 0x2, 
       0x1c91, 0x1c93, 0x7, 0x1e0, 0x2, 0x2, 0x1c92, 0x1c91, 0x3, 0x2, 0x2, 
       0x2, 0x1c92, 0x1c93, 0x3, 0x2, 0x2, 0x2, 0x1c93, 0x1c94, 0x3, 0x2, 
       0x2, 0x2, 0x1c94, 0x1c96, 0x7, 0x62, 0x2, 0x2, 0x1c95, 0x1c97, 0x7, 
       0x181, 0x2, 0x2, 0x1c96, 0x1c95, 0x3, 0x2, 0x2, 0x2, 0x1c96, 0x1c97, 
       0x3, 0x2, 0x2, 0x2, 0x1c97, 0x1c98, 0x3, 0x2, 0x2, 0x2, 0x1c98, 0x1c99, 
       0x5, 0x45c, 0x22f, 0x2, 0x1c99, 0x393, 0x3, 0x2, 0x2, 0x2, 0x1c9a, 
       0x1c9c, 0x7, 0x1e0, 0x2, 0x2, 0x1c9b, 0x1c9a, 0x3, 0x2, 0x2, 0x2, 
       0x1c9b, 0x1c9c, 0x3, 0x2, 0x2, 0x2, 0x1c9c, 0x1c9d, 0x3, 0x2, 0x2, 
       0x2, 0x1c9d, 0x1c9f, 0x5, 0x2da, 0x16e, 0x2, 0x1c9e, 0x1ca0, 0x7, 
       0x181, 0x2, 0x2, 0x1c9f, 0x1c9e, 0x3, 0x2, 0x2, 0x2, 0x1c9f, 0x1ca0, 
       0x3, 0x2, 0x2, 0x2, 0x1ca0, 0x1ca1, 0x3, 0x2, 0x2, 0x2, 0x1ca1, 0x1ca2, 
       0x5, 0x384, 0x1c3, 0x2, 0x1ca2, 0x395, 0x3, 0x2, 0x2, 0x2, 0x1ca3, 
       0x1ca4, 0x7, 0x22, 0x2, 0x2, 0x1ca4, 0x1ca5, 0x7, 0x1be, 0x2, 0x2, 
       0x1ca5, 0x1ca8, 0x5, 0x398, 0x1cd, 0x2, 0x1ca6, 0x1ca7, 0x7, 0xfc, 
       0x2, 0x2, 0x1ca7, 0x1ca9, 0x5, 0x450, 0x229, 0x2, 0x1ca8, 0x1ca6, 
       0x3, 0x2, 0x2, 0x2, 0x1ca8, 0x1ca9, 0x3, 0x2, 0x2, 0x2, 0x1ca9, 0x1cab, 
       0x3, 0x2, 0x2, 0x2, 0x1caa, 0x1cac, 0x5, 0x39a, 0x1ce, 0x2, 0x1cab, 
       0x1caa, 0x3, 0x2, 0x2, 0x2, 0x1cab, 0x1cac, 0x3, 0x2, 0x2, 0x2, 0x1cac, 
       0x1cae, 0x3, 0x2, 0x2, 0x2, 0x1cad, 0x1caf, 0x5, 0x39e, 0x1d0, 0x2, 
       0x1cae, 0x1cad, 0x3, 0x2, 0x2, 0x2, 0x1cae, 0x1caf, 0x3, 0x2, 0x2, 
       0x2, 0x1caf, 0x397, 0x3, 0x2, 0x2, 0x2, 0x1cb0, 0x1cb2, 0x7, 0x221, 
       0x2, 0x2, 0x1cb1, 0x1cb0, 0x3, 0x2, 0x2, 0x2, 0x1cb1, 0x1cb2, 0x3, 
       0x2, 0x2, 0x2, 0x1cb2, 0x1cb3, 0x3, 0x2, 0x2, 0x2, 0x1cb3, 0x1cb5, 
       0x7, 0x21a, 0x2, 0x2, 0x1cb4, 0x1cb6, 0x5, 0x39c, 0x1cf, 0x2, 0x1cb5, 
       0x1cb4, 0x3, 0x2, 0x2, 0x2, 0x1cb5, 0x1cb6, 0x3, 0x2, 0x2, 0x2, 0x1cb6, 
       0x1cb7, 0x3, 0x2, 0x2, 0x2, 0x1cb7, 0x1cb9, 0x7, 0x19b, 0x2, 0x2, 
       0x1cb8, 0x1cba, 0x5, 0x444, 0x223, 0x2, 0x1cb9, 0x1cb8, 0x3, 0x2, 
       0x2, 0x2, 0x1cb9, 0x1cba, 0x3, 0x2, 0x2, 0x2, 0x1cba, 0x1cbb, 0x3, 
       0x2, 0x2, 0x2, 0x1cbb, 0x1cd2, 0x7, 0x19c, 0x2, 0x2, 0x1cbc, 0x1cbe, 
       0x7, 0x221, 0x2, 0x2, 0x1cbd, 0x1cbc, 0x3, 0x2, 0x2, 0x2, 0x1cbd, 
       0x1cbe, 0x3, 0x2, 0x2, 0x2, 0x1cbe, 0x1cbf, 0x3, 0x2, 0x2, 0x2, 0x1cbf, 
       0x1cc0, 0x7, 0x9e, 0x2, 0x2, 0x1cc0, 0x1cc1, 0x7, 0x19b, 0x2, 0x2, 
       0x1cc1, 0x1cc2, 0x5, 0x294, 0x14b, 0x2, 0x1cc2, 0x1cc3, 0x7, 0x19c, 
       0x2, 0x2, 0x1cc3, 0x1cd2, 0x3, 0x2, 0x2, 0x2, 0x1cc4, 0x1ccf, 0x9, 
       0x7b, 0x2, 0x2, 0x1cc5, 0x1cc6, 0x7, 0x19b, 0x2, 0x2, 0x1cc6, 0x1cc7, 
       0x5, 0x294, 0x14b, 0x2, 0x1cc7, 0x1cc8, 0x7, 0x19c, 0x2, 0x2, 0x1cc8, 
       0x1cd0, 0x3, 0x2, 0x2, 0x2, 0x1cc9, 0x1cca, 0x7, 0x5c, 0x2, 0x2, 
       0x1cca, 0x1ccc, 0x7, 0x19b, 0x2, 0x2, 0x1ccb, 0x1ccd, 0x5, 0x444, 
       0x223, 0x2, 0x1ccc, 0x1ccb, 0x3, 0x2, 0x2, 0x2, 0x1ccc, 0x1ccd, 0x3, 
       0x2, 0x2, 0x2, 0x1ccd, 0x1cce, 0x3, 0x2, 0x2, 0x2, 0x1cce, 0x1cd0, 
       0x7, 0x19c, 0x2, 0x2, 0x1ccf, 0x1cc5, 0x3, 0x2, 0x2, 0x2, 0x1ccf, 
       0x1cc9, 0x3, 0x2, 0x2, 0x2, 0x1cd0, 0x1cd2, 0x3, 0x2, 0x2, 0x2, 0x1cd1, 
       0x1cb1, 0x3, 0x2, 0x2, 0x2, 0x1cd1, 0x1cbd, 0x3, 0x2, 0x2, 0x2, 0x1cd1, 
       0x1cc4, 0x3, 0x2, 0x2, 0x2, 0x1cd2, 0x399, 0x3, 0x2, 0x2, 0x2, 0x1cd3, 
       0x1cd4, 0x7, 0x14f, 0x2, 0x2, 0x1cd4, 0x1cd6, 0x7, 0x1be, 0x2, 0x2, 
       0x1cd5, 0x1cd7, 0x7, 0x221, 0x2, 0x2, 0x1cd6, 0x1cd5, 0x3, 0x2, 0x2, 
       0x2, 0x1cd6, 0x1cd7, 0x3, 0x2, 0x2, 0x2, 0x1cd7, 0x1ce2, 0x3, 0x2, 
       0x2, 0x2, 0x1cd8, 0x1cd9, 0x7, 0x9e, 0x2, 0x2, 0x1cd9, 0x1cda, 0x7, 
       0x19b, 0x2, 0x2, 0x1cda, 0x1cdb, 0x5, 0x294, 0x14b, 0x2, 0x1cdb, 
       0x1cdc, 0x7, 0x19c, 0x2, 0x2, 0x1cdc, 0x1ce3, 0x3, 0x2, 0x2, 0x2, 
       0x1cdd, 0x1cdf, 0x7, 0x21a, 0x2, 0x2, 0x1cde, 0x1ce0, 0x5, 0x39c, 
       0x1cf, 0x2, 0x1cdf, 0x1cde, 0x3, 0x2, 0x2, 0x2, 0x1cdf, 0x1ce0, 0x3, 
       0x2, 0x2, 0x2, 0x1ce0, 0x1ce1, 0x3, 0x2, 0x2, 0x2, 0x1ce1, 0x1ce3, 
       0x5, 0x446, 0x224, 0x2, 0x1ce2, 0x1cd8, 0x3, 0x2, 0x2, 0x2, 0x1ce2, 
       0x1cdd, 0x3, 0x2, 0x2, 0x2, 0x1ce3, 0x1ce6, 0x3, 0x2, 0x2, 0x2, 0x1ce4, 
       0x1ce5, 0x7, 0x150, 0x2, 0x2, 0x1ce5, 0x1ce7, 0x5, 0x450, 0x229, 
       0x2, 0x1ce6, 0x1ce4, 0x3, 0x2, 0x2, 0x2, 0x1ce6, 0x1ce7, 0x3, 0x2, 
       0x2, 0x2, 0x1ce7, 0x39b, 0x3, 0x2, 0x2, 0x2, 0x1ce8, 0x1ce9, 0x6, 
       0x1cf, 0xc1, 0x2, 0x1ce9, 0x1cea, 0x7, 0x40, 0x2, 0x2, 0x1cea, 0x1ceb, 
       0x7, 0x181, 0x2, 0x2, 0x1ceb, 0x1cec, 0x5, 0x450, 0x229, 0x2, 0x1cec, 
       0x39d, 0x3, 0x2, 0x2, 0x2, 0x1ced, 0x1cee, 0x7, 0x19b, 0x2, 0x2, 
       0x1cee, 0x1cf3, 0x5, 0x3a0, 0x1d1, 0x2, 0x1cef, 0x1cf0, 0x7, 0x198, 
       0x2, 0x2, 0x1cf0, 0x1cf2, 0x5, 0x3a0, 0x1d1, 0x2, 0x1cf1, 0x1cef, 
       0x3, 0x2, 0x2, 0x2, 0x1cf2, 0x1cf5, 0x3, 0x2, 0x2, 0x2, 0x1cf3, 0x1cf1, 
       0x3, 0x2, 0x2, 0x2, 0x1cf3, 0x1cf4, 0x3, 0x2, 0x2, 0x2, 0x1cf4, 0x1cf6, 
       0x3, 0x2, 0x2, 0x2, 0x1cf5, 0x1cf3, 0x3, 0x2, 0x2, 0x2, 0x1cf6, 0x1cf7, 
       0x7, 0x19c, 0x2, 0x2, 0x1cf7, 0x39f, 0x3, 0x2, 0x2, 0x2, 0x1cf8, 
       0x1cf9, 0x7, 0x22, 0x2, 0x2, 0x1cf9, 0x1d04, 0x5, 0x442, 0x222, 0x2, 
       0x1cfa, 0x1cfb, 0x7, 0x2a0, 0x2, 0x2, 0x1cfb, 0x1cfc, 0x7, 0xb2, 
       0x2, 0x2, 0x1cfc, 0x1cff, 0x7, 0x15c, 0x2, 0x2, 0x1cfd, 0x1d00, 0x5, 
       0x3a8, 0x1d5, 0x2, 0x1cfe, 0x1d00, 0x7, 0x230, 0x2, 0x2, 0x1cff, 
       0x1cfd, 0x3, 0x2, 0x2, 0x2, 0x1cff, 0x1cfe, 0x3, 0x2, 0x2, 0x2, 0x1d00, 
       0x1d05, 0x3, 0x2, 0x2, 0x2, 0x1d01, 0x1d02, 0x7, 0x2a0, 0x2, 0x2, 
       0x1d02, 0x1d03, 0x7, 0x213, 0x2, 0x2, 0x1d03, 0x1d05, 0x5, 0x3a2, 
       0x1d2, 0x2, 0x1d04, 0x1cfa, 0x3, 0x2, 0x2, 0x2, 0x1d04, 0x1d01, 0x3, 
       0x2, 0x2, 0x2, 0x1d04, 0x1d05, 0x3, 0x2, 0x2, 0x2, 0x1d05, 0x1d09, 
       0x3, 0x2, 0x2, 0x2, 0x1d06, 0x1d08, 0x5, 0x3a4, 0x1d3, 0x2, 0x1d07, 
       0x1d06, 0x3, 0x2, 0x2, 0x2, 0x1d08, 0x1d0b, 0x3, 0x2, 0x2, 0x2, 0x1d09, 
       0x1d07, 0x3, 0x2, 0x2, 0x2, 0x1d09, 0x1d0a, 0x3, 0x2, 0x2, 0x2, 0x1d0a, 
       0x1d17, 0x3, 0x2, 0x2, 0x2, 0x1d0b, 0x1d09, 0x3, 0x2, 0x2, 0x2, 0x1d0c, 
       0x1d0d, 0x7, 0x19b, 0x2, 0x2, 0x1d0d, 0x1d12, 0x5, 0x3a6, 0x1d4, 
       0x2, 0x1d0e, 0x1d0f, 0x7, 0x198, 0x2, 0x2, 0x1d0f, 0x1d11, 0x5, 0x3a6, 
       0x1d4, 0x2, 0x1d10, 0x1d0e, 0x3, 0x2, 0x2, 0x2, 0x1d11, 0x1d14, 0x3, 
       0x2, 0x2, 0x2, 0x1d12, 0x1d10, 0x3, 0x2, 0x2, 0x2, 0x1d12, 0x1d13, 
       0x3, 0x2, 0x2, 0x2, 0x1d13, 0x1d15, 0x3, 0x2, 0x2, 0x2, 0x1d14, 0x1d12, 
       0x3, 0x2, 0x2, 0x2, 0x1d15, 0x1d16, 0x7, 0x19c, 0x2, 0x2, 0x1d16, 
       0x1d18, 0x3, 0x2, 0x2, 0x2, 0x1d17, 0x1d0c, 0x3, 0x2, 0x2, 0x2, 0x1d17, 
       0x1d18, 0x3, 0x2, 0x2, 0x2, 0x1d18, 0x3a1, 0x3, 0x2, 0x2, 0x2, 0x1d19, 
       0x1d26, 0x5, 0x3a8, 0x1d5, 0x2, 0x1d1a, 0x1d1b, 0x7, 0x19b, 0x2, 
       0x2, 0x1d1b, 0x1d20, 0x5, 0x3a8, 0x1d5, 0x2, 0x1d1c, 0x1d1d, 0x7, 
       0x198, 0x2, 0x2, 0x1d1d, 0x1d1f, 0x5, 0x3a8, 0x1d5, 0x2, 0x1d1e, 
       0x1d1c, 0x3, 0x2, 0x2, 0x2, 0x1d1f, 0x1d22, 0x3, 0x2, 0x2, 0x2, 0x1d20, 
       0x1d1e, 0x3, 0x2, 0x2, 0x2, 0x1d20, 0x1d21, 0x3, 0x2, 0x2, 0x2, 0x1d21, 
       0x1d23, 0x3, 0x2, 0x2, 0x2, 0x1d22, 0x1d20, 0x3, 0x2, 0x2, 0x2, 0x1d23, 
       0x1d24, 0x7, 0x19c, 0x2, 0x2, 0x1d24, 0x1d26, 0x3, 0x2, 0x2, 0x2, 
       0x1d25, 0x1d19, 0x3, 0x2, 0x2, 0x2, 0x1d25, 0x1d1a, 0x3, 0x2, 0x2, 
       0x2, 0x1d26, 0x3a3, 0x3, 0x2, 0x2, 0x2, 0x1d27, 0x1d29, 0x7, 0x158, 
       0x2, 0x2, 0x1d28, 0x1d2a, 0x7, 0x181, 0x2, 0x2, 0x1d29, 0x1d28, 0x3, 
       0x2, 0x2, 0x2, 0x1d29, 0x1d2a, 0x3, 0x2, 0x2, 0x2, 0x1d2a, 0x1d2b, 
       0x3, 0x2, 0x2, 0x2, 0x1d2b, 0x1d4a, 0x5, 0x442, 0x222, 0x2, 0x1d2c, 
       0x1d2e, 0x7, 0x14a, 0x2, 0x2, 0x1d2d, 0x1d2c, 0x3, 0x2, 0x2, 0x2, 
       0x1d2d, 0x1d2e, 0x3, 0x2, 0x2, 0x2, 0x1d2e, 0x1d2f, 0x3, 0x2, 0x2, 
       0x2, 0x1d2f, 0x1d31, 0x7, 0x82, 0x2, 0x2, 0x1d30, 0x1d32, 0x7, 0x181, 
       0x2, 0x2, 0x1d31, 0x1d30, 0x3, 0x2, 0x2, 0x2, 0x1d31, 0x1d32, 0x3, 
       0x2, 0x2, 0x2, 0x1d32, 0x1d33, 0x3, 0x2, 0x2, 0x2, 0x1d33, 0x1d4a, 
       0x5, 0x420, 0x211, 0x2, 0x1d34, 0x1d36, 0x7, 0xf0, 0x2, 0x2, 0x1d35, 
       0x1d37, 0x7, 0x181, 0x2, 0x2, 0x1d36, 0x1d35, 0x3, 0x2, 0x2, 0x2, 
       0x1d36, 0x1d37, 0x3, 0x2, 0x2, 0x2, 0x1d37, 0x1d38, 0x3, 0x2, 0x2, 
       0x2, 0x1d38, 0x1d4a, 0x5, 0x450, 0x229, 0x2, 0x1d39, 0x1d3b, 0x9, 
       0x7c, 0x2, 0x2, 0x1d3a, 0x1d3c, 0x7, 0x181, 0x2, 0x2, 0x1d3b, 0x1d3a, 
       0x3, 0x2, 0x2, 0x2, 0x1d3b, 0x1d3c, 0x3, 0x2, 0x2, 0x2, 0x1d3c, 0x1d3d, 
       0x3, 0x2, 0x2, 0x2, 0x1d3d, 0x1d4a, 0x5, 0x450, 0x229, 0x2, 0x1d3e, 
       0x1d3f, 0x9, 0x7d, 0x2, 0x2, 0x1d3f, 0x1d41, 0x7, 0x79, 0x2, 0x2, 
       0x1d40, 0x1d42, 0x7, 0x181, 0x2, 0x2, 0x1d41, 0x1d40, 0x3, 0x2, 0x2, 
       0x2, 0x1d41, 0x1d42, 0x3, 0x2, 0x2, 0x2, 0x1d42, 0x1d43, 0x3, 0x2, 
       0x2, 0x2, 0x1d43, 0x1d4a, 0x5, 0x460, 0x231, 0x2, 0x1d44, 0x1d46, 
       0x7, 0xd, 0x2, 0x2, 0x1d45, 0x1d47, 0x7, 0x181, 0x2, 0x2, 0x1d46, 
       0x1d45, 0x3, 0x2, 0x2, 0x2, 0x1d46, 0x1d47, 0x3, 0x2, 0x2, 0x2, 0x1d47, 
       0x1d48, 0x3, 0x2, 0x2, 0x2, 0x1d48, 0x1d4a, 0x5, 0x460, 0x231, 0x2, 
       0x1d49, 0x1d27, 0x3, 0x2, 0x2, 0x2, 0x1d49, 0x1d2d, 0x3, 0x2, 0x2, 
       0x2, 0x1d49, 0x1d34, 0x3, 0x2, 0x2, 0x2, 0x1d49, 0x1d39, 0x3, 0x2, 
       0x2, 0x2, 0x1d49, 0x1d3e, 0x3, 0x2, 0x2, 0x2, 0x1d49, 0x1d44, 0x3, 
       0x2, 0x2, 0x2, 0x1d4a, 0x3a5, 0x3, 0x2, 0x2, 0x2, 0x1d4b, 0x1d4c, 
       0x7, 0x14f, 0x2, 0x2, 0x1d4c, 0x1d50, 0x5, 0x472, 0x23a, 0x2, 0x1d4d, 
       0x1d4f, 0x5, 0x3a4, 0x1d3, 0x2, 0x1d4e, 0x1d4d, 0x3, 0x2, 0x2, 0x2, 
       0x1d4f, 0x1d52, 0x3, 0x2, 0x2, 0x2, 0x1d50, 0x1d4e, 0x3, 0x2, 0x2, 
       0x2, 0x1d50, 0x1d51, 0x3, 0x2, 0x2, 0x2, 0x1d51, 0x3a7, 0x3, 0x2, 
       0x2, 0x2, 0x1d52, 0x1d50, 0x3, 0x2, 0x2, 0x2, 0x1d53, 0x1d54, 0x7, 
       0x19b, 0x2, 0x2, 0x1d54, 0x1d59, 0x5, 0x3aa, 0x1d6, 0x2, 0x1d55, 
       0x1d56, 0x7, 0x198, 0x2, 0x2, 0x1d56, 0x1d58, 0x5, 0x3aa, 0x1d6, 
       0x2, 0x1d57, 0x1d55, 0x3, 0x2, 0x2, 0x2, 0x1d58, 0x1d5b, 0x3, 0x2, 
       0x2, 0x2, 0x1d59, 0x1d57, 0x3, 0x2, 0x2, 0x2, 0x1d59, 0x1d5a, 0x3, 
       0x2, 0x2, 0x2, 0x1d5a, 0x1d5c, 0x3, 0x2, 0x2, 0x2, 0x1d5b, 0x1d59, 
       0x3, 0x2, 0x2, 0x2, 0x1d5c, 0x1d5d, 0x7, 0x19c, 0x2, 0x2, 0x1d5d, 
       0x3a9, 0x3, 0x2, 0x2, 0x2, 0x1d5e, 0x1d61, 0x5, 0x294, 0x14b, 0x2, 
       0x1d5f, 0x1d61, 0x7, 0x230, 0x2, 0x2, 0x1d60, 0x1d5e, 0x3, 0x2, 0x2, 
       0x2, 0x1d60, 0x1d5f, 0x3, 0x2, 0x2, 0x2, 0x1d61, 0x3ab, 0x3, 0x2, 
       0x2, 0x2, 0x1d62, 0x1d63, 0x7, 0x75, 0x2, 0x2, 0x1d63, 0x1d64, 0x7, 
       0x181, 0x2, 0x2, 0x1d64, 0x1d65, 0x5, 0x3dc, 0x1ef, 0x2, 0x1d65, 
       0x3ad, 0x3, 0x2, 0x2, 0x2, 0x1d66, 0x1d67, 0x7, 0x208, 0x2, 0x2, 
       0x1d67, 0x1d68, 0x7, 0x1f2, 0x2, 0x2, 0x1d68, 0x3af, 0x3, 0x2, 0x2, 
       0x2, 0x1d69, 0x1d6a, 0x7, 0x208, 0x2, 0x2, 0x1d6a, 0x1d6b, 0x5, 0x2dc, 
       0x16f, 0x2, 0x1d6b, 0x1d6c, 0x7, 0x1f2, 0x2, 0x2, 0x1d6c, 0x3b1, 
       0x3, 0x2, 0x2, 0x2, 0x1d6d, 0x1d6f, 0x9, 0x7e, 0x2, 0x2, 0x1d6e, 
       0x1d6d, 0x3, 0x2, 0x2, 0x2, 0x1d6e, 0x1d6f, 0x3, 0x2, 0x2, 0x2, 0x1d6f, 
       0x1d70, 0x3, 0x2, 0x2, 0x2, 0x1d70, 0x1d71, 0x5, 0x3b4, 0x1db, 0x2, 
       0x1d71, 0x3b3, 0x3, 0x2, 0x2, 0x2, 0x1d72, 0x1d73, 0x5, 0x42e, 0x218, 
       0x2, 0x1d73, 0x1d74, 0x5, 0x3b8, 0x1dd, 0x2, 0x1d74, 0x3b5, 0x3, 
       0x2, 0x2, 0x2, 0x1d75, 0x1d76, 0x7, 0x1c6, 0x2, 0x2, 0x1d76, 0x1d77, 
       0x5, 0x386, 0x1c4, 0x2, 0x1d77, 0x3b7, 0x3, 0x2, 0x2, 0x2, 0x1d78, 
       0x1d7a, 0x5, 0x36e, 0x1b8, 0x2, 0x1d79, 0x1d7b, 0x5, 0x3b6, 0x1dc, 
       0x2, 0x1d7a, 0x1d79, 0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d7b, 0x3, 0x2, 
       0x2, 0x2, 0x1d7b, 0x3b9, 0x3, 0x2, 0x2, 0x2, 0x1d7c, 0x1d7d, 0x7, 
       0x19b, 0x2, 0x2, 0x1d7d, 0x1d7e, 0x5, 0x3fc, 0x1ff, 0x2, 0x1d7e, 
       0x1d7f, 0x7, 0x198, 0x2, 0x2, 0x1d7f, 0x1d80, 0x5, 0x3fc, 0x1ff, 
       0x2, 0x1d80, 0x1d81, 0x7, 0x19c, 0x2, 0x2, 0x1d81, 0x3bb, 0x3, 0x2, 
       0x2, 0x2, 0x1d82, 0x1d87, 0x5, 0x40c, 0x207, 0x2, 0x1d83, 0x1d84, 
       0x7, 0x198, 0x2, 0x2, 0x1d84, 0x1d86, 0x5, 0x40c, 0x207, 0x2, 0x1d85, 
       0x1d83, 0x3, 0x2, 0x2, 0x2, 0x1d86, 0x1d89, 0x3, 0x2, 0x2, 0x2, 0x1d87, 
       0x1d85, 0x3, 0x2, 0x2, 0x2, 0x1d87, 0x1d88, 0x3, 0x2, 0x2, 0x2, 0x1d88, 
       0x3bd, 0x3, 0x2, 0x2, 0x2, 0x1d89, 0x1d87, 0x3, 0x2, 0x2, 0x2, 0x1d8a, 
       0x1d8f, 0x5, 0x3c0, 0x1e1, 0x2, 0x1d8b, 0x1d8c, 0x7, 0x198, 0x2, 
       0x2, 0x1d8c, 0x1d8e, 0x5, 0x3c0, 0x1e1, 0x2, 0x1d8d, 0x1d8b, 0x3, 
       0x2, 0x2, 0x2, 0x1d8e, 0x1d91, 0x3, 0x2, 0x2, 0x2, 0x1d8f, 0x1d8d, 
       0x3, 0x2, 0x2, 0x2, 0x1d8f, 0x1d90, 0x3, 0x2, 0x2, 0x2, 0x1d90, 0x3bf, 
       0x3, 0x2, 0x2, 0x2, 0x1d91, 0x1d8f, 0x3, 0x2, 0x2, 0x2, 0x1d92, 0x1d93, 
       0x5, 0x3f0, 0x1f9, 0x2, 0x1d93, 0x1d96, 0x7, 0x181, 0x2, 0x2, 0x1d94, 
       0x1d97, 0x5, 0x28a, 0x146, 0x2, 0x1d95, 0x1d97, 0x7, 0x1e0, 0x2, 
       0x2, 0x1d96, 0x1d94, 0x3, 0x2, 0x2, 0x2, 0x1d96, 0x1d95, 0x3, 0x2, 
       0x2, 0x2, 0x1d97, 0x3c1, 0x3, 0x2, 0x2, 0x2, 0x1d98, 0x1d99, 0x5, 
       0x2da, 0x16e, 0x2, 0x1d99, 0x1d9a, 0x5, 0x384, 0x1c3, 0x2, 0x1d9a, 
       0x3c3, 0x3, 0x2, 0x2, 0x2, 0x1d9b, 0x1d9d, 0x7, 0x5c, 0x2, 0x2, 0x1d9c, 
       0x1d9e, 0x5, 0x3c6, 0x1e4, 0x2, 0x1d9d, 0x1d9c, 0x3, 0x2, 0x2, 0x2, 
       0x1d9e, 0x1d9f, 0x3, 0x2, 0x2, 0x2, 0x1d9f, 0x1d9d, 0x3, 0x2, 0x2, 
       0x2, 0x1d9f, 0x1da0, 0x3, 0x2, 0x2, 0x2, 0x1da0, 0x3c5, 0x3, 0x2, 
       0x2, 0x2, 0x1da1, 0x1da2, 0x7, 0x289, 0x2, 0x2, 0x1da2, 0x1da3, 0x7, 
       0x1be, 0x2, 0x2, 0x1da3, 0x1dae, 0x5, 0x45e, 0x230, 0x2, 0x1da4, 
       0x1da6, 0x7, 0x24a, 0x2, 0x2, 0x1da5, 0x1da4, 0x3, 0x2, 0x2, 0x2, 
       0x1da5, 0x1da6, 0x3, 0x2, 0x2, 0x2, 0x1da6, 0x1da7, 0x3, 0x2, 0x2, 
       0x2, 0x1da7, 0x1da8, 0x7, 0x1ee, 0x2, 0x2, 0x1da8, 0x1da9, 0x7, 0x1be, 
       0x2, 0x2, 0x1da9, 0x1dae, 0x5, 0x45e, 0x230, 0x2, 0x1daa, 0x1dab, 
       0x7, 0x1f0, 0x2, 0x2, 0x1dab, 0x1dac, 0x7, 0x1be, 0x2, 0x2, 0x1dac, 
       0x1dae, 0x5, 0x45e, 0x230, 0x2, 0x1dad, 0x1da1, 0x3, 0x2, 0x2, 0x2, 
       0x1dad, 0x1da5, 0x3, 0x2, 0x2, 0x2, 0x1dad, 0x1daa, 0x3, 0x2, 0x2, 
       0x2, 0x1dae, 0x3c7, 0x3, 0x2, 0x2, 0x2, 0x1daf, 0x1db1, 0x7, 0x222, 
       0x2, 0x2, 0x1db0, 0x1db2, 0x5, 0x3ca, 0x1e6, 0x2, 0x1db1, 0x1db0, 
       0x3, 0x2, 0x2, 0x2, 0x1db2, 0x1db3, 0x3, 0x2, 0x2, 0x2, 0x1db3, 0x1db1, 
       0x3, 0x2, 0x2, 0x2, 0x1db3, 0x1db4, 0x3, 0x2, 0x2, 0x2, 0x1db4, 0x3c9, 
       0x3, 0x2, 0x2, 0x2, 0x1db5, 0x1db6, 0x9, 0x7f, 0x2, 0x2, 0x1db6, 
       0x1db7, 0x7, 0x1be, 0x2, 0x2, 0x1db7, 0x1db8, 0x5, 0x45e, 0x230, 
       0x2, 0x1db8, 0x3cb, 0x3, 0x2, 0x2, 0x2, 0x1db9, 0x1dbe, 0x5, 0x3dc, 
       0x1ef, 0x2, 0x1dba, 0x1dbb, 0x7, 0x198, 0x2, 0x2, 0x1dbb, 0x1dbd, 
       0x5, 0x3dc, 0x1ef, 0x2, 0x1dbc, 0x1dba, 0x3, 0x2, 0x2, 0x2, 0x1dbd, 
       0x1dc0, 0x3, 0x2, 0x2, 0x2, 0x1dbe, 0x1dbc, 0x3, 0x2, 0x2, 0x2, 0x1dbe, 
       0x1dbf, 0x3, 0x2, 0x2, 0x2, 0x1dbf, 0x3cd, 0x3, 0x2, 0x2, 0x2, 0x1dc0, 
       0x1dbe, 0x3, 0x2, 0x2, 0x2, 0x1dc1, 0x1dc6, 0x5, 0x3d2, 0x1ea, 0x2, 
       0x1dc2, 0x1dc3, 0x7, 0x198, 0x2, 0x2, 0x1dc3, 0x1dc5, 0x5, 0x3d2, 
       0x1ea, 0x2, 0x1dc4, 0x1dc2, 0x3, 0x2, 0x2, 0x2, 0x1dc5, 0x1dc8, 0x3, 
       0x2, 0x2, 0x2, 0x1dc6, 0x1dc4, 0x3, 0x2, 0x2, 0x2, 0x1dc6, 0x1dc7, 
       0x3, 0x2, 0x2, 0x2, 0x1dc7, 0x3cf, 0x3, 0x2, 0x2, 0x2, 0x1dc8, 0x1dc6, 
       0x3, 0x2, 0x2, 0x2, 0x1dc9, 0x1dce, 0x5, 0x3d4, 0x1eb, 0x2, 0x1dca, 
       0x1dcb, 0x7, 0x198, 0x2, 0x2, 0x1dcb, 0x1dcd, 0x5, 0x3d4, 0x1eb, 
       0x2, 0x1dcc, 0x1dca, 0x3, 0x2, 0x2, 0x2, 0x1dcd, 0x1dd0, 0x3, 0x2, 
       0x2, 0x2, 0x1dce, 0x1dcc, 0x3, 0x2, 0x2, 0x2, 0x1dce, 0x1dcf, 0x3, 
       0x2, 0x2, 0x2, 0x1dcf, 0x3d1, 0x3, 0x2, 0x2, 0x2, 0x1dd0, 0x1dce, 
       0x3, 0x2, 0x2, 0x2, 0x1dd1, 0x1de7, 0x5, 0x3dc, 0x1ef, 0x2, 0x1dd2, 
       0x1de5, 0x7, 0xa1, 0x2, 0x2, 0x1dd3, 0x1dd6, 0x7, 0x1be, 0x2, 0x2, 
       0x1dd4, 0x1dd5, 0x6, 0x1ea, 0xc2, 0x2, 0x1dd5, 0x1dd7, 0x7, 0xfd, 
       0x2, 0x2, 0x1dd6, 0x1dd4, 0x3, 0x2, 0x2, 0x2, 0x1dd6, 0x1dd7, 0x3, 
       0x2, 0x2, 0x2, 0x1dd7, 0x1dd8, 0x3, 0x2, 0x2, 0x2, 0x1dd8, 0x1de6, 
       0x5, 0x45e, 0x230, 0x2, 0x1dd9, 0x1dda, 0x6, 0x1ea, 0xc3, 0x2, 0x1dda, 
       0x1ddb, 0x7, 0x2ab, 0x2, 0x2, 0x1ddb, 0x1de3, 0x5, 0x472, 0x23a, 
       0x2, 0x1ddc, 0x1ddd, 0x7, 0x1b1, 0x2, 0x2, 0x1ddd, 0x1de2, 0x5, 0x45c, 
       0x22f, 0x2, 0x1dde, 0x1ddf, 0x6, 0x1ea, 0xc4, 0x2, 0x1ddf, 0x1de0, 
       0x7, 0x1be, 0x2, 0x2, 0x1de0, 0x1de2, 0x5, 0x45e, 0x230, 0x2, 0x1de1, 
       0x1ddc, 0x3, 0x2, 0x2, 0x2, 0x1de1, 0x1dde, 0x3, 0x2, 0x2, 0x2, 0x1de2, 
       0x1de4, 0x3, 0x2, 0x2, 0x2, 0x1de3, 0x1de1, 0x3, 0x2, 0x2, 0x2, 0x1de3, 
       0x1de4, 0x3, 0x2, 0x2, 0x2, 0x1de4, 0x1de6, 0x3, 0x2, 0x2, 0x2, 0x1de5, 
       0x1dd3, 0x3, 0x2, 0x2, 0x2, 0x1de5, 0x1dd9, 0x3, 0x2, 0x2, 0x2, 0x1de6, 
       0x1de8, 0x3, 0x2, 0x2, 0x2, 0x1de7, 0x1dd2, 0x3, 0x2, 0x2, 0x2, 0x1de7, 
       0x1de8, 0x3, 0x2, 0x2, 0x2, 0x1de8, 0x3d3, 0x3, 0x2, 0x2, 0x2, 0x1de9, 
       0x1e04, 0x5, 0x3dc, 0x1ef, 0x2, 0x1dea, 0x1e01, 0x7, 0xa1, 0x2, 0x2, 
       0x1deb, 0x1dec, 0x7, 0x2ab, 0x2, 0x2, 0x1dec, 0x1dee, 0x5, 0x472, 
       0x23a, 0x2, 0x1ded, 0x1deb, 0x3, 0x2, 0x2, 0x2, 0x1ded, 0x1dee, 0x3, 
       0x2, 0x2, 0x2, 0x1dee, 0x1def, 0x3, 0x2, 0x2, 0x2, 0x1def, 0x1df0, 
       0x7, 0x1be, 0x2, 0x2, 0x1df0, 0x1df3, 0x5, 0x45e, 0x230, 0x2, 0x1df1, 
       0x1df2, 0x7, 0x25f, 0x2, 0x2, 0x1df2, 0x1df4, 0x5, 0x45e, 0x230, 
       0x2, 0x1df3, 0x1df1, 0x3, 0x2, 0x2, 0x2, 0x1df3, 0x1df4, 0x3, 0x2, 
       0x2, 0x2, 0x1df4, 0x1df6, 0x3, 0x2, 0x2, 0x2, 0x1df5, 0x1df7, 0x5, 
       0x3d6, 0x1ec, 0x2, 0x1df6, 0x1df5, 0x3, 0x2, 0x2, 0x2, 0x1df6, 0x1df7, 
       0x3, 0x2, 0x2, 0x2, 0x1df7, 0x1e02, 0x3, 0x2, 0x2, 0x2, 0x1df8, 0x1df9, 
       0x7, 0x2ab, 0x2, 0x2, 0x1df9, 0x1dff, 0x5, 0x472, 0x23a, 0x2, 0x1dfa, 
       0x1dfb, 0x7, 0x1b1, 0x2, 0x2, 0x1dfb, 0x1dfd, 0x5, 0x45c, 0x22f, 
       0x2, 0x1dfc, 0x1dfe, 0x5, 0x3d6, 0x1ec, 0x2, 0x1dfd, 0x1dfc, 0x3, 
       0x2, 0x2, 0x2, 0x1dfd, 0x1dfe, 0x3, 0x2, 0x2, 0x2, 0x1dfe, 0x1e00, 
       0x3, 0x2, 0x2, 0x2, 0x1dff, 0x1dfa, 0x3, 0x2, 0x2, 0x2, 0x1dff, 0x1e00, 
       0x3, 0x2, 0x2, 0x2, 0x1e00, 0x1e02, 0x3, 0x2, 0x2, 0x2, 0x1e01, 0x1ded, 
       0x3, 0x2, 0x2, 0x2, 0x1e01, 0x1df8, 0x3, 0x2, 0x2, 0x2, 0x1e02, 0x1e05, 
       0x3, 0x2, 0x2, 0x2, 0x1e03, 0x1e05, 0x5, 0x3d8, 0x1ed, 0x2, 0x1e04, 
       0x1dea, 0x3, 0x2, 0x2, 0x2, 0x1e04, 0x1e03, 0x3, 0x2, 0x2, 0x2, 0x1e05, 
       0x3d5, 0x3, 0x2, 0x2, 0x2, 0x1e06, 0x1e07, 0x7, 0x2f8, 0x2, 0x2, 
       0x1e07, 0x1e08, 0x7, 0x6d, 0x2, 0x2, 0x1e08, 0x1e09, 0x7, 0xfd, 0x2, 
       0x2, 0x1e09, 0x3d7, 0x3, 0x2, 0x2, 0x2, 0x1e0a, 0x1e0b, 0x7, 0x7b, 
       0x2, 0x2, 0x1e0b, 0x1e0c, 0x7, 0x2f9, 0x2, 0x2, 0x1e0c, 0x1e0d, 0x7, 
       0xfd, 0x2, 0x2, 0x1e0d, 0x3d9, 0x3, 0x2, 0x2, 0x2, 0x1e0e, 0x1e0f, 
       0x7, 0x25f, 0x2, 0x2, 0x1e0f, 0x1e10, 0x5, 0x45e, 0x230, 0x2, 0x1e10, 
       0x3db, 0x3, 0x2, 0x2, 0x2, 0x1e11, 0x1e15, 0x5, 0x472, 0x23a, 0x2, 
       0x1e12, 0x1e13, 0x7, 0x1a2, 0x2, 0x2, 0x1e13, 0x1e16, 0x5, 0x472, 
       0x23a, 0x2, 0x1e14, 0x1e16, 0x7, 0x1a3, 0x2, 0x2, 0x1e15, 0x1e12, 
       0x3, 0x2, 0x2, 0x2, 0x1e15, 0x1e14, 0x3, 0x2, 0x2, 0x2, 0x1e15, 0x1e16, 
       0x3, 0x2, 0x2, 0x2, 0x1e16, 0x1e1c, 0x3, 0x2, 0x2, 0x2, 0x1e17, 0x1e19, 
       0x7, 0x1d2, 0x2, 0x2, 0x1e18, 0x1e1a, 0x5, 0x478, 0x23d, 0x2, 0x1e19, 
       0x1e18, 0x3, 0x2, 0x2, 0x2, 0x1e19, 0x1e1a, 0x3, 0x2, 0x2, 0x2, 0x1e1a, 
       0x1e1c, 0x3, 0x2, 0x2, 0x2, 0x1e1b, 0x1e11, 0x3, 0x2, 0x2, 0x2, 0x1e1b, 
       0x1e17, 0x3, 0x2, 0x2, 0x2, 0x1e1c, 0x3dd, 0x3, 0x2, 0x2, 0x2, 0x1e1d, 
       0x1e1e, 0x7, 0x21f, 0x2, 0x2, 0x1e1e, 0x1e1f, 0x5, 0x45c, 0x22f, 
       0x2, 0x1e1f, 0x3df, 0x3, 0x2, 0x2, 0x2, 0x1e20, 0x1e23, 0x5, 0x3de, 
       0x1f0, 0x2, 0x1e21, 0x1e23, 0x5, 0x15e, 0xb0, 0x2, 0x1e22, 0x1e20, 
       0x3, 0x2, 0x2, 0x2, 0x1e22, 0x1e21, 0x3, 0x2, 0x2, 0x2, 0x1e23, 0x3e1, 
       0x3, 0x2, 0x2, 0x2, 0x1e24, 0x1e25, 0x6, 0x1f2, 0xc5, 0x2, 0x1e25, 
       0x1e26, 0x9, 0x80, 0x2, 0x2, 0x1e26, 0x3e3, 0x3, 0x2, 0x2, 0x2, 0x1e27, 
       0x1e28, 0x9, 0x81, 0x2, 0x2, 0x1e28, 0x3e5, 0x3, 0x2, 0x2, 0x2, 0x1e29, 
       0x1e2a, 0x6, 0x1f4, 0xc6, 0x2, 0x1e2a, 0x1e2b, 0x7, 0x22, 0x2, 0x2, 
       0x1e2b, 0x1e2c, 0x5, 0x446, 0x224, 0x2, 0x1e2c, 0x3e7, 0x3, 0x2, 
       0x2, 0x2, 0x1e2d, 0x1e33, 0x5, 0x44c, 0x227, 0x2, 0x1e2e, 0x1e30, 
       0x5, 0x448, 0x225, 0x2, 0x1e2f, 0x1e31, 0x5, 0x44c, 0x227, 0x2, 0x1e30, 
       0x1e2f, 0x3, 0x2, 0x2, 0x2, 0x1e30, 0x1e31, 0x3, 0x2, 0x2, 0x2, 0x1e31, 
       0x1e33, 0x3, 0x2, 0x2, 0x2, 0x1e32, 0x1e2d, 0x3, 0x2, 0x2, 0x2, 0x1e32, 
       0x1e2e, 0x3, 0x2, 0x2, 0x2, 0x1e33, 0x3e9, 0x3, 0x2, 0x2, 0x2, 0x1e34, 
       0x1e35, 0x6, 0x1f6, 0xc7, 0x2, 0x1e35, 0x1e39, 0x5, 0x442, 0x222, 
       0x2, 0x1e36, 0x1e37, 0x6, 0x1f6, 0xc8, 0x2, 0x1e37, 0x1e39, 0x5, 
       0x3e8, 0x1f5, 0x2, 0x1e38, 0x1e34, 0x3, 0x2, 0x2, 0x2, 0x1e38, 0x1e36, 
       0x3, 0x2, 0x2, 0x2, 0x1e39, 0x3eb, 0x3, 0x2, 0x2, 0x2, 0x1e3a, 0x1e3b, 
       0x5, 0x442, 0x222, 0x2, 0x1e3b, 0x3ed, 0x3, 0x2, 0x2, 0x2, 0x1e3c, 
       0x1e3d, 0x7, 0x19b, 0x2, 0x2, 0x1e3d, 0x1e42, 0x5, 0x3ec, 0x1f7, 
       0x2, 0x1e3e, 0x1e3f, 0x7, 0x198, 0x2, 0x2, 0x1e3f, 0x1e41, 0x5, 0x3ec, 
       0x1f7, 0x2, 0x1e40, 0x1e3e, 0x3, 0x2, 0x2, 0x2, 0x1e41, 0x1e44, 0x3, 
       0x2, 0x2, 0x2, 0x1e42, 0x1e40, 0x3, 0x2, 0x2, 0x2, 0x1e42, 0x1e43, 
       0x3, 0x2, 0x2, 0x2, 0x1e43, 0x1e45, 0x3, 0x2, 0x2, 0x2, 0x1e44, 0x1e42, 
       0x3, 0x2, 0x2, 0x2, 0x1e45, 0x1e46, 0x7, 0x19c, 0x2, 0x2, 0x1e46, 
       0x3ef, 0x3, 0x2, 0x2, 0x2, 0x1e47, 0x1e48, 0x5, 0x3e8, 0x1f5, 0x2, 
       0x1e48, 0x3f1, 0x3, 0x2, 0x2, 0x2, 0x1e49, 0x1e4c, 0x5, 0x3f0, 0x1f9, 
       0x2, 0x1e4a, 0x1e4c, 0x5, 0x3f8, 0x1fd, 0x2, 0x1e4b, 0x1e49, 0x3, 
       0x2, 0x2, 0x2, 0x1e4b, 0x1e4a, 0x3, 0x2, 0x2, 0x2, 0x1e4c, 0x3f3, 
       0x3, 0x2, 0x2, 0x2, 0x1e4d, 0x1e4e, 0x5, 0x442, 0x222, 0x2, 0x1e4e, 
       0x3f5, 0x3, 0x2, 0x2, 0x2, 0x1e4f, 0x1e50, 0x5, 0x3e8, 0x1f5, 0x2, 
       0x1e50, 0x3f7, 0x3, 0x2, 0x2, 0x2, 0x1e51, 0x1e52, 0x5, 0x442, 0x222, 
       0x2, 0x1e52, 0x1e56, 0x7, 0x197, 0x2, 0x2, 0x1e53, 0x1e54, 0x5, 0x442, 
       0x222, 0x2, 0x1e54, 0x1e55, 0x7, 0x197, 0x2, 0x2, 0x1e55, 0x1e57, 
       0x3, 0x2, 0x2, 0x2, 0x1e56, 0x1e53, 0x3, 0x2, 0x2, 0x2, 0x1e56, 0x1e57, 
       0x3, 0x2, 0x2, 0x2, 0x1e57, 0x1e58, 0x3, 0x2, 0x2, 0x2, 0x1e58, 0x1e59, 
       0x7, 0x18b, 0x2, 0x2, 0x1e59, 0x3f9, 0x3, 0x2, 0x2, 0x2, 0x1e5a, 
       0x1e5b, 0x5, 0x442, 0x222, 0x2, 0x1e5b, 0x3fb, 0x3, 0x2, 0x2, 0x2, 
       0x1e5c, 0x1e5d, 0x5, 0x442, 0x222, 0x2, 0x1e5d, 0x3fd, 0x3, 0x2, 
       0x2, 0x2, 0x1e5e, 0x1e5f, 0x5, 0x448, 0x225, 0x2, 0x1e5f, 0x3ff, 
       0x3, 0x2, 0x2, 0x2, 0x1e60, 0x1e61, 0x5, 0x448, 0x225, 0x2, 0x1e61, 
       0x401, 0x3, 0x2, 0x2, 0x2, 0x1e62, 0x1e63, 0x5, 0x448, 0x225, 0x2, 
       0x1e63, 0x403, 0x3, 0x2, 0x2, 0x2, 0x1e64, 0x1e65, 0x5, 0x448, 0x225, 
       0x2, 0x1e65, 0x405, 0x3, 0x2, 0x2, 0x2, 0x1e66, 0x1e67, 0x5, 0x448, 
       0x225, 0x2, 0x1e67, 0x407, 0x3, 0x2, 0x2, 0x2, 0x1e68, 0x1e69, 0x5, 
       0x448, 0x225, 0x2, 0x1e69, 0x409, 0x3, 0x2, 0x2, 0x2, 0x1e6a, 0x1e6d, 
       0x5, 0x448, 0x225, 0x2, 0x1e6b, 0x1e6d, 0x5, 0x44c, 0x227, 0x2, 0x1e6c, 
       0x1e6a, 0x3, 0x2, 0x2, 0x2, 0x1e6c, 0x1e6b, 0x3, 0x2, 0x2, 0x2, 0x1e6d, 
       0x40b, 0x3, 0x2, 0x2, 0x2, 0x1e6e, 0x1e71, 0x5, 0x448, 0x225, 0x2, 
       0x1e6f, 0x1e71, 0x5, 0x44c, 0x227, 0x2, 0x1e70, 0x1e6e, 0x3, 0x2, 
       0x2, 0x2, 0x1e70, 0x1e6f, 0x3, 0x2, 0x2, 0x2, 0x1e71, 0x40d, 0x3, 
       0x2, 0x2, 0x2, 0x1e72, 0x1e73, 0x5, 0x442, 0x222, 0x2, 0x1e73, 0x40f, 
       0x3, 0x2, 0x2, 0x2, 0x1e74, 0x1e75, 0x5, 0x442, 0x222, 0x2, 0x1e75, 
       0x411, 0x3, 0x2, 0x2, 0x2, 0x1e76, 0x1e77, 0x5, 0x442, 0x222, 0x2, 
       0x1e77, 0x413, 0x3, 0x2, 0x2, 0x2, 0x1e78, 0x1e79, 0x5, 0x442, 0x222, 
       0x2, 0x1e79, 0x415, 0x3, 0x2, 0x2, 0x2, 0x1e7a, 0x1e7b, 0x5, 0x448, 
       0x225, 0x2, 0x1e7b, 0x417, 0x3, 0x2, 0x2, 0x2, 0x1e7c, 0x1e7d, 0x5, 
       0x448, 0x225, 0x2, 0x1e7d, 0x419, 0x3, 0x2, 0x2, 0x2, 0x1e7e, 0x1e7f, 
       0x5, 0x442, 0x222, 0x2, 0x1e7f, 0x41b, 0x3, 0x2, 0x2, 0x2, 0x1e80, 
       0x1e81, 0x5, 0x472, 0x23a, 0x2, 0x1e81, 0x41d, 0x3, 0x2, 0x2, 0x2, 
       0x1e82, 0x1e83, 0x5, 0x472, 0x23a, 0x2, 0x1e83, 0x41f, 0x3, 0x2, 
       0x2, 0x2, 0x1e84, 0x1e85, 0x5, 0x472, 0x23a, 0x2, 0x1e85, 0x421, 
       0x3, 0x2, 0x2, 0x2, 0x1e86, 0x1e89, 0x5, 0x448, 0x225, 0x2, 0x1e87, 
       0x1e89, 0x5, 0x44c, 0x227, 0x2, 0x1e88, 0x1e86, 0x3, 0x2, 0x2, 0x2, 
       0x1e88, 0x1e87, 0x3, 0x2, 0x2, 0x2, 0x1e89, 0x423, 0x3, 0x2, 0x2, 
       0x2, 0x1e8a, 0x1e8b, 0x5, 0x442, 0x222, 0x2, 0x1e8b, 0x1e8c, 0x5, 
       0x44c, 0x227, 0x2, 0x1e8c, 0x425, 0x3, 0x2, 0x2, 0x2, 0x1e8d, 0x1e95, 
       0x5, 0x442, 0x222, 0x2, 0x1e8e, 0x1e8f, 0x7, 0x197, 0x2, 0x2, 0x1e8f, 
       0x1e96, 0x7, 0x18b, 0x2, 0x2, 0x1e90, 0x1e93, 0x5, 0x44c, 0x227, 
       0x2, 0x1e91, 0x1e92, 0x7, 0x197, 0x2, 0x2, 0x1e92, 0x1e94, 0x7, 0x18b, 
       0x2, 0x2, 0x1e93, 0x1e91, 0x3, 0x2, 0x2, 0x2, 0x1e93, 0x1e94, 0x3, 
       0x2, 0x2, 0x2, 0x1e94, 0x1e96, 0x3, 0x2, 0x2, 0x2, 0x1e95, 0x1e8e, 
       0x3, 0x2, 0x2, 0x2, 0x1e95, 0x1e90, 0x3, 0x2, 0x2, 0x2, 0x1e95, 0x1e96, 
       0x3, 0x2, 0x2, 0x2, 0x1e96, 0x427, 0x3, 0x2, 0x2, 0x2, 0x1e97, 0x1e9a, 
       0x5, 0x448, 0x225, 0x2, 0x1e98, 0x1e9a, 0x5, 0x44c, 0x227, 0x2, 0x1e99, 
       0x1e97, 0x3, 0x2, 0x2, 0x2, 0x1e99, 0x1e98, 0x3, 0x2, 0x2, 0x2, 0x1e9a, 
       0x429, 0x3, 0x2, 0x2, 0x2, 0x1e9b, 0x1ea0, 0x5, 0x428, 0x215, 0x2, 
       0x1e9c, 0x1e9d, 0x7, 0x198, 0x2, 0x2, 0x1e9d, 0x1e9f, 0x5, 0x428, 
       0x215, 0x2, 0x1e9e, 0x1e9c, 0x3, 0x2, 0x2, 0x2, 0x1e9f, 0x1ea2, 0x3, 
       0x2, 0x2, 0x2, 0x1ea0, 0x1e9e, 0x3, 0x2, 0x2, 0x2, 0x1ea0, 0x1ea1, 
       0x3, 0x2, 0x2, 0x2, 0x1ea1, 0x42b, 0x3, 0x2, 0x2, 0x2, 0x1ea2, 0x1ea0, 
       0x3, 0x2, 0x2, 0x2, 0x1ea3, 0x1ea8, 0x5, 0x426, 0x214, 0x2, 0x1ea4, 
       0x1ea5, 0x7, 0x198, 0x2, 0x2, 0x1ea5, 0x1ea7, 0x5, 0x426, 0x214, 
       0x2, 0x1ea6, 0x1ea4, 0x3, 0x2, 0x2, 0x2, 0x1ea7, 0x1eaa, 0x3, 0x2, 
       0x2, 0x2, 0x1ea8, 0x1ea6, 0x3, 0x2, 0x2, 0x2, 0x1ea8, 0x1ea9, 0x3, 
       0x2, 0x2, 0x2, 0x1ea9, 0x42d, 0x3, 0x2, 0x2, 0x2, 0x1eaa, 0x1ea8, 
       0x3, 0x2, 0x2, 0x2, 0x1eab, 0x1eac, 0x5, 0x442, 0x222, 0x2, 0x1eac, 
       0x42f, 0x3, 0x2, 0x2, 0x2, 0x1ead, 0x1eb0, 0x5, 0x440, 0x221, 0x2, 
       0x1eae, 0x1eb0, 0x5, 0x484, 0x243, 0x2, 0x1eaf, 0x1ead, 0x3, 0x2, 
       0x2, 0x2, 0x1eaf, 0x1eae, 0x3, 0x2, 0x2, 0x2, 0x1eb0, 0x431, 0x3, 
       0x2, 0x2, 0x2, 0x1eb1, 0x1eb2, 0x5, 0x430, 0x219, 0x2, 0x1eb2, 0x433, 
       0x3, 0x2, 0x2, 0x2, 0x1eb3, 0x1eb6, 0x5, 0x440, 0x221, 0x2, 0x1eb4, 
       0x1eb6, 0x5, 0x48a, 0x246, 0x2, 0x1eb5, 0x1eb3, 0x3, 0x2, 0x2, 0x2, 
       0x1eb5, 0x1eb4, 0x3, 0x2, 0x2, 0x2, 0x1eb6, 0x435, 0x3, 0x2, 0x2, 
       0x2, 0x1eb7, 0x1eb8, 0x5, 0x434, 0x21b, 0x2, 0x1eb8, 0x437, 0x3, 
       0x2, 0x2, 0x2, 0x1eb9, 0x1eba, 0x5, 0x442, 0x222, 0x2, 0x1eba, 0x439, 
       0x3, 0x2, 0x2, 0x2, 0x1ebb, 0x1ebc, 0x5, 0x45c, 0x22f, 0x2, 0x1ebc, 
       0x43b, 0x3, 0x2, 0x2, 0x2, 0x1ebd, 0x1ebe, 0x5, 0x442, 0x222, 0x2, 
       0x1ebe, 0x43d, 0x3, 0x2, 0x2, 0x2, 0x1ebf, 0x1ec0, 0x5, 0x442, 0x222, 
       0x2, 0x1ec0, 0x43f, 0x3, 0x2, 0x2, 0x2, 0x1ec1, 0x1ec5, 0x9, 0x82, 
       0x2, 0x2, 0x1ec2, 0x1ec3, 0x6, 0x221, 0xc9, 0x2, 0x1ec3, 0x1ec5, 
       0x7, 0x300, 0x2, 0x2, 0x1ec4, 0x1ec1, 0x3, 0x2, 0x2, 0x2, 0x1ec4, 
       0x1ec2, 0x3, 0x2, 0x2, 0x2, 0x1ec5, 0x441, 0x3, 0x2, 0x2, 0x2, 0x1ec6, 
       0x1ec9, 0x5, 0x440, 0x221, 0x2, 0x1ec7, 0x1ec9, 0x5, 0x482, 0x242, 
       0x2, 0x1ec8, 0x1ec6, 0x3, 0x2, 0x2, 0x2, 0x1ec8, 0x1ec7, 0x3, 0x2, 
       0x2, 0x2, 0x1ec9, 0x443, 0x3, 0x2, 0x2, 0x2, 0x1eca, 0x1ecf, 0x5, 
       0x442, 0x222, 0x2, 0x1ecb, 0x1ecc, 0x7, 0x198, 0x2, 0x2, 0x1ecc, 
       0x1ece, 0x5, 0x442, 0x222, 0x2, 0x1ecd, 0x1ecb, 0x3, 0x2, 0x2, 0x2, 
       0x1ece, 0x1ed1, 0x3, 0x2, 0x2, 0x2, 0x1ecf, 0x1ecd, 0x3, 0x2, 0x2, 
       0x2, 0x1ecf, 0x1ed0, 0x3, 0x2, 0x2, 0x2, 0x1ed0, 0x445, 0x3, 0x2, 
       0x2, 0x2, 0x1ed1, 0x1ecf, 0x3, 0x2, 0x2, 0x2, 0x1ed2, 0x1ed3, 0x7, 
       0x19b, 0x2, 0x2, 0x1ed3, 0x1ed4, 0x5, 0x444, 0x223, 0x2, 0x1ed4, 
       0x1ed5, 0x7, 0x19c, 0x2, 0x2, 0x1ed5, 0x447, 0x3, 0x2, 0x2, 0x2, 
       0x1ed6, 0x1ed8, 0x5, 0x442, 0x222, 0x2, 0x1ed7, 0x1ed9, 0x5, 0x44c, 
       0x227, 0x2, 0x1ed8, 0x1ed7, 0x3, 0x2, 0x2, 0x2, 0x1ed8, 0x1ed9, 0x3, 
       0x2, 0x2, 0x2, 0x1ed9, 0x449, 0x3, 0x2, 0x2, 0x2, 0x1eda, 0x1edf, 
       0x5, 0x442, 0x222, 0x2, 0x1edb, 0x1edd, 0x5, 0x44c, 0x227, 0x2, 0x1edc, 
       0x1ede, 0x5, 0x44c, 0x227, 0x2, 0x1edd, 0x1edc, 0x3, 0x2, 0x2, 0x2, 
       0x1edd, 0x1ede, 0x3, 0x2, 0x2, 0x2, 0x1ede, 0x1ee0, 0x3, 0x2, 0x2, 
       0x2, 0x1edf, 0x1edb, 0x3, 0x2, 0x2, 0x2, 0x1edf, 0x1ee0, 0x3, 0x2, 
       0x2, 0x2, 0x1ee0, 0x1ee6, 0x3, 0x2, 0x2, 0x2, 0x1ee1, 0x1ee2, 0x6, 
       0x226, 0xca, 0x2, 0x1ee2, 0x1ee3, 0x5, 0x44c, 0x227, 0x2, 0x1ee3, 
       0x1ee4, 0x5, 0x44c, 0x227, 0x2, 0x1ee4, 0x1ee6, 0x3, 0x2, 0x2, 0x2, 
       0x1ee5, 0x1eda, 0x3, 0x2, 0x2, 0x2, 0x1ee5, 0x1ee1, 0x3, 0x2, 0x2, 
       0x2, 0x1ee6, 0x44b, 0x3, 0x2, 0x2, 0x2, 0x1ee7, 0x1ee8, 0x7, 0x197, 
       0x2, 0x2, 0x1ee8, 0x1ee9, 0x5, 0x442, 0x222, 0x2, 0x1ee9, 0x44d, 
       0x3, 0x2, 0x2, 0x2, 0x1eea, 0x1eeb, 0x9, 0x83, 0x2, 0x2, 0x1eeb, 
       0x44f, 0x3, 0x2, 0x2, 0x2, 0x1eec, 0x1eed, 0x9, 0x84, 0x2, 0x2, 0x1eed, 
       0x451, 0x3, 0x2, 0x2, 0x2, 0x1eee, 0x1eef, 0x9, 0x85, 0x2, 0x2, 0x1eef, 
       0x453, 0x3, 0x2, 0x2, 0x2, 0x1ef0, 0x1ef1, 0x9, 0x86, 0x2, 0x2, 0x1ef1, 
       0x455, 0x3, 0x2, 0x2, 0x2, 0x1ef2, 0x1efc, 0x5, 0x460, 0x231, 0x2, 
       0x1ef3, 0x1efc, 0x5, 0x466, 0x234, 0x2, 0x1ef4, 0x1efc, 0x5, 0x46c, 
       0x237, 0x2, 0x1ef5, 0x1efc, 0x5, 0x46a, 0x236, 0x2, 0x1ef6, 0x1efc, 
       0x5, 0x468, 0x235, 0x2, 0x1ef7, 0x1ef9, 0x7, 0x2fc, 0x2, 0x2, 0x1ef8, 
       0x1ef7, 0x3, 0x2, 0x2, 0x2, 0x1ef8, 0x1ef9, 0x3, 0x2, 0x2, 0x2, 0x1ef9, 
       0x1efa, 0x3, 0x2, 0x2, 0x2, 0x1efa, 0x1efc, 0x9, 0x87, 0x2, 0x2, 
       0x1efb, 0x1ef2, 0x3, 0x2, 0x2, 0x2, 0x1efb, 0x1ef3, 0x3, 0x2, 0x2, 
       0x2, 0x1efb, 0x1ef4, 0x3, 0x2, 0x2, 0x2, 0x1efb, 0x1ef5, 0x3, 0x2, 
       0x2, 0x2, 0x1efb, 0x1ef6, 0x3, 0x2, 0x2, 0x2, 0x1efb, 0x1ef8, 0x3, 
       0x2, 0x2, 0x2, 0x1efc, 0x457, 0x3, 0x2, 0x2, 0x2, 0x1efd, 0x1f03, 
       0x5, 0x456, 0x22c, 0x2, 0x1efe, 0x1eff, 0x7, 0x189, 0x2, 0x2, 0x1eff, 
       0x1f03, 0x5, 0x44e, 0x228, 0x2, 0x1f00, 0x1f01, 0x7, 0x18a, 0x2, 
       0x2, 0x1f01, 0x1f03, 0x5, 0x44e, 0x228, 0x2, 0x1f02, 0x1efd, 0x3, 
       0x2, 0x2, 0x2, 0x1f02, 0x1efe, 0x3, 0x2, 0x2, 0x2, 0x1f02, 0x1f00, 
       0x3, 0x2, 0x2, 0x2, 0x1f03, 0x459, 0x3, 0x2, 0x2, 0x2, 0x1f04, 0x1f05, 
       0x7, 0x19b, 0x2, 0x2, 0x1f05, 0x1f0a, 0x5, 0x45e, 0x230, 0x2, 0x1f06, 
       0x1f07, 0x7, 0x198, 0x2, 0x2, 0x1f07, 0x1f09, 0x5, 0x45e, 0x230, 
       0x2, 0x1f08, 0x1f06, 0x3, 0x2, 0x2, 0x2, 0x1f09, 0x1f0c, 0x3, 0x2, 
       0x2, 0x2, 0x1f0a, 0x1f08, 0x3, 0x2, 0x2, 0x2, 0x1f0a, 0x1f0b, 0x3, 
       0x2, 0x2, 0x2, 0x1f0b, 0x1f0d, 0x3, 0x2, 0x2, 0x2, 0x1f0c, 0x1f0a, 
       0x3, 0x2, 0x2, 0x2, 0x1f0d, 0x1f0e, 0x7, 0x19c, 0x2, 0x2, 0x1f0e, 
       0x45b, 0x3, 0x2, 0x2, 0x2, 0x1f0f, 0x1f13, 0x7, 0x301, 0x2, 0x2, 
       0x1f10, 0x1f11, 0x6, 0x22f, 0xcb, 0x2, 0x1f11, 0x1f13, 0x7, 0x300, 
       0x2, 0x2, 0x1f12, 0x1f0f, 0x3, 0x2, 0x2, 0x2, 0x1f12, 0x1f10, 0x3, 
       0x2, 0x2, 0x2, 0x1f13, 0x45d, 0x3, 0x2, 0x2, 0x2, 0x1f14, 0x1f18, 
       0x5, 0x45c, 0x22f, 0x2, 0x1f15, 0x1f18, 0x7, 0x1a7, 0x2, 0x2, 0x1f16, 
       0x1f18, 0x7, 0x1a8, 0x2, 0x2, 0x1f17, 0x1f14, 0x3, 0x2, 0x2, 0x2, 
       0x1f17, 0x1f15, 0x3, 0x2, 0x2, 0x2, 0x1f17, 0x1f16, 0x3, 0x2, 0x2, 
       0x2, 0x1f18, 0x45f, 0x3, 0x2, 0x2, 0x2, 0x1f19, 0x1f1b, 0x7, 0x2fc, 
       0x2, 0x2, 0x1f1a, 0x1f19, 0x3, 0x2, 0x2, 0x2, 0x1f1a, 0x1f1b, 0x3, 
       0x2, 0x2, 0x2, 0x1f1b, 0x1f1c, 0x3, 0x2, 0x2, 0x2, 0x1f1c, 0x1f1f, 
       0x5, 0x45c, 0x22f, 0x2, 0x1f1d, 0x1f1f, 0x7, 0x2fe, 0x2, 0x2, 0x1f1e, 
       0x1f1a, 0x3, 0x2, 0x2, 0x2, 0x1f1e, 0x1f1d, 0x3, 0x2, 0x2, 0x2, 0x1f1f, 
       0x1f23, 0x3, 0x2, 0x2, 0x2, 0x1f20, 0x1f22, 0x5, 0x45c, 0x22f, 0x2, 
       0x1f21, 0x1f20, 0x3, 0x2, 0x2, 0x2, 0x1f22, 0x1f25, 0x3, 0x2, 0x2, 
       0x2, 0x1f23, 0x1f21, 0x3, 0x2, 0x2, 0x2, 0x1f23, 0x1f24, 0x3, 0x2, 
       0x2, 0x2, 0x1f24, 0x461, 0x3, 0x2, 0x2, 0x2, 0x1f25, 0x1f23, 0x3, 
       0x2, 0x2, 0x2, 0x1f26, 0x1f27, 0x5, 0x45c, 0x22f, 0x2, 0x1f27, 0x463, 
       0x3, 0x2, 0x2, 0x2, 0x1f28, 0x1f2d, 0x5, 0x45c, 0x22f, 0x2, 0x1f29, 
       0x1f2a, 0x7, 0x198, 0x2, 0x2, 0x1f2a, 0x1f2c, 0x5, 0x45c, 0x22f, 
       0x2, 0x1f2b, 0x1f29, 0x3, 0x2, 0x2, 0x2, 0x1f2c, 0x1f2f, 0x3, 0x2, 
       0x2, 0x2, 0x1f2d, 0x1f2b, 0x3, 0x2, 0x2, 0x2, 0x1f2d, 0x1f2e, 0x3, 
       0x2, 0x2, 0x2, 0x1f2e, 0x465, 0x3, 0x2, 0x2, 0x2, 0x1f2f, 0x1f2d, 
       0x3, 0x2, 0x2, 0x2, 0x1f30, 0x1f31, 0x9, 0x85, 0x2, 0x2, 0x1f31, 
       0x467, 0x3, 0x2, 0x2, 0x2, 0x1f32, 0x1f33, 0x9, 0x88, 0x2, 0x2, 0x1f33, 
       0x469, 0x3, 0x2, 0x2, 0x2, 0x1f34, 0x1f35, 0x9, 0x89, 0x2, 0x2, 0x1f35, 
       0x46b, 0x3, 0x2, 0x2, 0x2, 0x1f36, 0x1f37, 0x7, 0x72, 0x2, 0x2, 0x1f37, 
       0x1f3d, 0x7, 0x301, 0x2, 0x2, 0x1f38, 0x1f39, 0x7, 0x162, 0x2, 0x2, 
       0x1f39, 0x1f3d, 0x7, 0x301, 0x2, 0x2, 0x1f3a, 0x1f3b, 0x7, 0x15f, 
       0x2, 0x2, 0x1f3b, 0x1f3d, 0x7, 0x301, 0x2, 0x2, 0x1f3c, 0x1f36, 0x3, 
       0x2, 0x2, 0x2, 0x1f3c, 0x1f38, 0x3, 0x2, 0x2, 0x2, 0x1f3c, 0x1f3a, 
       0x3, 0x2, 0x2, 0x2, 0x1f3d, 0x46d, 0x3, 0x2, 0x2, 0x2, 0x1f3e, 0x1f41, 
       0x5, 0x376, 0x1bc, 0x2, 0x1f3f, 0x1f41, 0x5, 0x470, 0x239, 0x2, 0x1f40, 
       0x1f3e, 0x3, 0x2, 0x2, 0x2, 0x1f40, 0x1f3f, 0x3, 0x2, 0x2, 0x2, 0x1f41, 
       0x46f, 0x3, 0x2, 0x2, 0x2, 0x1f42, 0x1f43, 0x7, 0x19b, 0x2, 0x2, 
       0x1f43, 0x1f44, 0x7, 0x17e, 0x2, 0x2, 0x1f44, 0x1f45, 0x7, 0x198, 
       0x2, 0x2, 0x1f45, 0x1f46, 0x7, 0x17e, 0x2, 0x2, 0x1f46, 0x1f47, 0x7, 
       0x19c, 0x2, 0x2, 0x1f47, 0x471, 0x3, 0x2, 0x2, 0x2, 0x1f48, 0x1f4b, 
       0x7, 0x301, 0x2, 0x2, 0x1f49, 0x1f4b, 0x5, 0x442, 0x222, 0x2, 0x1f4a, 
       0x1f48, 0x3, 0x2, 0x2, 0x2, 0x1f4a, 0x1f49, 0x3, 0x2, 0x2, 0x2, 0x1f4b, 
       0x473, 0x3, 0x2, 0x2, 0x2, 0x1f4c, 0x1f4f, 0x5, 0x434, 0x21b, 0x2, 
       0x1f4d, 0x1f4f, 0x5, 0x45c, 0x22f, 0x2, 0x1f4e, 0x1f4c, 0x3, 0x2, 
       0x2, 0x2, 0x1f4e, 0x1f4d, 0x3, 0x2, 0x2, 0x2, 0x1f4f, 0x475, 0x3, 
       0x2, 0x2, 0x2, 0x1f50, 0x1f53, 0x5, 0x454, 0x22b, 0x2, 0x1f51, 0x1f53, 
       0x5, 0x440, 0x221, 0x2, 0x1f52, 0x1f50, 0x3, 0x2, 0x2, 0x2, 0x1f52, 
       0x1f51, 0x3, 0x2, 0x2, 0x2, 0x1f53, 0x477, 0x3, 0x2, 0x2, 0x2, 0x1f54, 
       0x1f55, 0x7, 0x19b, 0x2, 0x2, 0x1f55, 0x1f56, 0x7, 0x19c, 0x2, 0x2, 
       0x1f56, 0x479, 0x3, 0x2, 0x2, 0x2, 0x1f57, 0x1f58, 0x9, 0x8a, 0x2, 
       0x2, 0x1f58, 0x47b, 0x3, 0x2, 0x2, 0x2, 0x1f59, 0x1f5a, 0x9, 0x8b, 
       0x2, 0x2, 0x1f5a, 0x47d, 0x3, 0x2, 0x2, 0x2, 0x1f5b, 0x1f5c, 0x7, 
       0x9d, 0x2, 0x2, 0x1f5c, 0x1f62, 0x7, 0x197, 0x2, 0x2, 0x1f5d, 0x1f5e, 
       0x7, 0xb6, 0x2, 0x2, 0x1f5e, 0x1f62, 0x7, 0x197, 0x2, 0x2, 0x1f5f, 
       0x1f60, 0x7, 0x136, 0x2, 0x2, 0x1f60, 0x1f62, 0x7, 0x197, 0x2, 0x2, 
       0x1f61, 0x1f5b, 0x3, 0x2, 0x2, 0x2, 0x1f61, 0x1f5d, 0x3, 0x2, 0x2, 
       0x2, 0x1f61, 0x1f5f, 0x3, 0x2, 0x2, 0x2, 0x1f62, 0x47f, 0x3, 0x2, 
       0x2, 0x2, 0x1f63, 0x1f64, 0x7, 0x2b3, 0x2, 0x2, 0x1f64, 0x1f6e, 0x7, 
       0x197, 0x2, 0x2, 0x1f65, 0x1f66, 0x7, 0x2c2, 0x2, 0x2, 0x1f66, 0x1f6e, 
       0x7, 0x197, 0x2, 0x2, 0x1f67, 0x1f68, 0x7, 0x9d, 0x2, 0x2, 0x1f68, 
       0x1f6e, 0x7, 0x197, 0x2, 0x2, 0x1f69, 0x1f6a, 0x7, 0xb6, 0x2, 0x2, 
       0x1f6a, 0x1f6e, 0x7, 0x197, 0x2, 0x2, 0x1f6b, 0x1f6c, 0x7, 0x136, 
       0x2, 0x2, 0x1f6c, 0x1f6e, 0x7, 0x197, 0x2, 0x2, 0x1f6d, 0x1f63, 0x3, 
       0x2, 0x2, 0x2, 0x1f6d, 0x1f65, 0x3, 0x2, 0x2, 0x2, 0x1f6d, 0x1f67, 
       0x3, 0x2, 0x2, 0x2, 0x1f6d, 0x1f69, 0x3, 0x2, 0x2, 0x2, 0x1f6d, 0x1f6b, 
       0x3, 0x2, 0x2, 0x2, 0x1f6e, 0x481, 0x3, 0x2, 0x2, 0x2, 0x1f6f, 0x1f77, 
       0x5, 0x484, 0x243, 0x2, 0x1f70, 0x1f77, 0x5, 0x486, 0x244, 0x2, 0x1f71, 
       0x1f77, 0x7, 0x13, 0x2, 0x2, 0x1f72, 0x1f73, 0x6, 0x242, 0xcc, 0x2, 
       0x1f73, 0x1f77, 0x7, 0x3a, 0x2, 0x2, 0x1f74, 0x1f75, 0x6, 0x242, 
       0xcd, 0x2, 0x1f75, 0x1f77, 0x7, 0x2eb, 0x2, 0x2, 0x1f76, 0x1f6f, 
       0x3, 0x2, 0x2, 0x2, 0x1f76, 0x1f70, 0x3, 0x2, 0x2, 0x2, 0x1f76, 0x1f71, 
       0x3, 0x2, 0x2, 0x2, 0x1f76, 0x1f72, 0x3, 0x2, 0x2, 0x2, 0x1f76, 0x1f74, 
       0x3, 0x2, 0x2, 0x2, 0x1f77, 0x483, 0x3, 0x2, 0x2, 0x2, 0x1f78, 0x1f83, 
       0x5, 0x488, 0x245, 0x2, 0x1f79, 0x1f83, 0x7, 0x87, 0x2, 0x2, 0x1f7a, 
       0x1f83, 0x7, 0x93, 0x2, 0x2, 0x1f7b, 0x1f83, 0x7, 0xf1, 0x2, 0x2, 
       0x1f7c, 0x1f83, 0x7, 0x107, 0x2, 0x2, 0x1f7d, 0x1f83, 0x7, 0x10b, 
       0x2, 0x2, 0x1f7e, 0x1f83, 0x7, 0x11a, 0x2, 0x2, 0x1f7f, 0x1f83, 0x7, 
       0x11d, 0x2, 0x2, 0x1f80, 0x1f83, 0x7, 0x2e6, 0x2, 0x2, 0x1f81, 0x1f83, 
       0x7, 0x151, 0x2, 0x2, 0x1f82, 0x1f78, 0x3, 0x2, 0x2, 0x2, 0x1f82, 
       0x1f79, 0x3, 0x2, 0x2, 0x2, 0x1f82, 0x1f7a, 0x3, 0x2, 0x2, 0x2, 0x1f82, 
       0x1f7b, 0x3, 0x2, 0x2, 0x2, 0x1f82, 0x1f7c, 0x3, 0x2, 0x2, 0x2, 0x1f82, 
       0x1f7d, 0x3, 0x2, 0x2, 0x2, 0x1f82, 0x1f7e, 0x3, 0x2, 0x2, 0x2, 0x1f82, 
       0x1f7f, 0x3, 0x2, 0x2, 0x2, 0x1f82, 0x1f80, 0x3, 0x2, 0x2, 0x2, 0x1f82, 
       0x1f81, 0x3, 0x2, 0x2, 0x2, 0x1f83, 0x485, 0x3, 0x2, 0x2, 0x2, 0x1f84, 
       0x1f8a, 0x9, 0x8c, 0x2, 0x2, 0x1f85, 0x1f86, 0x6, 0x244, 0xce, 0x2, 
       0x1f86, 0x1f8a, 0x7, 0x3a, 0x2, 0x2, 0x1f87, 0x1f88, 0x6, 0x244, 
       0xcf, 0x2, 0x1f88, 0x1f8a, 0x7, 0xa4, 0x2, 0x2, 0x1f89, 0x1f84, 0x3, 
       0x2, 0x2, 0x2, 0x1f89, 0x1f85, 0x3, 0x2, 0x2, 0x2, 0x1f89, 0x1f87, 
       0x3, 0x2, 0x2, 0x2, 0x1f8a, 0x487, 0x3, 0x2, 0x2, 0x2, 0x1f8b, 0x1f95, 
       0x9, 0x8d, 0x2, 0x2, 0x1f8c, 0x1f8d, 0x6, 0x245, 0xd0, 0x2, 0x1f8d, 
       0x1f95, 0x7, 0x3a, 0x2, 0x2, 0x1f8e, 0x1f8f, 0x6, 0x245, 0xd1, 0x2, 
       0x1f8f, 0x1f95, 0x9, 0x8e, 0x2, 0x2, 0x1f90, 0x1f91, 0x6, 0x245, 
       0xd2, 0x2, 0x1f91, 0x1f95, 0x9, 0x8f, 0x2, 0x2, 0x1f92, 0x1f93, 0x6, 
       0x245, 0xd3, 0x2, 0x1f93, 0x1f95, 0x7, 0x2b5, 0x2, 0x2, 0x1f94, 0x1f8b, 
       0x3, 0x2, 0x2, 0x2, 0x1f94, 0x1f8c, 0x3, 0x2, 0x2, 0x2, 0x1f94, 0x1f8e, 
       0x3, 0x2, 0x2, 0x2, 0x1f94, 0x1f90, 0x3, 0x2, 0x2, 0x2, 0x1f94, 0x1f92, 
       0x3, 0x2, 0x2, 0x2, 0x1f95, 0x489, 0x3, 0x2, 0x2, 0x2, 0x1f96, 0x1f99, 
       0x5, 0x488, 0x245, 0x2, 0x1f97, 0x1f99, 0x5, 0x486, 0x244, 0x2, 0x1f98, 
       0x1f96, 0x3, 0x2, 0x2, 0x2, 0x1f98, 0x1f97, 0x3, 0x2, 0x2, 0x2, 0x1f99, 
       0x48b, 0x3, 0x2, 0x2, 0x2, 0x43f, 0x48f, 0x493, 0x496, 0x498, 0x4be, 
       0x4c6, 0x4cb, 0x4db, 0x4e2, 0x4e9, 0x4ec, 0x4f3, 0x4f8, 0x4fb, 0x500, 
       0x506, 0x508, 0x50c, 0x510, 0x519, 0x51d, 0x522, 0x528, 0x52f, 0x533, 
       0x538, 0x53d, 0x544, 0x547, 0x54d, 0x550, 0x557, 0x561, 0x566, 0x56b, 
       0x573, 0x579, 0x57d, 0x582, 0x58b, 0x591, 0x597, 0x59d, 0x5a8, 0x5ae, 
       0x5b7, 0x5c5, 0x5c9, 0x5cf, 0x5d3, 0x5db, 0x5df, 0x5e4, 0x5e7, 0x5ed, 
       0x5f3, 0x5f9, 0x5fd, 0x602, 0x606, 0x60a, 0x612, 0x614, 0x61b, 0x623, 
       0x62b, 0x62f, 0x639, 0x649, 0x64c, 0x655, 0x65a, 0x660, 0x665, 0x669, 
       0x66e, 0x672, 0x676, 0x67a, 0x67f, 0x683, 0x685, 0x690, 0x695, 0x69b, 
       0x6a3, 0x6ac, 0x6b1, 0x6b4, 0x6b9, 0x6c0, 0x6c8, 0x6cc, 0x6d1, 0x6d8, 
       0x6dd, 0x6e2, 0x6ea, 0x6ee, 0x6f3, 0x6f6, 0x6f9, 0x6fc, 0x703, 0x70a, 
       0x70e, 0x726, 0x72a, 0x730, 0x737, 0x73a, 0x73e, 0x745, 0x748, 0x74b, 
       0x74e, 0x757, 0x75e, 0x763, 0x766, 0x769, 0x76f, 0x775, 0x778, 0x77d, 
       0x787, 0x78a, 0x790, 0x796, 0x7a0, 0x7a3, 0x7ab, 0x7b1, 0x7bc, 0x7bf, 
       0x7c4, 0x7d7, 0x7da, 0x7dd, 0x7e3, 0x7e6, 0x7e8, 0x7ee, 0x7f8, 0x802, 
       0x805, 0x808, 0x80d, 0x813, 0x820, 0x824, 0x829, 0x832, 0x843, 0x856, 
       0x85f, 0x862, 0x86a, 0x86f, 0x873, 0x87a, 0x87f, 0x88e, 0x892, 0x898, 
       0x89e, 0x8a4, 0x8aa, 0x8b0, 0x8b5, 0x8b9, 0x8c1, 0x8c7, 0x8cd, 0x8d2, 
       0x8d5, 0x8d8, 0x8e1, 0x8e4, 0x8ef, 0x8fb, 0x904, 0x908, 0x911, 0x914, 
       0x91a, 0x91c, 0x920, 0x927, 0x934, 0x93b, 0x941, 0x944, 0x955, 0x969, 
       0x96d, 0x973, 0x979, 0x97f, 0x984, 0x98b, 0x992, 0x997, 0x99a, 0x99e, 
       0x9a2, 0x9a7, 0x9ab, 0x9af, 0x9b5, 0x9ba, 0x9bd, 0x9c1, 0x9c7, 0x9cb, 
       0x9cf, 0x9d7, 0x9df, 0x9e8, 0x9f1, 0x9fe, 0xa01, 0xa05, 0xa0b, 0xa13, 
       0xa17, 0xa1a, 0xa1d, 0xa20, 0xa22, 0xa28, 0xa2a, 0xa39, 0xa3f, 0xa46, 
       0xa49, 0xa4b, 0xa4d, 0xa57, 0xa59, 0xa5d, 0xa60, 0xa63, 0xa67, 0xa6d, 
       0xa70, 0xa76, 0xa79, 0xa82, 0xa8b, 0xa8f, 0xa93, 0xa99, 0xa9e, 0xaa3, 
       0xaa8, 0xaac, 0xab8, 0xabb, 0xac0, 0xac6, 0xac9, 0xacc, 0xacf, 0xad2, 
       0xad9, 0xae4, 0xae7, 0xaeb, 0xaef, 0xaf5, 0xafa, 0xafe, 0xb03, 0xb06, 
       0xb0a, 0xb10, 0xb15, 0xb1e, 0xb22, 0xb26, 0xb29, 0xb2e, 0xb31, 0xb33, 
       0xb37, 0xb3a, 0xb40, 0xb42, 0xb49, 0xb4d, 0xb4f, 0xb54, 0xb58, 0xb5c, 
       0xb62, 0xb6a, 0xb6f, 0xb72, 0xb75, 0xb78, 0xb7b, 0xb7f, 0xb8e, 0xb92, 
       0xb98, 0xb9b, 0xb9e, 0xba4, 0xba9, 0xbad, 0xbb0, 0xbb8, 0xbba, 0xbc7, 
       0xbd3, 0xbd8, 0xbdb, 0xbde, 0xbe3, 0xbe9, 0xbf9, 0xc0d, 0xc16, 0xc1a, 
       0xc21, 0xc26, 0xc2f, 0xc36, 0xc41, 0xc48, 0xc53, 0xc5a, 0xc5e, 0xc64, 
       0xc69, 0xc6e, 0xc72, 0xc78, 0xc7e, 0xc80, 0xc83, 0xc87, 0xc92, 0xc97, 
       0xc9e, 0xca7, 0xcaf, 0xcb4, 0xcb8, 0xcbe, 0xcc1, 0xcc4, 0xcc8, 0xccc, 
       0xcd6, 0xcda, 0xcdd, 0xce0, 0xce5, 0xceb, 0xcef, 0xcf5, 0xcf8, 0xcfa, 
       0xcff, 0xd0b, 0xd14, 0xd21, 0xd24, 0xd29, 0xd30, 0xd34, 0xd38, 0xd3a, 
       0xd48, 0xd4d, 0xd56, 0xd5c, 0xd65, 0xd69, 0xd6d, 0xd77, 0xd79, 0xd81, 
       0xd88, 0xd8d, 0xd91, 0xd95, 0xd98, 0xd9e, 0xda1, 0xda4, 0xdaa, 0xdb1, 
       0xdb6, 0xdba, 0xdbd, 0xdc0, 0xdc3, 0xdc5, 0xdc9, 0xdd1, 0xdd9, 0xde0, 
       0xde6, 0xdea, 0xdef, 0xdf2, 0xdf5, 0xdf8, 0xdfa, 0xdff, 0xe08, 0xe15, 
       0xe17, 0xe1b, 0xe21, 0xe24, 0xe27, 0xe2d, 0xe34, 0xe36, 0xe3e, 0xe44, 
       0xe49, 0xe4c, 0xe53, 0xe55, 0xe5e, 0xe67, 0xe70, 0xe79, 0xe7d, 0xe84, 
       0xe87, 0xe89, 0xe93, 0xe9d, 0xea4, 0xeed, 0xefb, 0xf03, 0xf06, 0xf12, 
       0xf17, 0xf1d, 0xf24, 0xf2b, 0xf32, 0xf39, 0xf40, 0xf47, 0xf4a, 0xf51, 
       0xf59, 0xf61, 0xf6b, 0xf71, 0xf75, 0xf79, 0xf7e, 0xf81, 0xf83, 0xf8c, 
       0xf92, 0xf99, 0xf9e, 0xfa3, 0xfa8, 0xfab, 0xfb2, 0xfbf, 0xfc5, 0xfcb, 
       0xfd2, 0xfda, 0xfe0, 0xfec, 0xfee, 0xff4, 0xff8, 0xffa, 0xffe, 0x100c, 
       0x1012, 0x101a, 0x1026, 0x102a, 0x1038, 0x103a, 0x1041, 0x1049, 0x104c, 
       0x104f, 0x1052, 0x1058, 0x105b, 0x1060, 0x106b, 0x106d, 0x1078, 0x107d, 
       0x1085, 0x108b, 0x108d, 0x108f, 0x1095, 0x10a1, 0x10a6, 0x10a8, 0x10ac, 
       0x10b2, 0x10b5, 0x10c0, 0x10c2, 0x10c8, 0x10cf, 0x10d5, 0x10e6, 0x10f6, 
       0x10fb, 0x1103, 0x110c, 0x1111, 0x1117, 0x111a, 0x111c, 0x1124, 0x1133, 
       0x1137, 0x113b, 0x1142, 0x1148, 0x114e, 0x1150, 0x1154, 0x115f, 0x1169, 
       0x116e, 0x1173, 0x1178, 0x117b, 0x117f, 0x1184, 0x118d, 0x1199, 0x11a7, 
       0x11b0, 0x11b2, 0x11b9, 0x11bf, 0x11c3, 0x11cd, 0x11d4, 0x11d8, 0x11de, 
       0x11e2, 0x11e9, 0x11ec, 0x11f5, 0x11fb, 0x1200, 0x1217, 0x121a, 0x121e, 
       0x1225, 0x1227, 0x122a, 0x122f, 0x1231, 0x1246, 0x124a, 0x124c, 0x1250, 
       0x125c, 0x1263, 0x126c, 0x1273, 0x1276, 0x127a, 0x127d, 0x1280, 0x1284, 
       0x1287, 0x128b, 0x128e, 0x1293, 0x1296, 0x129b, 0x129e, 0x12a5, 0x12a9, 
       0x12af, 0x12b2, 0x12bb, 0x12bd, 0x12c3, 0x12c7, 0x12ca, 0x12cd, 0x12d1, 
       0x12d7, 0x12da, 0x12dd, 0x12e7, 0x12eb, 0x12f4, 0x12f7, 0x12fc, 0x12ff, 
       0x1302, 0x1306, 0x1309, 0x130e, 0x1312, 0x131a, 0x1328, 0x133a, 0x133f, 
       0x1344, 0x134c, 0x1352, 0x1354, 0x1358, 0x135b, 0x1369, 0x1373, 0x1377, 
       0x137f, 0x1382, 0x1386, 0x1390, 0x1394, 0x139b, 0x13a0, 0x13a8, 0x13ad, 
       0x13b3, 0x13ba, 0x13bf, 0x13c5, 0x13cc, 0x13d6, 0x13d8, 0x13e0, 0x13e5, 
       0x13e9, 0x13ec, 0x13f3, 0x13f8, 0x13fc, 0x1408, 0x1410, 0x1414, 0x1417, 
       0x141a, 0x141e, 0x1422, 0x1427, 0x142d, 0x1431, 0x143c, 0x143f, 0x1442, 
       0x1445, 0x144d, 0x1451, 0x1456, 0x145e, 0x1466, 0x146c, 0x1477, 0x1481, 
       0x1487, 0x1495, 0x1498, 0x149c, 0x14a7, 0x14a9, 0x14b2, 0x14be, 0x14c0, 
       0x14c7, 0x14cd, 0x14d5, 0x14e0, 0x14e4, 0x1501, 0x1503, 0x150a, 0x151b, 
       0x1522, 0x1530, 0x153f, 0x1546, 0x1549, 0x156b, 0x1573, 0x1575, 0x157e, 
       0x1583, 0x1589, 0x1591, 0x1598, 0x159e, 0x15a3, 0x15a9, 0x15ae, 0x15b3, 
       0x15b9, 0x15be, 0x15c4, 0x15cc, 0x15d4, 0x15dc, 0x15e4, 0x15e9, 0x15ef, 
       0x15f4, 0x15f8, 0x15fc, 0x1601, 0x1603, 0x1618, 0x161c, 0x1623, 0x162f, 
       0x1632, 0x1636, 0x163b, 0x1640, 0x1644, 0x164e, 0x1657, 0x1659, 0x165c, 
       0x1665, 0x166c, 0x1679, 0x167e, 0x1685, 0x168b, 0x16a5, 0x16c4, 0x16d8, 
       0x16de, 0x16e2, 0x16fd, 0x1709, 0x1716, 0x171a, 0x171e, 0x173a, 0x1772, 
       0x177d, 0x1781, 0x178d, 0x1792, 0x179f, 0x17b3, 0x17b7, 0x17c8, 0x17cb, 
       0x17d0, 0x17d3, 0x17dc, 0x17e0, 0x17e6, 0x17ec, 0x17f0, 0x17fb, 0x1801, 
       0x1803, 0x180a, 0x1811, 0x1815, 0x181c, 0x1821, 0x1826, 0x1829, 0x182e, 
       0x1832, 0x1836, 0x183a, 0x183e, 0x184b, 0x184f, 0x1852, 0x1856, 0x185a, 
       0x185e, 0x1863, 0x1867, 0x186b, 0x186f, 0x1876, 0x187c, 0x1884, 0x1895, 
       0x189a, 0x18a1, 0x18b8, 0x18c8, 0x18d2, 0x18d6, 0x18dd, 0x18e0, 0x18eb, 
       0x18f4, 0x18f7, 0x18fe, 0x1903, 0x191d, 0x1923, 0x1929, 0x192d, 0x1937, 
       0x193b, 0x1948, 0x1954, 0x1966, 0x196e, 0x1978, 0x197b, 0x1980, 0x1984, 
       0x198b, 0x1990, 0x1997, 0x199f, 0x19a2, 0x19a7, 0x19aa, 0x19b2, 0x19b5, 
       0x19c3, 0x19c6, 0x19d3, 0x19d7, 0x19d9, 0x19de, 0x19e2, 0x19e9, 0x19ef, 
       0x19f4, 0x19f7, 0x19fd, 0x1a02, 0x1a05, 0x1a0b, 0x1a10, 0x1a12, 0x1a18, 
       0x1a1a, 0x1a1d, 0x1a23, 0x1a29, 0x1a2f, 0x1a31, 0x1a37, 0x1a3c, 0x1a40, 
       0x1a45, 0x1a4b, 0x1a52, 0x1a55, 0x1a57, 0x1a5a, 0x1a64, 0x1a68, 0x1a6e, 
       0x1a76, 0x1a79, 0x1a86, 0x1a8a, 0x1a8f, 0x1a93, 0x1a96, 0x1a9b, 0x1a9f, 
       0x1aa7, 0x1aaf, 0x1ab1, 0x1ab8, 0x1ac0, 0x1ac7, 0x1aca, 0x1ad2, 0x1ada, 
       0x1adc, 0x1ae2, 0x1ae8, 0x1aec, 0x1af4, 0x1aff, 0x1b08, 0x1b0b, 0x1b10, 
       0x1b12, 0x1b15, 0x1b18, 0x1b1c, 0x1b1f, 0x1b23, 0x1b28, 0x1b2b, 0x1b2f, 
       0x1b32, 0x1b36, 0x1b3b, 0x1b3f, 0x1b4b, 0x1b4f, 0x1b55, 0x1b58, 0x1b5d, 
       0x1b61, 0x1b65, 0x1b6a, 0x1b73, 0x1b76, 0x1b7a, 0x1b7e, 0x1b81, 0x1b85, 
       0x1b89, 0x1b8e, 0x1b93, 0x1b99, 0x1b9e, 0x1ba3, 0x1baf, 0x1bb4, 0x1bbb, 
       0x1bc3, 0x1bc9, 0x1bcb, 0x1bcf, 0x1bd3, 0x1bd7, 0x1bdb, 0x1bea, 0x1bef, 
       0x1bf3, 0x1bf8, 0x1bfe, 0x1c02, 0x1c08, 0x1c0c, 0x1c10, 0x1c15, 0x1c1a, 
       0x1c1f, 0x1c24, 0x1c2a, 0x1c30, 0x1c35, 0x1c3a, 0x1c40, 0x1c45, 0x1c4a, 
       0x1c4f, 0x1c54, 0x1c5e, 0x1c64, 0x1c6a, 0x1c70, 0x1c73, 0x1c7a, 0x1c7f, 
       0x1c82, 0x1c86, 0x1c89, 0x1c8d, 0x1c92, 0x1c96, 0x1c9b, 0x1c9f, 0x1ca8, 
       0x1cab, 0x1cae, 0x1cb1, 0x1cb5, 0x1cb9, 0x1cbd, 0x1ccc, 0x1ccf, 0x1cd1, 
       0x1cd6, 0x1cdf, 0x1ce2, 0x1ce6, 0x1cf3, 0x1cff, 0x1d04, 0x1d09, 0x1d12, 
       0x1d17, 0x1d20, 0x1d25, 0x1d29, 0x1d2d, 0x1d31, 0x1d36, 0x1d3b, 0x1d41, 
       0x1d46, 0x1d49, 0x1d50, 0x1d59, 0x1d60, 0x1d6e, 0x1d7a, 0x1d87, 0x1d8f, 
       0x1d96, 0x1d9f, 0x1da5, 0x1dad, 0x1db3, 0x1dbe, 0x1dc6, 0x1dce, 0x1dd6, 
       0x1de1, 0x1de3, 0x1de5, 0x1de7, 0x1ded, 0x1df3, 0x1df6, 0x1dfd, 0x1dff, 
       0x1e01, 0x1e04, 0x1e15, 0x1e19, 0x1e1b, 0x1e22, 0x1e30, 0x1e32, 0x1e38, 
       0x1e42, 0x1e4b, 0x1e56, 0x1e6c, 0x1e70, 0x1e88, 0x1e93, 0x1e95, 0x1e99, 
       0x1ea0, 0x1ea8, 0x1eaf, 0x1eb5, 0x1ec4, 0x1ec8, 0x1ecf, 0x1ed8, 0x1edd, 
       0x1edf, 0x1ee5, 0x1ef8, 0x1efb, 0x1f02, 0x1f0a, 0x1f12, 0x1f17, 0x1f1a, 
       0x1f1e, 0x1f23, 0x1f2d, 0x1f3c, 0x1f40, 0x1f4a, 0x1f4e, 0x1f52, 0x1f61, 
       0x1f6d, 0x1f76, 0x1f82, 0x1f89, 0x1f94, 0x1f98, 
  };

  _serializedATN.insert(_serializedATN.end(), serializedATNSegment0,
    serializedATNSegment0 + sizeof(serializedATNSegment0) / sizeof(serializedATNSegment0[0]));
  _serializedATN.insert(_serializedATN.end(), serializedATNSegment1,
    serializedATNSegment1 + sizeof(serializedATNSegment1) / sizeof(serializedATNSegment1[0]));
  _serializedATN.insert(_serializedATN.end(), serializedATNSegment2,
    serializedATNSegment2 + sizeof(serializedATNSegment2) / sizeof(serializedATNSegment2[0]));
  _serializedATN.insert(_serializedATN.end(), serializedATNSegment3,
    serializedATNSegment3 + sizeof(serializedATNSegment3) / sizeof(serializedATNSegment3[0]));


  atn::ATNDeserializer deserializer;
  _atn = deserializer.deserialize(_serializedATN);

  size_t count = _atn.getNumberOfDecisions();
  _decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    _decisionToDFA.emplace_back(_atn.getDecisionState(i), i);
  }
}

MySQLParser::Initializer MySQLParser::_init;
